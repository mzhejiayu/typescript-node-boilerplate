{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/accepts/index.js","webpack:///./node_modules/array-flatten/array-flatten.js","webpack:///./node_modules/basic-auth/index.js","webpack:///./node_modules/basic-auth/node_modules/safe-buffer/index.js","webpack:///./node_modules/bintrees/index.js","webpack:///./node_modules/bintrees/lib/bintree.js","webpack:///./node_modules/bintrees/lib/rbtree.js","webpack:///./node_modules/bintrees/lib/treebase.js","webpack:///./node_modules/body-parser/index.js","webpack:///./node_modules/body-parser/lib/read.js","webpack:///./node_modules/body-parser/lib/types/json.js","webpack:///./node_modules/body-parser/lib/types/raw.js","webpack:///./node_modules/body-parser/lib/types/text.js","webpack:///./node_modules/body-parser/lib/types/urlencoded.js","webpack:///./node_modules/bytes/index.js","webpack:///./node_modules/cassandra-driver/index.js","webpack:///./node_modules/cassandra-driver/lib/auth/index.js","webpack:///./node_modules/cassandra-driver/lib/auth/plain-text-auth-provider.js","webpack:///./node_modules/cassandra-driver/lib/auth/provider.js","webpack:///./node_modules/cassandra-driver/lib/client-options.js","webpack:///./node_modules/cassandra-driver/lib/client.js","webpack:///./node_modules/cassandra-driver/lib/concurrent/index.js","webpack:///./node_modules/cassandra-driver/lib/connection.js","webpack:///./node_modules/cassandra-driver/lib/control-connection.js","webpack:///./node_modules/cassandra-driver/lib/encoder.js","webpack:///./node_modules/cassandra-driver/lib/errors.js","webpack:///./node_modules/cassandra-driver/lib/execution-options.js","webpack:///./node_modules/cassandra-driver/lib/execution-profile.js","webpack:///./node_modules/cassandra-driver/lib/host-connection-pool.js","webpack:///./node_modules/cassandra-driver/lib/host.js","webpack:///./node_modules/cassandra-driver/lib/mapping/cache.js","webpack:///./node_modules/cassandra-driver/lib/mapping/doc-info-adapter.js","webpack:///./node_modules/cassandra-driver/lib/mapping/index.js","webpack:///./node_modules/cassandra-driver/lib/mapping/mapper.js","webpack:///./node_modules/cassandra-driver/lib/mapping/mapping-handler.js","webpack:///./node_modules/cassandra-driver/lib/mapping/model-batch-item.js","webpack:///./node_modules/cassandra-driver/lib/mapping/model-batch-mapper.js","webpack:///./node_modules/cassandra-driver/lib/mapping/model-mapper.js","webpack:///./node_modules/cassandra-driver/lib/mapping/model-mapping-info.js","webpack:///./node_modules/cassandra-driver/lib/mapping/object-selector.js","webpack:///./node_modules/cassandra-driver/lib/mapping/q.js","webpack:///./node_modules/cassandra-driver/lib/mapping/query-generator.js","webpack:///./node_modules/cassandra-driver/lib/mapping/result-mapper.js","webpack:///./node_modules/cassandra-driver/lib/mapping/result.js","webpack:///./node_modules/cassandra-driver/lib/mapping/table-mappings.js","webpack:///./node_modules/cassandra-driver/lib/mapping/tree.js","webpack:///./node_modules/cassandra-driver/lib/metadata/aggregate.js","webpack:///./node_modules/cassandra-driver/lib/metadata/client-state.js","webpack:///./node_modules/cassandra-driver/lib/metadata/data-collection.js","webpack:///./node_modules/cassandra-driver/lib/metadata/event-debouncer.js","webpack:///./node_modules/cassandra-driver/lib/metadata/index.js","webpack:///./node_modules/cassandra-driver/lib/metadata/materialized-view.js","webpack:///./node_modules/cassandra-driver/lib/metadata/schema-function.js","webpack:///./node_modules/cassandra-driver/lib/metadata/schema-index.js","webpack:///./node_modules/cassandra-driver/lib/metadata/schema-parser.js","webpack:///./node_modules/cassandra-driver/lib/metadata/table-metadata.js","webpack:///./node_modules/cassandra-driver/lib/metrics/client-metrics.js","webpack:///./node_modules/cassandra-driver/lib/metrics/default-metrics.js","webpack:///./node_modules/cassandra-driver/lib/metrics/index.js","webpack:///./node_modules/cassandra-driver/lib/operation-state.js","webpack:///./node_modules/cassandra-driver/lib/policies/address-resolution.js","webpack:///./node_modules/cassandra-driver/lib/policies/index.js","webpack:///./node_modules/cassandra-driver/lib/policies/load-balancing.js","webpack:///./node_modules/cassandra-driver/lib/policies/reconnection.js","webpack:///./node_modules/cassandra-driver/lib/policies/retry.js","webpack:///./node_modules/cassandra-driver/lib/policies/speculative-execution.js","webpack:///./node_modules/cassandra-driver/lib/policies/timestamp-generation.js","webpack:///./node_modules/cassandra-driver/lib/prepare-handler.js","webpack:///./node_modules/cassandra-driver/lib/readers.js","webpack:///./node_modules/cassandra-driver/lib/request-execution.js","webpack:///./node_modules/cassandra-driver/lib/request-handler.js","webpack:///./node_modules/cassandra-driver/lib/requests.js","webpack:///./node_modules/cassandra-driver/lib/stream-id-stack.js","webpack:///./node_modules/cassandra-driver/lib/streams.js","webpack:///./node_modules/cassandra-driver/lib/token.js","webpack:///./node_modules/cassandra-driver/lib/tokenizer.js","webpack:///./node_modules/cassandra-driver/lib/tracker/index.js","webpack:///./node_modules/cassandra-driver/lib/tracker/request-logger.js","webpack:///./node_modules/cassandra-driver/lib/tracker/request-tracker.js","webpack:///./node_modules/cassandra-driver/lib/types/big-decimal.js","webpack:///./node_modules/cassandra-driver/lib/types/duration.js","webpack:///./node_modules/cassandra-driver/lib/types/index.js","webpack:///./node_modules/cassandra-driver/lib/types/inet-address.js","webpack:///./node_modules/cassandra-driver/lib/types/integer.js","webpack:///./node_modules/cassandra-driver/lib/types/local-date.js","webpack:///./node_modules/cassandra-driver/lib/types/local-time.js","webpack:///./node_modules/cassandra-driver/lib/types/mutable-long.js","webpack:///./node_modules/cassandra-driver/lib/types/protocol-version.js","webpack:///./node_modules/cassandra-driver/lib/types/result-set.js","webpack:///./node_modules/cassandra-driver/lib/types/result-stream.js","webpack:///./node_modules/cassandra-driver/lib/types/row.js","webpack:///./node_modules/cassandra-driver/lib/types/time-uuid.js","webpack:///./node_modules/cassandra-driver/lib/types/tuple.js","webpack:///./node_modules/cassandra-driver/lib/types/uuid.js","webpack:///./node_modules/cassandra-driver/lib/types/version-number.js","webpack:///./node_modules/cassandra-driver/lib/utils.js","webpack:///./node_modules/cassandra-driver/lib/writers.js","webpack:///./node_modules/content-disposition/index.js","webpack:///./node_modules/content-disposition/node_modules/safe-buffer/index.js","webpack:///./node_modules/content-type/index.js","webpack:///./node_modules/cookie-signature/index.js","webpack:///./node_modules/cookie/index.js","webpack:///./node_modules/debug/src/browser.js","webpack:///./node_modules/debug/src/debug.js","webpack:///./node_modules/debug/src/index.js","webpack:///./node_modules/debug/src/node.js","webpack:///./node_modules/depd/index.js","webpack:///./node_modules/depd/lib/compat/callsite-tostring.js","webpack:///./node_modules/depd/lib/compat/event-listener-count.js","webpack:///./node_modules/depd/lib/compat/index.js","webpack:///./node_modules/destroy/index.js","webpack:///./node_modules/ee-first/index.js","webpack:///./node_modules/encodeurl/index.js","webpack:///./node_modules/escape-html/index.js","webpack:///./node_modules/etag/index.js","webpack:///./node_modules/express-basic-auth/index.js","webpack:///./node_modules/express/index.js","webpack:///./node_modules/express/lib sync","webpack:///./node_modules/express/lib/application.js","webpack:///./node_modules/express/lib/express.js","webpack:///./node_modules/express/lib/middleware/init.js","webpack:///./node_modules/express/lib/middleware/query.js","webpack:///./node_modules/express/lib/request.js","webpack:///./node_modules/express/lib/response.js","webpack:///./node_modules/express/lib/router/index.js","webpack:///./node_modules/express/lib/router/layer.js","webpack:///./node_modules/express/lib/router/route.js","webpack:///./node_modules/express/lib/utils.js","webpack:///./node_modules/express/lib/view.js","webpack:///./node_modules/express/node_modules/safe-buffer/index.js","webpack:///./node_modules/finalhandler/index.js","webpack:///./node_modules/forwarded/index.js","webpack:///./node_modules/fresh/index.js","webpack:///./node_modules/http-errors/index.js","webpack:///./node_modules/http-errors/node_modules/inherits/inherits.js","webpack:///./node_modules/http-errors/node_modules/inherits/inherits_browser.js","webpack:///./node_modules/iconv-lite/encodings/dbcs-codec.js","webpack:///./node_modules/iconv-lite/encodings/dbcs-data.js","webpack:///./node_modules/iconv-lite/encodings/index.js","webpack:///./node_modules/iconv-lite/encodings/internal.js","webpack:///./node_modules/iconv-lite/encodings/sbcs-codec.js","webpack:///./node_modules/iconv-lite/encodings/sbcs-data-generated.js","webpack:///./node_modules/iconv-lite/encodings/sbcs-data.js","webpack:///./node_modules/iconv-lite/encodings/utf16.js","webpack:///./node_modules/iconv-lite/encodings/utf7.js","webpack:///./node_modules/iconv-lite/lib/bom-handling.js","webpack:///./node_modules/iconv-lite/lib/extend-node.js","webpack:///./node_modules/iconv-lite/lib/index.js","webpack:///./node_modules/iconv-lite/lib/streams.js","webpack:///./node_modules/inherits/inherits.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/ipaddr.js/lib/ipaddr.js","webpack:///./node_modules/long/dist/Long.js","webpack:///./node_modules/media-typer/index.js","webpack:///./node_modules/merge-descriptors/index.js","webpack:///./node_modules/methods/index.js","webpack:///./node_modules/mime-db/index.js","webpack:///./node_modules/mime-types/index.js","webpack:///./node_modules/mime/mime.js","webpack:///./node_modules/ms/index.js","webpack:///./node_modules/negotiator/index.js","webpack:///./node_modules/negotiator/lib/charset.js","webpack:///./node_modules/negotiator/lib/encoding.js","webpack:///./node_modules/negotiator/lib/language.js","webpack:///./node_modules/negotiator/lib/mediaType.js","webpack:///./node_modules/on-finished/index.js","webpack:///./node_modules/parseurl/index.js","webpack:///./node_modules/path-to-regexp/index.js","webpack:///./node_modules/prom-client/index.js","webpack:///./node_modules/prom-client/lib/bucketGenerators.js","webpack:///./node_modules/prom-client/lib/cluster.js","webpack:///./node_modules/prom-client/lib/counter.js","webpack:///./node_modules/prom-client/lib/defaultMetrics.js","webpack:///./node_modules/prom-client/lib/gauge.js","webpack:///./node_modules/prom-client/lib/histogram.js","webpack:///./node_modules/prom-client/lib/metricAggregators.js","webpack:///./node_modules/prom-client/lib/metrics/eventLoopLag.js","webpack:///./node_modules/prom-client/lib/metrics/heapSizeAndUsed.js","webpack:///./node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js","webpack:///./node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js","webpack:///./node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js","webpack:///./node_modules/prom-client/lib/metrics/osMemoryHeap.js","webpack:///./node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js","webpack:///./node_modules/prom-client/lib/metrics/processCpuTotal.js","webpack:///./node_modules/prom-client/lib/metrics/processHandles.js","webpack:///./node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js","webpack:///./node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js","webpack:///./node_modules/prom-client/lib/metrics/processRequests.js","webpack:///./node_modules/prom-client/lib/metrics/processStartTime.js","webpack:///./node_modules/prom-client/lib/metrics/version.js","webpack:///./node_modules/prom-client/lib/pushgateway.js","webpack:///./node_modules/prom-client/lib/registry.js","webpack:///./node_modules/prom-client/lib/summary.js","webpack:///./node_modules/prom-client/lib/timeWindowQuantiles.js","webpack:///./node_modules/prom-client/lib/util.js","webpack:///./node_modules/prom-client/lib/validation.js","webpack:///./node_modules/proxy-addr/index.js","webpack:///./node_modules/qs/lib/formats.js","webpack:///./node_modules/qs/lib/index.js","webpack:///./node_modules/qs/lib/parse.js","webpack:///./node_modules/qs/lib/stringify.js","webpack:///./node_modules/qs/lib/utils.js","webpack:///./node_modules/range-parser/index.js","webpack:///./node_modules/raw-body/index.js","webpack:///./node_modules/rxjs/_esm5/index.js","webpack:///./node_modules/rxjs/_esm5/internal/AsyncSubject.js","webpack:///./node_modules/rxjs/_esm5/internal/BehaviorSubject.js","webpack:///./node_modules/rxjs/_esm5/internal/InnerSubscriber.js","webpack:///./node_modules/rxjs/_esm5/internal/Notification.js","webpack:///./node_modules/rxjs/_esm5/internal/Observable.js","webpack:///./node_modules/rxjs/_esm5/internal/Observer.js","webpack:///./node_modules/rxjs/_esm5/internal/OuterSubscriber.js","webpack:///./node_modules/rxjs/_esm5/internal/ReplaySubject.js","webpack:///./node_modules/rxjs/_esm5/internal/Scheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/Subject.js","webpack:///./node_modules/rxjs/_esm5/internal/SubjectSubscription.js","webpack:///./node_modules/rxjs/_esm5/internal/Subscriber.js","webpack:///./node_modules/rxjs/_esm5/internal/Subscription.js","webpack:///./node_modules/rxjs/_esm5/internal/config.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/bindCallback.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/combineLatest.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/concat.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/defer.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/empty.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/forkJoin.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/from.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/fromArray.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/fromEvent.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/generate.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/iif.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/interval.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/merge.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/never.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/of.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/pairs.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/partition.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/race.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/range.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/throwError.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/timer.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/using.js","webpack:///./node_modules/rxjs/_esm5/internal/observable/zip.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/audit.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/auditTime.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/buffer.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/bufferCount.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/bufferTime.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/bufferToggle.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/bufferWhen.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/catchError.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/combineAll.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/combineLatest.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/concat.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/concatAll.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/concatMap.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/concatMapTo.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/count.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/debounce.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/debounceTime.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/delay.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/delayWhen.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/dematerialize.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/distinct.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/elementAt.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/endWith.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/every.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/exhaust.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/expand.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/filter.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/finalize.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/find.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/findIndex.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/first.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/groupBy.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/isEmpty.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/last.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/map.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/mapTo.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/materialize.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/max.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/merge.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/mergeAll.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/mergeMap.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/mergeScan.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/min.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/multicast.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/observeOn.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/pairwise.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/partition.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/pluck.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/publish.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/publishBehavior.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/publishLast.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/publishReplay.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/race.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/reduce.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/refCount.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/repeat.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/repeatWhen.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/retry.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/retryWhen.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/sample.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/sampleTime.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/scan.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/share.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/shareReplay.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/single.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/skip.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/skipLast.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/skipUntil.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/skipWhile.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/startWith.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/subscribeOn.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/switchAll.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/switchMap.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/take.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/takeLast.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/takeUntil.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/takeWhile.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/tap.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/throttle.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/throttleTime.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/timeInterval.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/timeout.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/timestamp.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/toArray.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/window.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/windowCount.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/windowTime.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/windowToggle.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/windowWhen.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/zip.js","webpack:///./node_modules/rxjs/_esm5/internal/operators/zipAll.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduled/scheduled.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/Action.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/asap.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/async.js","webpack:///./node_modules/rxjs/_esm5/internal/scheduler/queue.js","webpack:///./node_modules/rxjs/_esm5/internal/symbol/iterator.js","webpack:///./node_modules/rxjs/_esm5/internal/symbol/observable.js","webpack:///./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js","webpack:///./node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js","webpack:///./node_modules/rxjs/_esm5/internal/util/EmptyError.js","webpack:///./node_modules/rxjs/_esm5/internal/util/Immediate.js","webpack:///./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js","webpack:///./node_modules/rxjs/_esm5/internal/util/TimeoutError.js","webpack:///./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js","webpack:///./node_modules/rxjs/_esm5/internal/util/canReportError.js","webpack:///./node_modules/rxjs/_esm5/internal/util/hostReportError.js","webpack:///./node_modules/rxjs/_esm5/internal/util/identity.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isArray.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isArrayLike.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isDate.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isFunction.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isIterable.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isNumeric.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isObject.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isObservable.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isPromise.js","webpack:///./node_modules/rxjs/_esm5/internal/util/isScheduler.js","webpack:///./node_modules/rxjs/_esm5/internal/util/noop.js","webpack:///./node_modules/rxjs/_esm5/internal/util/not.js","webpack:///./node_modules/rxjs/_esm5/internal/util/pipe.js","webpack:///./node_modules/rxjs/_esm5/internal/util/subscribeTo.js","webpack:///./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js","webpack:///./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js","webpack:///./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js","webpack:///./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js","webpack:///./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js","webpack:///./node_modules/rxjs/_esm5/internal/util/toSubscriber.js","webpack:///./node_modules/rxjs/_esm5/operators/index.js","webpack:///./node_modules/safer-buffer/safer.js","webpack:///./node_modules/send/index.js","webpack:///./node_modules/send/node_modules/http-errors/index.js","webpack:///./node_modules/send/node_modules/ms/index.js","webpack:///./node_modules/serve-static/index.js","webpack:///./node_modules/setprototypeof/index.js","webpack:///./node_modules/statuses/index.js","webpack:///./node_modules/tdigest/tdigest.js","webpack:///./node_modules/toidentifier/index.js","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./node_modules/type-is/index.js","webpack:///./node_modules/unpipe/index.js","webpack:///./node_modules/utils-merge/index.js","webpack:///./node_modules/vary/index.js","webpack:///(webpack)/buildin/module.js","webpack:///./src/index.ts","webpack:///external \"assert\"","webpack:///external \"buffer\"","webpack:///external \"cluster\"","webpack:///external \"crypto\"","webpack:///external \"dns\"","webpack:///external \"events\"","webpack:///external \"fs\"","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///external \"net\"","webpack:///external \"path\"","webpack:///external \"process\"","webpack:///external \"querystring\"","webpack:///external \"stream\"","webpack:///external \"string_decoder\"","webpack:///external \"tls\"","webpack:///external \"tty\"","webpack:///external \"url\"","webpack:///external \"util\"","webpack:///external \"v8\"","webpack:///external \"vm\"","webpack:///external \"zlib\""],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,sDAAY;AACrC,WAAW,mBAAO,CAAC,sDAAY;;AAE/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7OY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,gFAAa;;AAElC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACpIA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AACA,YAAY,mBAAO,CAAC,2DAAc;AAClC,aAAa,mBAAO,CAAC,6DAAe;AACpC;;;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,2DAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACzGA,eAAe,mBAAO,CAAC,2DAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;;AAEA;AACA,sBAAsB;AACtB,uBAAuB;AACvB,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxNA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,0CAAM;;AAE9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,sEAAkB;AACzC;AACA;AACA,eAAe,mBAAO,CAAC,oEAAiB;AACxC;AACA;AACA,eAAe,mBAAO,CAAC,sEAAkB;AACzC;AACA;AACA,eAAe,mBAAO,CAAC,kFAAwB;AAC/C;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,wDAAa;AACvC,cAAc,mBAAO,CAAC,kDAAU;AAChC,YAAY,mBAAO,CAAC,0DAAY;AAChC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,4CAAO;AAC3B,kBAAkB,mBAAO,CAAC,0DAAc;AACxC,kBAAkB,mBAAO,CAAC,wDAAa;AACvC,YAAY,mBAAO,CAAC,gDAAO;AAC3B,WAAW,mBAAO,CAAC,uDAAS;AAC5B,aAAa,mBAAO,CAAC,gDAAS;;AAE9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,4CAAO;AAC3B,YAAY,mBAAO,CAAC,gDAAO;AAC3B,WAAW,mBAAO,CAAC,uDAAS;AAC5B,aAAa,mBAAO,CAAC,gDAAS;;AAE9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,4CAAO;AAC3B,kBAAkB,mBAAO,CAAC,0DAAc;AACxC,YAAY,mBAAO,CAAC,gDAAO;AAC3B,WAAW,mBAAO,CAAC,uDAAS;AAC5B,aAAa,mBAAO,CAAC,gDAAS;;AAE9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,4CAAO;AAC3B,kBAAkB,mBAAO,CAAC,0DAAc;AACxC,kBAAkB,mBAAO,CAAC,wDAAa;AACvC,YAAY,mBAAO,CAAC,gDAAO;AAC3B,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,WAAW,mBAAO,CAAC,uDAAS;AAC5B,aAAa,mBAAO,CAAC,gDAAS;;AAE9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,0CAAI;AACxB;AACA;AACA,YAAY,mBAAO,CAAC,gCAAa;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,8CAA8C,0BAA0B;AACxE;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3RA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,EAAE;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACjKa;;AAEb,sBAAsB,mBAAO,CAAC,mFAAsB;AACpD,iBAAiB,mBAAO,CAAC,mEAAc;AACvC,2BAA2B,mBAAO,CAAC,yFAAyB;AAC5D,2BAA2B,mBAAO,CAAC,yFAAyB;AAC5D,gBAAgB,mBAAO,CAAC,uEAAa;AACrC,iBAAiB,mBAAO,CAAC,mEAAc;AACvC,mBAAmB,mBAAO,CAAC,6EAAgB;AAC3C,eAAe,mBAAO,CAAC,qEAAY;AACnC,kBAAkB,mBAAO,CAAC,2EAAe;AACzC,kBAAkB,mBAAO,CAAC,2EAAe;AACzC,kBAAkB,mBAAO,CAAC,2EAAe;AACzC,qBAAqB,mBAAO,CAAC,iFAAkB;;AAE/C,cAAc,mBAAO,CAAC,iEAAa;AACnC;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,6EAAgB;AACzC;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,qEAAe;AACzC;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,oEAAgB,U;;;;;;;;;;;;AC/B7B;AACb;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,2EAAe;AAC5C;AACA;AACA,gCAAgC,mBAAO,CAAC,2GAA+B,E;;;;;;;;;;;;ACR1D;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,iBAAiB,mBAAO,CAAC,2EAAe;AACxC,cAAc,mBAAO,CAAC,8DAAU;AAChC;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAA2D;AACzF,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,gCAAgC;AACjE;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uC;;;;;;;;;;;;AC9Da;AACb;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B,gCAAgC;AAC9D,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA,sC;;;;;;;;;;;;AC/Da;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,iBAAiB,mBAAO,CAAC,yEAAY;AACrC,cAAc,mBAAO,CAAC,mEAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,gBAAgB,mBAAO,CAAC,uEAAW;AACnC,gBAAgB,mBAAO,CAAC,uEAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,GAAG,mDAAmD;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oE;;;;;;;;;;;;AC/Oa;AACb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,cAAc,mBAAO,CAAC,gEAAY;AAClC,eAAe,mBAAO,CAAC,kEAAa;AACpC,cAAc,mBAAO,CAAC,mEAAS;AAC/B,uBAAuB,mBAAO,CAAC,qFAAqB;AACpD,iBAAiB,mBAAO,CAAC,mEAAY;AACrC,sBAAsB,mBAAO,CAAC,+EAAkB;AAChD,oBAAoB,mBAAO,CAAC,6FAAyB;AACrD,oBAAoB,mBAAO,CAAC,qEAAiB;AAC7C,gBAAgB,mBAAO,CAAC,qEAAiB;AACzC,gCAAgC,mBAAO,CAAC,qFAAqB;;AAE7D;AACA;AACA,wBAAwB,mBAAO,CAAC,uFAAsB;AACtD,qBAAqB,mBAAO,CAAC,iFAAmB;AAChD,qBAAqB,mBAAO,CAAC,iFAAmB;AAChD;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,cAAc,OAAO,0EAA0E,aAAa;AAC5G,cAAc,OAAO;AACrB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA,iCAAiC,gDAAgD;AACjF;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC;AACA,cAAc,YAAY;AAC1B,cAAc,mBAAmB;AACjC,cAAc,kBAAkB;AAChC,cAAc,2BAA2B;AACzC;AACA;AACA;AACA,mDAAmD;AACnD,wEAAwE;AACxE;AACA,cAAc,mBAAmB;AACjC,+BAA+B,6DAA6D;AAC5F;AACA,kDAAkD;AAClD;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,8DAA8D,qBAAqB;AACnF;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;AACA,cAAc,aAAa;AAC3B,cAAc,eAAe;AAC7B;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,yBAAyB,4CAA4C,uBAAuB;AAC1G,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4FAA4F;AACvH;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA,+DAA+D,qBAAqB;AACpF;AACA,oCAAoC,kFAAkF;AACtH;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,mCAAmC,iCAAiC;AACzF,cAAc,OAAO;AACrB;AACA,cAAc,wBAAwB,sDAAsD,uBAAuB;AACnH;AACA,cAAc,OAAO;AACrB,cAAc,mBAAmB;AACjC;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAwD;AACnF;AACA,2BAA2B,4BAA4B;AACvD,wCAAwC,yCAAyC;AACjF;AACA,cAAc,QAAQ;AACtB;AACA;AACA,kEAAkE,wCAAwC;AAC1G;AACA;AACA;AACA,cAAc,OAAO;AACrB,0FAA0F,sBAAsB;AAChH;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA,cAAc,QAAQ;AACtB,oBAAoB,mBAAmB;AACvC,cAAc,QAAQ;AACtB,oBAAoB,mBAAmB;AACvC,cAAc,cAAc;AAC5B;AACA,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA,qEAAqE,4BAA4B;AACjG,aAAa,oBAAoB;AACjC;AACA,cAAc,MAAM;AACpB;AACA,cAAc,aAAa;AAC3B,cAAc,MAAM;AACpB;AACA,cAAc,OAAO;AACrB;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA,cAAc,QAAQ;AACtB;AACA,4DAA4D,wCAAwC;AACpG;;AAEA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,8BAA8B,mEAAmE;AACjG;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mCAAmC;AAC1E,iDAAiD,0CAA0C;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,yBAAyB,mCAAmC;AAC5D;AACA,uCAAuC,oCAAoC;AAC3E,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;;AAEA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,mBAAmB;AACtF;AACA;AACA,mBAAmB,wCAAwC,aAAa,oBAAoB,KAAK;AACjG;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA,SAAS,uBAAuB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,6DAA6D,sCAAsC;AACnG;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qEAAqE;AAC5G;AACA;AACA;AACA;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB,cAAc,EAAE;AAClD;AACA,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,uBAAuB,cAAc,EAAE;AAClD,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB;;AAEA;;;;;;;;;;;;;ACrmCa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO,aAAa,aAAa;AAC5C,WAAW,cAAc,cAAc,EAAE;AACzC,WAAW,2BAA2B,gBAAgB,YAAY,gBAAgB,aAAa,cAAc;AAC7G,+EAA+E,YAAY,KAAK,aAAa;AAC7G;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,eAAe,6BAA6B;AAC5C,WAAW,OAAO;AAClB;AACA,aAAa,wBAAwB,4BAA4B,qBAAqB;AACtF;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qCAAqC;AACrC,MAAM;AACN,qCAAqC;AACrC,MAAM;AACN,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,oBAAoB,cAAc,EAAE;AACjD,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,YAAY,4BAA4B,6BAA6B;AACvF;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,KAAK;AACL,kDAAkD;AAClD;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wC;;;;;;;;;;;;AC9Ta;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,gBAAK;;AAEzB,gBAAgB,mBAAO,CAAC,oEAAc;AACtC,mBAAmB,mBAAO,CAAC,iEAAW;AACtC,iBAAiB,mBAAO,CAAC,mEAAY;AACrC,gBAAgB,mBAAO,CAAC,iEAAW;AACnC,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,mEAAS;AAC/B,eAAe,mBAAO,CAAC,+DAAU;AACjC,sBAAsB,mBAAO,CAAC,iFAAmB;AACjD,uBAAuB,mBAAO,CAAC,iFAAmB;AAClD,yBAAyB,mBAAO,CAAC,qFAAqB;;AAEtD;AACA;AACA,UAAU,mBAAO,CAAC,gBAAK;;AAEvB;AACA;AACA,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,oDAAoD;;AAE9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,gCAAgC;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,wCAAwC,mBAAmB;AAC3D,oCAAoC,mBAAmB;AACvD,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iFAAiF,uBAAuB;AACxG;AACA;AACA;AACA,oCAAoC,0BAA0B;;AAE9D;AACA,qCAAqC,gEAAgE;AACrG;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,qCAAqC,4BAA4B;;AAEjE;AACA,wDAAwD,0BAA0B;AAClF;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,oDAAoD;;AAEnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,0BAA0B;AACzG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,0BAA0B;AACzE;;AAEA;AACA;AACA,wBAAwB,0BAA0B;AAClD,SAAS,0CAA0C;AACnD;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACztBa;AACb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,gBAAK;;AAEzB,eAAe,mBAAO,CAAC,+DAAU;AACjC,aAAa,mBAAO,CAAC,2DAAQ;AAC7B,gBAAgB,mBAAO,CAAC,2DAAQ;AAChC,iBAAiB,mBAAO,CAAC,yEAAY;AACrC,uBAAuB,mBAAO,CAAC,mGAA4B;AAC3D,mBAAmB,mBAAO,CAAC,uEAAc;AACzC,iBAAiB,mBAAO,CAAC,mEAAY;AACrC,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,mEAAS;AAC/B;AACA;AACA,UAAU,mBAAO,CAAC,gBAAK;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY,4DAA4D;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAoD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ,GAAG,WAAW;AAC5C;;AAEA;AACA,oDAAoD,QAAQ,IAAI,WAAW;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,aAAa;AAC7B,yBAAyB,gCAAgC;AACzD,KAAK;AACL,2CAA2C,gCAAgC;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mFAAmF,2BAA2B;AAC9G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D,kCAAkC;AAC5F;AACA,yBAAyB,qCAAqC;;AAE9D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,qCAAqC;;AAE9F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,8FAA8F;AAC1G,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA,gCAAgC,kEAAkE;AAClG;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAyB;AAC1E;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,iDAAiD,wBAAwB;AACzE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,gCAAgC;AACxD;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AClhCa;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,cAAc,mBAAO,CAAC,mEAAS;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,uFAAsB;AAClD,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;;AAE/B,6BAA6B,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,KAAK;AACL,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAoD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,6BAA6B;AAC1C,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,gCAAgC;AAC7C,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,6BAA6B;AACjF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB,aAAa,SAAS;AACtB,aAAa,SAAS,2CAA2C,iDAAiD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,6BAA6B,eAAe;AACxD;AACA;AACA;AACA,0DAA0D,uCAAuC;AACjG;AACA,MAAM,uCAAuC;AAC7C;AACA;AACA,aAAa;AACb,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5pDa;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,uDAAuD,sCAAsC;AAC7F,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI,8CAA8C;AAClD,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AChKa;;AAEb,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,mEAAS;AAC/B,eAAe,mBAAO,CAAC,+DAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;AAClB;AACA;AACA;;AAEA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA,kCAAkC,iCAAiC;AACnE;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA,6EAA6E,mBAAmB;AAChG;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA,6BAA6B,4BAA4B;AACzD;AACA,eAAe,YAAY;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD,aAAa,aAAa;AAC1B,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2DAA2D,oCAAoC;AAC/F;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD,aAAa,kBAAkB;AAC/B,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,6C;;;;;;;;;;;;ACthBL;AACb,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,mEAAS;;AAE/B;AACA,8BAA8B,uBAAuB;AACrD;AACA,gGAAgG,aAAa;AAC7G;AACA,SAAS,uBAAuB,iDAAiD,aAAa;AAC9F;AACA,WAAW,OAAO;AAClB;AACA,wFAAwF,uBAAuB;AAC/G;AACA;AACA,WAAW,OAAO,0EAA0E,aAAa;AACzG;AACA,WAAW,OAAO;AAClB,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,wBAAwB;AACnC,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;AACA;AACA;;AAEA,cAAc,oBAAoB;AAClC;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,6DAA6D,6BAA6B,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3Ja;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,mBAAmB,mBAAO,CAAC,uEAAc;AACzC,cAAc,mBAAO,CAAC,6DAAS;AAC/B,eAAe,mBAAO,CAAC,+DAAU;AACjC,uBAAuB,mBAAO,CAAC,+EAAkB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA,oC;;;;;;;;;;;;AC7fa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,mEAAS;AAC/B,2BAA2B,mBAAO,CAAC,2FAAwB;AAC3D,uBAAuB,mBAAO,CAAC,iFAAmB;;AAElD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA,0CAA0C,oDAAoD;;AAE9F;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uCAAuC,yEAAyE;;AAEhH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,qCAAqC;AACjF,4DAA4D,iDAAiD;;AAE7G;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gCAAgC,aAAa,0CAA0C,uBAAuB;AAC9G,GAAG;AACH,6BAA6B,aAAa;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,WAAW;AACtB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB,6BAA6B,EAAE,oBAAoB;AAC/G;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvlBa;;AAEb,gBAAgB,mBAAO,CAAC,6DAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,wBAAwB;AACtC,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,2CAA2C;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;;ACrLa;;AAEb,eAAe,mBAAO,CAAC,gEAAW;AAClC,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,MAAM,QAAQ;AAC3B,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc,SAAS;AACvB,aAAa,iBAAiB;AAC9B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;AC9Ia;;AAEb;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,uEAAU;AACnC,sBAAsB,mBAAO,CAAC,mFAAgB;AAC9C,2BAA2B,mBAAO,CAAC,+FAAsB;AACzD,yBAAyB,mBAAO,CAAC,2FAAoB;AACrD,iBAAiB,mBAAO,CAAC,uEAAU;AACnC,4BAA4B,mBAAO,CAAC,uFAAkB;AACtD;AACA;AACA;AACA,YAAY,mBAAO,CAAC,6DAAK,I;;;;;;;;;;;;AChBZ;;AAEb,oBAAoB,mBAAO,CAAC,mFAAgB;AAC5C,uBAAuB,mBAAO,CAAC,yFAAmB;AAClD,uBAAuB,mBAAO,CAAC,2FAAoB;AACnD,eAAe,mBAAO,CAAC,gEAAW;AAClC,eAAe,mBAAO,CAAC,uEAAU;AACjC,qBAAqB,mBAAO,CAAC,qFAAiB;AAC9C,yBAAyB,mBAAO,CAAC,+FAAsB;AACvD,uBAAuB,mBAAO,CAAC,2FAAoB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uCAAuC;AACpG;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe,gCAAgC,oCAAoC;AAChG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,iCAAiC;AAC3D;AACA,aAAa,OAAO;AACpB,eAAe,YAAY,iBAAiB,iCAAiC;AAC7E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,YAAY;AACzB;AACA,eAAe,gBAAgB,uCAAuC,4BAA4B;AAClG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,qBAAqB,aAAa,EAAE;AAClD;AACA,cAAc,cAAc;AAC5B;AACA,cAAc,wBAAwB;AACtC;AACA,cAAc,OAAO;AACrB;;AAEA,wB;;;;;;;;;;;;AC1Ka;;AAEb,cAAc,mBAAO,CAAC,8DAAU;AAChC,uBAAuB,mBAAO,CAAC,yFAAmB;AAClD,qBAAqB,mBAAO,CAAC,qFAAiB;AAC9C,eAAe,mBAAO,CAAC,uEAAU;AACjC,cAAc,mBAAO,CAAC,qEAAS;AAC/B,aAAa,mBAAO,CAAC,mEAAQ;AAC7B,uBAAuB,mBAAO,CAAC,yFAAmB;AAClD,uBAAuB,mBAAO,CAAC,2FAAoB;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,wBAAwB;AACtC,aAAa,QAAQ;AACrB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uEAAuE,sCAAsC;;AAE7G;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,0EAA0E,sCAAsC;;AAEhH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,0BAA0B;AACxC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE,iBAAiB;;AAExF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,0BAA0B;AACxC,eAAe,eAAe,oBAAoB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE,iBAAiB;;AAExF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,eAAe,kCAAkC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,2CAA2C;AACzD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE,iBAAiB;;AAExF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,2CAA2C;AACzD,eAAe,eAAe,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6DAA6D,mBAAmB;AAChF;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;AC3Ya;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,SAAS,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mEAAmE;AACrF,OAAO;;AAEP,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;ACvDa;;AAEb,cAAc,mBAAO,CAAC,qEAAS;AAC/B,aAAa,mBAAO,CAAC,mEAAQ;AAC7B,uBAAuB,mBAAO,CAAC,2FAAoB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,oCAAoC;AACjE;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,eAAe,eAAe,oBAAoB,oCAAoC;AACtF;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;;AAEvF;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,oCAAoC;AACjE;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe,oBAAoB,oCAAoC;AACtF;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;;AAEvF;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,oCAAoC;AACjE;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,eAAe,oBAAoB,oCAAoC;AACtF;AACA;AACA;AACA;AACA;AACA,uEAAuE,gBAAgB;;AAEvF;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kC;;;;;;;;;;;;AClIa;;AAEb,yBAAyB,mBAAO,CAAC,+FAAsB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iCAAiC,sCAAsC;AACvE;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA,sBAAsB,KAAK;AAC3B;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,aAAa,uBAAuB;AACpC;AACA,aAAa,OAAO;AACpB;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,cAAc,gBAAgB,uCAAuC,4BAA4B;AACjG;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA,uBAAuB,SAAS,GAAG,WAAW,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,aAAa,uBAAuB;AACpC;AACA,aAAa,OAAO;AACpB;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,cAAc,gBAAgB,uCAAuC,4BAA4B;AACjG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA,cAAc,gBAAgB,uCAAuC,4BAA4B;AACjG;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA,cAAc,gBAAgB,uCAAuC,4BAA4B;AACjG;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA,cAAc,gBAAgB,uCAAuC,4BAA4B;AACjG;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,YAAY;AACzB;AACA;AACA,cAAc,SAAS;AACvB,wCAAwC,4BAA4B;AACpE;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;;ACjSa;;AAEb,4BAA4B,mBAAO,CAAC,uFAAkB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,aAAa,EAAE;AACnC,aAAa,cAAc;AAC3B,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,iEAAiE,UAAU;AAC3E;;AAEA;AACA,OAAO;AACP,KAAK;AACL,kBAAkB,iCAAiC;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,iCAAiC;AAC1C;AACA;AACA;AACA;;AAEA,kC;;;;;;;;;;;;AClIa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,qBAAqB;AAClC,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,sCAAsC,oBAAoB;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sDAAsD,uDAAuD;AAC7G,gDAAgD;;AAEhD;AACA,uBAAuB,YAAY,kCAAkC;AACrE;AACA;AACA,uBAAuB,aAAa,oCAAoC;AACxE;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,aAAa,MAAM;AACnB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;;AAEA;AACA;AACA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA,kDAAkD;;AAElD;AACA,yBAAyB,eAAe,4BAA4B;AACpE;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;;AAEA;AACA;AACA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA,kDAAkD;;AAElD;AACA,yBAAyB,eAAe,4BAA4B;AACpE;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;ACrPa;;AAEb,eAAe,mBAAO,CAAC,gEAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,sC;;;;;;;;;;;;ACnIa;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,6DAAK;AAC7B;AACA;AACA,cAAc,mBAAO,CAAC,oEAAU;AAChC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB,SAAS,GAAG,UAAU;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mEAAmE;AACnE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,GAAG;;AAExB;AACA,oCAAoC,sBAAsB;AAC1D;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,kBAAkB;AAC/B,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,cAAc;AACd;AACA;AACA,+BAA+B,SAAS,GAAG,UAAU;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mEAAmE;AACnE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,GAAG;;AAExB;AACA,oCAAoC,sBAAsB;AAC1D;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,kBAAkB;AAC/B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B;AACA;AACA,0BAA0B,SAAS,GAAG,UAAU;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa,OAAO,aAAa,GAAG,aAAa;AACvE;AACA;AACA,oBAAoB,aAAa,KAAK,aAAa,GAAG,aAAa;AACnE;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,iBAAiB;AAC9B,eAAe;AACf;AACA;AACA,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,GAAG;;AAExB;AACA,oCAAoC,sBAAsB;AAC1D;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,kBAAkB;AAC/B,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS,GAAG,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA,mEAAmE;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,GAAG;;AAExB;AACA,oCAAoC,sBAAsB;AAC1D;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,WAAW,IAAI,eAAe;AACnF;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,qCAAqC,OAAO,4BAA4B;AAC1F,eAAe,qCAAqC,OAAO,4BAA4B;AACvF;AACA,gBAAgB,OAAO;AACvB;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO,IAAI,eAAe,IAAI,mDAAmD;AACpG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,+DAA+D;AACjF,cAAc,UAAU,GAAG,+DAA+D;AAC1F;AACA,gBAAgB,WAAW,GAAG,UAAU;AACxC;AACA,cAAc,WAAW;AACzB;AACA;;AAEA,gC;;;;;;;;;;;;AC3Za;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,cAAc,mBAAO,CAAC,8DAAU;AAChC,cAAc,mBAAO,CAAC,oEAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD,yCAAyC;;AAEzC,8CAA8C,6BAA6B,YAAY,OAAO,GAAG;;AAEjG,mCAAmC,GAAG;;AAEtC;AACA,oCAAoC,kCAAkC;AACtE;;AAEA;AACA;AACA,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,iBAAiB;AAC9B,aAAa,UAAU;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,cAAc;AACd;;AAEA,YAAY;AACZ;AACA;;AAEA,8B;;;;;;;;;;;;ACvFa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAU;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wB;;;;;;;;;;;;ACvHa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,mCAAmC;AAChF;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oD;;;;;;;;;;;;ACzGa;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sB;;;;;;;;;;;;ACnIa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY,QAAQ,WAAW;AAC/B;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,2B;;;;;;;;;;;;ACxDa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,gEAAW;;AAElC;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,wBAAwB;AACnC,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,0DAA0D;AAChE,kCAAkC,kBAAkB,EAAE;AACtD;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;;AC9Fa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAkD;AAC5F,yCAAyC,kDAAkD;AAC3F;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA,gC;;;;;;;;;;;;ACpJa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,kCAAkC;AAClC,WAAW,QAAQ;AACnB;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,YAAY,wDAAwD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA,gC;;;;;;;;;;;;ACtIa;AACb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA;AACA,UAAU,mBAAO,CAAC,sEAAc;AAChC,cAAc,mBAAO,CAAC,8DAAU;AAChC,eAAe,mBAAO,CAAC,gEAAW;AAClC,cAAc,mBAAO,CAAC,oEAAU;AAChC,iBAAiB,mBAAO,CAAC,oEAAa;AACtC,4BAA4B,mBAAO,CAAC,sFAAiB;AACrD,mBAAmB,mBAAO,CAAC,8DAAU;AACrC,yBAAyB,mBAAO,CAAC,sFAAsB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAoD;AAC9F,oDAAoD,8DAA8D;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS,oEAAoE,oBAAoB;AAC5G;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS,6EAA6E;AACjG;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,uBAAuB,WAAW,EAAE;AAC/C,WAAW,SAAS,oEAAoE,qBAAqB;AAC7G;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS,6EAA6E,gBAAgB;AACjH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,uBAAuB,WAAW,EAAE;AAC/C,WAAW,SAAS,oEAAoE,gBAAgB;AACxG;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS,oEAAoE,uBAAuB;AAC/G;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8EAA8E;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;ACliCa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,uBAAuB,mBAAO,CAAC,0FAAmB;AAClD;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA,kC;;;;;;;;;;;;AChCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY,QAAQ,WAAW;AAC/B;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,gC;;;;;;;;;;;;ACvDa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAU;AAChC,cAAc,mBAAO,CAAC,oEAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,iBAAiB,WAAW,EAAE;AACzC,aAAa;AACb;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;;ACrIa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,oEAAU;AAChC,cAAc,mBAAO,CAAC,8DAAU;AAChC,eAAe,mBAAO,CAAC,gEAAW;AAClC,sBAAsB,mBAAO,CAAC,wFAAkB;AAChD,kBAAkB,mBAAO,CAAC,8EAAa;AACvC,uBAAuB,mBAAO,CAAC,0FAAmB;AAClD,cAAc,mBAAO,CAAC,oFAAgB;AACtC,yBAAyB,mBAAO,CAAC,8FAAqB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oGAAoG;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,cAAc;AACd,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,SAAS,oDAAoD,eAAe;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC,WAAW,IAAI;AACf,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,IAAI;AACf,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI;AACf,WAAW,SAAS;AACpB;AACA;AACA;;AAEA,cAAc,IAAI;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAA2C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA;AACA,+BAA+B,iGAAiG;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,+CAA+C;AACpD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA,qBAAqB,6CAA6C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,aAAa,kDAAkD;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,kBAAkB;AAC7B,WAAW,SAAS;AACpB,WAAW,eAAe;AAC1B,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACv2Ca;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,uBAAuB,mBAAO,CAAC,0FAAmB;;AAElD;AACA;AACA;AACA,WAAW,OAAO;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA,+B;;;;;;;;;;;;AC9Da;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;;AAEA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA,+B;;;;;;;;;;;;AChHa;;AAEb,sBAAsB,mBAAO,CAAC,uFAAkB;AAChD,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA,qCAAqC,oCAAoC;AACzE,yDAAyD,qBAAqB;AAC9E;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B,kBAAkB,aAAa;AAC/B;AACA,kBAAkB,aAAa;AAC/B;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;ACrLa;;AAEb,sBAAsB,mBAAO,CAAC,uFAAkB;AAChD,uBAAuB,mBAAO,CAAC,yFAAmB;;AAElD;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iC;;;;;;;;;;;;ACXL;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,eAAe,mBAAO,CAAC,+DAAU;AACjC,iBAAiB,mBAAO,CAAC,mEAAY;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iDAAiD;AAC1F;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;ACpJa;AACb,YAAY,mBAAO,CAAC,gBAAK;AACzB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,aAAa;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO,6DAA6D,oBAAoB;AACnG,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,wBAAwB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA,4D;;;;;;;;;;;;AC3Ha;;AAEb;AACA,iEAAiE,oCAAoC;AACrG,eAAe,4BAA4B,yBAAyB,mCAAmC;AACvG,yBAAyB,wCAAwC;AACjE,2BAA2B,0CAA0C;AACrE,4BAA4B,2CAA2C;AACvE;AACA;AACA,sDAAsD,mBAAO,CAAC,gGAAsB;AACpF,8CAA8C,mBAAO,CAAC,wFAAkB;AACxE,4CAA4C,mBAAO,CAAC,oFAAgB;AACpE,8BAA8B,mBAAO,CAAC,sEAAS;AAC/C,4DAA4D,mBAAO,CAAC,sGAAyB;AAC7F,0DAA0D,mBAAO,CAAC,oGAAwB;;AAE1F;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,E;;;;;;;;;;;;AChEa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,oEAAU;AAChC,cAAc,mBAAO,CAAC,iEAAa;AACnC,eAAe,mBAAO,CAAC,mEAAc;;AAErC,0CAA0C,aAAa;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2BAA2B;AACpD,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACvda;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sE;;;;;;;;;;;;AC7Ia;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO,+BAA+B,iCAAiC;AAClF;AACA,WAAW,OAAO;AAClB,0BAA0B,iCAAiC;AAC3D,WAAW,OAAO;AAClB,+EAA+E;AAC/E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO,+BAA+B,iCAAiC;AAClF;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,0BAA0B,iCAAiC;AAC3D,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO,+BAA+B,iCAAiC;AAClF;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,iBAAiB,iCAAiC;AAClD,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD,4BAA4B,2CAA2C;AACvE;AACA;AACA,mFAAmF,kCAAkC;AACrH;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,WAAW,cAAc;AACzB,WAAW,iBAAiB,+BAA+B,iCAAiC;AAC5F;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,mBAAmB,mDAAmD,iCAAiC;AACrH,WAAW,iBAAiB;AAC5B,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,mBAAmB;AACjC,aAAa;AACb;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,UAAU;AACV,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAsD;AAC3E,oCAAoC,mBAAmB;AACvD;AACA;AACA,WAAW,YAAY;AACvB,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,mBAAmB,sDAAsD;AACzE,cAAc,OAAO,uCAAuC,iCAAiC;AAC7F,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,WAAW,iBAAiB;AAC5B,cAAc,OAAO;AACrB;;AAEA;AACA,kE;;;;;;;;;;;;ACnNa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,gEAAW;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,iCAAiC;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM,iCAAiC;AACvC;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gF;;;;;;;;;;;;AC/Ha;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,aAAa,mBAAO,CAAC,oEAAU;AAC/B,eAAe,mBAAO,CAAC,gEAAW;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA,wEAAwE,gCAAgC;AACxG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO,aAAa,aAAa;AAC5C,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,WAAW;AACjB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kE;;;;;;;;;;;;AC1Ja;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,+DAAU;AACjC,cAAc,mBAAO,CAAC,6DAAS;AAC/B,uBAAuB,mBAAO,CAAC,iFAAmB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,oBAAoB;AACjC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,oBAAoB;AACjC,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,KAAK;AAClB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA,gC;;;;;;;;;;;;AC5Oa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,mEAAS;AAC/B,eAAe,mBAAO,CAAC,+DAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,0BAA0B,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9ca;;AAEb,eAAe,mBAAO,CAAC,+DAAU;AACjC,iBAAiB,mBAAO,CAAC,mEAAY;AACrC,cAAc,mBAAO,CAAC,+EAAkB;AACxC,cAAc,mBAAO,CAAC,mEAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;;AAE/B;AACA;AACA;AACA;AACA,CAAC;;AAED,uCAAuC,oDAAoD;;AAE3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,cAAc;AAC3C,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,cAAc;AAC3C,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,wBAAwB;AACzC,eAAe,gCAAgC;;AAE/C;;AAEA;AACA;AACA,8CAA8C,wBAAwB;AACtE;;AAEA;AACA;AACA,0CAA0C,cAAc,wBAAwB,oBAAoB,IAAI,WAAW;AACnH;;AAEA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gCAAgC;AACxG;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,kC;;;;;;;;;;;;AC1aa;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,eAAe,mBAAO,CAAC,+DAAU;AACjC,cAAc,mBAAO,CAAC,mEAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,yBAAyB,mBAAO,CAAC,qFAAqB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,6BAA6B;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7Qa;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,oBAAoB,mBAAO,CAAC,iEAAW;AACvC,cAAc,mBAAO,CAAC,mEAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,yBAAyB,mBAAO,CAAC,qFAAqB;AACtD,oBAAoB,mBAAO,CAAC,qEAAiB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,cAAc;AACd,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,qBAAqB;AACrD,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,iDAAiD;AACjF;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ,sBAAsB,EAAE;AAC7C,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzba;;AAEb,cAAc,mBAAO,CAAC,mEAAS;;AAE/B;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,4BAA4B;AACtE,IAAI;AACJ;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,mBAAmB;AACpC,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA,+B;;;;;;;;;;;;ACxLa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;;AAEA,cAAc,mBAAO,CAAC,mEAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,eAAe,mBAAO,CAAC,+DAAU;AACjC;AACA,oBAAoB,mBAAO,CAAC,iEAAW;;AAEvC;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAAwE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yEAAyE;AAC7F;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D;AACA;;AAEA;AACA;AACA,YAAY,oDAAoD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA,wBAAwB,0EAA0E;AAClG;AACA,wBAAwB,0FAA0F;AAClH;AACA,wBAAwB,qDAAqD;AAC7E;AACA,wBAAwB,2BAA2B;AACnD;AACA,wBAAwB,qDAAqD;AAC7E;AACA,wBAAwB,+FAA+F;AACvH;AACA;;AAEA;AACA;AACA;AACA,YAAY,oDAAoD;AAChE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,oDAAoD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,oDAAoD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gDAAgD;AAC5F;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3hBa;;AAEb,cAAc,mBAAO,CAAC,mEAAS;AAC/B,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,0BAA0B;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,+CAA+C,qCAAqC;AACpF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,aAAa;AAC5B,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,eAAe,O;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC9Qa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,mEAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,cAAc,mBAAO,CAAC,6DAAS;AAC/B,oBAAoB,mBAAO,CAAC,uFAAsB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC;;AAEA;AACA,aAAa,aAAa;AAC1B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACzjBa;;AAEb;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAO,CAAC,uFAAkB;AAClD,yBAAyB,mBAAO,CAAC,yFAAmB,E;;;;;;;;;;;;ACRvC;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,uBAAuB,mBAAO,CAAC,yFAAmB;AAClD,eAAe,mBAAO,CAAC,gEAAW;AAClC,eAAe,mBAAO,CAAC,kBAAM;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA,8BAA8B,+CAA+C;AAC7E;AACA;;AAEA;AACA,gCAAgC,oBAAoB;AACpD,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,uDAAuD,sCAAsC;AAC7F,aAAa,QAAQ;AACrB;AACA,uDAAuD,uCAAuC;AAC9F,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mGAAmG;AACnG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+EAA+E;AAC/E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,qCAAqC;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,oCAAoC;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+B;;;;;;;;;;;;ACrRa;;AAEb;AACA,mCAAmC,aAAa;AAChD;AACA,QAAQ,qBAAqB;AAC7B,MAAM,+BAA+B,KAAK,6BAA6B;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,aAAa;AAC1B;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,aAAa;AAC1B;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB;AACA,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gC;;;;;;;;;;;;ACzDa;AACb,gBAAgB,mBAAO,CAAC,uEAAW;AACnC,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,4B;;;;;;;;;;;;AC/Pa;AACb,aAAa,mBAAO,CAAC,8CAAM;AAC3B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;;AAE9E;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,eAAe;AACjC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,SAAS,KAAK,SAAS;AACnC,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA,cAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC1rBa;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,eAAe,mBAAO,CAAC,gEAAW;AAClC,iBAAiB,mBAAO,CAAC,2EAAa;AACtC,aAAa,mBAAO,CAAC,iEAAQ;AAC7B,wBAAwB,mBAAO,CAAC,yFAAoB;AACpD,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;AACA;AACA,4DAA4D,iDAAiD;AAC7G;AACA;AACA,aAAa,mBAAO,CAAC,8CAAM;;;AAG3B;AACA;AACA,UAAU;AACV,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,SAAS;AACT;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,UAAU;AACV,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;;AAE3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,4BAA4B;AACtF;AACA,YAAY,8BAA8B;AAC1C,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,wBAAwB;AAC9E;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,+EAAe;AAC5C,mBAAmB,mBAAO,CAAC,yEAAY;AACvC;AACA,sBAAsB,mBAAO,CAAC,iFAAgB;AAC9C,kBAAkB,mBAAO,CAAC,uEAAW;AACrC,oBAAoB,mBAAO,CAAC,6EAAc;AAC1C,oBAAoB,mBAAO,CAAC,6EAAc;AAC1C;AACA,oBAAoB,mBAAO,CAAC,6EAAc;AAC1C,uBAAuB,mBAAO,CAAC,mFAAiB;AAChD,cAAc,mBAAO,CAAC,+DAAO;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,mEAAS;AACjC;AACA;AACA;;;;;;;;;;;;;ACnmBa;;AAEb,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY,mBAAO,CAAC,8DAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;;AAGA,WAAW,SAAS;AACpB;;;AAGA,WAAW,SAAS;AACpB;;;AAGA;AACA,UAAU;AACV;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA,aAAa,OAAO;AACpB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA,aAAa;AACb,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA,aAAa,OAAO;AACpB;AACA;AACA;;;AAGA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;;;AAGA,aAAa,QAAQ;AACrB;AACA;AACA;;;AAGA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA,aAAa,SAAS;AACtB;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,iBAAiB,uBAAuB;AACxC,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;;AAGA,aAAa,SAAS;AACtB;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACt1Ba;AACb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,cAAc,mBAAO,CAAC,8DAAU;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,iGAAiG;AAC3K;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2B;;;;;;;;;;;;AC5Oa;AACb,aAAa,mBAAO,CAAC,8CAAM;AAC3B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,8DAAU;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2B;;;;;;;;;;;;ACvRa;;AAEb,aAAa,mBAAO,CAAC,8CAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6B;;;;;;;;;;;;AC/Ta;;AAEb,cAAc,mBAAO,CAAC,8DAAU;AAChC,sBAAsB,mBAAO,CAAC,qFAAkB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,aAAa;AAC1B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iC;;;;;;;;;;;;ACtNa;AACb,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA,gBAAgB,KAAK;AACrB,gBAAgB,eAAe;AAC/B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oDAAoD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY,QAAQ,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,2CAA2C;AAC9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kFAAkF;AACjH;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2B;;;;;;;;;;;;AC1Ka;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8B;;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oDAAoD;AAChG;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qB;;;;;;;;;;;;AChEa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,aAAa,mBAAO,CAAC,8CAAM;;AAE3B,aAAa,mBAAO,CAAC,iEAAQ;AAC7B,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,O;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,6B;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0B;;;;;;;;;;;;AC1Ya;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA,+CAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,uB;;;;;;;;;;;;ACvFa;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,cAAc,mBAAO,CAAC,8DAAU;;AAEhC;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzIa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+B;;;;;;;;;;;;AChIa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,+DAAU;;AAEjC;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,oCAAoC;;AAEpC;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA,cAAc;AACd;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,iBAAiB;AAC5B,cAAc,gBAAgB,YAAY,kDAAkD;AAC5F;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ,yCAAyC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0B;;;;;;;;;;;;ACn6Ba;AACb,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,cAAc,mBAAO,CAAC,mEAAS;AAC/B,cAAc,mBAAO,CAAC,gEAAY;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,KAAK;AACnB;AACA;AACA;;AAEA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,8CAA8C,EAAE;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qBAAqB,0CAA0C;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,kBAAM;AAC7B,aAAa,mBAAO,CAAC,yFAAa;;AAElC;AACA;AACA;AACA;;AAEA,sDAAsD,YAAY;;AAElE;AACA;AACA;AACA;;AAEA,sCAAsC,EAAE;AACxC,+CAA+C,EAAE;;AAEjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,iBAAiB,IAAI,aAAa,EAAE,EAAE,IAAI,UAAU,IAAI,oBAAoB,EAAE;;AAE/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8EAA8E;;AAE9E;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACzcA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7NA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C,iBAAiB;AACjB;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,sCAAI;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,yDAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,mDAAW;AACtC;;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,cAAI;AAC3B,2CAA2C,mBAAmB;AAC9D;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,gBAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvPA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAO,CAAC,6DAAc;AAC7C,yBAAyB,mBAAO,CAAC,6DAAc;AAC/C,eAAe,mBAAO,CAAC,kBAAM;;AAE7B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;;AAEvC;AACA,4CAA4C;AAC5C;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kBAAkB;AAC1B;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D,cAAc,oBAAoB;AAClC;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACzgBA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,sBAAQ;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,mBAAO,CAAC,gFAAqB;AACrE,CAAC;;AAED;AACA,uCAAuC,mBAAO,CAAC,sFAAwB;AACvE,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,cAAI;AAC7B,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,wBAAwB;AACxB;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,YAAY,mBAAO,CAAC,cAAI;;AAExB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AClIA,aAAa,mBAAO,CAAC,sDAAY;AACjC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,wBAAwB,mBAAO,CAAC,sBAAQ;;AAExC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B;;AAE3B;AACA,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,iBAAiB,mBAAO,CAAC,4DAAe;;;;;;;;;;;;ACVxC;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,qE;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,0DAAc;AACzC,aAAa,mBAAO,CAAC,4DAAU;AAC/B,cAAc,mBAAO,CAAC,gDAAS;AAC/B,iBAAiB,mBAAO,CAAC,wEAAmB;AAC5C,YAAY,mBAAO,CAAC,0EAAoB;AACxC,YAAY,mBAAO,CAAC,gDAAO;AAC3B,WAAW,mBAAO,CAAC,kDAAQ;AAC3B,WAAW,mBAAO,CAAC,kBAAM;AACzB,kBAAkB,mBAAO,CAAC,oDAAS;AACnC,yBAAyB,mBAAO,CAAC,oDAAS;AAC1C,mBAAmB,mBAAO,CAAC,oDAAS;AACpC,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,cAAc,mBAAO,CAAC,oEAAe;AACrC,YAAY,mBAAO,CAAC,wDAAa;AACjC,cAAc,mBAAO,CAAC,kBAAM;AAC5B,qBAAqB,mBAAO,CAAC,8DAAgB;AAC7C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,aAAoB,IAAI,KAAa;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,IAAI;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,YAAY,IAAI;AAChB;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,IAAI;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,IAAI;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,IAAI;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA,OAAO;AACP;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;ACnoBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,YAAY,mBAAO,CAAC,oEAAmB;AACvC,YAAY,mBAAO,CAAC,gEAAe;AACnC,YAAY,mBAAO,CAAC,kEAAgB;AACpC,aAAa,mBAAO,CAAC,4DAAU;AAC/B,UAAU,mBAAO,CAAC,wDAAW;AAC7B,UAAU,mBAAO,CAAC,0DAAY;;AAE9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV,GAAG;;AAEH;AACA;AACA,UAAU;AACV,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,0EAAoB;AAC5C;AACA,iBAAiB,mBAAO,CAAC,0DAAc;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;ACnHD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAO,CAAC,8DAAgB;;AAE7C;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,wDAAa;AACjC,eAAe,mBAAO,CAAC,kDAAU;AACjC,SAAS,mBAAO,CAAC,0CAAI;;AAErB;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,gDAAS;AAC/B,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,WAAW,mBAAO,CAAC,gBAAK;AACxB,aAAa,mBAAO,CAAC,gDAAS;AAC9B,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,4CAAO;AAC3B,iBAAiB,mBAAO,CAAC,0DAAc;AACvC,YAAY,mBAAO,CAAC,kDAAU;AAC9B,gBAAgB,mBAAO,CAAC,sDAAY;;AAEpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC5gBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,6EAAa;AAClC,yBAAyB,mBAAO,CAAC,wEAAqB;AACtD,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,gBAAgB,mBAAO,CAAC,oDAAW;AACnC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,WAAW,mBAAO,CAAC,kBAAM;AACzB,iBAAiB,mBAAO,CAAC,oDAAS;AAClC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,WAAW,mBAAO,CAAC,kBAAM;AACzB,eAAe,mBAAO,CAAC,kDAAU;AACjC,YAAY,mBAAO,CAAC,wDAAa;AACjC,WAAW,mBAAO,CAAC,kEAAkB;AACrC,oBAAoB,mBAAO,CAAC,oDAAS;AACrC,qBAAqB,mBAAO,CAAC,oDAAS;AACtC,iBAAiB,mBAAO,CAAC,oDAAS;AAClC,aAAa,mBAAO,CAAC,8CAAQ;AAC7B,WAAW,mBAAO,CAAC,0CAAM;AACzB;AACA;AACA;AACA,WAAW,mBAAO,CAAC,0CAAM;;AAEzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA,WAAW,oCAAoC;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA,WAAW,6BAA6B;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA,WAAW,6BAA6B;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4FAA4F;AAC5F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,qDAAqD,iBAAiB;AACtE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,aAAa;AACxB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,gCAAgC;AAChC;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA,oBAAoB,kCAAkC;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAyD;AAC9F;AACA;AACA,qCAAqC,iCAAiC;AACtE;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;;;;;;ACrnCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,2DAAS;AAC7B,YAAY,mBAAO,CAAC,2DAAS;AAC7B,cAAc,mBAAO,CAAC,gDAAS;AAC/B,YAAY,mBAAO,CAAC,wDAAa;AACjC,YAAY,mBAAO,CAAC,gDAAO;AAC3B,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,cAAc,mBAAO,CAAC,oEAAe;AACrC,eAAe,mBAAO,CAAC,kDAAU;AACjC,qBAAqB,mBAAO,CAAC,8DAAgB;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,IAAI;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrpBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,8DAAgB;AACzC,YAAY,mBAAO,CAAC,gDAAO;;AAE3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,gDAAO;AAC3B,cAAc,mBAAO,CAAC,oEAAe;AACrC,YAAY,mBAAO,CAAC,2DAAS;AAC7B,cAAc,mBAAO,CAAC,gDAAS;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,WAAW,SAAS;AACpB,YAAY,MAAM;AAClB;AACA;;AAEA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;ACvND;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,6EAAa;AAClC,yBAAyB,mBAAO,CAAC,wEAAqB;AACtD,kBAAkB,mBAAO,CAAC,0DAAc;AACxC,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,cAAc,mBAAO,CAAC,oEAAe;AACrC,WAAW,mBAAO,CAAC,0CAAM;AACzB,WAAW,mBAAO,CAAC,0CAAM;AACzB,gBAAgB,mBAAO,CAAC,sDAAY;AACpC,SAAS,mBAAO,CAAC,0CAAI;AACrB,kBAAkB,mBAAO,CAAC,gCAAa;;AAEvC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA,oCAAoC,cAAc;;AAElD;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA,qCAAqC,aAAa;;AAElD;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,OAAO,qCAAqC;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA,4BAA4B;AAC5B,aAAa,wCAAwC;;AAErD,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,gDAAO;AAC3B,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,iEAAQ,GAAG,CAAC;;AAEzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,2BAA2B;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACrLA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,gDAAO;AAC3B,gBAAgB,mBAAO,CAAC,oDAAW;AACnC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,eAAe,mBAAO,CAAC,kDAAU;AACjC,eAAe,mBAAO,CAAC,kDAAU;AACjC,aAAa,mBAAO,CAAC,8CAAQ;;AAE7B;AACA;AACA;AACA;;AAEA,gCAAgC,EAAE;AAClC;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,aAAoB;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;;;;;;;;;;;;AC1UA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACxIA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,qBAAqB,mBAAO,CAAC,8DAAgB;AAC7C,eAAe,mBAAO,CAAC,kDAAU;AACjC,eAAe,mBAAO,CAAC,8EAAU;AACjC,mBAAmB,mBAAO,CAAC,0DAAc;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;;;ACzQA;AACA,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA,CAAC;AACD,mBAAmB,mBAAO,CAAC,mGAAuB;AAClD;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBa;AACb,aAAa,mBAAO,CAAC,0DAAc;;AAEnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,WAAW;AAC1B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,WAAW;AACrC;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,0BAA0B,WAAW;AACrC;AACA,K;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU,UAAU;AACpB;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO,OAAO;AAC9C;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA,uCAAuC;AACvC,2BAA2B,iBAAiB;AAC5C;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,mCAAmC,SAAS;AAC5C,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,S;AACA,4CAA4C;AAC5C;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0B;AACA;;AAEA;AACA,gDAAgD;AAChD,iCAAiC;AACjC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D;AACA,8CAA8C;AAC9C;AACA;;AAEA,aAAa,uCAAuC;AACpD;;AAEA,aAAa,iCAAiC;;AAE9C;AACA;AACA;AACA,uCAAuC;AACvC,qCAAqC;;AAErC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE,qEAAqE;AACrE,mEAAmE;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;;AAEA,sBAAsB;AACtB;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,8CAA8C;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,gBAAgB;AAC1C;;AAEA;AACA;;AAEA,yB;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,sCAAsC;AACtC;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACziBa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,wFAAwB,GAAG;AACtE,oBAAoB,+BAA+B;AACnD,0BAA0B,yBAAyB;AACnD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,kFAAqB,GAAG;AACnE,oBAAoB,+BAA+B;AACnD,KAAK;;AAEL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,kFAAqB,GAAG;AACnE,KAAK;;AAEL;AACA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,kFAAqB,SAAS,mBAAO,CAAC,0FAAyB,IAAI;AAC9G,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,kFAAqB,SAAS,mBAAO,CAAC,0FAAyB,IAAI;AAC9G,6BAA6B,QAAQ,mBAAO,CAAC,oGAA8B,GAAG;AAC9E;AACA,oBAAoB,YAAY;AAChC,KAAK;;AAEL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,kFAAqB,GAAG;AACnE,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,kFAAqB,GAAG;AACnE,KAAK;;AAEL;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,mBAAO,CAAC,kFAAqB,SAAS,mBAAO,CAAC,4FAA0B,IAAI;AAC/G;AACA,KAAK;;AAEL;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ka;;AAEb;AACA;AACA;AACA,IAAI,mBAAO,CAAC,mEAAY;AACxB,IAAI,mBAAO,CAAC,6DAAS;AACrB,IAAI,mBAAO,CAAC,2DAAQ;AACpB,IAAI,mBAAO,CAAC,uEAAc;AAC1B,IAAI,mBAAO,CAAC,qEAAa;AACzB,IAAI,mBAAO,CAAC,yFAAuB;AACnC,IAAI,mBAAO,CAAC,uEAAc;AAC1B,IAAI,mBAAO,CAAC,qEAAa;AACzB;;AAEA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBa;AACb,aAAa,mBAAO,CAAC,0DAAc;;AAEnC;;AAEA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,mCAAmC;AAChD;;AAEA,aAAa,mCAAmC;AAChD;;AAEA,aAAa,oBAAoB;AACjC,aAAa,oBAAoB;AACjC,aAAa,oBAAoB;;AAEjC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAO,CAAC,sCAAgB;;AAE5C;AACA;;;AAGA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,wCAAwC;AACxC,gCAAgC;AAChC;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA,aAAa,2BAA2B;AACxC;AACA,8BAA8B;AAC9B,aAAa,2BAA2B;AACxC;AACA,8BAA8B;AAC9B,aAAa,OAAO;AACpB;AACA;AACA,SAAS,OAAO;AAChB,gCAAgC;AAChC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3La;AACb,aAAa,mBAAO,CAAC,0DAAc;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,+BAA+B;AAClD;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uNAAuN,iEAAiE,EAAE;AAC1R,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,2JAA2J,iEAAiE,EAAE;AAC9N,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yLAAyL,iEAAiE,EAAE;AAC5P,GAAG;AACH;AACA;AACA,uNAAuN,iEAAiE,EAAE;AAC1R,GAAG;AACH;AACA;AACA,uNAAuN,gEAAgE,EAAE;AACzR,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AClca;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5Ka;AACb,aAAa,mBAAO,CAAC,0DAAc;;AAEnC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC,yBAAyB,mBAAmB;AAC5C;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA,UAAU,kBAAkB;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,+DAA+D,4BAA4B;;AAE3F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;;AAEnE,2BAA2B,UAAU;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC9Ka;AACb,aAAa,mBAAO,CAAC,0DAAc;;AAEnC;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,gBAAgB;AACnC,wBAAwB;AACxB;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA,SAAS,OAAO;AAChB,uCAAuC;AACvC,wDAAwD;AACxD;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D,KAAK;AACL;;AAEA,+DAA+D;AAC/D,iDAAiD;AACjD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,SAAS,OAAO;AAChB;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,wBAAwB;AACxB;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA,SAAS,OAAO;AAChB,2CAA2C;AAC3C,wDAAwD;AACxD;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D,KAAK;AACL;;AAEA,+DAA+D;AAC/D,iDAAiD;AACjD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/Ra;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;AClDa;AACb,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,mBAAO,CAAC,sBAAQ;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,2BAA2B,mBAAO,CAAC,sBAAQ;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8FAA8F;;AAE9F;;AAEA,yBAAyB,mBAAO,CAAC,sBAAQ;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAO,CAAC,sBAAQ;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxNa;;AAEb;AACA;AACA,aAAa,mBAAO,CAAC,0DAAc;;AAEnC,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;;AAE3B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,mBAAO,CAAC,kEAAc,EAAE;;AAElD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yEAAyE;AACzE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,EAAE;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,mBAAO,CAAC,2DAAW;AAC3B;;AAEA;AACA,IAAI,mBAAO,CAAC,mEAAe;AAC3B;;AAEA,IAAI,KAAe,EAAE,EAEpB;;;;;;;;;;;;;ACxJY;;AAEb,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,gBAAgB,mBAAO,CAAC,sBAAQ;;;AAGhC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA,kBAAkB;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,oBAAoB,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA,kBAAkB;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,cAAc,EAAE;AACrD;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACvHA;AACA,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA,mBAAmB,mBAAO,CAAC,0EAAuB;AAClD;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;AACA;;AAEA;;AAEA;;AAEA,OAAO,KAA6B;AACpC;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,GAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA,yBAAyB,GAAG;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,mFAAmF,EAAE;AACrF;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;;AChqBD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,IAA6C;AAC/D,QAAQ,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAC3B,wBAAwB,EAGkD;;AAE1E,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB,8CAA8C;AACnF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,kBAAkB;AACjG;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,qFAAqF,qBAAqB;AAC1G;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,qFAAqF,oBAAoB;AACzG;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,8FAA8F,2BAA2B;AACzH;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,wFAAwF,uBAAuB;AAC/G;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,iGAAiG,8BAA8B;AAC/H;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,kBAAkB;AACzE;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mFAAmF,oBAAoB;AACvG;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gFAAgF,oBAAoB;AACpG;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,kBAAkB;AAC1F;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE,kBAAkB;AACtF;AACA,eAAe,oBAAoB;AACnC,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iGAAiG,qBAAqB;AACtH;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iHAAiH,sBAAsB;AACvI;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,4GAA4G,8BAA8B;AAC1I;AACA,eAAe,aAAa;AAC5B,iBAAiB,MAAM;AACvB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACtjCD;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC;AACA,yDAAyD,MAAM;AAC/D,qDAAqD,MAAM;AAC3D,oDAAoD,MAAM,oCAAoC,MAAM;;AAEpG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC7QA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,iDAAW;;;;;;;;;;;;;ACVpC;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,gDAAS;AAC1B,cAAc,mBAAO,CAAC,kBAAM;;AAE5B;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;AC3LA,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,mBAAO,CAAC,oDAAc;;AAElC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,+DAAe;AACtC;AACA;AACA,eAAe,mBAAO,CAAC,iEAAgB;AACvC;AACA;AACA,eAAe,mBAAO,CAAC,iEAAgB;AACvC;AACA;AACA,eAAe,mBAAO,CAAC,mEAAiB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,UAAU;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,UAAU;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,aAAa,YAAY;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC;AAClC,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS,YAAY;;AAE9D;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;;AAE/B,wBAAwB,uBAAuB;AAC/C;AACA;AACA,KAAK;AACL,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrSA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,kDAAU;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7JA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AChIA;AACA;AACA;AACA;;AAEa;;AAEb,mBAAmB,mBAAO,CAAC,kEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,kEAAgB;AAC3C,sBAAsB,mBAAO,CAAC,kEAAgB;AAC9C,6BAA6B,mBAAO,CAAC,sEAAkB;;AAEvD,kBAAkB,mBAAO,CAAC,gEAAe;AACzC,gBAAgB,mBAAO,CAAC,4DAAa;AACrC,oBAAoB,mBAAO,CAAC,oEAAiB;AAC7C,kBAAkB,mBAAO,CAAC,gEAAe;AACzC,sBAAsB,mBAAO,CAAC,wEAAmB;;AAEjD,wBAAwB,mBAAO,CAAC,kFAAwB;AACxD,6BAA6B,mBAAO,CAAC,kFAAwB;;AAE7D,gCAAgC,mBAAO,CAAC,8EAAsB;;AAE9D,sBAAsB,mBAAO,CAAC,oFAAyB;AACvD,6BAA6B,mBAAO,CAAC,gEAAe;;;;;;;;;;;;;ACxBvC;;AAEb;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,iBAAiB,mBAAO,CAAC,8DAAY;AACrC,OAAO,UAAU,GAAG,mBAAO,CAAC,sDAAQ;AACpC,OAAO,cAAc,GAAG,mBAAO,CAAC,gFAAqB;;AAErD;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD,YAAY,UAAU;AACtB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;;AAEA;;;;;;;;;;;;;AChMA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;;AAEpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;;AAE1B;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,mBAAmB,4BAA4B;AAC/C;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnLa;;AAEb,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,yBAAyB,mBAAO,CAAC,8FAA4B;AAC7D,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,mCAAmC,mBAAO,CAAC,kHAAsC;AACjF,kCAAkC,mBAAO,CAAC,gHAAqC;AAC/E,qBAAqB,mBAAO,CAAC,sFAAwB;AACrD,uBAAuB,mBAAO,CAAC,0FAA0B;AACzD,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,wBAAwB,mBAAO,CAAC,4FAA2B;AAC3D,8BAA8B,mBAAO,CAAC,wGAAiC;AACvE,gBAAgB,mBAAO,CAAC,4EAAmB;AAC3C,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C,OAAO,8CAA8C,GAAG,mBAAO,CAAC,sDAAQ;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACpFA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;AACpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;;AAE1B;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,SAAS;AACvB;AACA;AACA;AACA,WAAW;AACX,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,OAAO;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvQA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,uBAAuB,mBAAO,CAAC,8DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;AACpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;;AAE1B;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,sBAAsB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,OAAO;AACP,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,SAAS;AACvB;AACA;AACA;AACA,UAAU;AACV,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,kCAAkC;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D,8CAA8C,eAAe;AAC7D,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClUa;;AAEb,OAAO,sBAAsB,GAAG,mBAAO,CAAC,sDAAQ;;AAEhD;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB,GAAG,IAAI;AAC5C,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU,WAAW;AAClC;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;;AAEhC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9Ba;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,wBAAwB,mBAAO,CAAC,oGAA2B;;AAE3D;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtEa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC;;AAEA;AACA,MAAM,mBAAO,CAAC,cAAI;AAClB,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0DAA0D,WAAW;AACrE,CAAC;;AAED,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA,YAAY;AACZ,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC,oBAAoB,mBAAmB;AACvC;AACA,KAAK,mBAAmB;AACxB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3Ea;;AAEb;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,GAAG;AACH,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCa;;AAEb;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACba;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,qBAAqB,mBAAO,CAAC,wFAAqB;AAClD,wBAAwB,mBAAO,CAAC,oGAA2B;;AAE3D;;AAEA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,WAAW,mBAAO,CAAC,cAAI;;AAEvB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEa;;AAEb,gBAAgB,mBAAO,CAAC,6DAAY;AACpC;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,gHAAiC;AAC3E,OAAO,gBAAgB,GAAG,mBAAO,CAAC,gHAAiC;AACnE,cAAc,mBAAO,CAAC,yDAAU;;AAEhC;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AChDa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,WAAW,mBAAO,CAAC,cAAI;;AAEvB;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;;ACvCa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,wBAAS;;AAEjC;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;;ACjCa;AACb,cAAc,mBAAO,CAAC,yDAAU;AAChC,OAAO,wBAAwB,GAAG,mBAAO,CAAC,gHAAiC;AAC3E,OAAO,gBAAgB,GAAG,mBAAO,CAAC,gHAAiC;;AAEnE;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCa;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC;;AAEA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3Ba;;AAEb,cAAc,mBAAO,CAAC,yDAAU;AAChC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvCa;;AAEb,YAAY,mBAAO,CAAC,gBAAK;AACzB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,oBAAO;AAC7B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe,eAAe;AAC/C;AACA,GAAG,EAAE,6BAA6B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB,GAAG,mCAAmC;AAC5E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjGa;AACb,OAAO,mBAAmB,GAAG,mBAAO,CAAC,sDAAQ;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA,yBAAyB,KAAK,GAAG,wBAAwB;AACzD,yBAAyB,KAAK,GAAG,UAAU;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,IAAI,IAAI,kCAAkC;AAC3D;;AAEA;AACA;AACA,oBAAoB,EAAE,wCAAwC;AAC9D;;AAEA,iBAAiB,WAAW,GAAG,4BAA4B;AAC3D;AACA,gBAAgB,cAAc;AAC9B;AACA,gBAAgB,YAAY;AAC5B;;AAEA,YAAY,KAAK,IAAI,KAAK,IAAI,OAAO;AACrC;;AAEA;AACA;;AAEA;AACA,iBAAiB,+CAA+C;AAChE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/JA;AACA;AACA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,iBAAiB,GAAG,mBAAO,CAAC,8DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sDAAQ;AACpB;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,kEAAc;AAC1B,4BAA4B,mBAAO,CAAC,oFAAuB;;AAE3D,oCAAoC;;AAEpC;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,sBAAsB;AAClC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;AAClB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,SAAS;AACvB;AACA;AACA;AACA,UAAU;AACV,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,kCAAkC;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClSa;;AAEb,OAAO,UAAU,GAAG,mBAAO,CAAC,kDAAS;;AAErC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7Da;;AAEb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF,YAAY,MAAM;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,OAAO,cAAc;AACrB,aAAa,QAAQ,GAAG,gBAAgB;AACxC;AACA,YAAY,QAAQ,GAAG,gBAAgB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+FAA+F,YAAY,QAAQ,EAAE;AACrH;AACA;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd,YAAY,EAAE;AACd,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpIa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,MAAM,yCAAyC;AACnE;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,oDAAW;AACnC,aAAa,mBAAO,CAAC,yDAAW;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtUa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;ACjBa;;AAEb,gBAAgB,mBAAO,CAAC,uDAAa;AACrC,YAAY,mBAAO,CAAC,+CAAS;AAC7B,cAAc,mBAAO,CAAC,mDAAW;;AAEjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,+CAAS;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gCAAgC;;AAExE;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACjPa;;AAEb,YAAY,mBAAO,CAAC,+CAAS;AAC7B,cAAc,mBAAO,CAAC,mDAAW;AACjC;;AAEA;AACA,yCAAyC;AACzC;AACA,KAAK;AACL;AACA,4CAA4C;AAC5C;AACA,KAAK;AACL,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC5Qa;;AAEb;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD,EAAE;AACpD;AACA,SAAS;AACT;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,OAAO,WAAW,aAAa;AACjD;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,4CAAO;AAC3B,kBAAkB,mBAAO,CAAC,wDAAa;AACvC,YAAY,mBAAO,CAAC,0DAAY;AAChC,aAAa,mBAAO,CAAC,8CAAQ;;AAE7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACmD;AACiC;AACnB;AACP;AACb;AACgB;AACJ;AACF;AACW;AACG;AACA;AAC2B;AACA;AAC/C;AACM;AACJ;AACsB;AAC7B;AACA;AACQ;AACQ;AACsB;AAC1B;AAC0B;AACR;AACd;AACM;AACQ;AACN;AACd;AACF;AACA;AACM;AACR;AACU;AACc;AAChB;AACV;AACU;AACN;AACA;AACN;AAC8B;AACxB;AACQ;AACV;AACE;AACU;AACV;AACA;AACJ;AACW;AACP;AACA;AACT;AAC3C;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACG;AACU;AAC9C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gDAAO;AACe;AACxB;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACG;AACqC;AACzE;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gDAAO;AACkB;AAC3B;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AACiC;AACS;AAC1C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACe;AAC3B;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACN;AACgB;AAC9C;AACP;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAE;AACzB;AACA,uBAAuB,yEAAU;AACjC;AACA,uBAAuB,+DAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACuD;AACJ;AACmB;AAC1B;AACV;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAY;AAC/B;AACA;AACA;AACA;AACA,qCAAqC,8CAAM;AAC3C;AACA;AACA;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAM;AACtB;AACA;AACA;AACA,gBAAgB,2EAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAiB;AAC1C;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB,EAAE,kBAAkB,oBAAoB,EAAE,eAAe,uBAAuB,EAAE;AAC9I,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA,sBAAsB,8CAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AACkC;AACuB;AAClD;AACP;AACA,4BAA4B,EAAE;AAC9B;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA,YAAY,6EAAe;AAC3B;AACA,KAAK;AACL,2BAA2B;AAC3B;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AACiC;AACS;AAC1C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACe;AAC3B;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACG;AACM;AACI;AACc;AACa;AACb;AAC5D;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA,2BAA2B,0DAAY;AACvC;AACA;AACA;AACA,+BAA+B,wEAAmB;AAClD;AACA;AACA,4CAA4C,wEAAmB;AAC/D;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gDAAO;AACgB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACpHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA,CAAC;AACoB;AACrB;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACS;AACA;AACI;AAC2B;AACb;AACyB;AACrF;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACiB;AAC7B;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA,uBAAuB,wEAAmB;AAC1C;AACA;AACA;AACA,6BAA6B,sDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACO;AACnB;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA,CAAC;AAC2B;AAC5B;;;;;;;;;;;;;AC7JA;AAAA;AAAA;AAAA;AAAA;AACiC;AACa;AAC9C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,0DAAY;AACiB;AAC/B;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACc;AACK;AACN;AACuC;AACnD;AACuB;AACzD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+CAAa;AACjD;AACA;AACA;AACA,wCAAwC,+CAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0EAAkB,iBAAiB,aAAa;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,0DAAY;AACQ;AACtB;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,mEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAa;AAChD;AACA,oBAAoB,mEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8CAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,6CAA6C;AAChG,qBAAqB,8CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAM;AACtB;AACA;AACA;AACA,gBAAgB,6EAAe;AAC/B;AACA;AACA;AACA;AACA,aAAa,8CAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAM;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;;;;;;;;;;;;;ACxOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACyC;AACE;AACI;AACkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA,YAAY,mEAAU;AACtB;AACA;AACA;AACA;AACA,sCAAsC,6EAAmB;AACzD;AACA;AACA,YAAY,6DAAO;AACnB;AACA;AACA;AACA;AACA,oBAAoB,+DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,yCAAyC,6EAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6EAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACuB;AACxB;AACA,+CAA+C,oCAAoC,6EAAmB,sBAAsB,EAAE;AAC9H;AACA;;;;;;;;;;;;;ACvIA;AAAA;AAAA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACc;AACJ;AACA;AACI;AACyB;AACxE;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0DAAY;AAC5D;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAmB;AAClC;AACA;AACA,CAAC,CAAC,sDAAU;AACqB;AACjC;AACO;AACP,eAAe,cAAc;AAC7B,gBAAgB,2BAA2B;AAC3C,eAAe,8BAA8B;AAC7C,kBAAkB,8BAA8B;AAChD,iBAAiB,qCAAqC;AACtD,kBAAkB,sDAAsD;AACxE,iBAAiB,qCAAqC;AACtD,cAAc,kCAAkC;AAChD,eAAe;AACf;AACA;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,0DAAiB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC3IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACF;AACK;AAC9C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAS;AACtB;AACA;AACA;AACA,8BAA8B,oDAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC,CAAC,sDAAU;AACqB;AACjC;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACI;AACR;AACiB;AACd;AACQ;AAC3C;AACP;AACA,YAAY,qEAAW;AACvB;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA,sFAAsF,0DAAG,kBAAkB,QAAQ,6DAAO,mEAAmE,EAAE;AAC/L;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAU;AAC7B;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAY;AACnD;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,2DAA2D,iCAAiC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACI;AACR;AACiB;AACN;AACR;AACnC;AACP;AACA,YAAY,qEAAW;AACvB;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA,0FAA0F,0DAAG,kBAAkB,QAAQ,6DAAO,mEAAmE,EAAE;AACnM;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAU;AAC7B;AACA;AACA;AACA;AACA,mDAAmD,0DAAY;AAC/D;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAA2D;AACnH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAY;AACnD;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA,gEAAgE,6BAA6B;AAC7F;AACA;AACA;AACA,+DAA+D,iCAAiC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,6BAA6B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACiB;AACR;AACW;AACS;AACtB;AACxC;AACO;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,QAAQ,qEAAW;AACnB;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAO;AAC3C;AACA;AACA,WAAW,4DAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgC;AACjC;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA,yBAAyB,iFAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACkB;AACnC;;;;;;;;;;;;;ACpGA;AAAA;AAAA;AAAA;AAAA;AAC0B;AACyB;AAC5C;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,WAAW,sEAAS,GAAG,sCAAE;AACzB;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACb;AACE;AACzB;AACP,eAAe,sDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAI,UAAU,oDAAK;AAChD;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACpC,8BAA8B,sDAAU,wBAAwB,8BAA8B,EAAE;AAChG;AACP;AACA;AACA;AACA,eAAe,sDAAU,wBAAwB,wCAAwC,8BAA8B,EAAE,EAAE,EAAE;AAC7H;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACD;AACH;AACK;AACd;AACvB;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,YAAY,6DAAO;AACnB;AACA;AACA,YAAY,+DAAQ;AACpB;AACA,6DAA6D,qBAAqB,EAAE;AACpF;AACA;AACA;AACA;AACA,2CAA2C,6DAAO;AAClD,oDAAoD,0DAAG,kBAAkB,6CAA6C,EAAE;AACxH;AACA;AACA;AACA;AACA,eAAe,sDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uCAAuC,8BAA8B,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA,uEAAuE,0CAA0C,EAAE,IAAI;AACvH;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACO;AACC;AAC5C;AACP;AACA,6BAA6B,sDAAU;AACvC;AACA;AACA,mBAAmB,sDAAU,CAAC,qEAAW;AACzC;AACA;AACA,eAAe,sEAAS;AACxB;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACiB;AACD;AACpD;AACP;AACA,mBAAmB,sDAAU,CAAC,+EAAgB;AAC9C;AACA;AACA,eAAe,8EAAa;AAC5B;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACD;AACM;AACT;AACvC;AACO;AACP,QAAQ,mEAAU;AAClB;AACA;AACA;AACA;AACA,0DAA0D,0DAAG,kBAAkB,QAAQ,6DAAO,mEAAmE,EAAE;AACnK;AACA,eAAe,sDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kEAAkE;AACrG;AACA;AACA;AACA;AACA,mCAAmC,yCAAyC;AAC5E;AACA;AACA;AACA;AACA,mCAAmC,oDAAoD;AACvF;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACD;AACM;AACT;AAChC;AACP;AACA,gEAAgE,0DAAG,kBAAkB,QAAQ,6DAAO,mEAAmE,EAAE;AACzK;AACA,eAAe,sDAAU;AACzB;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAU;AACvB;AACA;AACA,4BAA4B,yCAAyC;AACrE,KAAK;AACL;AACA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACC;AACM;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uDAAQ;AAC3D;AACA;AACA,yDAAyD,qEAAW;AACpE;AACA,yBAAyB,uDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5HA;AAAA;AAAA;AAAA;AAAA;AACgC;AACA;AACzB;AACP;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA,WAAW,oDAAK,cAAc,+CAA+C,EAAE;AAC/E;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACA;AACG;AACvC;AACP;AACA;AACA;AACA;AACA,oBAAoB,sDAAK;AACzB;AACA,SAAS,iEAAS;AAClB;AACA;AACA;AACA,oBAAoB,sDAAK;AACzB;AACA,eAAe,sDAAU;AACzB,6DAA6D,qDAAqD;AAClH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,+DAA+D;AAClF;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACO;AACD;AACT;AACjC;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,sDAAU;AAC9F;AACA;AACA,WAAW,oEAAQ,aAAa,4DAAS;AACzC;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACP;AAC7B,8BAA8B,sDAAU,CAAC,+CAAI;AAC7C;AACP;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACkD;AACV;AACmB;AACpD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,QAAQ,qEAAW;AACnB;AACA,eAAe,8EAAa;AAC5B;AACA;AACA,eAAe,4DAAS;AACxB;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACb;AACY;AACV;AACzB;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,eAAe,4CAAK;AACpB;AACA;AACA,gCAAgC,6DAAO;AACvC;AACA;AACA,eAAe,sDAAU;AACzB,mCAAmC,yFAAyF;AAC5H,eAAe,kDAAI;AACnB,oCAAoC,wBAAwB,EAAE;AAC9D;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACI;AACxC;AACP;AACA,mBAAmB,sDAAU;AAC7B;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,sDAAU;AAC7B;AACA,mCAAmC,0DAAY;AAC/C,8DAA8D,qFAAqF;AACnJ;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4CAA4C,6FAA6F;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACkC;AACgB;AACL;AACF;AACpC;AACP;AACA,QAAQ,gEAAM,yBAAyB,sDAAU,CAAC,qEAAW;AAC7D,QAAQ,gEAAM,CAAC,qDAAG,0BAA0B,sDAAU,CAAC,qEAAW;AAClE;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACS;AACF;AACa;AACS;AACvD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,YAAY,6DAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA,mCAAmC,iFAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACS;AAC1B;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACpC;AACP;AACA;AACA;AACA,eAAe,sDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAC2C;AACpC;AACP;AACA,mBAAmB,sDAAU,wBAAwB,gCAAgC,EAAE;AACvF;AACA;AACA,mBAAmB,sDAAU,wBAAwB,yCAAyC,uCAAuC,EAAE,EAAE;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACA;AACG;AACI;AAC3C;AACP;AACA;AACA;AACA;AACA,QAAQ,iEAAS;AACjB;AACA;AACA,aAAa,qEAAW;AACxB;AACA;AACA,SAAS,qEAAW;AACpB,oBAAoB,sDAAK;AACzB;AACA,eAAe,sDAAU;AACzB,kBAAkB,iEAAS;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACb;AACE;AACzB;AACP,eAAe,sDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAI,WAAW,4CAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACO;AACE;AACC;AACU;AACS;AACe;AACtE;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAO;AACnB;AACA;AACA,8BAA8B,kEAAe;AAC7C,oDAAoD,kEAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAe;AACjD;AACA;AACA;AACA;AACA;AACA,kCAAkC,+BAA+B,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iFAAiB;AAChC;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACzNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iFAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACX;AACY;AACrC;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA,WAAW,oDAAK,cAAc,QAAQ,+DAAK,sBAAsB,EAAE;AACnE;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA,kBAAkB,iFAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACA;AACO;AAC3C;AACP;AACA,oBAAoB,sDAAK;AACzB,QAAQ,qEAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,2CAA2C;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACc;AACe;AACT;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,kBAAkB,iFAAiB;AACnC;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C,uBAAuB;AACvB;AACA,gCAAgC,iFAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACc;AACM;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,gCAAgC,iFAAiB;AACjD;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACA;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAe;AACrD;AACA,YAAY,iFAAiB;AAC7B;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AACoE;AAC7D;AACP,8BAA8B,wBAAwB,+EAAqB,WAAW;AACtF;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0C;AAC0B;AAC1B;AAC1C;AACO;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAO;AAC3C;AACA;AACA,8BAA8B,yBAAyB,6DAAI,oCAAoC,+EAAqB,WAAW;AAC/H;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAC8D;AACvD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,8BAA8B,yBAAyB,yDAAY,8CAA8C;AACjH;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AACsC;AAC/B;AACP,WAAW,0DAAQ;AACnB;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACsC;AAC/B;AACP,WAAW,0DAAQ;AACnB;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACwC;AACjC;AACP,WAAW,4DAAS,cAAc,wBAAwB,EAAE;AAC5D;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,0DAA0D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP,8BAA8B,4DAA4D;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iFAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACA;AACpC;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA,8BAA8B,kEAAkE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA;AACA;AACA;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA,8BAA8B,8DAA8D;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACH;AACG;AACI;AACxC;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA,wBAAwB,2DAAM;AAC9B;AACA,8BAA8B,4DAA4D;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACA;AACU;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAkE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP,8BAA8B,gEAAgE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAsB,iFAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACa;AAC9B;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,4EAA4E;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAC8D;AACvD;AACP,WAAW,kFAAoB,kBAAkB,8DAA8D,EAAE;AACjH;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0E;AACxC;AACY;AACI;AACpB;AACvB;AACP;AACA,kBAAkB,qFAAuB;AACzC;AACA;AACA;AACA,2BAA2B,sDAAM,kBAAkB,oBAAoB,EAAE,GAAG,kDAAI;AAChF,cAAc,sEAAc;AAC5B,cAAc,kEAAY,cAAc,YAAY,qFAAuB,GAAG,EAAE;AAChF;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACR;AAC/B;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,8BAA8B,QAAQ,iEAAM,SAAS,iDAAE,uBAAuB;AAC9E;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,mEAAmE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP,8BAA8B,+CAA+C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iFAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACA;AACS;AAClC;AACc;AACnC;AACP;AACA,kCAAkC,gDAAgD,QAAQ,6DAAI,qBAAqB,gDAAG,mBAAmB,oCAAoC,EAAE,GAAG,EAAE,GAAG;AACvL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAe;AACjD;AACA;AACA,QAAQ,iFAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAwE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iFAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACW;AAC5B;;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACI;AACxC;AACP,8BAA8B,mDAAmD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA,8BAA8B,8EAA8E;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACmB;AAC/B;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AACsD;AAC/C;AACP,8BAA8B,wBAAwB,iEAAiB,oCAAoC;AAC3G;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACgD;AACd;AACJ;AACoB;AACJ;AACF;AACrC;AACP;AACA,8BAA8B,gCAAgC,sDAAM,kBAAkB,gCAAgC,EAAE,IAAI,uDAAQ,EAAE,kDAAI,uBAAuB,sEAAc,iBAAiB,kEAAY,cAAc,YAAY,2DAAU,GAAG,EAAE,GAAG;AACxP;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACI;AACJ;AACN;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gDAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACiB;AAC7B;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,0DAAY;AACd;;;;;;;;;;;;;ACrLA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,2CAA2C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACgD;AACd;AACI;AACQ;AACI;AACN;AACrC;AACP;AACA,8BAA8B,gCAAgC,sDAAM,kBAAkB,gCAAgC,EAAE,IAAI,uDAAQ,EAAE,0DAAQ,uBAAuB,sEAAc,iBAAiB,kEAAY,cAAc,YAAY,2DAAU,GAAG,EAAE,GAAG;AAC5P;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,8CAA8C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACI;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA,8BAA8B,0DAAY;AAC1C;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AACkC;AAC3B;AACP;AACA,2BAA2B,mCAAmC;AAC9D,2BAA2B,sBAAsB;AACjD,WAAW,sDAAM;AACjB;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAC2D;AACpD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,8BAA8B,yBAAyB,uDAAW,8CAA8C;AAChH;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AACsC;AACM;AACrC;AACP;AACA;AACA;AACA,WAAW,0DAAQ,CAAC,uDAAQ;AAC5B;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AAC6B;AACT;AACA;AACzB;AACc;AACnC;AACP;AACA;AACA;AACA;AACA,kCAAkC,8CAA8C,QAAQ,6DAAI,qBAAqB,gDAAG,mBAAmB,oCAAoC,EAAE,GAAG,EAAE,eAAe;AACjM;AACA;AACA;AACA;AACA,8BAA8B,+DAA+D;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC2B;AAC5B;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAe;AACjD;AACA;AACA,QAAQ,iFAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACa;AAC9B;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AACsC;AAC/B;AACP;AACA;AACA;AACA;AACA,eAAe,0DAAQ,cAAc,wBAAwB,EAAE;AAC/D;AACA;AACA;AACA;AACA,WAAW,0DAAQ,cAAc,wBAAwB,EAAE;AAC3D;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AAC6B;AACT;AACA;AAC9C;AACP;AACA;AACA;AACA,8BAA8B,0EAA0E;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAe;AACjD;AACA;AACA,QAAQ,iFAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACc;AAC/B;;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AACkC;AAC3B;AACP;AACA,2BAA2B,mCAAmC;AAC9D,2BAA2B,sBAAsB;AACjD,WAAW,sDAAM;AACjB;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AACsF;AAC/E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iGAA+B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACI;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC2B;AAC5B;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACS;AACA;AACW;AACA;AACS;AACvD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,oCAAoC,6DAAO;AAC3C;AACA;AACA,8BAA8B,gEAAgE;AAC9F;AACO;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,oCAAoC,6DAAO;AAC3C;AACA;AACA;AACA,WAAW,6DAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAe;AACrD;AACA;AACA,YAAY,iFAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,4CAA4C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AACkC;AACA;AAC3B;AACP;AACA;AACA,YAAY,sDAAM;AAClB,YAAY,sDAAM,CAAC,qDAAG;AACtB;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAC4B;AACrB;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ,gDAAG,sCAAsC;AAC/E;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AACqC;AACG;AACjC;AACP;AACA,QAAQ,4DAAS,cAAc,YAAY,gDAAO,GAAG,EAAE;AACvD,QAAQ,4DAAS,KAAK,gDAAO;AAC7B;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AACqD;AACb;AACjC;AACP,8BAA8B,QAAQ,4DAAS,KAAK,gEAAe,iBAAiB;AACpF;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACP;AACjC;AACP,8BAA8B,QAAQ,4DAAS,KAAK,0DAAY,YAAY;AAC5E;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AACiD;AACT;AACjC;AACP;AACA;AACA;AACA;AACA,sBAAsB,4DAAa;AACnC,8BAA8B,QAAQ,4DAAS,cAAc,gBAAgB,EAAE,oBAAoB;AACnG;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAC0C;AACc;AACjD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,wCAAwC,6DAAO;AAC/C;AACA;AACA,gCAAgC,qDAAU;AAC1C;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8B;AACQ;AACY;AACd;AAC7B;AACP;AACA;AACA,mBAAmB,uDAAI,CAAC,kDAAI,qBAAqB,0DAAQ,KAAK,sEAAc;AAC5E;AACA;AACA;AACA,eAAe,uDAAI,CAAC,kDAAI,+BAA+B,2CAA2C,EAAE,GAAG,0DAAQ;AAC/G;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACC;AACrC;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACI;AACgB;AACS;AACvD;AACP,8BAA8B,sDAAsD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gDAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAAiB;AACpD;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA,8BAA8B,sDAAsD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACI;AACgB;AACS;AACvD;AACP,8BAA8B,6DAA6D;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iFAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP,8BAA8B,kDAAkD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iFAAiB;AAC1C;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACA;AACpC;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA,8BAA8B,+DAA+D;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,oEAAoE,oCAAoC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,sEAAsE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACgC;AACjC;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACuB;AACnC;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AACwC;AACF;AACD;AACrC;AACA,eAAe,gDAAO;AACtB;AACO;AACP,8BAA8B,QAAQ,0DAAQ,GAAG,4DAAS,+BAA+B;AACzF;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACiD;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAiD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAa;AACvC;AACA,wCAAwC,qBAAqB,EAAE;AAC/D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACK;AACzC;AACP,8BAA8B,2DAA2D;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAU;AAC5C;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,6CAA6C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AAC+B;AACnE;AACP,8BAA8B,iDAAiD;AAC/E;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA,wCAAwC,sDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACA;AACS;AACvD;AACP,8BAA8B,qDAAqD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA,kCAAkC,gEAAe;AACjD;AACA;AACA,QAAQ,iFAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP,8BAA8B,sDAAsD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACI;AAC3C;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,QAAQ,qEAAW;AACnB;AACA,kCAAkC,QAAQ,iEAAM,2BAA2B;AAC3E;AACA;AACA,kCAAkC,QAAQ,iEAAM,gBAAgB;AAChE;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAC4E;AACrE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uFAAqB;AACxC;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AACwC;AACI;AACrC;AACP,WAAW,4DAAS,CAAC,uDAAQ;AAC7B;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACA;AACS;AAClC;AACc;AACnC;AACP;AACA,kCAAkC,+CAA+C,QAAQ,6DAAI,qBAAqB,gDAAG,mBAAmB,oCAAoC,EAAE,GAAG,EAAE,GAAG;AACtL;AACA,8BAA8B,oDAAoD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAe;AACjD;AACA;AACA,iCAAiC,iFAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AACwC;AACjC;AACP,4BAA4B,4DAAS,cAAc,wBAAwB,EAAE,oBAAoB,4DAAS,cAAc,wBAAwB,EAAE;AAClJ;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AAC+B;AAC9B;AACrC;AACP;AACA;AACA,mBAAmB,+DAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AAC+B;AAC9B;AACrC;AACP;AACA;AACA,mBAAmB,+DAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qFAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP,8BAA8B,qDAAqD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACP;AACY;AACzC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA,yBAAyB,+CAAI;AAC7B,0BAA0B,+CAAI;AAC9B,6BAA6B,+CAAI;AACjC,mCAAmC,+CAAI;AACvC,yCAAyC,+CAAI;AAC7C,YAAY,mEAAU;AACtB;AACA;AACA;AACA;AACA;AACA,oDAAoD,+CAAI;AACxD,sDAAsD,+CAAI;AAC1D,4DAA4D,+CAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8BAA8B,6FAA6F;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iFAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACA;AACQ;AAC5C;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA;AACA,iBAAiB,+DAAqB;AACtC;AACA,8BAA8B,oGAAoG;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,mBAAmB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACe;AACL;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA,eAAe,2DAAU;AACzB;AACA;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACb;AACc;AAChB;AACrB;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA;AACA,eAAe,+DAAK;AACpB,+BAA+B,kDAAI;AACnC;AACA,yBAAyB,wDAAwD;AACjF,aAAa,GAAG,8DAA8D,GAAG,gDAAG;AACpF;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACS;AACR;AACU;AAC/C;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA,WAAW,gEAAW,MAAM,yEAAU,KAAK,+DAAY;AACvD;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACH;AACa;AACS;AACvD;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA;AACA,8BAA8B,2DAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iFAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACf;AACrB;AACP;AACA,oBAAoB,sDAAK;AACzB;AACA,WAAW,gDAAG,mBAAmB,8CAA8C,EAAE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AACkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sDAAM;AACjB;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACI;AACgB;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iFAAiB;AAClD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA,2BAA2B,gDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gDAAO;AACjD;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACU;AACN;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACI;AACM;AACA;AACG;AACI;AAC3C;AACP,oBAAoB,sDAAK;AACzB;AACA;AACA,QAAQ,qEAAW;AACnB;AACA;AACA,QAAQ,qEAAW;AACnB;AACA;AACA,aAAa,iEAAS;AACtB;AACA;AACA,QAAQ,qEAAW;AACnB;AACA;AACA,aAAa,iEAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC,CAAC,gDAAO;AACT;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACI;AACU;AACM;AACS;AACvD;AACP,8BAA8B,yEAAyE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,2CAA2C,iFAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAO;AACtC,mCAAmC,0DAAY;AAC/C,6BAA6B;AAC7B;AACA,oCAAoC,iFAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AChIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACI;AACgB;AACS;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gDAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iFAAiB;AAC7D;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACoB;AACS;AACvD;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,uBAAuB,SAAS;AAChC;AACA,sBAAsB,iFAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,gEAAe;AACjB;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACqD;AAC9C;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA,gCAAgC,mDAAS;AACzC;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AACgD;AACzC;AACP,8BAA8B,wBAAwB,2DAAW,WAAW;AAC5E;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACI;AACxC;AACP,eAAe,sDAAU;AACzB,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACI;AACkB;AAC1D;AACP;AACA;AACA;AACA,eAAe,sDAAU;AACzB,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,yDAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACI;AACwB;AAChE;AACP,eAAe,sDAAU;AACzB,sBAAsB,0DAAY;AAClC;AACA,mCAAmC,6DAAiB;AACpD;AACA,wCAAwC,yCAAyC,+BAA+B,EAAE,GAAG,EAAE;AACvH,uCAAuC,yCAAyC,8BAA8B,EAAE,GAAG,EAAE;AACrH,uCAAuC,yCAAyC,8BAA8B,EAAE,GAAG,EAAE;AACrH,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACI;AACxC;AACP,eAAe,sDAAU;AACzB,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA,4DAA4D,8BAA8B,EAAE;AAC5F,iBAAiB;AACjB,aAAa;AACb,wDAAwD,8BAA8B,EAAE;AACxF,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC0D;AACN;AACJ;AACM;AACY;AACpB;AACI;AACF;AACzC;AACP;AACA,YAAY,qFAAmB;AAC/B,mBAAmB,8EAAkB;AACrC;AACA,iBAAiB,iEAAS;AAC1B,mBAAmB,wEAAe;AAClC;AACA,iBAAiB,qEAAW;AAC5B,mBAAmB,oEAAa;AAChC;AACA,iBAAiB,mEAAU;AAC3B,mBAAmB,0EAAgB;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AACiC;AACc;AAC/C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,0DAAY;AACI;AAClB;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AACiC;AACW;AAC5C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,8BAA8B,EAAE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,wDAAW;AACmB;AAChC;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AACiC;AACiB;AAClD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8DAAc;AACmB;AACnC;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACa;AACF;AAC5C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yDAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,wDAAW;AACS;AACtB;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AACiC;AACiB;AAClD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8DAAc;AACS;AACzB;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AACiC;AACC;AAClC;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8CAAM;AACe;AACvB;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAA;AACiC;AACQ;AACzC;AACA,IAAI,+CAAiB;AACrB;AACA;AACA,kBAAkB,oDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,oDAAS;AACe;AAC1B;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AACiC;AACW;AAC5C;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,wDAAW;AACU;AACvB;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AACiC;AACiB;AAClD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA,CAAC,CAAC,8DAAc;AACU;AAC1B;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACiC;AACW;AACM;AAClD;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,oBAAoB,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,8DAAc;AACgB;AAChC;AACA,IAAI,+CAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,wDAAW;AACY;AACzB;;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAC8D;AACM;AAC7D,uCAAuC,gFAAuB,CAAC,0EAAoB;AAC1F;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAC0C;AACM;AACzC,6BAA6B,4DAAa,CAAC,sDAAU;AAC5D;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAC4C;AACM;AAC3C,8BAA8B,8DAAc,CAAC,wDAAW;AAC/D;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAC4C;AACM;AAC3C,8BAA8B,8DAAc,CAAC,wDAAW;AAC/D;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACP;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACO;AACP;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AACO;AACP;AACA;AACO;AACP;;;;;;;;;;;;;ACLA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4CAA4C,6BAA6B,EAAE;AAC3E;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA,oGAAoG,sCAAsC,EAAE;AAC5I;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAC2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA,uDAAuD,sDAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AACO;AACP,4BAA4B,WAAW,EAAE;AACzC;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACO,8CAA8C,0CAA0C,EAAE;AACjG;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACO,iCAAiC,qEAAqE,EAAE;AAC/G;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACuE;AAChE;AACP,iCAAiC,6DAAiB;AAClD;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACiE;AAC1D;AACP,iCAAiC,yDAAe;AAChD;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACoC;AAC7B;AACP,YAAY,wDAAO;AACnB;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAC2C;AACpC;AACP,oCAAoC,sDAAU;AAC9C;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACO,iBAAiB;AACxB;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAC8B;AACvB;AACP;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,0CAAI;AACnB;AACA;AACA;AACA;AACA;AACA,+CAA+C,iBAAiB,EAAE;AAClE;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACsD;AACI;AACE;AACI;AACpB;AACJ;AACF;AAC2B;AACM;AAChE;AACP,kCAAkC,6DAAiB;AACnD,eAAe,oFAAqB;AACpC;AACA,aAAa,gEAAW;AACxB,eAAe,0EAAgB;AAC/B;AACA,aAAa,4DAAS;AACtB,eAAe,8EAAkB;AACjC;AACA,uCAAuC,yDAAe;AACtD,eAAe,gFAAmB;AAClC;AACA;AACA,oBAAoB,0DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AACO;AACP;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AACiE;AAC1D;AACP;AACA,gCAAgC,yDAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AACuE;AAChE;AACP;AACA,sBAAsB,6DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AACoD;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB,8BAA8B,EAAE;AAC3D,wBAAwB,gEAAe;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AACqD;AACT;AACD;AACpC;AACP;AACA,0BAA0B,gEAAe;AACzC;AACA;AACA;AACA;AACA,0BAA0B,sDAAU;AACpC;AACA;AACA,WAAW,gEAAW;AACtB;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;AACiC;AACvB;AAC9C;AACP;AACA,sCAAsC,sDAAU;AAChD;AACA;AACA,2BAA2B,iEAAkB;AAC7C,kCAAkC,iEAAkB;AACpD;AACA;AACA;AACA,mBAAmB,sDAAU,CAAC,+CAAa;AAC3C;AACA,eAAe,sDAAU;AACzB;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACoD;AACQ;AACN;AACU;AACF;AACI;AACJ;AACA;AACA;AACM;AACd;AACM;AACA;AACI;AACZ;AACM;AACQ;AACI;AAClB;AACQ;AACQ;AACV;AACwB;AACM;AAC5B;AACJ;AACJ;AACI;AACM;AACR;AACA;AACI;AACR;AACU;AACR;AACI;AACc;AACd;AACN;AACF;AACI;AACY;AAChB;AACI;AACM;AACA;AACW;AACP;AACF;AACZ;AACY;AACA;AACgB;AAClB;AACE;AACR;AACI;AACgB;AACR;AACI;AAClB;AACI;AACA;AACQ;AACV;AACQ;AACF;AACJ;AACQ;AACZ;AACkB;AAChB;AACY;AACV;AACJ;AACQ;AACE;AACA;AACA;AACI;AACJ;AACA;AACI;AACd;AACQ;AACE;AACA;AACZ;AACU;AACQ;AACA;AACA;AACV;AACQ;AACJ;AACJ;AACF;AACU;AACF;AACI;AACJ;AACQ;AACtB;AACM;AACtD;;;;;;;;;;;;;ACzGA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,0EAAa;AACvC,YAAY,mBAAO,CAAC,gDAAO;AAC3B,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,cAAc,mBAAO,CAAC,gDAAS;AAC/B,gBAAgB,mBAAO,CAAC,oDAAW;AACnC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,WAAW,mBAAO,CAAC,0CAAM;AACzB,YAAY,mBAAO,CAAC,4CAAO;AAC3B,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,yCAAM;AACzB,SAAS,mBAAO,CAAC,wDAAI;AACrB,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,iBAAiB,mBAAO,CAAC,0DAAc;AACvC,WAAW,mBAAO,CAAC,kBAAM;AACzB,eAAe,mBAAO,CAAC,kDAAU;AACjC,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,IAAI;AAC5D;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;;;;;;;;;;;;ACxmCA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,0CAAM;AAC9B,qBAAqB,mBAAO,CAAC,8DAAgB;AAC7C,eAAe,mBAAO,CAAC,kDAAU;AACjC,eAAe,mBAAO,CAAC,qDAAU;AACjC,mBAAmB,mBAAO,CAAC,0DAAc;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;;;ACzQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,oDAAW;AACnC,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,eAAe,mBAAO,CAAC,kDAAU;AACjC,cAAc,mBAAO,CAAC,kBAAM;AAC5B,WAAW,mBAAO,CAAC,0CAAM;AACzB,UAAU,mBAAO,CAAC,gBAAK;;AAEvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjNY;AACZ;AACA,4CAA4C,gBAAgB;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,wDAAc;;AAElC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,kDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B,yCAAyC,gBAAgB,EAAE;AAC3D,KAAK;AACL,yCAAyC,cAAc,mBAAmB,EAAE,EAAE;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO,EAAE;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oCAAoC;AACpC,KAAK;AACL,yCAAyC;AACzC,KAAK;AACL,+CAA+C;AAC/C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO,EAAE;AACnD,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,EAAE;AAC3D;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC3YA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEO;AACP;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEO;AACP;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEO;AACP,mCAAmC,oCAAoC;AACvE;;AAEO;AACP;AACA;;AAEO;AACP;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;;AAEO;AACP,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,gBAAgB;AACzC;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEO;AACP,4BAA4B,sBAAsB;AAClD;AACA;AACA;;AAEO;AACP,iDAAiD,QAAQ;AACzD,wCAAwC,QAAQ;AAChD,wDAAwD,QAAQ;AAChE;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA,iBAAiB,sFAAsF,aAAa,EAAE;AACtH,sBAAsB,gCAAgC,qCAAqC,0CAA0C,EAAE,EAAE,GAAG;AAC5I,2BAA2B,MAAM,eAAe,EAAE,YAAY,oBAAoB,EAAE;AACpF,sBAAsB,oGAAoG;AAC1H,6BAA6B,uBAAuB;AACpD,4BAA4B,wBAAwB;AACpD,2BAA2B,yDAAyD;AACpF;;AAEO;AACP;AACA,iBAAiB,4CAA4C,SAAS,EAAE,qDAAqD,aAAa,EAAE;AAC5I,yBAAyB,6BAA6B,oBAAoB,gDAAgD,gBAAgB,EAAE,KAAK;AACjJ;;AAEO;AACP;AACA;AACA,2GAA2G,sFAAsF,aAAa,EAAE;AAChN,sBAAsB,8BAA8B,gDAAgD,uDAAuD,EAAE,EAAE,GAAG;AAClK,4CAA4C,sCAAsC,UAAU,oBAAoB,EAAE,EAAE,UAAU;AAC9H;;AAEO;AACP,gCAAgC,uCAAuC,aAAa,EAAE,EAAE,OAAO,kBAAkB;AACjH;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,4CAA4C;AAC5C;;;;;;;;;;;;;ACnMA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,wDAAa;AACjC,WAAW,mBAAO,CAAC,sDAAY;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,uBAAuB;AACvB,4BAA4B;AAC5B,6CAA6C;AAC7C;AACA;AACA,qCAAqC;AACrC,mCAAmC;AACnC,wCAAwC;AACxC;AACA,uBAAuB;AACvB;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;ACzQA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACpEA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACJ;AACsC;AAChC;AAExC,MAAM,UAAU,GAAG,mBAAO,CAAC,wDAAa,CAAC;AACzC,MAAM,SAAS,GAAG,mBAAO,CAAC,sEAAoB,CAAC;AAG/C,MAAM,MAAM,GAAG,CAAC,IAAY,EAAE,QAAgB,EAAU,EAAE;IACxD,OAAO,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,QAAQ;AACzD,CAAC;AAED,yDAAyD;AACzD,MAAM,WAAW,GAAG,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC;AAC/C,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,EAAE,aAAa,CAAC;AAC9C,MAAM,QAAQ,GAAG,MAAM,CAAC,UAAU,EAAE,OAAO,CAAC;AAC5C,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC;AACpC,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC;AAGjC,wDAAwD;AACxD,iDAAI,CAAC,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAC,IAAI,CAC9B,+DAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,sDAAS,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CACrC,CAAC,SAAS,CAAC,CAAC,CAAK,EAAE,EAAE;IACpB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC;AAGF,0DAA0D;AAC1D,MAAM,QAAQ,GAAG,IAAI,UAAU,CAAC,QAAQ,EAAE;AAG1C,MAAM,MAAM,GAAG,IAAI,uDAAW,CAAC,EAAE,aAAa,EAAE,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,eAAe,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;AAC3H,MAAM,KAAK,GAAG,iCAAiC,KAAK,EAAE,CAAC;AACvD,iDAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAClC,+DAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,iDAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAC5B,CAAC,SAAS,CAAC;IACV,IAAI,EAAE,CAAC,CAAC,EAAE;QACR,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IACxB,CAAC;CACF,CAAC;AACF,2DAA2D;AAE3D,MAAM,GAAG,GAAG,oCAAO,EAAE;AACrB,4DAA4D;AAC5D,sBAAsB;AACtB,iCAAiC;AACjC,qBAAqB;AACrB,0BAA0B;AAC1B,MAAM;AAEN,GAAG,CAAC,GAAG,CAAC,kBAAkB,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;IACvC,GAAG,CAAC,GAAG,CAAC,EAAC,cAAc,EAAE,UAAU,EAAC,CAAC;IACrC,iDAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAClC,+DAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,iDAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAC3B,6DAAM,CAAC,CAAC,EAAE,EAAE,KAAK,EAAE,EAAE;QACnB,OAAO,EAAE,GAAE,GAAG,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,OAAO,MAAM;IAC7D,CAAC,EAAE,uBAAuB,CAAC,EAC3B,2DAAI,CAAC,CAAC,CAAC,CACR,CAAC,SAAS,CAAC;QACV,IAAI,EAAE,CAAC,CAAC,EAAE;YACR,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;QACb,CAAC;KACF,CAAC;AACJ,CAAC,CAAC;AAEF,qDAAqD;AACrD,MAAM,CAAC,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC;IAChC,IAAI,EAAE,cAAc;IACpB,IAAI,EAAE,sBAAsB;IAC3B,UAAU,EAAE,CAAC,MAAM,CAAC;IACpB,SAAS,EAAE,CAAC,QAAQ,CAAC;CACtB,CAAC;AAEF,GAAG,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;IAC/B,CAAC,CAAC,GAAG,CAAC,EAAC,IAAI,EAAE,GAAG,EAAC,CAAC;IAClB,GAAG,CAAC,GAAG,CAAC,cAAc,EAAE,QAAQ,CAAC,WAAW,CAAC;IAC7C,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;AAC7B,CAAC,CAAC;AACF,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,yBAAyB,IAAI,EAAE,CAAC,CAAC;;;;;;;;;;;;AChFpE,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,2C;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC","file":"index.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","/*!\n * accepts\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Negotiator = require('negotiator')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Accepts\n\n/**\n * Create a new Accepts object for the given req.\n *\n * @param {object} req\n * @public\n */\n\nfunction Accepts (req) {\n  if (!(this instanceof Accepts)) {\n    return new Accepts(req)\n  }\n\n  this.headers = req.headers\n  this.negotiator = new Negotiator(req)\n}\n\n/**\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single mime type string\n * such as \"application/json\", the extension name\n * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     this.types('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     this.types('html');\n *     // => \"html\"\n *     this.types('text/html');\n *     // => \"text/html\"\n *     this.types('json', 'text');\n *     // => \"json\"\n *     this.types('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     this.types('image/png');\n *     this.types('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     this.types(['html', 'json']);\n *     this.types('html', 'json');\n *     // => \"json\"\n *\n * @param {String|Array} types...\n * @return {String|Array|Boolean}\n * @public\n */\n\nAccepts.prototype.type =\nAccepts.prototype.types = function (types_) {\n  var types = types_\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i]\n    }\n  }\n\n  // no types, return all requested types\n  if (!types || types.length === 0) {\n    return this.negotiator.mediaTypes()\n  }\n\n  // no accept header, return first given type\n  if (!this.headers.accept) {\n    return types[0]\n  }\n\n  var mimes = types.map(extToMime)\n  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))\n  var first = accepts[0]\n\n  return first\n    ? types[mimes.indexOf(first)]\n    : false\n}\n\n/**\n * Return accepted encodings or best fit based on `encodings`.\n *\n * Given `Accept-Encoding: gzip, deflate`\n * an array sorted by quality is returned:\n *\n *     ['gzip', 'deflate']\n *\n * @param {String|Array} encodings...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.encoding =\nAccepts.prototype.encodings = function (encodings_) {\n  var encodings = encodings_\n\n  // support flattened arguments\n  if (encodings && !Array.isArray(encodings)) {\n    encodings = new Array(arguments.length)\n    for (var i = 0; i < encodings.length; i++) {\n      encodings[i] = arguments[i]\n    }\n  }\n\n  // no encodings, return all requested encodings\n  if (!encodings || encodings.length === 0) {\n    return this.negotiator.encodings()\n  }\n\n  return this.negotiator.encodings(encodings)[0] || false\n}\n\n/**\n * Return accepted charsets or best fit based on `charsets`.\n *\n * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n * an array sorted by quality is returned:\n *\n *     ['utf-8', 'utf-7', 'iso-8859-1']\n *\n * @param {String|Array} charsets...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.charset =\nAccepts.prototype.charsets = function (charsets_) {\n  var charsets = charsets_\n\n  // support flattened arguments\n  if (charsets && !Array.isArray(charsets)) {\n    charsets = new Array(arguments.length)\n    for (var i = 0; i < charsets.length; i++) {\n      charsets[i] = arguments[i]\n    }\n  }\n\n  // no charsets, return all requested charsets\n  if (!charsets || charsets.length === 0) {\n    return this.negotiator.charsets()\n  }\n\n  return this.negotiator.charsets(charsets)[0] || false\n}\n\n/**\n * Return accepted languages or best fit based on `langs`.\n *\n * Given `Accept-Language: en;q=0.8, es, pt`\n * an array sorted by quality is returned:\n *\n *     ['es', 'pt', 'en']\n *\n * @param {String|Array} langs...\n * @return {Array|String}\n * @public\n */\n\nAccepts.prototype.lang =\nAccepts.prototype.langs =\nAccepts.prototype.language =\nAccepts.prototype.languages = function (languages_) {\n  var languages = languages_\n\n  // support flattened arguments\n  if (languages && !Array.isArray(languages)) {\n    languages = new Array(arguments.length)\n    for (var i = 0; i < languages.length; i++) {\n      languages[i] = arguments[i]\n    }\n  }\n\n  // no languages, return all requested languages\n  if (!languages || languages.length === 0) {\n    return this.negotiator.languages()\n  }\n\n  return this.negotiator.languages(languages)[0] || false\n}\n\n/**\n * Convert extnames to mime.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction extToMime (type) {\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if mime is valid.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction validMime (type) {\n  return typeof type === 'string'\n}\n","'use strict'\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = arrayFlatten\n\n/**\n * Recursive flatten function with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {Number} depth\n * @return {Array}\n */\nfunction flattenWithDepth (array, result, depth) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > 0 && Array.isArray(value)) {\n      flattenWithDepth(value, result, depth - 1)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Recursive flatten function. Omitting depth is slightly faster.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenForever (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenForever(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array, with the ability to define a depth.\n *\n * @param  {Array}  array\n * @param  {Number} depth\n * @return {Array}\n */\nfunction arrayFlatten (array, depth) {\n  if (depth == null) {\n    return flattenForever(array, [])\n  }\n\n  return flattenWithDepth(array, [], depth)\n}\n","/*!\n * basic-auth\n * Copyright(c) 2013 TJ Holowaychuk\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Buffer = require('safe-buffer').Buffer\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = auth\nmodule.exports.parse = parse\n\n/**\n * RegExp for basic auth credentials\n *\n * credentials = auth-scheme 1*SP token68\n * auth-scheme = \"Basic\" ; case insensitive\n * token68     = 1*( ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\n * @private\n */\n\nvar CREDENTIALS_REGEXP = /^ *(?:[Bb][Aa][Ss][Ii][Cc]) +([A-Za-z0-9._~+/-]+=*) *$/\n\n/**\n * RegExp for basic auth user/pass\n *\n * user-pass   = userid \":\" password\n * userid      = *<TEXT excluding \":\">\n * password    = *TEXT\n * @private\n */\n\nvar USER_PASS_REGEXP = /^([^:]*):(.*)$/\n\n/**\n * Parse the Authorization header field of a request.\n *\n * @param {object} req\n * @return {object} with .name and .pass\n * @public\n */\n\nfunction auth (req) {\n  if (!req) {\n    throw new TypeError('argument req is required')\n  }\n\n  if (typeof req !== 'object') {\n    throw new TypeError('argument req is required to be an object')\n  }\n\n  // get header\n  var header = getAuthorization(req)\n\n  // parse header\n  return parse(header)\n}\n\n/**\n * Decode base64 string.\n * @private\n */\n\nfunction decodeBase64 (str) {\n  return Buffer.from(str, 'base64').toString()\n}\n\n/**\n * Get the Authorization header from request object.\n * @private\n */\n\nfunction getAuthorization (req) {\n  if (!req.headers || typeof req.headers !== 'object') {\n    throw new TypeError('argument req is required to have headers property')\n  }\n\n  return req.headers.authorization\n}\n\n/**\n * Parse basic auth to object.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction parse (string) {\n  if (typeof string !== 'string') {\n    return undefined\n  }\n\n  // parse header\n  var match = CREDENTIALS_REGEXP.exec(string)\n\n  if (!match) {\n    return undefined\n  }\n\n  // decode user pass\n  var userPass = USER_PASS_REGEXP.exec(decodeBase64(match[1]))\n\n  if (!userPass) {\n    return undefined\n  }\n\n  // return credentials object\n  return new Credentials(userPass[1], userPass[2])\n}\n\n/**\n * Object to represent user credentials.\n * @private\n */\n\nfunction Credentials (name, pass) {\n  this.name = name\n  this.pass = pass\n}\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        cb(data);\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        cb(data);\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar deprecate = require('depd')('body-parser')\n\n/**\n * Cache of loaded parsers.\n * @private\n */\n\nvar parsers = Object.create(null)\n\n/**\n * @typedef Parsers\n * @type {function}\n * @property {function} json\n * @property {function} raw\n * @property {function} text\n * @property {function} urlencoded\n */\n\n/**\n * Module exports.\n * @type {Parsers}\n */\n\nexports = module.exports = deprecate.function(bodyParser,\n  'bodyParser: use individual json/urlencoded middlewares')\n\n/**\n * JSON parser.\n * @public\n */\n\nObject.defineProperty(exports, 'json', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('json')\n})\n\n/**\n * Raw parser.\n * @public\n */\n\nObject.defineProperty(exports, 'raw', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('raw')\n})\n\n/**\n * Text parser.\n * @public\n */\n\nObject.defineProperty(exports, 'text', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('text')\n})\n\n/**\n * URL-encoded parser.\n * @public\n */\n\nObject.defineProperty(exports, 'urlencoded', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('urlencoded')\n})\n\n/**\n * Create a middleware to parse json and urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @deprecated\n * @public\n */\n\nfunction bodyParser (options) {\n  var opts = {}\n\n  // exclude type option\n  if (options) {\n    for (var prop in options) {\n      if (prop !== 'type') {\n        opts[prop] = options[prop]\n      }\n    }\n  }\n\n  var _urlencoded = exports.urlencoded(opts)\n  var _json = exports.json(opts)\n\n  return function bodyParser (req, res, next) {\n    _json(req, res, function (err) {\n      if (err) return next(err)\n      _urlencoded(req, res, next)\n    })\n  }\n}\n\n/**\n * Create a getter for loading a parser.\n * @private\n */\n\nfunction createParserGetter (name) {\n  return function get () {\n    return loadParser(name)\n  }\n}\n\n/**\n * Load a parser module.\n * @private\n */\n\nfunction loadParser (parserName) {\n  var parser = parsers[parserName]\n\n  if (parser !== undefined) {\n    return parser\n  }\n\n  // this uses a switch for static require analysis\n  switch (parserName) {\n    case 'json':\n      parser = require('./lib/types/json')\n      break\n    case 'raw':\n      parser = require('./lib/types/raw')\n      break\n    case 'text':\n      parser = require('./lib/types/text')\n      break\n    case 'urlencoded':\n      parser = require('./lib/types/urlencoded')\n      break\n  }\n\n  // store to prevent invoking require()\n  return (parsers[parserName] = parser)\n}\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar getBody = require('raw-body')\nvar iconv = require('iconv-lite')\nvar onFinished = require('on-finished')\nvar zlib = require('zlib')\n\n/**\n * Module exports.\n */\n\nmodule.exports = read\n\n/**\n * Read a request into a buffer and parse.\n *\n * @param {object} req\n * @param {object} res\n * @param {function} next\n * @param {function} parse\n * @param {function} debug\n * @param {object} options\n * @private\n */\n\nfunction read (req, res, next, parse, debug, options) {\n  var length\n  var opts = options\n  var stream\n\n  // flag as parsed\n  req._body = true\n\n  // read options\n  var encoding = opts.encoding !== null\n    ? opts.encoding\n    : null\n  var verify = opts.verify\n\n  try {\n    // get the content stream\n    stream = contentstream(req, debug, opts.inflate)\n    length = stream.length\n    stream.length = undefined\n  } catch (err) {\n    return next(err)\n  }\n\n  // set raw-body options\n  opts.length = length\n  opts.encoding = verify\n    ? null\n    : encoding\n\n  // assert charset is supported\n  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {\n    return next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n      charset: encoding.toLowerCase(),\n      type: 'charset.unsupported'\n    }))\n  }\n\n  // read body\n  debug('read body')\n  getBody(stream, opts, function (error, body) {\n    if (error) {\n      var _error\n\n      if (error.type === 'encoding.unsupported') {\n        // echo back charset\n        _error = createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n          charset: encoding.toLowerCase(),\n          type: 'charset.unsupported'\n        })\n      } else {\n        // set status code on error\n        _error = createError(400, error)\n      }\n\n      // read off entire request\n      stream.resume()\n      onFinished(req, function onfinished () {\n        next(createError(400, _error))\n      })\n      return\n    }\n\n    // verify\n    if (verify) {\n      try {\n        debug('verify body')\n        verify(req, res, body, encoding)\n      } catch (err) {\n        next(createError(403, err, {\n          body: body,\n          type: err.type || 'entity.verify.failed'\n        }))\n        return\n      }\n    }\n\n    // parse\n    var str = body\n    try {\n      debug('parse body')\n      str = typeof body !== 'string' && encoding !== null\n        ? iconv.decode(body, encoding)\n        : body\n      req.body = parse(str)\n    } catch (err) {\n      next(createError(400, err, {\n        body: str,\n        type: err.type || 'entity.parse.failed'\n      }))\n      return\n    }\n\n    next()\n  })\n}\n\n/**\n * Get the content stream of the request.\n *\n * @param {object} req\n * @param {function} debug\n * @param {boolean} [inflate=true]\n * @return {object}\n * @api private\n */\n\nfunction contentstream (req, debug, inflate) {\n  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()\n  var length = req.headers['content-length']\n  var stream\n\n  debug('content-encoding \"%s\"', encoding)\n\n  if (inflate === false && encoding !== 'identity') {\n    throw createError(415, 'content encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n\n  switch (encoding) {\n    case 'deflate':\n      stream = zlib.createInflate()\n      debug('inflate body')\n      req.pipe(stream)\n      break\n    case 'gzip':\n      stream = zlib.createGunzip()\n      debug('gunzip body')\n      req.pipe(stream)\n      break\n    case 'identity':\n      stream = req\n      stream.length = length\n      break\n    default:\n      throw createError(415, 'unsupported content encoding \"' + encoding + '\"', {\n        encoding: encoding,\n        type: 'encoding.unsupported'\n      })\n  }\n\n  return stream\n}\n","/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:json')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = json\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/ // eslint-disable-line no-control-regex\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json (options) {\n  var opts = options || {}\n\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var inflate = opts.inflate !== false\n  var reviver = opts.reviver\n  var strict = opts.strict !== false\n  var type = opts.type || 'application/json'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {}\n    }\n\n    if (strict) {\n      var first = firstchar(body)\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation')\n        throw createStrictSyntaxError(body, first)\n      }\n    }\n\n    try {\n      debug('parse json')\n      return JSON.parse(body, reviver)\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      })\n    }\n  }\n\n  return function jsonParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8'\n    if (charset.substr(0, 4) !== 'utf-') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\nfunction createStrictSyntaxError (str, char) {\n  var index = str.indexOf(char)\n  var partial = str.substring(0, index) + '#'\n\n  try {\n    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    })\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\nfunction firstchar (str) {\n  return FIRST_CHAR_REGEXP.exec(str)[1]\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\nfunction normalizeJsonSyntaxError (error, obj) {\n  var keys = Object.getOwnPropertyNames(error)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key]\n    }\n  }\n\n  // replace stack before message for Node.js 0.10 and below\n  error.stack = obj.stack.replace(error.message, obj.message)\n  error.message = obj.message\n\n  return error\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar debug = require('debug')('body-parser:raw')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = raw\n\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw (options) {\n  var opts = options || {}\n\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/octet-stream'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (buf) {\n    return buf\n  }\n\n  return function rawParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar debug = require('debug')('body-parser:text')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = text\n\n/**\n * Create a middleware to parse text bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction text (options) {\n  var opts = options || {}\n\n  var defaultCharset = opts.defaultCharset || 'utf-8'\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'text/plain'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (buf) {\n    return buf\n  }\n\n  return function textParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // get charset\n    var charset = getCharset(req) || defaultCharset\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar deprecate = require('depd')('body-parser')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Cache of parser modules.\n */\n\nvar parsers = Object.create(null)\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded (options) {\n  var opts = options || {}\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option')\n  }\n\n  var extended = opts.extended !== false\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/x-www-form-urlencoded'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended\n    ? extendedparser(opts)\n    : simpleparser(opts)\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    return body.length\n      ? queryparse(body)\n      : {}\n  }\n\n  return function urlencodedParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8'\n    if (charset !== 'utf-8') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction extendedparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('qs')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    var arrayLimit = Math.max(100, paramCount)\n\n    debug('parse extended urlencoding')\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount (body, limit) {\n  var count = 0\n  var index = 0\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++\n    index++\n\n    if (count === limit) {\n      return undefined\n    }\n  }\n\n  return count\n}\n\n/**\n * Get parser for module name dynamically.\n *\n * @param {string} name\n * @return {function}\n * @api private\n */\n\nfunction parser (name) {\n  var mod = parsers[name]\n\n  if (mod !== undefined) {\n    return mod.parse\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs')\n      break\n    case 'querystring':\n      mod = require('querystring')\n      break\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod\n\n  return mod.parse\n}\n\n/**\n * Get the simple query parser.\n *\n * @param {object} options\n */\n\nfunction simpleparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('querystring')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    debug('parse urlencoding')\n    return parse(body, undefined, undefined, { maxKeys: parameterLimit })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = bytes;\nmodule.exports.format = format;\nmodule.exports.parse = parse;\n\n/**\n * Module variables.\n * @private\n */\n\nvar formatThousandsRegExp = /\\B(?=(\\d{3})+(?!\\d))/g;\n\nvar formatDecimalsRegExp = /(?:\\.0*|(\\.[^0]+)0+)$/;\n\nvar map = {\n  b:  1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: Math.pow(1024, 4),\n  pb: Math.pow(1024, 5),\n};\n\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\n\n/**\n * Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: [string],\n *  decimalPlaces: [number]\n *  fixedDecimals: [boolean]\n *  thousandsSeparator: [string]\n *  unitSeparator: [string]\n *  }} [options] bytes options.\n *\n * @returns {string|number|null}\n */\n\nfunction bytes(value, options) {\n  if (typeof value === 'string') {\n    return parse(value);\n  }\n\n  if (typeof value === 'number') {\n    return format(value, options);\n  }\n\n  return null;\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {object} [options]\n * @param {number} [options.decimalPlaces=2]\n * @param {number} [options.fixedDecimals=false]\n * @param {string} [options.thousandsSeparator=]\n * @param {string} [options.unit=]\n * @param {string} [options.unitSeparator=]\n *\n * @returns {string|null}\n * @public\n */\n\nfunction format(value, options) {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n\n  var mag = Math.abs(value);\n  var thousandsSeparator = (options && options.thousandsSeparator) || '';\n  var unitSeparator = (options && options.unitSeparator) || '';\n  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;\n  var fixedDecimals = Boolean(options && options.fixedDecimals);\n  var unit = (options && options.unit) || '';\n\n  if (!unit || !map[unit.toLowerCase()]) {\n    if (mag >= map.pb) {\n      unit = 'PB';\n    } else if (mag >= map.tb) {\n      unit = 'TB';\n    } else if (mag >= map.gb) {\n      unit = 'GB';\n    } else if (mag >= map.mb) {\n      unit = 'MB';\n    } else if (mag >= map.kb) {\n      unit = 'KB';\n    } else {\n      unit = 'B';\n    }\n  }\n\n  var val = value / map[unit.toLowerCase()];\n  var str = val.toFixed(decimalPlaces);\n\n  if (!fixedDecimals) {\n    str = str.replace(formatDecimalsRegExp, '$1');\n  }\n\n  if (thousandsSeparator) {\n    str = str.replace(formatThousandsRegExp, thousandsSeparator);\n  }\n\n  return str + unitSeparator + unit;\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n *\n * @returns {number|null}\n * @public\n */\n\nfunction parse(val) {\n  if (typeof val === 'number' && !isNaN(val)) {\n    return val;\n  }\n\n  if (typeof val !== 'string') {\n    return null;\n  }\n\n  // Test if the string passed is valid\n  var results = parseRegExp.exec(val);\n  var floatValue;\n  var unit = 'b';\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val, 10);\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1]);\n    unit = results[4].toLowerCase();\n  }\n\n  return Math.floor(map[unit] * floatValue);\n}\n","'use strict';\n\nconst clientOptions = require('./lib/client-options');\nexports.Client = require('./lib/client');\nexports.ExecutionProfile = require('./lib/execution-profile').ExecutionProfile;\nexports.ExecutionOptions = require('./lib/execution-options').ExecutionOptions;\nexports.types = require('./lib/types');\nexports.errors = require('./lib/errors');\nexports.policies = require('./lib/policies');\nexports.auth = require('./lib/auth');\nexports.mapping = require('./lib/mapping');\nexports.tracker = require('./lib/tracker');\nexports.metrics = require('./lib/metrics');\nexports.concurrent = require('./lib/concurrent');\n\nconst token = require('./lib/token');\nexports.token = {\n  Token: token.Token,\n  TokenRange: token.TokenRange\n};\nconst Metadata = require('./lib/metadata');\nexports.metadata = {\n  Metadata: Metadata\n};\nexports.Encoder = require('./lib/encoder');\n/**\n * Returns a new instance of the default [options]{@link ClientOptions} used by the driver.\n */\nexports.defaultOptions = function () {\n  return clientOptions.defaultOptions();\n};\nexports.version = require('./package.json').version;","'use strict';\n/**\n * Authentication module.\n * @module auth\n */\nconst baseProvider = require('./provider.js');\nexports.AuthProvider = baseProvider.AuthProvider;\nexports.Authenticator = baseProvider.Authenticator;\nexports.PlainTextAuthProvider = require('./plain-text-auth-provider.js');","'use strict';\nconst util = require('util');\n\nconst provider = require('./provider.js');\nconst utils = require('../utils');\nconst AuthProvider = provider.AuthProvider;\nconst Authenticator = provider.Authenticator;\n/**\n * Creates a new instance of the Authenticator provider\n * @classdesc Provides plain text [Authenticator]{@link module:auth~Authenticator} instances to be used when\n * connecting to a host.\n * @extends module:auth~AuthProvider\n * @example\n * var authProvider = new cassandra.auth.PlainTextAuthProvider('my_user', 'p@ssword1!');\n * //Set the auth provider in the clientOptions when creating the Client instance\n * const client = new Client({ contactPoints: contactPoints, authProvider: authProvider });\n * @param {String} username User name in plain text\n * @param {String} password Password in plain text\n * @alias module:auth~PlainTextAuthProvider\n * @constructor\n */\nfunction PlainTextAuthProvider(username, password) {\n  this.username = username;\n  this.password = password;\n}\n\nutil.inherits(PlainTextAuthProvider, AuthProvider);\n\n/**\n * Returns a new [Authenticator]{@link module:auth~Authenticator} instance to be used for plain text authentication.\n * @override\n * @returns {Authenticator}\n */\nPlainTextAuthProvider.prototype.newAuthenticator = function () {\n  return new PlainTextAuthenticator(this.username, this.password);\n};\n\n/**\n * @ignore\n */\nfunction PlainTextAuthenticator(username, password) {\n  this.username = username;\n  this.password = password;\n}\n\nutil.inherits(PlainTextAuthenticator, Authenticator);\n\nPlainTextAuthenticator.prototype.initialResponse = function (callback) {\n  const initialToken = Buffer.concat([\n    utils.allocBufferFromArray([0]),\n    utils.allocBufferFromString(this.username, 'utf8'),\n    utils.allocBufferFromArray([0]),\n    utils.allocBufferFromString(this.password, 'utf8')\n  ]);\n  callback(null, initialToken);\n};\n\nPlainTextAuthenticator.prototype.evaluateChallenge = function (challenge, callback) {\n  //noop\n  callback();\n};\n\nmodule.exports = PlainTextAuthProvider;","'use strict';\n/**\n * @classdesc Provides [Authenticator]{@link module:auth~Authenticator} instances to be used when connecting to a host.\n * @constructor\n * @abstract\n * @alias module:auth~AuthProvider\n */\nfunction AuthProvider() {\n\n}\n\n/**\n * Returns an [Authenticator]{@link module:auth~Authenticator} instance to be used when connecting to a host.\n * @param {String} endpoint The ip address and port number in the format ip:port\n * @param {String} name Authenticator name\n * @abstract\n * @returns {Authenticator}\n */\nAuthProvider.prototype.newAuthenticator = function (endpoint, name) {\n  throw new Error('This is an abstract class, you must implement newAuthenticator method or ' +\n    'use another auth provider that inherits from this class');\n};\n\n/**\n * @class\n * @classdesc Handles SASL authentication with Cassandra servers.\n * Each time a new connection is created and the server requires authentication,\n * a new instance of this class will be created by the corresponding.\n * @constructor\n * @alias module:auth~Authenticator\n */\nfunction Authenticator() {\n\n}\n\n/**\n * Obtain an initial response token for initializing the SASL handshake.\n * @param {Function} callback\n */\nAuthenticator.prototype.initialResponse = function (callback) {\n  callback(new Error('Not implemented'));\n};\n\n/**\n * Evaluates a challenge received from the Server. Generally, this method should callback with\n * no error and no additional params when authentication is complete from the client perspective.\n * @param {Buffer} challenge\n * @param {Function} callback\n */\nAuthenticator.prototype.evaluateChallenge = function (challenge, callback) {\n  callback(new Error('Not implemented'));\n};\n\n/**\n * Called when authentication is successful with the last information\n * optionally sent by the server.\n * @param {Buffer} [token]\n */\nAuthenticator.prototype.onAuthenticationSuccess = function (token) {\n\n};\n\nexports.AuthProvider = AuthProvider;\nexports.Authenticator = Authenticator;","\"use strict\";\nconst util = require('util');\n\nconst policies = require('./policies');\nconst types = require('./types');\nconst utils = require('./utils');\nconst tracker = require('./tracker');\nconst metrics = require('./metrics');\n\n/** Core connections per host for protocol versions 1 and 2 */\nconst coreConnectionsPerHostV2 = {\n  [types.distance.local]: 2,\n  [types.distance.remote]: 1,\n  [types.distance.ignored]: 0\n};\n\n/** Core connections per host for protocol version 3 and above */\nconst coreConnectionsPerHostV3 = {\n  [types.distance.local]: 1,\n  [types.distance.remote]: 1,\n  [types.distance.ignored]: 0\n};\n\n/** Default maxRequestsPerConnection value for protocol v1 and v2 */\nconst maxRequestsPerConnectionV2 = 128;\n\n/** Default maxRequestsPerConnection value for protocol v3+ */\nconst maxRequestsPerConnectionV3 = 2048;\n\n/**\n * @returns {ClientOptions}\n */\nfunction defaultOptions () {\n  return ({\n    policies: {\n      addressResolution: policies.defaultAddressTranslator(),\n      loadBalancing: policies.defaultLoadBalancingPolicy(),\n      reconnection: policies.defaultReconnectionPolicy(),\n      retry: policies.defaultRetryPolicy(),\n      speculativeExecution: policies.defaultSpeculativeExecutionPolicy(),\n      timestampGeneration: policies.defaultTimestampGenerator()\n    },\n    queryOptions: {\n      consistency: types.consistencies.localOne,\n      fetchSize: 5000,\n      prepare: false,\n      captureStackTrace: false\n    },\n    protocolOptions: {\n      port: 9042,\n      maxSchemaAgreementWaitSeconds: 10,\n      maxVersion: 0,\n      noCompact: false\n    },\n    pooling: {\n      heartBeatInterval: 30000,\n      warmup: true\n    },\n    socketOptions: {\n      connectTimeout: 5000,\n      defunctReadTimeoutThreshold: 64,\n      keepAlive: true,\n      keepAliveDelay: 0,\n      readTimeout: 12000,\n      tcpNoDelay: true,\n      coalescingThreshold: 65536\n    },\n    authProvider: null,\n    requestTracker: null,\n    metrics: new metrics.DefaultMetrics(),\n    maxPrepared: 500,\n    refreshSchemaDelay: 1000,\n    isMetadataSyncEnabled: true,\n    prepareOnAllHosts: true,\n    rePrepareOnUp: true,\n    encoding: {\n      copyBuffer: true,\n      useUndefinedAsUnset: true\n    }\n  });\n}\n\n/**\n * Extends and validates the user options\n * @param {Object} [baseOptions] The source object instance that will be overridden\n * @param {Object} userOptions\n * @returns {Object}\n */\nfunction extend(baseOptions, userOptions) {\n  if (arguments.length === 1) {\n    userOptions = arguments[0];\n    baseOptions = {};\n  }\n  const options = utils.deepExtend(baseOptions, defaultOptions(), userOptions);\n  if (!util.isArray(options.contactPoints) || options.contactPoints.length === 0) {\n    throw new TypeError('Contacts points are not defined.');\n  }\n  for (let i = 0; i < options.contactPoints.length; i++) {\n    const hostName = options.contactPoints[i];\n    if (!hostName) {\n      throw new TypeError(util.format('Contact point %s (%s) is not a valid host name, ' +\n        'the following values are valid contact points: ipAddress, hostName or ipAddress:port', i, hostName));\n    }\n  }\n  if (!options.logEmitter) {\n    options.logEmitter = function () {};\n  }\n  if (!options.queryOptions) {\n    throw new TypeError('queryOptions not defined in options');\n  }\n\n  if (options.requestTracker !== null && !(options.requestTracker instanceof tracker.RequestTracker)) {\n    throw new TypeError('requestTracker must be an instance of RequestTracker');\n  }\n\n  if (!(options.metrics instanceof metrics.ClientMetrics)) {\n    throw new TypeError('metrics must be an instance of ClientMetrics');\n  }\n\n  validatePoliciesOptions(options.policies);\n  validateProtocolOptions(options.protocolOptions);\n  validateSocketOptions(options.socketOptions);\n  options.encoding = options.encoding || {};\n  validateEncodingOptions(options.encoding);\n  if (options.profiles && !util.isArray(options.profiles)) {\n    throw new TypeError('profiles must be an Array of ExecutionProfile instances');\n  }\n  return options;\n}\n\n/**\n * Validates the policies from the client options.\n * @param {ClientOptions.policies} policiesOptions\n * @private\n */\nfunction validatePoliciesOptions(policiesOptions) {\n  if (!policiesOptions) {\n    throw new TypeError('policies not defined in options');\n  }\n  if (!(policiesOptions.loadBalancing instanceof policies.loadBalancing.LoadBalancingPolicy)) {\n    throw new TypeError('Load balancing policy must be an instance of LoadBalancingPolicy');\n  }\n  if (!(policiesOptions.reconnection instanceof policies.reconnection.ReconnectionPolicy)) {\n    throw new TypeError('Reconnection policy must be an instance of ReconnectionPolicy');\n  }\n  if (!(policiesOptions.retry instanceof policies.retry.RetryPolicy)) {\n    throw new TypeError('Retry policy must be an instance of RetryPolicy');\n  }\n  if (!(policiesOptions.addressResolution instanceof policies.addressResolution.AddressTranslator)) {\n    throw new TypeError('Address resolution policy must be an instance of AddressTranslator');\n  }\n  if (policiesOptions.timestampGeneration !== null &&\n    !(policiesOptions.timestampGeneration instanceof policies.timestampGeneration.TimestampGenerator)) {\n    throw new TypeError('Timestamp generation policy must be an instance of TimestampGenerator');\n  }\n}\n\n/**\n * Validates the protocol options.\n * @param {ClientOptions.protocolOptions} protocolOptions\n * @private\n */\nfunction validateProtocolOptions(protocolOptions) {\n  if (!protocolOptions) {\n    throw new TypeError('protocolOptions not defined in options');\n  }\n  const version = protocolOptions.maxVersion;\n  if (version && (typeof version !== 'number' || !types.protocolVersion.isSupported(version))) {\n    throw new TypeError(util.format('protocolOptions.maxVersion provided (%s) is invalid', version));\n  }\n}\n\n/**\n * Validates the socket options.\n * @param {ClientOptions.socketOptions} socketOptions\n * @private\n */\nfunction validateSocketOptions(socketOptions) {\n  if (!socketOptions) {\n    throw new TypeError('socketOptions not defined in options');\n  }\n  if (typeof socketOptions.readTimeout !== 'number') {\n    throw new TypeError('socketOptions.readTimeout must be a Number');\n  }\n  if (typeof socketOptions.coalescingThreshold !== 'number' || socketOptions.coalescingThreshold <= 0) {\n    throw new TypeError('socketOptions.coalescingThreshold must be a positive Number');\n  }\n}\n\n/**\n * Validates the encoding options.\n * @param {ClientOptions.encoding} encodingOptions\n * @private\n */\nfunction validateEncodingOptions(encodingOptions) {\n  if (encodingOptions.map) {\n    const mapConstructor = encodingOptions.map;\n    if (typeof mapConstructor !== 'function' ||\n      typeof mapConstructor.prototype.forEach !== 'function' ||\n      typeof mapConstructor.prototype.set !== 'function') {\n      throw new TypeError('Map constructor not valid');\n    }\n  }\n\n  if (encodingOptions.set) {\n    const setConstructor = encodingOptions.set;\n    if (typeof setConstructor !== 'function' ||\n      typeof setConstructor.prototype.forEach !== 'function' ||\n      typeof setConstructor.prototype.add !== 'function') {\n      throw new TypeError('Set constructor not valid');\n    }\n  }\n\n  if ((encodingOptions.useBigIntAsLong || encodingOptions.useBigIntAsVarint) && typeof BigInt === 'undefined') {\n    throw new TypeError('BigInt is not supported by the JavaScript engine');\n  }\n}\n\n/**\n * Sets the default options that depend on the protocol version.\n * @param {ClientOptions} options\n * @param {Number} version\n */\nfunction setProtocolDependentDefaults(options, version) {\n  let coreConnectionsPerHost = coreConnectionsPerHostV3;\n  let maxRequestsPerConnection = maxRequestsPerConnectionV3;\n  if (!types.protocolVersion.uses2BytesStreamIds(version)) {\n    coreConnectionsPerHost = coreConnectionsPerHostV2;\n    maxRequestsPerConnection = maxRequestsPerConnectionV2;\n  }\n  options.pooling = utils.deepExtend({}, { coreConnectionsPerHost, maxRequestsPerConnection }, options.pooling);\n}\n\nexports.extend = extend;\nexports.defaultOptions = defaultOptions;\nexports.coreConnectionsPerHostV2 = coreConnectionsPerHostV2;\nexports.coreConnectionsPerHostV3 = coreConnectionsPerHostV3;\nexports.maxRequestsPerConnectionV2 = maxRequestsPerConnectionV2;\nexports.maxRequestsPerConnectionV3 = maxRequestsPerConnectionV3;\nexports.setProtocolDependentDefaults = setProtocolDependentDefaults;","\"use strict\";\nconst events = require('events');\nconst util = require('util');\n\nconst utils = require('./utils.js');\nconst errors = require('./errors.js');\nconst types = require('./types');\nconst ProfileManager = require('./execution-profile').ProfileManager;\nconst requests = require('./requests');\nconst clientOptions = require('./client-options');\nconst ClientState = require('./metadata/client-state');\nconst description = require('../package.json').description;\nconst version = require('../package.json').version;\nconst DefaultExecutionOptions = require('./execution-options').DefaultExecutionOptions;\n\n// Allow injection of the following modules\n/* eslint-disable prefer-const */\nlet ControlConnection = require('./control-connection');\nlet RequestHandler = require('./request-handler');\nlet PrepareHandler = require('./prepare-handler');\n/* eslint-enable prefer-const */\n\n/**\n * Max amount of pools being warmup in parallel, when warmup is enabled\n * @private\n */\nconst warmupLimit = 32;\n\n\n/**\n * Client options\n * @typedef {Object} ClientOptions\n * @property {Array.<string>} contactPoints\n * Array of addresses or host names of the nodes to add as contact points.\n * <p>\n *  Contact points are addresses of Cassandra nodes that the driver uses to discover the cluster topology.\n * </p>\n * <p>\n *  Only one contact point is required (the driver will retrieve the address of the other nodes automatically),\n *  but it is usually a good idea to provide more than one contact point, because if that single contact point is\n *  unavailable, the driver will not be able to initialize correctly.\n * </p>\n * @property {String} [localDataCenter] The local data center to use.\n * <p>\n *   If using DCAwareRoundRobinPolicy (default), this option is required and only hosts from this data center are\n *   connected to and used in query plans.\n * </p>\n * @property {String} keyspace The logged keyspace for all the connections created within the {@link Client} instance.\n * @property {Number} refreshSchemaDelay The default window size in milliseconds used to debounce node list and schema\n * refresh metadata requests. Default: 1000.\n * @property {Boolean} isMetadataSyncEnabled Determines whether client-side schema metadata retrieval and update is\n * enabled.\n * <p>Setting this value to <code>false</code> will cause keyspace information not to be automatically loaded, affecting\n * replica calculation per token in the different keyspaces. When disabling metadata synchronization, use\n * [Metadata.refreshKeyspaces()]{@link module:metadata~Metadata#refreshKeyspaces} to keep keyspace information up to\n * date or token-awareness will not work correctly.</p>\n * Default: <code>true</code>.\n * @property {Boolean} prepareOnAllHosts Determines if the driver should prepare queries on all hosts in the cluster.\n * Default: <code>true</code>.\n * @property {Boolean} rePrepareOnUp Determines if the driver should re-prepare all cached prepared queries on a\n * host when it marks it back up.\n * Default: <code>true</code>.\n * @property {Number} maxPrepared Determines the maximum amount of different prepared queries before evicting items\n * from the internal cache. Reaching a high threshold hints that the queries are not being reused, like when\n * hard-coding parameter values inside the queries.\n * Default: <code>500</code>.\n * @property {Object} policies\n * @property {LoadBalancingPolicy} policies.loadBalancing The load balancing policy instance to be used to determine\n * the coordinator per query.\n * @property {RetryPolicy} policies.retry The retry policy.\n * @property {ReconnectionPolicy} policies.reconnection The reconnection policy to be used.\n * @property {AddressTranslator} policies.addressResolution The address resolution policy.\n * @property {SpeculativeExecutionPolicy} policies.speculativeExecution The <code>SpeculativeExecutionPolicy</code>\n * instance to be used to determine if the client should send speculative queries when the selected host takes more\n * time than expected.\n * <p>\n *   Default: <code>[NoSpeculativeExecutionPolicy]{@link\n  *   module:policies/speculativeExecution~NoSpeculativeExecutionPolicy}</code>\n * </p>\n * @property {TimestampGenerator} policies.timestampGeneration The client-side\n * [query timestamp generator]{@link module:policies/timestampGeneration~TimestampGenerator}.\n * <p>\n *   Default: <code>[MonotonicTimestampGenerator]{@link module:policies/timestampGeneration~MonotonicTimestampGenerator}\n *   </code>\n * </p>\n * <p>Use <code>null</code> to disable client-side timestamp generation.</p>\n * @property {QueryOptions} queryOptions Default options for all queries.\n * @property {Object} pooling Pooling options.\n * @property {Number} pooling.heartBeatInterval The amount of idle time in milliseconds that has to pass before the\n * driver issues a request on an active connection to avoid idle time disconnections. Default: 30000.\n * @property {Object} pooling.coreConnectionsPerHost Associative array containing amount of connections per host\n * distance.\n * @property {Number} pooling.maxRequestsPerConnection The maximum number of requests per connection. The default\n * value is:\n * <ul>\n *   <li>For modern protocol versions (v3 and above): 2048</li>\n *   <li>For older protocol versions (v1 and v2): 128</li>\n * </ul>\n * @property {Boolean} pooling.warmup Determines if all connections to hosts in the local datacenter must be opened on\n * connect. Default: true.\n * @property {Object} protocolOptions\n * @property {Number} protocolOptions.port The port to use to connect to the Cassandra host. If not set through this\n * method, the default port (9042) will be used instead.\n * @property {Number} protocolOptions.maxSchemaAgreementWaitSeconds The maximum time in seconds to wait for schema\n * agreement between nodes before returning from a DDL query. Default: 10.\n * @property {Number} protocolOptions.maxVersion When set, it limits the maximum protocol version used to connect to\n * the nodes.\n * Useful for using the driver against a cluster that contains nodes with different major/minor versions of Cassandra.\n * @property {Boolean} protocolOptions.noCompact When set to true, enables the NO_COMPACT startup option.\n * <p>\n * When this option is supplied <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>BATCH</code>\n * statements on <code>COMPACT STORAGE</code> tables function in \"compatibility\" mode which allows seeing these tables\n * as if they were \"regular\" CQL tables.\n * </p>\n * <p>\n * This option only effects interactions with interactions with tables using <code>COMPACT STORAGE</code> and is only\n * supported by C* 3.0.16+, 3.11.2+, 4.0+ and DSE 6.0+.\n * </p>\n * @property {Object} socketOptions\n * @property {Number} socketOptions.connectTimeout Connection timeout in milliseconds. Default: 5000.\n * @property {Number} socketOptions.defunctReadTimeoutThreshold Determines the amount of requests that simultaneously\n * have to timeout before closing the connection. Default: 64.\n * @property {Boolean} socketOptions.keepAlive Whether to enable TCP keep-alive on the socket. Default: true.\n * @property {Number} socketOptions.keepAliveDelay TCP keep-alive delay in milliseconds. Default: 0.\n * @property {Number} socketOptions.readTimeout Per-host read timeout in milliseconds.\n * <p>\n *   Please note that this is not the maximum time a call to {@link Client#execute} may have to wait;\n *   this is the maximum time that call will wait for one particular Cassandra host, but other hosts will be tried if\n *   one of them timeout. In other words, a {@link Client#execute} call may theoretically wait up to\n *   <code>readTimeout * number_of_cassandra_hosts</code> (though the total number of hosts tried for a given query also\n *   depends on the LoadBalancingPolicy in use).\n * <p>When setting this value, keep in mind the following:</p>\n * <ul>\n *   <li>the timeout settings used on the Cassandra side (*_request_timeout_in_ms in cassandra.yaml) should be taken\n *   into account when picking a value for this read timeout. You should pick a value a couple of seconds greater than\n *   the Cassandra timeout settings.\n *   </li>\n *   <li>\n *     the read timeout is only approximate and only control the timeout to one Cassandra host, not the full query.\n *   </li>\n * </ul>\n * Setting a value of 0 disables read timeouts. Default: <code>12000</code>.\n * @property {Boolean} socketOptions.tcpNoDelay When set to true, it disables the Nagle algorithm. Default: true.\n * @property {Number} socketOptions.coalescingThreshold Buffer length in bytes use by the write queue before flushing\n * the frames. Default: 8000.\n * @property {AuthProvider} authProvider Provider to be used to authenticate to an auth-enabled cluster.\n * @property {RequestTracker} requestTracker The instance of RequestTracker used to monitor or log requests executed\n * with this instance.\n * @property {Object} sslOptions Client-to-node ssl options. When set the driver will use the secure layer.\n * You can specify cert, ca, ... options named after the Node.js <code>tls.connect()</code> options.\n * <p>\n *   It uses the same default values as Node.js <code>tls.connect()</code> except for <code>rejectUnauthorized</code>\n *   which is set to <code>false</code> by default (for historical reasons). This setting is likely to change\n *   in upcoming versions to enable validation by default.\n * </p>\n * @property {Object} encoding\n * @property {Function} encoding.map Map constructor to use for Cassandra map<k,v> type encoding and decoding.\n * If not set, it will default to Javascript Object with map keys as property names.\n * @property {Function} encoding.set Set constructor to use for Cassandra set<k> type encoding and decoding.\n * If not set, it will default to Javascript Array.\n * @property {Boolean} encoding.copyBuffer Determines if the network buffer should be copied for buffer based data\n * types (blob, uuid, timeuuid and inet).\n * <p>\n *   Setting it to true will cause that the network buffer is copied for each row value of those types,\n *   causing additional allocations but freeing the network buffer to be reused.\n *   Setting it to true is a good choice for cases where the Row and ResultSet returned by the queries are long-lived\n *   objects.\n * </p>\n * <p>\n *  Setting it to false will cause less overhead and the reference of the network buffer to be maintained until the row\n *  / result set are de-referenced.\n *  Default: true.\n * </p>\n * @property {Boolean} encoding.useUndefinedAsUnset Valid for Cassandra 2.2 and above. Determines that, if a parameter\n * is set to\n * <code>undefined</code> it should be encoded as <code>unset</code>.\n * <p>\n *  By default, ECMAScript <code>undefined</code> is encoded as <code>null</code> in the driver. Cassandra 2.2\n *  introduced the concept of unset.\n *  At driver level, you can set a parameter to unset using the field <code>types.unset</code>. Setting this flag to\n *  true allows you to use ECMAScript undefined as Cassandra <code>unset</code>.\n * </p>\n * <p>\n *   Default: true.\n * </p>\n * @property {Boolean} encoding.useBigIntAsLong Use [BigInt ECMAScript type](https://tc39.github.io/proposal-bigint/)\n * to represent CQL bigint and counter data types.\n * @property {Boolean} encoding.useBigIntAsVarint Use [BigInt ECMAScript type](https://tc39.github.io/proposal-bigint/)\n * to represent CQL varint data type.\n * @property {Array.<ExecutionProfile>} profiles The array of [execution profiles]{@link ExecutionProfile}.\n * @property {Function} promiseFactory Function to be used to create a <code>Promise</code> from a\n * callback-style function.\n * <p>\n *   Promise libraries often provide different methods to create a promise. For example, you can use Bluebird's\n *   <code>Promise.fromCallback()</code> method.\n * </p>\n * <p>\n *   By default, the driver will use the\n *   [Promise constructor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.\n * </p>\n */\n\n/**\n * Query options\n * @typedef {Object} QueryOptions\n * @property {Boolean} [autoPage] Determines if the driver must retrieve the following result pages automatically.\n * <p>\n *   This setting is only considered by the [Client#eachRow()]{@link Client#eachRow} method. For more information,\n *   check the\n *   [paging results documentation]{@link http://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.\n * </p>\n * @property {Boolean} [captureStackTrace] Determines if the stack trace before the query execution should be\n * maintained.\n * <p>\n *   Useful for debugging purposes, it should be set to <code>false</code> under production environment as it adds an\n *   unnecessary overhead to each execution.\n * </p>\n * Default: false.\n * @property {Number} [consistency] [Consistency level]{@link module:types~consistencies}. Default: localOne.\n * @property {Object} [customPayload] Key-value payload to be passed to the server. On the Cassandra side, \n * implementations of QueryHandler can use this data.\n * @property {String|ExecutionProfile} [executionProfile] Name or instance of the [profile]{@link ExecutionProfile} to\n * be used for this execution. If not set, it will the use \"default\" execution profile.\n * @property {Number} [fetchSize] Amount of rows to retrieve per page.\n * @property {Array|Array<Array>} [hints] Type hints for parameters given in the query, ordered as for the parameters.\n * <p>For batch queries, an array of such arrays, ordered as with the queries in the batch.</p>\n * @property {Host} [host] The host that should handle the query.\n * <p>\n *   Use of this option is <em>heavily discouraged</em> and should only be used in the following cases:\n * </p>\n * <ol>\n *   <li>\n *     Querying node-local tables, such as tables in the <code>system</code> and <code>system_views</code>\n *     keyspaces.\n *   </li>\n *   <li>\n *     Applying a series of schema changes, where it may be advantageous to execute schema changes in sequence on the\n *     same node.\n *   </li>\n * </ol> \n * <p>\n *   Configuring a specific host causes the configured\n *   [LoadBalancingPolicy]{@link module:policies/loadBalancing~LoadBalancingPolicy} to be completely bypassed.\n *   However, if the load balancing policy dictates that the host is at a\n *   [distance of ignored]{@link module:types~distance} or there is no active connectivity to the host, the request will\n *   fail with a [NoHostAvailableError]{@link module:errors~NoHostAvailableError}.\n * </p>\n * @property {Boolean} [isIdempotent] Defines whether the query can be applied multiple times without changing the result\n * beyond the initial application.\n * <p>\n *   The query execution idempotence can be used at [RetryPolicy]{@link module:policies/retry~RetryPolicy} level to\n *   determine if an statement can be retried in case of request error or write timeout.\n * </p>\n * <p>Default: <code>false</code>.</p>\n * @property {String} [keyspace] Specifies the keyspace for the query. Used for routing within the driver, this\n * property is suitable when the query operates on a different keyspace than the current {@link Client#keyspace}.\n * <p>\n *   This property should only be set manually by the user when the query operates on a different keyspace than\n *   the current {@link Client#keyspace} and using either batch or non-prepared query executions.\n * </p>\n * @property {Boolean} [logged] Determines if the batch should be written to the batchlog. Only valid for\n * [Client#batch()]{@link Client#batch}, it will be ignored by other methods. Default: true.\n * @property {Boolean} [counter] Determines if its a counter batch. Only valid for\n * [Client#batch()]{@link Client#batch}, it will be ignored by other methods. Default: false.\n * @property {Buffer|String} [pageState] Buffer or string token representing the paging state.\n * <p>Useful for manual paging, if provided, the query will be executed starting from a given paging state.</p>\n * @property {Boolean} [prepare] Determines if the query must be executed as a prepared statement.\n * @property {Number} [readTimeout] When defined, it overrides the default read timeout\n * (<code>socketOptions.readTimeout</code>) in milliseconds for this execution per coordinator.\n * <p>\n *   Suitable for statements for which the coordinator may allow a longer server-side timeout, for example aggregation\n *   queries.\n * </p>\n * <p>\n *   A value of <code>0</code> disables client side read timeout for the execution. Default: <code>undefined</code>.\n * </p>\n * @property {RetryPolicy} [retry] Retry policy for the query.\n * <p>\n *   This property can be used to specify a different [retry policy]{@link module:policies/retry} to the one specified\n *   in the {@link ClientOptions}.policies.\n * </p>\n * @property {Array} [routingIndexes] Index of the parameters that are part of the partition key to determine\n * the routing.\n * @property {Buffer|Array} [routingKey] Partition key(s) to determine which coordinator should be used for the query.\n * @property {Array} [routingNames] Array of the parameters names that are part of the partition key to determine the\n * routing. Only valid for non-prepared requests, it's recommended that you use the prepare flag instead.\n * @property {Number} [serialConsistency] Serial consistency is the consistency level for the serial phase of\n * conditional updates.\n * This option will be ignored for anything else that a conditional update/insert.\n * @property {Number|Long} [timestamp] The default timestamp for the query in microseconds from the unix epoch\n * (00:00:00, January 1st, 1970).\n * <p>If provided, this will replace the server side assigned timestamp as default timestamp.</p>\n * <p>Use [generateTimestamp()]{@link module:types~generateTimestamp} utility method to generate a valid timestamp\n * based on a Date and microseconds parts.</p>\n * @property {Boolean} [traceQuery] Enable query tracing for the execution. Use query tracing to diagnose performance\n * problems related to query executions. Default: false.\n * <p>To retrieve trace, you can call [Metadata.getTrace()]{@link module:metadata~Metadata#getTrace} method.</p>\n */\n\n/**\n * Creates a new instance of {@link Client}.\n * @classdesc\n * A Client holds connections to a Cassandra cluster, allowing it to be queried.\n * Each Client instance maintains multiple connections to the cluster nodes,\n * provides [policies]{@link module:policies} to choose which node to use for each query,\n * and handles [retries]{@link module:policies/retry} for failed query (when it makes sense), etc...\n * <p>\n * Client instances are designed to be long-lived and usually a single instance is enough\n * per application. As a given Client can only be \"logged\" into one keyspace at\n * a time (where the \"logged\" keyspace is the one used by query if the query doesn't\n * explicitly use a fully qualified table name), it can make sense to create one\n * client per keyspace used. This is however not necessary to query multiple keyspaces\n * since it is always possible to use a single session with fully qualified table name\n * in queries.\n * </p>\n * @extends EventEmitter\n * @param {ClientOptions} options The options for this instance.\n * @example <caption>Creating a new client instance</caption>\n * const client = new Client({ contactPoints: ['192.168.1.100'], localDataCenter: 'datacenter1' });\n * client.connect(function (err) {\n *   if (err) return console.error(err);\n *   console.log('Connected to cluster with %d host(s): %j', client.hosts.length, client.hosts.keys());\n * });\n * @example <caption>Executing a query</caption>\n * // calling #execute() can be made without previously calling #connect(), as internally\n * // it will ensure it's connected before attempting to execute the query\n * client.execute('SELECT key FROM system.local', function (err, result) {\n *   if (err) return console.error(err);\n *   const row = result.first();\n *   console.log(row['key']);\n * });\n * @example <caption>Executing a query with promise-based API</caption>\n * const result = await client.execute('SELECT key FROM system.local');\n * const row = result.first();\n * console.log(row['key']);\n * @constructor\n */\nfunction Client(options) {\n  events.EventEmitter.call(this);\n  this.options = clientOptions.extend({ logEmitter: this.emit.bind(this) }, options);\n  Object.defineProperty(this, 'profileManager', { value: new ProfileManager(this.options) });\n  Object.defineProperty(this, 'controlConnection', {\n    value: new ControlConnection(this.options, this.profileManager), writable: true }\n  );\n  //Unlimited amount of listeners for internal event queues by default\n  this.setMaxListeners(0);\n  this.connected = false;\n  this.isShuttingDown = false;\n  /**\n   * Gets the name of the active keyspace.\n   * @type {String}\n   */\n  this.keyspace = options.keyspace;\n  /**\n   * Gets the schema and cluster metadata information.\n   * @type {Metadata}\n   */\n  this.metadata = this.controlConnection.metadata;\n  /**\n   * Gets an associative array of cluster hosts.\n   * @type {HostMap}\n   */\n  this.hosts = this.controlConnection.hosts;\n\n  /**\n   * The [ClientMetrics]{@link module:metrics~ClientMetrics} instance used to expose measurements of its internal\n   * behavior and of the server as seen from the driver side.\n   * <p>By default, a [DefaultMetrics]{@link module:metrics~DefaultMetrics} instance is used.</p>\n   * @type {ClientMetrics}\n   */\n  this.metrics = this.options.metrics;\n}\n\nutil.inherits(Client, events.EventEmitter);\n\n/**\n * Emitted when a new host is added to the cluster.\n * <ul>\n *   <li>{@link Host} The host being added.</li>\n * </ul>\n * @event Client#hostAdd\n */\n/**\n * Emitted when a host is removed from the cluster\n * <ul>\n *   <li>{@link Host} The host being removed.</li>\n * </ul>\n * @event Client#hostRemove\n */\n/**\n * Emitted when a host in the cluster changed status from down to up.\n * <ul>\n *   <li>{@link Host host} The host that changed the status.</li>\n * </ul>\n * @event Client#hostUp\n */\n/**\n * Emitted when a host in the cluster changed status from up to down.\n * <ul>\n *   <li>{@link Host host} The host that changed the status.</li>\n * </ul>\n * @event Client#hostDown\n */\n\n/**\n * Tries to connect to one of the [contactPoints]{@link ClientOptions} and discovers the rest the nodes of the cluster.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the client is connected. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * <p>\n *   If the {@link Client} is already connected, it invokes callback immediately (when provided) or the promise is\n *   fulfilled .\n * </p>\n * @example <caption>Callback-based execution</caption>\n * client.connect(function (err) {\n *   if (err) return console.error(err);\n *   console.log('Connected to cluster with %d host(s): %j', client.hosts.length, client.hosts.keys());\n * });\n * @example <caption>Promise-based execution</caption>\n * await client.connect();\n * @param {function} [callback] The callback is invoked when the pool is connected it failed to connect.\n */\nClient.prototype.connect = function (callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, this._connectCb);\n};\n\n/**\n * @param {Function} callback\n * @private\n */\nClient.prototype._connectCb = function (callback) {\n  if (this.connected) {\n    return callback();\n  }\n  if (this.isShuttingDown) {\n    //it is being shutdown, don't allow further calls to connect()\n    return callback(new errors.NoHostAvailableError(null, 'Connecting after shutdown is not supported'));\n  }\n  this.once('connected', callback);\n  if (this.connecting) {\n    //the listener to connect was added, move on\n    return;\n  }\n  this.connecting = true;\n  const self = this;\n  this.log('info', util.format(\"Connecting to cluster using '%s' version %s\", description, version));\n  utils.series([\n    function initControlConnection(next) {\n      self.controlConnection.init(next);\n    },\n    function initLoadBalancingPolicy(next) {\n      self.hosts = self.controlConnection.hosts;\n      self.profileManager.init(self, self.hosts, next);\n    },\n    function setKeyspace(next) {\n      if (!self.keyspace) {\n        return next();\n      }\n      RequestHandler.setKeyspace(self, next);\n    },\n    function setPoolOptionsAndWarmup(next) {\n      clientOptions.setProtocolDependentDefaults(self.options, self.controlConnection.protocolVersion);\n\n      if (!self.options.pooling.warmup) {\n        return next();\n      }\n      self._warmup(next);\n    }\n  ], function connectFinished(err) {\n    if (err) {\n      // We should close the pools (if any) and reset the state to allow successive calls to connect()\n      return self.controlConnection.reset(function () {\n        self.connected = false;\n        self.connecting = false;\n        self.emit('connected', err);\n      });\n    }\n    self._setHostListeners();\n    // Set the distance of the control connection host relatively to this instance\n    self.profileManager.getDistance(self.controlConnection.host);\n    self.connected = true;\n    self.connecting = false;\n    self.emit('connected');\n  });\n};\n\n/**\n * Executes a query on an available connection.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the execution completes. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * <p>The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag.</p>\n * <p>\n *   Some executions failures can be handled transparently by the driver, according to the\n *   [RetryPolicy]{@link module:policies/retry~RetryPolicy} defined at {@link ClientOptions} or {@link QueryOptions}\n *   level.\n * </p>\n * @param {String} query The query to execute.\n * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names\n * as keys and its value.\n * @param {QueryOptions} [options] The query options for the execution.\n * @param {ResultCallback} [callback] Executes callback(err, result) when execution completed. When not defined, the\n * method will return a promise.\n * @example <caption>Callback-based API</caption>\n * const query = 'SELECT name, email FROM users WHERE id = ?';\n * client.execute(query, [ id ], { prepare: true }, function (err, result) {\n *   assert.ifError(err);\n *   const row = result.first();\n *   console.log('%s: %s', row.name, row.email);\n * });\n * @example <caption>Promise-based API, using async/await</caption>\n * const query = 'SELECT name, email FROM users WHERE id = ?';\n * const result = await client.execute(query, [ id ], { prepare: true });\n * const row = result.first();\n * console.log('%s: %s', row.name, row.email);\n * @see {@link ExecutionProfile} to reuse a set of options across different query executions.\n */\nClient.prototype.execute = function (query, params, options, callback) {\n  // set default argument values for optional parameters\n  callback = callback || (options ? options : params);\n  if (typeof callback === 'function') {\n    params = typeof params !== 'function' ? params : null;\n  }\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    let execOptions;\n    try {\n      execOptions = DefaultExecutionOptions.create(options, this);\n    }\n    catch (e) {\n      return cb(e);\n    }\n\n    this._innerExecute(query, params, execOptions, cb);\n  });\n};\n\n/**\n * Executes the query and calls rowCallback for each row as soon as they are received. Calls final callback after all\n * rows have been sent, or when there is an error.\n * <p>\n *   The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag. Retries on multiple\n *   hosts if needed.\n * </p>\n * @param {String} query The query to execute\n * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names\n * as keys and its value.\n * @param {QueryOptions} [options]\n * @param {function} rowCallback Executes <code>rowCallback(n, row)</code> per each row received, where n is the row\n * index and row is the current Row.\n * @param {function} [callback] Executes <code>callback(err, result)</code> after all rows have been received.\n * <p>\n *   When dealing with paged results, [ResultSet#nextPage()]{@link module:types~ResultSet#nextPage} method can be used\n *   to retrieve the following page. In that case, <code>rowCallback()</code> will be again called for each row and\n *   the final callback will be invoked when all rows in the following page has been retrieved.\n * </p>\n * @example <caption>Using per-row callback and arrow functions</caption>\n * client.eachRow(query, params, { prepare: true }, (n, row) => console.log(n, row), err => console.error(err));\n * @example <caption>Overloads</caption>\n * client.eachRow(query, rowCallback);\n * client.eachRow(query, params, rowCallback);\n * client.eachRow(query, params, options, rowCallback);\n * client.eachRow(query, params, rowCallback, callback);\n * client.eachRow(query, params, options, rowCallback, callback);\n */\nClient.prototype.eachRow = function (query, params, options, rowCallback, callback) {\n  if (!callback && rowCallback && typeof options === 'function') {\n    callback = utils.validateFn(rowCallback, 'rowCallback');\n    rowCallback = options;\n  } else {\n    callback = callback || utils.noop;\n    rowCallback = utils.validateFn(rowCallback || options || params, 'rowCallback');\n  }\n\n  params = typeof params !== 'function' ? params : null;\n\n  let execOptions;\n  try {\n    execOptions = DefaultExecutionOptions.create(options, this, rowCallback);\n  }\n  catch (e) {\n    return callback(e);\n  }\n\n  const self = this;\n  let rowLength = 0;\n\n  function nextPage() {\n    self._innerExecute(query, params, execOptions, pageCallback);\n  }\n\n  function pageCallback (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    // Next requests in case paging (auto or explicit) is used\n    rowLength += result.rowLength;\n\n    if (result.rawPageState !== undefined) {\n      // Use new page state as next request page state\n      execOptions.setPageState(result.rawPageState);\n      if (execOptions.isAutoPage()) {\n        // Issue next request for the next page\n        return nextPage();\n      }\n      // Allows for explicit (manual) paging, in case the caller needs it\n      result.nextPage = nextPage;\n    }\n\n    // Finished auto-paging\n    result.rowLength = rowLength;\n    callback(null, result);\n  }\n\n  this._innerExecute(query, params, execOptions, pageCallback);\n};\n\n/**\n * Executes the query and pushes the rows to the result stream\n *  as soon as they received.\n * Calls callback after all rows have been sent, or when there is an error.\n * <p>\n * The stream is a [Readable Streams2]{@link http://nodejs.org/api/stream.html#stream_class_stream_readable} object\n *  that contains the raw bytes of the field value.\n *  It can be piped downstream and provides automatic pause/resume logic (it buffers when not read).\n * </p>\n * <p>\n *   The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag. Retries on multiple\n *   hosts if needed.\n * </p>\n * @param {String} query The query to prepare and execute\n * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names\n * as keys and its value\n * @param {QueryOptions} [options]\n * @param {function} [callback], executes callback(err) after all rows have been received or if there is an error\n * @returns {types.ResultStream}\n */\nClient.prototype.stream = function (query, params, options, callback) {\n  callback = callback || utils.noop;\n  // NOTE: the nodejs stream maintains yet another internal buffer \n  // we rely on the default stream implementation to keep memory \n  // usage reasonable.\n  const resultStream = new types.ResultStream({ objectMode: 1 });\n  function onFinish(err, result) {\n    if (err) {\n      resultStream.emit('error', err);\n    }\n    if (result && result.nextPage ) {\n      // allows for throttling as per the\n      // default nodejs stream implementation\n      resultStream._valve(function pageValve() {\n        try {\n          result.nextPage();\n        }\n        catch( ex ) {\n          resultStream.emit('error', ex );\n        }\n      });\n      return;\n    }\n    // Explicitly dropping the valve (closure)\n    resultStream._valve(null);\n    resultStream.add(null);\n    callback(err);\n  }\n  let sync = true;\n  this.eachRow(query, params, options, function rowCallback(n, row) {\n    resultStream.add(row);\n  }, function eachRowFinished(err, result) {\n    if (sync) {\n      // Prevent sync callback\n      return setImmediate(function eachRowFinishedImmediate() {\n        onFinish(err, result);\n      });\n    }\n    onFinish(err, result);\n  });\n  sync = false;\n  return resultStream;\n};\n\n/**\n * Executes batch of queries on an available connection to a host.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the execution completes. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * @param {Array.<string>|Array.<{query, params}>} queries The queries to execute as an Array of strings or as an array\n * of object containing the query and params\n * @param {QueryOptions} [options]\n * @param {ResultCallback} [callback] Executes callback(err, result) when the batch was executed\n */\nClient.prototype.batch = function (queries, options, callback) {\n  callback = callback || options;\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._batchCb(queries, options, cb);\n  });\n};\n\n/**\n * @param {Array.<string>|Array.<{query, params}>}queries\n * @param {QueryOptions} options\n * @param {ResultCallback} callback\n * @private\n */\nClient.prototype._batchCb = function (queries, options, callback) {\n  if (!Array.isArray(queries)) {\n    // We should throw (not callback) for an unexpected type\n    throw new errors.ArgumentError('Queries should be an Array');\n  }\n  if (queries.length === 0) {\n    return callback(new errors.ArgumentError('Queries array can not be empty'));\n  }\n\n  let execOptions;\n  try {\n    execOptions = DefaultExecutionOptions.create(options, this);\n  } catch (e) {\n    return callback(e);\n  }\n\n  let queryItems;\n  let request;\n\n  utils.series([\n    next => this.connect(next),\n    next => {\n      if (execOptions.isPrepared()) {\n        return PrepareHandler.getPreparedMultiple(\n          this, execOptions.getLoadBalancingPolicy(), queries, this.keyspace, function(err, result) {\n            queryItems = result;\n            next(err);\n          });\n      }\n      queryItems = new Array(queries.length);\n      for (let i = 0; i < queries.length; i++) {\n        const item = queries[i];\n        if (!item) {\n          return next(new errors.ArgumentError(util.format('Invalid query at index %d', i)));\n        }\n        const query = typeof item === 'string' ? item : item.query;\n        if (!query) {\n          return next(errors.ArgumentError(util.format('Invalid query at index %d', i)));\n        }\n        queryItems[i] = { query: query, params: item.params };\n      }\n      next();\n    },\n    next => this._createBatchRequest(queryItems, execOptions, (err, r) => {\n      request = r;\n      next(err);\n    }),\n    next => RequestHandler.send(request, execOptions, this, next)\n  ], callback);\n};\n\n/**\n * Gets the host list representing the replicas that contain such partition.\n * @param {String} keyspace\n * @param {Buffer} token\n * @returns {Array}\n */\nClient.prototype.getReplicas = function (keyspace, token) {\n  return this.metadata.getReplicas(keyspace, token);\n};\n\n/**\n * Gets a snapshot containing information on the connections pools held by this Client at the current time.\n * <p>\n *   The information provided in the returned object only represents the state at the moment this method was called and\n *   it's not maintained in sync with the driver metadata.\n * </p>\n * @return module:metadata~ClientState\n */\nClient.prototype.getState = function () {\n  return ClientState.from(this);\n};\n\nClient.prototype.log = utils.log;\n\n/**\n * Closes all connections to all hosts.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the client is disconnected. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * @param {Function} [callback] Optional callback to be invoked when finished closing all connections.\n */\nClient.prototype.shutdown = function (callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, this._shutdownCb);\n};\n\n/**\n * @param {Function} callback\n * @private\n */\nClient.prototype._shutdownCb = function (callback) {\n  const self = this;\n  function doShutdown() {\n    self.connected = false;\n    self.isShuttingDown = true;\n    const hosts = self.hosts.values();\n    // Shutdown the ControlConnection before shutting down the pools\n    self.controlConnection.shutdown();\n    self.options.policies.speculativeExecution.shutdown();\n    if (self.options.requestTracker) {\n      self.options.requestTracker.shutdown();\n    }\n    // go through all the host and shut down their pools\n    utils.each(hosts, (h, next) => h.shutdown(false, next), callback);\n  }\n  this.log('info', 'Shutting down');\n  callback = callback || utils.noop;\n  if (!this.hosts || !this.connected) {\n    // not initialized\n    this.connected = false;\n    return callback();\n  }\n  if (this.connecting) {\n    this.log('warning', 'Shutting down while connecting');\n    // wait until finish connecting for easier troubleshooting\n    return this.once('connected', doShutdown);\n  }\n  doShutdown();\n};\n\n/**\n * Waits until that the schema version in all nodes is the same or the waiting time passed.\n * @param {Connection} connection\n * @param {Function} callback\n * @ignore\n */\nClient.prototype._waitForSchemaAgreement = function (connection, callback) {\n  if (this.hosts.length === 1) {\n    return setImmediate(() => callback(null, true));\n  }\n\n  const start = process.hrtime();\n  const maxWaitSeconds = this.options.protocolOptions.maxSchemaAgreementWaitSeconds;\n\n  this.log('info', 'Waiting for schema agreement');\n\n  let versionsMatch;\n\n  utils.whilst(\n    () => !versionsMatch && process.hrtime(start)[0] < maxWaitSeconds,\n    next => {\n      this.metadata.compareSchemaVersions(connection, (err, agreement) => {\n        if (err) {\n          return next(err);\n        }\n\n        versionsMatch = agreement;\n\n        if (versionsMatch) {\n          this.log('info', 'Schema versions match');\n          return next();\n        }\n\n        // Let some time pass before the next check\n        setTimeout(next, 500);\n      });\n    },\n    (err) => callback(err, versionsMatch));\n};\n\n/**\n * Waits for schema agreements and schedules schema metadata refresh.\n * @param {Connection} connection\n * @param event\n * @param {Function} callback\n * @ignore\n * @internal\n */\nClient.prototype.handleSchemaAgreementAndRefresh = function (connection, event, callback) {\n  this._waitForSchemaAgreement(connection, (err, agreement) => {\n    if (err) {\n      //we issue a warning but we continue with the normal flow\n      this.log('warning', 'There was an error while waiting for the schema agreement between nodes', err);\n    }\n    if (!this.options.isMetadataSyncEnabled) {\n      return callback(agreement);\n    }\n\n    // schedule metadata refresh immediately and the callback will be invoked once it was refreshed\n    this.controlConnection.handleSchemaChange(event, true, (err) => {\n      if (err) {\n        this.log('warning', 'There was an error while handling schema change', err);\n      }\n      callback(agreement);\n    });\n  });\n};\n\n/**\n * Connects and handles the execution of prepared and simple statements. All parameters are mandatory.\n * @param {string} query\n * @param {Array} params\n * @param {ExecutionOptions} execOptions\n * @param {Function} callback\n * @private\n */\nClient.prototype._innerExecute = function (query, params, execOptions, callback) {\n  const version = this.controlConnection.protocolVersion;\n\n  if (!execOptions.isPrepared() && params && !util.isArray(params) && !types.protocolVersion.supportsNamedParameters(version)) {\n    // Only Cassandra 2.1 and above supports named parameters\n    return callback(\n      new errors.ArgumentError('Named parameters for simple statements are not supported, use prepare flag'));\n  }\n\n  let request;\n  utils.series([\n    next => this.connect(next),\n    next => {\n      if (!execOptions.isPrepared()) {\n        return this._createQueryRequest(query, execOptions, params, (err, r) => {\n          request = r;\n          next(err);\n        });\n      }\n\n      const lbp = execOptions.getLoadBalancingPolicy();\n      PrepareHandler.getPrepared(this, lbp, query, this.keyspace, (err, queryId, meta) => {\n        if (err) {\n          return next(err);\n        }\n        this._createExecuteRequest(query, queryId, execOptions, params, meta, (err, r) => {\n          request = r;\n          next(err);\n        });\n      });\n    },\n    next => RequestHandler.send(request, execOptions, this, next)\n  ], callback);\n};\n\n/**\n * Sets the listeners for the nodes.\n * @private\n */\nClient.prototype._setHostListeners = function () {\n  function getHostUpListener(emitter, h) {\n    return () => emitter.emit('hostUp', h);\n  }\n  function getHostDownListener(emitter, h) {\n    return () => emitter.emit('hostDown', h);\n  }\n  const self = this;\n  //Add status listeners when new nodes are added and emit hostAdd\n  this.hosts.on('add', function hostAddedListener(h) {\n    h.on('up', getHostUpListener(self, h));\n    h.on('down', getHostDownListener(self, h));\n    self.emit('hostAdd', h);\n  });\n  //Remove all listeners and emit hostRemove\n  this.hosts.on('remove', function hostRemovedListener(h) {\n    h.removeAllListeners();\n    self.emit('hostRemove', h);\n  });\n  //Add status listeners for existing hosts\n  this.hosts.forEach(function (h) {\n    h.on('up', getHostUpListener(self, h));\n    h.on('down', getHostDownListener(self, h));\n  });\n};\n\nClient.prototype._warmup = function (callback) {\n  const self = this;\n  const hosts = this.hosts.values();\n  utils.timesLimit(hosts.length, warmupLimit, function warmupEachCallback(i, next) {\n    const h = hosts[i];\n    const distance = self.profileManager.getDistance(h);\n    if (distance !== types.distance.local) {\n      //do not warmup pool for remote or ignored hosts\n      return next();\n    }\n    h.warmupPool(function (err) {\n      if (err) {\n        //An error while trying to create a connection\n        //To 1 host is not an issue, warn the user and move on\n        self.log('warning', util.format('Connection pool to host %s could not be created: %s', h.address, err));\n      }\n      next();\n    });\n  }, callback);\n};\n\n/**\n * @returns {Encoder}\n * @private\n */\nClient.prototype._getEncoder = function () {\n  const encoder = this.controlConnection.getEncoder();\n  if (!encoder) {\n    throw new errors.DriverInternalError('Encoder is not defined');\n  }\n  return encoder;\n};\n\n/**\n * Returns a BatchRequest instance and fills the routing key information in the provided options.\n * @private\n */\nClient.prototype._createBatchRequest = function (queryItems, info, callback) {\n  const firstQuery = queryItems[0];\n  if (!firstQuery.meta) {\n    return callback(null, new requests.BatchRequest(queryItems, info));\n  }\n\n  this._setRoutingInfo(info, firstQuery.params, firstQuery.meta, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new requests.BatchRequest(queryItems, info));\n  });\n};\n\n/**\n * Returns an ExecuteRequest instance and fills the routing key information in the provided options.\n * @private\n */\nClient.prototype._createExecuteRequest = function(query, queryId, info, params, meta, callback) {\n  try {\n    params = utils.adaptNamedParamsPrepared(params, meta.columns);\n  }\n  catch (err) {\n    return callback(err);\n  }\n\n  this._setRoutingInfo(info, params, meta, err => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new requests.ExecuteRequest(query, queryId, params, info, meta));\n  });\n};\n\n/**\n * Returns a QueryRequest instance and fills the routing key information in the provided options.\n * @private\n */\nClient.prototype._createQueryRequest = function (query, execOptions, params, callback) {\n  this.metadata.adaptUserHints(this.keyspace, execOptions.getHints(), (err) => {\n    if (err) {\n      return callback(err);\n    }\n\n    let paramsInfo;\n    try {\n      paramsInfo = utils.adaptNamedParamsWithHints(params, execOptions);\n      this._getEncoder().setRoutingKeyFromUser(paramsInfo.params, execOptions, paramsInfo.keyIndexes);\n    } catch (err) {\n      return callback(err);\n    }\n\n    callback(null, new requests.QueryRequest(query, paramsInfo.params, execOptions, paramsInfo.namedParameters));\n  });\n};\n\n/**\n * Sets the routing key based on the parameter values or the provided routing key components.\n * @param {ExecutionOptions} execOptions\n * @param {Array} params\n * @param meta\n * @param {Function} callback\n * @private\n */\nClient.prototype._setRoutingInfo = function (execOptions, params, meta, callback) {\n  const self = this;\n\n  /** Wrapper function as encoding a routing key could throw a TypeError */\n  function encodeRoutingKey(fromUser) {\n    const encoder = self._getEncoder();\n    try {\n      if (fromUser) {\n        encoder.setRoutingKeyFromUser(params, execOptions);\n      } else {\n        encoder.setRoutingKeyFromMeta(meta, params, execOptions);\n      }\n    }\n    catch (err) {\n      return callback(err);\n    }\n    callback();\n  }\n\n  if (!execOptions.getKeyspace() && meta.keyspace) {\n    execOptions.setKeyspace(meta.keyspace);\n  }\n  if (execOptions.getRoutingKey()) {\n    // Routing information provided by the user\n    return encodeRoutingKey(true);\n  }\n  if (Array.isArray(meta.partitionKeys)) {\n    // The partition keys are provided as part of the metadata for modern protocol versions\n    execOptions.setRoutingIndexes(meta.partitionKeys);\n    return encodeRoutingKey();\n  }\n\n  // Older versions of the protocol (v3 and below) don't provide routing information\n  this.metadata.getTable(meta.keyspace, meta.table, (err, tableInfo) => {\n    if (err) {\n      this.log('warning', util.format('Table %s.%s metadata could not be retrieved', meta.keyspace, meta.table));\n      return callback();\n    }\n    if (!tableInfo) {\n      // The schema data is not there, maybe it is being recreated, avoid setting the routing information\n      return callback();\n    }\n    execOptions.setRoutingIndexes(tableInfo.partitionKeys.map(c => meta.columnsByName[c.name]));\n    // Skip parsing metadata next time\n    meta.partitionKeys = execOptions.getRoutingIndexes();\n    encodeRoutingKey();\n  });\n};\n\n/**\n * Callback used by execution methods.\n * @callback ResultCallback\n * @param {Error} err Error occurred in the execution of the query.\n * @param {ResultSet} [result] Result of the execution of the query.\n */\n\nmodule.exports = Client;\n","'use strict';\n\nconst Stream = require('stream').Stream;\nconst utils = require('../utils');\n\n/**\n * Utilities for concurrent query execution with the DataStax Node.js Driver.\n * @module concurrent\n */\n\n/**\n * Executes multiple queries concurrently at the defined concurrency level.\n * @static\n * @param {Client} client The {@link Client} instance.\n * @param {String|Array<{query, params}>} query The query to execute per each parameter item.\n * @param {Array<Array>|Stream|Object} parameters An {@link Array} or a readable {@link Stream} composed of {@link Array}\n * items representing each individual set of parameters. Per each item in the {@link Array} or {@link Stream}, an\n * execution is going to be made.\n * @param {Object} [options] The execution options.\n * @param {String} [options.executionProfile] The execution profile to be used.\n * @param {Number} [options.concurrencyLevel=100] The concurrency level to determine the maximum amount of in-flight\n * operations at any given time\n * @param {Boolean} [options.raiseOnFirstError=true] Determines whether execution should stop after the first failed\n * execution and the corresponding exception will be raised.\n * @param {Boolean} [options.collectResults=false] Determines whether each individual\n * [ResultSet]{@link module:types~ResultSet} instance should be collected in the grouped result.\n * @param {Number} [options.maxErrors=100] The maximum amount of errors to be collected before ignoring the rest of\n * the error results.\n * @returns {Promise<ResultSetGroup>} A <code>Promise</code> of {@link ResultSetGroup} that is resolved when all the\n * executions completed and it's rejected when <code>raiseOnFirstError</code> is <code>true</code> and there is one\n * or more failures.\n * @example <caption>Using a fixed query and an Array of Arrays as parameters</caption>\n * const query = 'INSERT INTO table1 (id, value) VALUES (?, ?)';\n * const parameters = [[1, 'a'], [2, 'b'], [3, 'c'], ]; // ...\n * const result = await executeConcurrent(client, query, parameters);\n * @example <caption>Using a fixed query and a readable stream</caption>\n * const stream = csvStream.pipe(transformLineToArrayStream);\n * const result = await executeConcurrent(client, query, stream);\n * @example <caption>Using a different queries</caption>\n * const queryAndParameters = [\n *   { query: 'INSERT INTO videos (id, name, user_id) VALUES (?, ?, ?)',\n *     params: [ id, name, userId ] },\n *   { query: 'INSERT INTO user_videos (user_id, id, name) VALUES (?, ?, ?)',\n *     params: [ userId, id, name ] },\n *   { query: 'INSERT INTO latest_videos (id, name, user_id) VALUES (?, ?, ?)',\n *     params: [ id, name, userId ] },\n * ];\n *\n * const result = await executeConcurrent(client, queryAndParameters);\n */\nfunction executeConcurrent(client, query, parameters, options) {\n  if (!client) {\n    throw new TypeError('Client instance is not defined');\n  }\n\n  if (typeof query === 'string') {\n    if (Array.isArray(parameters)) {\n      return new ArrayBasedExecutor(client, query, parameters, options).execute();\n    }\n\n    if (parameters instanceof Stream) {\n      return new StreamBasedExecutor(client, query, parameters, options).execute();\n    }\n\n    throw new TypeError('parameters should be an Array or a Stream instance');\n  }\n\n  if (Array.isArray(query)) {\n    options = parameters;\n    return new ArrayBasedExecutor(client, null, query, options).execute();\n  }\n\n  throw new TypeError('A string query or query and parameters array should be provided');\n}\n\n/**\n * Wraps the functionality to execute given an Array.\n * @ignore\n */\nclass ArrayBasedExecutor {\n\n  /**\n   * @param {Client} client\n   * @param {String} query\n   * @param {Array<Array>|Array<{query, params}>} parameters\n   * @param {Object} [options] The execution options.\n   * @private\n   */\n  constructor(client, query, parameters, options) {\n    this._client = client;\n    this._query = query;\n    this._parameters = parameters;\n    options = options || utils.emptyObject;\n    this._raiseOnFirstError = options.raiseOnFirstError !== false;\n    this._concurrencyLevel = Math.min(options.concurrencyLevel || 100, this._parameters.length);\n    this._queryOptions = { prepare: true, executionProfile: options.executionProfile };\n    this._result = new ResultSetGroup(options);\n    this._stop = false;\n  }\n\n  execute() {\n    const promises = new Array(this._concurrencyLevel);\n\n    for (let i = 0; i < this._concurrencyLevel; i++) {\n      promises[i] = this._executeOneAtATime(i, 0);\n    }\n\n    return Promise.all(promises).then(() => this._result);\n  }\n\n  _executeOneAtATime(initialIndex, iteration) {\n    const index = initialIndex + this._concurrencyLevel * iteration;\n\n    if (index >= this._parameters.length || this._stop) {\n      return Promise.resolve();\n    }\n\n    const item = this._parameters[index];\n    let query;\n    let params;\n\n    if (this._query === null) {\n      query = item.query;\n      params = item.params;\n    } else {\n      query = this._query;\n      params = item;\n    }\n\n    return this._client.execute(query, params, this._queryOptions)\n      .then(rs => this._result.setResultItem(index, rs))\n      .catch(err => this._setError(index, err))\n      .then(() => this._executeOneAtATime(initialIndex, iteration + 1));\n  }\n\n  _setError(index, err) {\n    this._result.setError(index, err);\n\n    if (this._raiseOnFirstError) {\n      this._stop = true;\n      throw err;\n    }\n  }\n}\n\n/**\n * Wraps the functionality to execute given a Stream.\n * @ignore\n */\nclass StreamBasedExecutor {\n\n  /**\n   * @param {Client} client\n   * @param {String} query\n   * @param {Stream} stream\n   * @param {Object} [options] The execution options.\n   * @private\n   */\n  constructor(client, query, stream, options) {\n    this._client = client;\n    this._query = query;\n    this._stream = stream;\n    options = options || utils.emptyObject;\n    this._raiseOnFirstError = options.raiseOnFirstError !== false;\n    this._concurrencyLevel = options.concurrencyLevel || 100;\n    this._queryOptions = { prepare: true, executionProfile: options.executionProfile };\n    this._inFlight = 0;\n    this._index = 0;\n    this._result = new ResultSetGroup(options);\n    this._resolveCallback = null;\n    this._rejectCallback = null;\n    this._readEnded = false;\n  }\n\n  execute() {\n    return new Promise((resolve, reject) => {\n      this._resolveCallback = resolve;\n      this._rejectCallback = reject;\n\n      this._stream\n        .on('data', params => this._executeOne(params))\n        .on('error', err => this._setReadEnded(err))\n        .on('end', () => this._setReadEnded());\n    });\n  }\n\n  _executeOne(params) {\n    if (!Array.isArray(params)) {\n      return this._setReadEnded(new TypeError('Stream should be in objectMode and should emit Array instances'));\n    }\n\n    if (this._readEnded) {\n      // Read ended abruptly because of incorrect format or error event being emitted.\n      // We shouldn't consider additional items.\n      return;\n    }\n\n    const index = this._index++;\n    this._inFlight++;\n\n    this._client.execute(this._query, params, this._queryOptions)\n      .then(rs => {\n        this._result.setResultItem(index, rs);\n        this._inFlight--;\n      })\n      .catch(err => {\n        this._inFlight--;\n        this._setError(index, err);\n      })\n      .then(() => {\n        if (this._stream.isPaused()) {\n          this._stream.resume();\n        }\n\n        if (this._readEnded && this._inFlight === 0) {\n          // When read ended and there are no more in-flight requests\n          // We yield the result to the user.\n          // It could have ended prematurely when there is a read error\n          // or there was an execution error and raiseOnFirstError is true\n          // In that case, calling the resolve callback has no effect\n          this._resolveCallback(this._result);\n        }\n      });\n\n    if (this._inFlight >= this._concurrencyLevel) {\n      this._stream.pause();\n    }\n  }\n\n  /**\n   * Marks the stream read process as ended.\n   * @param {Error} [err] The stream read error.\n   * @private\n   */\n  _setReadEnded(err) {\n    if (!this._readEnded) {\n      this._readEnded = true;\n\n      if (err) {\n        // There was an error while reading from the input stream.\n        // This should be surfaced as a failure\n        this._rejectCallback(err);\n      } else if (this._inFlight === 0) {\n        // Ended signaled and there are no more pending messages.\n        this._resolveCallback(this._result);\n      }\n    }\n  }\n\n  _setError(index, err) {\n    this._result.setError(index, err);\n\n    if (this._raiseOnFirstError) {\n      this._readEnded = true;\n      this._rejectCallback(err);\n    }\n  }\n}\n\n/**\n * Represents results from different related executions.\n */\nclass ResultSetGroup {\n\n  /**\n   * Creates a new instance of {@link ResultSetGroup}.\n   * @ignore\n   */\n  constructor(options) {\n    this._collectResults = options.collectResults;\n    this._maxErrors = options.maxErrors || 100;\n    this.totalExecuted = 0;\n    this.errors = [];\n\n    if (this._collectResults) {\n      /**\n       * Gets an {@link Array} containing the [ResultSet]{@link module:types~ResultSet} instances from each execution.\n       * <p>\n       *   Note that when <code>collectResults</code> is set to <code>false</code>, accessing this property will\n       *   throw an error.\n       * </p>\n       * @type {Array}\n       */\n      this.resultItems = [];\n    } else {\n      Object.defineProperty(this, 'resultItems', { enumerable: false, get: () => {\n        throw new Error('Property resultItems can not be accessed when collectResults is set to false');\n      }});\n    }\n  }\n\n  /** @ignore */\n  setResultItem(index, rs) {\n    this.totalExecuted++;\n\n    if (this._collectResults) {\n      this.resultItems[index] = rs;\n    }\n  }\n\n  /**\n   * Internal method to set the error of an execution.\n   * @ignore\n   */\n  setError(index, err) {\n    this.totalExecuted++;\n\n    if (this.errors.length < this._maxErrors) {\n      this.errors.push(err);\n    }\n\n    if (this._collectResults) {\n      this.resultItems[index] = err;\n    }\n  }\n}\n\nexports.executeConcurrent = executeConcurrent;\nexports.ResultSetGroup = ResultSetGroup;","\"use strict\";\n\nconst events = require('events');\nconst util = require('util');\nconst tls = require('tls');\n\nconst Encoder = require('./encoder.js');\nconst WriteQueue = require('./writers').WriteQueue;\nconst requests = require('./requests');\nconst streams = require('./streams');\nconst utils = require('./utils');\nconst types = require('./types');\nconst errors = require('./errors');\nconst StreamIdStack = require('./stream-id-stack');\nconst OperationState = require('./operation-state');\nconst ExecutionOptions = require('./execution-options').ExecutionOptions;\n\n// Allow injection of net module\n// eslint-disable-next-line prefer-const\nlet net = require('net');\n\n/**\n * Represents a connection to a Cassandra node\n * @param {String} endpoint An string containing ip address and port of the host\n * @param {Number|null} protocolVersion\n * @param {ClientOptions} options\n * @extends EventEmitter\n * @constructor\n */\nfunction Connection(endpoint, protocolVersion, options) {\n  events.EventEmitter.call(this);\n  this.setMaxListeners(0);\n\n  if (!options) {\n    throw new Error('options is not defined');\n  }\n\n  /**\n   * Gets the ip and port of the server endpoint.\n   * @type {String}\n   */\n  this.endpoint = endpoint;\n\n  /**\n   * Gets the friendly name of the host, used to identify the connection in log messages.\n   * With direct connect, this is the address and port.\n   * @type {String}\n   */\n  this.endpointFriendlyName = endpoint;\n\n  if (!this.endpoint || this.endpoint.indexOf(':') < 0) {\n    throw new Error('EndPoint must contain the ip address and port separated by : symbol');\n  }\n\n  const portSeparatorIndex = this.endpoint.lastIndexOf(':');\n  this.address = this.endpoint.substr(0, portSeparatorIndex);\n  this.port = this.endpoint.substr(portSeparatorIndex + 1);\n\n  Object.defineProperty(this, \"options\", { value: options, enumerable: false, writable: false});\n\n  if (protocolVersion === null) {\n    // Set initial protocol version\n    protocolVersion = types.protocolVersion.maxSupported;\n    if (options.protocolOptions.maxVersion) {\n      // User provided the protocol version\n      protocolVersion = options.protocolOptions.maxVersion;\n    }\n    // Allow to check version using this connection instance\n    this._checkingVersion = true;\n  }\n\n  this.protocolVersion = protocolVersion;\n  /** @type {Object.<String, OperationState>} */\n  this._operations = {};\n  this._pendingWrites = [];\n  this._preparing = {};\n\n  /**\n   * The timeout state for the idle request (heartbeat)\n   */\n  this._idleTimeout = null;\n  this.timedOutOperations = 0;\n  this._streamIds = new StreamIdStack(this.protocolVersion);\n  this._metrics = options.metrics;\n\n  this.encoder = new Encoder(protocolVersion, options);\n  this.keyspace = null;\n  this.emitDrain = false;\n  /**\n   * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests / \n   * receive events\n   */\n  this.connected = false;\n  /**\n   * Determines if the socket can be considered as open\n   */\n  this.isSocketOpen = false;\n}\n\nutil.inherits(Connection, events.EventEmitter);\n\nConnection.prototype.log = utils.log;\n\n/**\n * Binds the necessary event listeners for the socket\n */\nConnection.prototype.bindSocketListeners = function() {\n  //Remove listeners that were used for connecting\n  this.netClient.removeAllListeners('connect');\n  this.netClient.removeAllListeners('timeout');\n  // The socket is expected to be open at this point\n  this.isSocketOpen = true;\n  this.netClient.on('close', () => {\n    this.log('info', `Connection to ${this.endpointFriendlyName} closed`);\n    this.isSocketOpen = false;\n    const wasConnected = this.connected;\n    this.close();\n    if (wasConnected) {\n      // Emit only when it was closed unexpectedly\n      this.emit('socketClose');\n    }\n  });\n\n  this.protocol = new streams.Protocol({ objectMode: true });\n  this.parser = new streams.Parser({ objectMode: true }, this.encoder);\n  const resultEmitter = new streams.ResultEmitter({objectMode: true});\n  resultEmitter.on('result', this.handleResult.bind(this));\n  resultEmitter.on('row', this.handleRow.bind(this));\n  resultEmitter.on('frameEnded', this.freeStreamId.bind(this));\n  resultEmitter.on('nodeEvent', this.handleNodeEvent.bind(this));\n\n  this.netClient\n    .pipe(this.protocol)\n    .pipe(this.parser)\n    .pipe(resultEmitter);\n\n  this.writeQueue = new WriteQueue(this.netClient, this.encoder, this.options);\n};\n\n/**\n * Connects a socket and sends the startup protocol messages.\n * Note that when open() callbacks in error, the caller should immediately call {@link Connection#close}.\n */\nConnection.prototype.open = function (callback) {\n  const self = this;\n  this.log('info', `Connecting to ${this.endpointFriendlyName}`);\n\n  if (!this.options.sslOptions) {\n    this.netClient = new net.Socket({ highWaterMark: this.options.socketOptions.coalescingThreshold });\n    this.netClient.connect(this.port, this.address, function connectCallback() {\n      self.log('verbose', `Socket connected to ${self.endpointFriendlyName}`);\n      self.bindSocketListeners();\n      self.startup(callback);\n    });\n  } else {\n    // Use TLS\n    const sslOptions = utils.extend({ rejectUnauthorized: false }, this.options.sslOptions);\n\n    this.netClient = tls.connect(this.port, this.address, sslOptions, function tlsConnectCallback() {\n      self.log('verbose', `Secure socket connected to ${self.endpointFriendlyName}`);\n      self.bindSocketListeners();\n      self.startup(callback);\n    });\n\n    // TLSSocket will validate for values from 512 to 16K (depending on the SSL protocol version)\n    this.netClient.setMaxSendFragment(this.options.socketOptions.coalescingThreshold);\n  }\n\n  this.netClient.once('error', function socketError(err) {\n    self.errorConnecting(err, false, callback);\n  });\n\n  this.netClient.once('timeout', function connectTimedOut() {\n    const err = new types.DriverError('Connection timeout');\n    self.errorConnecting(err, true, callback);\n  });\n\n  this.netClient.setTimeout(this.options.socketOptions.connectTimeout);\n\n  // Improve failure detection with TCP keep-alives\n  if (this.options.socketOptions.keepAlive) {\n    this.netClient.setKeepAlive(true, this.options.socketOptions.keepAliveDelay);\n  }\n\n  this.netClient.setNoDelay(!!this.options.socketOptions.tcpNoDelay);\n};\n\n/**\n * Determines the protocol version to use and sends the STARTUP request\n * @param {Function} callback\n */\nConnection.prototype.startup = function (callback) {\n  if (this._checkingVersion) {\n    this.log('info', 'Trying to use protocol version 0x' + this.protocolVersion.toString(16));\n  }\n\n  const self = this;\n  const request = new requests.StartupRequest({ noCompact: this.options.protocolOptions.noCompact });\n\n  this.sendStream(request, null, function responseCallback(err, response) {\n    if (err && self._checkingVersion) {\n      let invalidProtocol = (err instanceof errors.ResponseError &&\n        err.code === types.responseErrorCodes.protocolError &&\n        err.message.indexOf('Invalid or unsupported protocol version') >= 0);\n      if (!invalidProtocol && types.protocolVersion.canStartupResponseErrorBeWrapped(self.protocolVersion)) {\n        //For some versions of Cassandra, the error is wrapped into a server error\n        //See CASSANDRA-9451\n        invalidProtocol = (err instanceof errors.ResponseError &&\n          err.code === types.responseErrorCodes.serverError &&\n          err.message.indexOf('ProtocolException: Invalid or unsupported protocol version') > 0);\n      }\n      if (invalidProtocol) {\n        // The server can respond with a message using the lower protocol version supported\n        // or using the same version as the one provided\n        let lowerVersion = self.protocol.version;\n        if (lowerVersion === self.protocolVersion) {\n          lowerVersion = types.protocolVersion.getLowerSupported(self.protocolVersion);\n        }\n        if (!lowerVersion) {\n          return startupCallback(\n            new Error('Connection was unable to STARTUP using protocol version ' + self.protocolVersion));\n        }\n        self.log('info', 'Protocol 0x' + self.protocolVersion.toString(16) + ' not supported, using 0x' + lowerVersion.toString(16));\n        self.decreaseVersion(lowerVersion);\n        // The host closed the connection, close the socket and start the connection flow again\n        setImmediate(function decreasingVersionClosing() {\n          self.close(function decreasingVersionOpening() {\n            // Attempt to open with the correct protocol version\n            self.open(callback);\n          });\n        });\n        return;\n      }\n    }\n    if (response && response.mustAuthenticate) {\n      return self.startAuthenticating(response.authenticatorName, startupCallback);\n    }\n    startupCallback(err);\n  });\n\n  function startupCallback(err) {\n    if (err) {\n      return self.errorConnecting(err, false, callback);\n    }\n    //The socket is connected and the connection is authenticated\n    return self.connectionReady(callback);\n  }\n};\n\nConnection.prototype.errorConnecting = function (err, destroy, callback) {\n  this.log('warning', `There was an error when trying to connect to the host ${this.endpointFriendlyName}`, err);\n  if (destroy) {\n    //there is a TCP connection that should be killed.\n    this.netClient.destroy();\n  }\n\n  this._metrics.onConnectionError(err);\n\n  callback(err);\n};\n\n/**\n * Sets the connection to ready/connected status\n */\nConnection.prototype.connectionReady = function (callback) {\n  this.emit('connected');\n  this.connected = true;\n  // Remove existing error handlers as the connection is now ready.\n  this.netClient.removeAllListeners('error');\n  this.netClient.on('error', this.handleSocketError.bind(this));\n  callback();\n};\n\n/** @param {Number} lowerVersion */\nConnection.prototype.decreaseVersion = function (lowerVersion) {\n  // The response already has the max protocol version supported by the Cassandra host.\n  this.protocolVersion = lowerVersion;\n  this.encoder.setProtocolVersion(lowerVersion);\n  this._streamIds.setVersion(lowerVersion);\n};\n\n/**\n * Handle socket errors, if the socket is not readable invoke all pending callbacks\n */\nConnection.prototype.handleSocketError = function (err) {\n  this._metrics.onConnectionError(err);\n  this.clearAndInvokePending(err);\n};\n\n/**\n * Cleans all internal state and invokes all pending callbacks of sent streams\n */\nConnection.prototype.clearAndInvokePending = function (innerError) {\n  if (this._idleTimeout) {\n    //Remove the idle request\n    clearTimeout(this._idleTimeout);\n    this._idleTimeout = null;\n  }\n  this._streamIds.clear();\n  if (this.emitDrain) {\n    this.emit('drain');\n  }\n  const err = new types.DriverError('Socket was closed');\n  err.isSocketError = true;\n  if (innerError) {\n    err.innerError = innerError;\n  }\n\n  //copy all handlers\n  const operations = utils.objectValues(this._operations);\n\n  //remove it from the map\n  this._operations = {};\n  if (operations.length > 0) {\n    this.log('info', 'Invoking ' + operations.length + ' pending callbacks');\n  }\n\n  // Invoke all handlers\n  utils.each(operations, function (operation, next) {\n    operation.setResult(err);\n    next();\n  });\n\n  const pendingWritesCopy = this._pendingWrites;\n  this._pendingWrites = [];\n  utils.each(pendingWritesCopy, function (operation, next) {\n    operation.setResult(err);\n    next();\n  });\n};\n\n/**\n * Starts the SASL flow\n * @param {String} authenticatorName\n * @param {Function} callback\n */\nConnection.prototype.startAuthenticating = function (authenticatorName, callback) {\n  if (!this.options.authProvider) {\n    return callback(new errors.AuthenticationError('Authentication provider not set'));\n  }\n  const authenticator = this.options.authProvider.newAuthenticator(this.endpoint, authenticatorName);\n  const self = this;\n  authenticator.initialResponse(function initialResponseCallback(err, token) {\n    // Start the flow with the initial token\n    if (err) {\n      return self.onAuthenticationError(callback, err);\n    }\n    self.authenticate(authenticator, token, callback);\n  });\n};\n\n/**\n * Handles authentication requests and responses.\n * @param {Authenticator} authenticator\n * @param {Buffer} token\n * @param {Function} callback\n */\nConnection.prototype.authenticate = function(authenticator, token, callback) {\n  const self = this;\n  let request = new requests.AuthResponseRequest(token);\n  if (this.protocolVersion === 1) {\n    //No Sasl support, use CREDENTIALS\n    if (!authenticator.username) {\n      return self.onAuthenticationError(\n        callback, new errors.AuthenticationError('Only plain text authenticator providers allowed under protocol v1'));\n    }\n\n    request = new requests.CredentialsRequest(authenticator.username, authenticator.password);\n  }\n\n  this.sendStream(request, null, function authResponseCallback(err, result) {\n    if (err) {\n      if (err instanceof errors.ResponseError && err.code === types.responseErrorCodes.badCredentials) {\n        const authError = new errors.AuthenticationError(err.message);\n        authError.additionalInfo = err;\n        err = authError;\n      }\n      return self.onAuthenticationError(callback, err);\n    }\n\n    if (result.ready) {\n      authenticator.onAuthenticationSuccess();\n      return callback();\n    }\n\n    if (result.authChallenge) {\n      return authenticator.evaluateChallenge(result.token, function evaluateCallback(err, t) {\n        if (err) {\n          return self.onAuthenticationError(callback, err);\n        }\n        //here we go again\n        self.authenticate(authenticator, t, callback);\n      });\n    }\n\n    callback(new errors.DriverInternalError('Unexpected response from Cassandra: ' + util.inspect(result)));\n  });\n};\n\nConnection.prototype.onAuthenticationError = function(callback, err) {\n  this._metrics.onAuthenticationError(err);\n  callback(err);\n};\n\n/**\n * Executes a 'USE ' query, if keyspace is provided and it is different from the current keyspace\n * @param {?String} keyspace\n * @param {Function} callback\n */\nConnection.prototype.changeKeyspace = function (keyspace, callback) {\n  if (!keyspace || this.keyspace === keyspace) {\n    return callback();\n  }\n  this.once('keyspaceChanged', callback);\n  if (this.toBeKeyspace === keyspace) {\n    // It will be invoked once the keyspace is changed\n    return;\n  }\n  this.toBeKeyspace = keyspace;\n  const query = util.format('USE \"%s\"', keyspace);\n  const self = this;\n  this.sendStream(\n    new requests.QueryRequest(query, null, null),\n    null,\n    function changeKeyspaceResponseCallback(err) {\n      if (err) {\n        self.log('error', `Connection to ${self.endpointFriendlyName} could not switch active keyspace`, err);\n      }\n      else {\n        self.keyspace = keyspace;\n      }\n      self.toBeKeyspace = null;\n      self.emit('keyspaceChanged', err, keyspace);\n    });\n};\n\n/**\n * Prepares a query on a given connection. If its already being prepared, it queues the callback.\n * @param {String} query\n * @param {function} callback\n */\nConnection.prototype.prepareOnce = function (query, callback) {\n  const name = ( this.keyspace || '' ) + query;\n  let info = this._preparing[name];\n  if (this._preparing[name]) {\n    //Its being already prepared\n    return info.once('prepared', callback);\n  }\n  info = new events.EventEmitter();\n  info.setMaxListeners(0);\n  info.once('prepared', callback);\n  this._preparing[name] = info;\n  const self = this;\n  this.sendStream(new requests.PrepareRequest(query), null, function (err, response) {\n    info.emit('prepared', err, response);\n    delete self._preparing[name];\n  });\n};\n\n/**\n * Queues the operation to be written to the wire and invokes the callback once the response was obtained or with an\n * error (socket error or OperationTimedOutError or serialization-related error).\n * @param {Request} request\n * @param {ExecutionOptions|null} execOptions\n * @param {function} callback Function to be called once the response has been received\n * @return {OperationState}\n */\nConnection.prototype.sendStream = function (request, execOptions, callback) {\n  execOptions = execOptions || ExecutionOptions.empty();\n\n  // Create a new operation that will contain the request, callback and timeouts\n  const operation = new OperationState(request, execOptions.getRowCallback(), (err, response, length) => {\n    if (!err || !err.isSocketError) {\n      // Emit that a response was obtained when there is a valid response\n      // or when the error is not a socket error\n      this.emit('responseDequeued');\n    }\n    callback(err, response, length);\n  });\n\n  const streamId = this._getStreamId();\n\n  // Start the request timeout without waiting for the request to be written\n  operation.setRequestTimeout(execOptions, this.options.socketOptions.readTimeout, this.endpoint,\n    () => this.timedOutOperations++,\n    () => this.timedOutOperations--);\n\n  if (streamId === null) {\n    this.log('info',\n      'Enqueuing ' +\n      this._pendingWrites.length +\n      ', if this message is recurrent consider configuring more connections per host or lowering the pressure');\n    this._pendingWrites.push(operation);\n    return operation;\n  }\n  this._write(operation, streamId);\n  return operation;\n};\n\n/**\n * Pushes the item into the queue.\n * @param {OperationState} operation\n * @param {Number} streamId\n * @private\n */\nConnection.prototype._write = function (operation, streamId) {\n  operation.streamId = streamId;\n  const self = this;\n  this.writeQueue.push(operation, function writeCallback (err) {\n    if (err) {\n      // The request was not written.\n      // There was a serialization error or the operation has already timed out or was cancelled\n      self._streamIds.push(streamId);\n      return operation.setResult(err);\n    }\n    self.log('verbose', 'Sent stream #' + streamId + ' to ' + self.endpointFriendlyName);\n    if (operation.isByRow()) {\n      self.parser.setOptions(streamId, { byRow: true });\n    }\n    self._setIdleTimeout();\n    self._operations[streamId] = operation;\n  });\n};\n\nConnection.prototype._setIdleTimeout = function () {\n  if (!this.options.pooling.heartBeatInterval) {\n    return;\n  }\n  const self = this;\n  // Scheduling the new timeout before de-scheduling the previous performs significantly better\n  // than de-scheduling first, see nodejs implementation: https://github.com/nodejs/node/blob/master/lib/timers.js\n  const previousTimeout = this._idleTimeout;\n  self._idleTimeout = setTimeout(() => self._idleTimeoutHandler(), self.options.pooling.heartBeatInterval);\n  if (previousTimeout) {\n    //remove the previous timeout for the idle request\n    clearTimeout(previousTimeout);\n  }\n};\n\n/**\n * Function that gets executed once the idle timeout has passed to issue a request to keep the connection alive\n */\nConnection.prototype._idleTimeoutHandler = function () {\n  if (this.sendingIdleQuery) {\n    //don't issue another\n    //schedule for next time\n    this._idleTimeout = setTimeout(() => this._idleTimeoutHandler(), this.options.pooling.heartBeatInterval);\n    return;\n  }\n\n  this.log('verbose', `Connection to ${this.endpointFriendlyName} idling, issuing a request to prevent disconnects`);\n  this.sendingIdleQuery = true;\n  this.sendStream(requests.options, null, (err) => {\n    this.sendingIdleQuery = false;\n    if (!err) {\n      //The sending succeeded\n      //There is a valid response but we don't care about the response\n      return;\n    }\n    this.log('warning', 'Received heartbeat request error', err);\n    this.emit('idleRequestError', err, this);\n  });\n};\n\n/**\n * Returns an available streamId or null if there isn't any available\n * @returns {Number}\n */\nConnection.prototype._getStreamId = function() {\n  return this._streamIds.pop();\n};\n\nConnection.prototype.freeStreamId = function(header) {\n  const streamId = header.streamId;\n  if (streamId < 0) {\n    return;\n  }\n  delete this._operations[streamId];\n  this._streamIds.push(streamId);\n  if (this.emitDrain && this._streamIds.inUse === 0 && this._pendingWrites.length === 0) {\n    this.emit('drain');\n  }\n  this._writeNext();\n};\n\nConnection.prototype._writeNext = function () {\n  if (this._pendingWrites.length === 0) {\n    return;\n  }\n  const streamId = this._getStreamId();\n  if (streamId === null) {\n    // No streamId available\n    return;\n  }\n  const self = this;\n  let operation;\n  while ((operation = this._pendingWrites.shift()) && !operation.canBeWritten()) {\n    // Trying to obtain an pending operation that can be written\n  }\n\n  if (!operation) {\n    // There isn't a pending operation that can be written\n    this._streamIds.push(streamId);\n    return;\n  }\n\n  // Schedule after current I/O callbacks have been executed\n  setImmediate(function writeNextPending() {\n    self._write(operation, streamId);\n  });\n};\n\n/**\n * Returns the number of requests waiting for response\n * @returns {Number}\n */\nConnection.prototype.getInFlight = function () {\n  return this._streamIds.inUse;\n};\n\n/**\n * Handles a result and error response\n */\nConnection.prototype.handleResult = function (header, err, result) {\n  const streamId = header.streamId;\n  if(streamId < 0) {\n    return this.log('verbose', 'event received', header);\n  }\n  const operation = this._operations[streamId];\n  if (!operation) {\n    return this.log('error', 'The server replied with a wrong streamId #' + streamId);\n  }\n  this.log('verbose', 'Received frame #' + streamId + ' from ' + this.endpointFriendlyName);\n  operation.setResult(err, result, header.bodyLength);\n};\n\nConnection.prototype.handleNodeEvent = function (header, event) {\n  switch (event.eventType) {\n    case types.protocolEvents.schemaChange:\n      this.emit('nodeSchemaChange', event);\n      break;\n    case types.protocolEvents.topologyChange:\n      this.emit('nodeTopologyChange', event);\n      break;\n    case types.protocolEvents.statusChange:\n      this.emit('nodeStatusChange', event);\n      break;\n  }\n};\n\n/**\n * Handles a row response\n */\nConnection.prototype.handleRow = function (header, row, meta, rowLength, flags) {\n  const streamId = header.streamId;\n  if(streamId < 0) {\n    return this.log('verbose', 'Event received', header);\n  }\n  const operation = this._operations[streamId];\n  if (!operation) {\n    return this.log('error', 'The server replied with a wrong streamId #' + streamId);\n  }\n  operation.setResultRow(row, meta, rowLength, flags, header);\n};\n\n/**\n * Closes the socket (if not already closed) and cancels all in-flight requests.\n * Multiple calls to this method have no additional side-effects.\n * @param {Function} [callback]\n */\nConnection.prototype.close = function (callback) {\n  callback = callback || utils.noop;\n\n  if (!this.connected && !this.isSocketOpen) {\n    return callback();\n  }\n\n  this.connected = false;\n  // Drain is never going to be emitted, once it is set to closed\n  this.removeAllListeners('drain');\n  this.clearAndInvokePending();\n\n  if (!this.isSocketOpen) {\n    return callback();\n  }\n\n  // Set the socket as closed now (before socket.end() is called) to avoid being invoked more than once\n  this.isSocketOpen = false;\n  this.log('verbose', `Closing connection to ${this.endpointFriendlyName}`);\n  const self = this;\n\n  // If server doesn't acknowledge the half-close within connection timeout, destroy the socket.\n  const endTimeout = setTimeout(() => {\n    this.log('info', `${this.endpointFriendlyName} did not respond to connection close within ` +\n      `${this.options.socketOptions.connectTimeout}ms, destroying connection`);\n    this.netClient.destroy();\n  }, this.options.socketOptions.connectTimeout);\n\n  this.netClient.once('close', function (hadError) {\n    clearTimeout(endTimeout);\n    if (hadError) {\n      self.log('info', 'The socket closed with a transmission error');\n    }\n    setImmediate(callback);\n  });\n\n  // At this point, the error event can be triggered because:\n  // - It's connected and writes haven't completed yet\n  // - The server abruptly closed its end of the connection (ECONNRESET) as a result of protocol error / auth error\n  // We need to remove any listeners and make sure we callback are pending writes\n  this.netClient.removeAllListeners('error');\n  this.netClient.on('error', err => this.clearAndInvokePending(err));\n\n  // Half-close the socket, it will result in 'close' event being fired\n  this.netClient.end();\n};\n\n/**\n * Gets the local IP address to which this connection socket is bound to.\n * @returns {String|undefined}\n */\nConnection.prototype.getLocalAddress = function () {\n  if (!this.netClient) {\n    return undefined;\n  }\n\n  return this.netClient.localAddress;\n};\n\nmodule.exports = Connection;\n","\"use strict\";\nconst events = require('events');\nconst util = require('util');\nconst net = require('net');\n\nconst errors = require('./errors');\nconst Host = require('./host').Host;\nconst HostMap = require('./host').HostMap;\nconst Metadata = require('./metadata');\nconst EventDebouncer = require('./metadata/event-debouncer');\nconst Connection = require('./connection');\nconst requests = require('./requests');\nconst utils = require('./utils');\nconst types = require('./types');\nconst f = util.format;\n// eslint-disable-next-line prefer-const\nlet dns = require('dns');\n\nconst selectPeers = \"SELECT * FROM system.peers\";\nconst selectLocal = \"SELECT * FROM system.local WHERE key='local'\";\nconst newNodeDelay = 1000;\nconst metadataQueryAbortTimeout = 2000;\nconst schemaChangeTypes = {\n  created: 'CREATED',\n  updated: 'UPDATED',\n  dropped: 'DROPPED'\n};\n\n/**\n * Creates a new instance of <code>ControlConnection</code>.\n * @classdesc\n * Represents a connection used by the driver to receive events and to check the status of the cluster.\n * <p>It uses an existing connection from the hosts' connection pool to maintain the driver metadata up-to-date.</p>\n * @param {Object} options\n * @param {ProfileManager} profileManager\n * @param {{borrowHostConnection: function, createConnection: function}} [context] An object containing methods to\n * allow dependency injection.\n * @extends EventEmitter\n * @constructor\n */\nfunction ControlConnection(options, profileManager, context) {\n  this.protocolVersion = null;\n  this.hosts = new HostMap();\n  this.setMaxListeners(0);\n  Object.defineProperty(this, \"options\", { value: options, enumerable: false, writable: false});\n  /**\n   * Cluster metadata that is going to be shared between the Client and ControlConnection\n   */\n  this.metadata = new Metadata(this.options, this);\n  this.addressTranslator = this.options.policies.addressResolution;\n  this.reconnectionPolicy = this.options.policies.reconnection;\n  this.reconnectionSchedule = this.reconnectionPolicy.newSchedule();\n  this.initialized = false;\n  this.isShuttingDown = false;\n  /**\n   * Host used by the control connection\n   * @type {Host|null}\n   */\n  this.host = null;\n  /**\n   * Connection used to retrieve metadata and subscribed to events\n   * @type {Connection|null}\n   */\n  this.connection = null;\n  /**\n   * Reference to the encoder of the last valid connection\n   * @type {Encoder|null}\n   */\n  this.encoder = null;\n  this.debouncer = new EventDebouncer(options.refreshSchemaDelay, this.log.bind(this));\n  this.profileManager = profileManager;\n  /** Timeout used for delayed handling of topology changes */\n  this.topologyChangeTimeout = null;\n  /** Timeout used for delayed handling of node status changes */\n  this.nodeStatusChangeTimeout = null;\n  this.reconnectionTimeout = null;\n  this.hostIterator = null;\n  this.triedHosts = null;\n  this._resolvedContactPoints = new Map();\n  this._contactPoints = new Set();\n\n  if (context && context.borrowHostConnection) {\n    this.borrowHostConnection = context.borrowHostConnection;\n  }\n\n  if (context && context.createConnection) {\n    this.createConnection = context.createConnection;\n  }\n}\n\nutil.inherits(ControlConnection, events.EventEmitter);\n\n/**\n * Stores the contact point information and what it resolved to.\n * @param {String|null} address\n * @param {String} port\n * @param {String} name\n * @param {Boolean} isIPv6\n */\nControlConnection.prototype.addContactPoint = function(address, port, name, isIPv6) {\n  if (address === null) {\n    // Contact point could not be resolved, store that the resolution came back empty\n    this._resolvedContactPoints.set(name, utils.emptyArray);\n    return;\n  }\n\n  const portNumber = parseInt(port, 10) || this.options.protocolOptions.port;\n  const endpoint = `${address}:${portNumber}`;\n  this._contactPoints.add(endpoint);\n\n  // Use RFC 3986 for IPv4 and IPv6\n  const standardEndpoint = !isIPv6 ? endpoint : `[${address}]:${portNumber}`;\n\n  let resolvedAddressedByName = this._resolvedContactPoints.get(name);\n  if (resolvedAddressedByName === undefined) {\n    resolvedAddressedByName = [];\n    this._resolvedContactPoints.set(name, resolvedAddressedByName);\n  }\n\n  resolvedAddressedByName.push(standardEndpoint);\n};\n\nControlConnection.prototype.parseEachContactPoint = function(name, next) {\n  let addressOrName = name;\n  let port = null;\n\n  if (name.indexOf('[') === 0 && name.indexOf(']:') > 1) {\n    // IPv6 host notation [ip]:port (RFC 3986 section 3.2.2)\n    const index = name.lastIndexOf(']:');\n    addressOrName = name.substr(1, index - 1);\n    port = name.substr(index + 2);\n  } else if (name.indexOf(':') > 0) {\n    // IPv4 or host name with port notation\n    const parts = name.split(':');\n    if (parts.length === 2) {\n      addressOrName = parts[0];\n      port = parts[1];\n    }\n  }\n\n  if (net.isIP(addressOrName)) {\n    this.addContactPoint(addressOrName, port, name, net.isIPv6(addressOrName));\n    return next();\n  }\n\n  resolveAll(addressOrName, (err, addresses) => {\n    if (err) {\n      this.log('error', `Host with name ${addressOrName} could not be resolved`, err);\n      this.addContactPoint(null, null, name, false);\n      return next();\n    }\n\n    addresses.forEach(addressInfo => this.addContactPoint(addressInfo.address, port, name, addressInfo.isIPv6));\n\n    next();\n  });\n};\n\n/**\n * Tries to determine a suitable protocol version to be used.\n * Tries to retrieve the hosts in the Cluster.\n * @param {Function} callback\n */\nControlConnection.prototype.init = function (callback) {\n  if (this.initialized) {\n    // Prevent multiple serial initializations\n    return callback();\n  }\n\n  const contactPointsResolutionCb = (err) => {\n    if (!err && this._contactPoints.size === 0) {\n      err = new errors.NoHostAvailableError({}, 'No host could be resolved');\n    }\n\n    if (err) {\n      return callback(err);\n    }\n\n    this.refresh(false, err => {\n      this.initialized = !err;\n      callback(err);\n    });\n  };\n\n  utils.each(\n    this.options.contactPoints,\n    (name, eachNext) => this.parseEachContactPoint(name, eachNext),\n    contactPointsResolutionCb);\n};\n\nControlConnection.prototype.setHealthListeners = function (host, connection) {\n  const self = this;\n  let wasRefreshCalled = 0;\n\n  function removeListeners() {\n    host.removeListener('down', downOrIgnoredHandler);\n    host.removeListener('ignore', downOrIgnoredHandler);\n    connection.removeListener('socketClose', socketClosedHandler);\n  }\n\n  function startReconnecting(hostDown) {\n    if (wasRefreshCalled++ !== 0) {\n      // Prevent multiple calls to reconnect\n      return;\n    }\n\n    removeListeners();\n\n    if (self.isShuttingDown) {\n      // Don't attempt to reconnect when the ControlConnection is being shutdown\n      return;\n    }\n\n    if (hostDown) {\n      self.log('warning',\n        `Host ${host.address} used by the ControlConnection DOWN, ` +\n        `connection to ${connection.endpointFriendlyName} will not longer by used`);\n    } else {\n      self.log('warning', `Connection to ${connection.endpointFriendlyName} used by the ControlConnection was closed`);\n    }\n\n    self.refresh();\n  }\n\n  function downOrIgnoredHandler() {\n    startReconnecting(true);\n  }\n\n  function socketClosedHandler() {\n    startReconnecting(false);\n  }\n\n  host.once('down', downOrIgnoredHandler);\n  host.once('ignore', downOrIgnoredHandler);\n  connection.once('socketClose', socketClosedHandler);\n};\n\n/**\n * Iterates through the hostIterator and gets the following open connection.\n * @param callback\n */\nControlConnection.prototype.borrowAConnection = function (callback) {\n  const self = this;\n  let host;\n  let connection = null;\n\n  utils.whilst(\n    function condition() {\n      // while there isn't a valid connection\n      if (connection) {\n        return false;\n      }\n      const item = self.hostIterator.next();\n      host = item.value;\n      return (!item.done);\n    },\n    function whileIterator(next) {\n      if (self.initialized) {\n        // Only check distance once the load-balancing policies have been initialized\n        const distance = self.profileManager.getDistance(host);\n        if (!host.isUp() || distance === types.distance.ignored) {\n          return next();\n        }\n\n        self.borrowHostConnection(host, function (err, c) {\n          self.triedHosts[host.address] = err;\n          connection = c;\n          next();\n        });\n      } else {\n        // Host is an endpoint string\n        self.createConnection(host, (err, c) => {\n          self.triedHosts[host] = err;\n          connection = c;\n          next();\n        });\n      }\n    },\n    function whilstEnded() {\n      if (!connection) {\n        return callback(new errors.NoHostAvailableError(self.triedHosts));\n      }\n\n      if (!self.initialized) {\n        self.protocolVersion = connection.protocolVersion;\n        self.encoder = connection.encoder;\n      }\n\n      self.connection = connection;\n      callback();\n    });\n};\n\n/** Default implementation for borrowing connections, that can be injected at constructor level */\nControlConnection.prototype.borrowHostConnection = function (host, callback) {\n  // Borrow any open connection, regardless of the keyspace\n  host.borrowConnection(null, null, callback);\n};\n\n/**\n * Default implementation for creating initial connections, that can be injected at constructor level\n * @param {String} contactPoint\n * @param {Function} callback\n */\nControlConnection.prototype.createConnection = function (contactPoint, callback) {\n  const c = new Connection(contactPoint, null, this.options);\n  c.open(err => {\n    if (err) {\n      setImmediate(() => c.close());\n      return callback(err);\n    }\n\n    callback(null, c);\n  });\n};\n\n/**\n * Gets the info from local and peer metadata, reloads the keyspaces metadata and rebuilds tokens.\n * @param {Boolean} initializing Determines whether this function was called in order to initialize the control\n * connection the first time\n * @param {Boolean} setCurrentHost\n * @param {Function} [callback]\n */\nControlConnection.prototype.refreshHosts = function (initializing, setCurrentHost, callback) {\n  callback = callback || utils.noop;\n\n  // Get a reference to the current connection as it might change from external events\n  const c = this.connection;\n\n  if (!c) {\n    // it's possible that this was called as a result of a topology change, but the connection was lost\n    // between scheduling time and now. This will be called again when there is a new connection.\n    return callback();\n  }\n\n  const self = this;\n  this.log('info', 'Refreshing local and peers info');\n\n  utils.series([\n    function getLocalInfo(next) {\n      const request = new requests.QueryRequest(selectLocal, null, null);\n      c.sendStream(request, null, function (err, result) {\n        self.setLocalInfo(initializing, setCurrentHost, c, result);\n\n        if (!err && !self.host) {\n          return next(new errors.DriverInternalError('Information from system.local could not be retrieved'));\n        }\n\n        next(err);\n      });\n    },\n    function getPeersInfo(next) {\n      const request = new requests.QueryRequest(selectPeers, null, null);\n      c.sendStream(request, null, function (err, result) {\n        self.setPeersInfo(initializing, err, result, next);\n      });\n    },\n    function resolveAndSetProtocolVersion(next) {\n      if (!self.initialized) {\n        // resolve protocol version from highest common version among hosts.\n        const highestCommon = types.protocolVersion.getHighestCommon(c, self.hosts);\n        const reconnect = highestCommon !== self.protocolVersion;\n\n        // set protocol version on each host.\n        self.protocolVersion = highestCommon;\n        self.hosts.forEach(h => h.setProtocolVersion(self.protocolVersion));\n\n        // if protocol version changed, reconnect the control connection with new version.\n        if (reconnect) {\n          self.log('info', `Reconnecting since the protocol version changed to 0x${highestCommon.toString(16)}`);\n          c.decreaseVersion(self.protocolVersion);\n          c.close(() =>\n            setImmediate(() => c.open(err => {\n              if (err) {\n                c.close();\n              }\n\n              next(err);\n            })));\n          return;\n        }\n      }\n      next();\n    },\n    function getKeyspaces(next) {\n      // to acquire metadata we need to specify the cassandra version\n      self.metadata.setCassandraVersion(self.host.getCassandraVersion());\n      self.metadata.buildTokens(self.hosts);\n      if (!self.options.isMetadataSyncEnabled) {\n        self.metadata.initialized = true;\n        return next();\n      }\n      self.metadata._refreshKeyspaces(false, true, () => {\n        self.metadata.initialized = true;\n        next();\n      });\n    }\n  ], callback);\n};\n\n/**\n * Acquires a connection and refreshes topology and keyspace metadata.\n * <p>If it fails obtaining a connection:</p>\n * <ul>\n *   <li>\n *     When its initializing, it should:\n *     <ul>\n *       <li>Continue iterating through the hosts</li>\n *       <li>When there aren't any more hosts, it should invoke callback with the inner errors</li>\n *     </ul>\n *   </li>\n *   <li>\n *     When its running in the background, it should:\n *     <ul>\n *       <li>Continue iterating through the hosts</li>\n *       <li>\n *         When there aren't any more hosts, it should:\n *         <ul>\n *           <li>Schedule reconnection</li>\n *           <li>Invoke callback with the inner errors</li>\n *         </ul>\n *       </li>\n *     </ul>\n *   </li>\n * </ul>\n * <p>If it fails obtaining the metadata, it should:</p>\n * <ul>\n *   <li>It should mark connection and/or host unusable</li>\n *   <li>Retry using the same iterator from query plan / host list</li>\n * </ul>\n * @param {Boolean} [reuseQueryPlan]\n * @param {Function} [callback]\n */\nControlConnection.prototype.refresh = function (reuseQueryPlan, callback) {\n  const initializing = !this.initialized;\n  callback = callback || utils.noop;\n\n  if (this.isShuttingDown) {\n    this.log('info', 'The ControlConnection will not be refreshed as the Client is being shutdown');\n    return callback(new errors.NoHostAvailableError({}, 'ControlConnection is shutting down'));\n  }\n\n  // Reset host and connection\n  this.host = null;\n  this.connection = null;\n\n  const self = this;\n\n  utils.series([\n    function getHostIterator(next) {\n      if (reuseQueryPlan) {\n        return next();\n      }\n\n      self.triedHosts = {};\n\n      if (initializing) {\n        self.log('info', 'Getting first connection');\n        const hosts = Array.from(self._contactPoints);\n        // Randomize order of contact points resolved.\n        utils.shuffleArray(hosts);\n        self.hostIterator = hosts[Symbol.iterator]();\n        return next();\n      }\n\n      self.log('info', 'Trying to acquire a connection to a new host');\n\n      self.profileManager.getDefaultLoadBalancing().newQueryPlan(null, null, function onNewPlan(err, iterator) {\n        if (err) {\n          self.log('error', 'ControlConnection could not retrieve a query plan to determine which hosts to use', err);\n          return next(err);\n        }\n        self.hostIterator = iterator;\n        next();\n      });\n    },\n    function getConnectionTask(next) {\n      self.borrowAConnection(next);\n    },\n    function getLocalAndPeersInfo(next) {\n      self.log('info',\n        (initializing\n          ? `ControlConnection using protocol version 0x${self.protocolVersion.toString(16)},`\n          : `ControlConnection`) +\n        ` connected to ${self.connection.endpointFriendlyName}`);\n\n      self.refreshHosts(initializing, true, next);\n    },\n    function subscribeConnectionEvents(next) {\n      self.connection.on('nodeTopologyChange', self.nodeTopologyChangeHandler.bind(self));\n      self.connection.on('nodeStatusChange', self.nodeStatusChangeHandler.bind(self));\n      self.connection.on('nodeSchemaChange', self.nodeSchemaChangeHandler.bind(self));\n      const request = new requests.RegisterRequest(['TOPOLOGY_CHANGE', 'STATUS_CHANGE', 'SCHEMA_CHANGE']);\n      self.connection.sendStream(request, null, next);\n    }\n  ], function refreshSeriesEnd(err) {\n    // Refresh ended, possible scenarios:\n    // - There was a failure obtaining a connection\n    // - There was a failure in metadata retrieval\n    // - There wasn't a failure but connection is now disconnected at this time\n    // - Everything succeeded\n    if (!err) {\n      if (!self.connection.connected) {\n        // Before refreshSeriesEnd() was invoked, the connection changed to a \"not connected\" state.\n        // We have to avoid subscribing to 'down' or 'socketClosed' events after it was down / connection closed.\n        // The connection is no longer valid and we should retry the whole thing\n        self.log('info', f('Connection to %s was closed before finishing refresh', self.host.address));\n        return self.refresh(false, callback);\n      }\n\n      if (initializing) {\n        // The healthy connection used to initialize should be part of the Host pool\n        self.host.pool.addExistingConnection(self.connection);\n      }\n\n      self.setHealthListeners(self.host, self.connection);\n      self.reconnectionSchedule = self.reconnectionPolicy.newSchedule();\n      self.emit('newConnection', null, self.connection, self.host);\n      self.log('info', `ControlConnection connected to ${self.connection.endpointFriendlyName} and up to date`);\n\n      return callback();\n    }\n\n    if (!self.connection) {\n      self.log('error', 'ControlConnection failed to acquire a connection', err);\n      if (!initializing && !self.isShuttingDown) {\n        self.noOpenConnectionHandler();\n        self.emit('newConnection', err);\n      }\n\n      return callback(err);\n    }\n\n    self.log('error', 'ControlConnection failed to retrieve topology and keyspaces information', err);\n    self.triedHosts[self.connection.endpoint] = err;\n\n    if (err && err.isSocketError && !initializing && self.host) {\n      self.host.removeFromPool(self.connection);\n    }\n\n    // Retry the whole thing with the same query plan, in the background or foreground\n    self.refresh(true, callback);\n  });\n};\n\n/**\n * There isn't an open connection at the moment, try again later.\n */\nControlConnection.prototype.noOpenConnectionHandler = function () {\n  const delay = this.reconnectionSchedule.next().value;\n  this.log('warning', f('ControlConnection could not reconnect, scheduling reconnection in %dms', delay));\n  const self = this;\n  setTimeout(() => self.refresh(), delay);\n};\n\n/**\n * @param {String} type\n * @param {String} info\n * @param [furtherInfo]\n */\nControlConnection.prototype.log = utils.log;\n\n/**\n * Handles a TOPOLOGY_CHANGE event\n */\nControlConnection.prototype.nodeTopologyChangeHandler = function (event) {\n  this.log('info', 'Received topology change', event);\n  // all hosts information needs to be refreshed as tokens might have changed\n  const self = this;\n  clearTimeout(this.topologyChangeTimeout);\n  // Use an additional timer to make sure that the refresh hosts is executed only AFTER the delay\n  // In this case, the event debouncer doesn't help because it could not honor the sliding delay (ie: processNow)\n  this.topologyChangeTimeout = setTimeout(() => self.scheduleRefreshHosts(), newNodeDelay);\n};\n\n/**\n * Handles a STATUS_CHANGE event\n */\nControlConnection.prototype.nodeStatusChangeHandler = function (event) {\n  const self = this;\n  const addressToTranslate = event.inet.address.toString();\n  const port = this.options.protocolOptions.port;\n  this.addressTranslator.translate(addressToTranslate, port, function translateCallback(endPoint) {\n    const host = self.hosts.get(endPoint);\n    if (!host) {\n      self.log('warning', 'Received status change event but host was not found: ' + addressToTranslate);\n      return;\n    }\n    const distance = self.profileManager.getDistance(host);\n    if (event.up) {\n      if (distance === types.distance.ignored) {\n        return host.setUp(true);\n      }\n      clearTimeout(self.nodeStatusChangeTimeout);\n      // Waits a couple of seconds before marking it as UP\n      self.nodeStatusChangeTimeout = setTimeout(() => host.checkIsUp(), newNodeDelay);\n      return;\n    }\n    // marked as down\n    if (distance === types.distance.ignored) {\n      return host.setDown();\n    }\n    self.log('warning', 'Received status change to DOWN for host ' + host.address);\n  });\n};\n\n/**\n * Handles a SCHEMA_CHANGE event\n */\nControlConnection.prototype.nodeSchemaChangeHandler = function (event) {\n  this.log('info', 'Schema change', event);\n  if (!this.options.isMetadataSyncEnabled) {\n    return;\n  }\n  this.handleSchemaChange(event, false);\n};\n\n/**\n * @param {{keyspace: string, isKeyspace: boolean, schemaChangeType, table, udt, functionName, aggregate}} event\n * @param {Boolean} processNow\n * @param {Function} [callback]\n */\nControlConnection.prototype.handleSchemaChange = function (event, processNow, callback) {\n  const self = this;\n  let handler, cqlObject;\n  if (event.isKeyspace) {\n    if (event.schemaChangeType === schemaChangeTypes.dropped) {\n      handler = function removeKeyspace() {\n        // if on the same event queue there is a creation, this handler is not going to be executed\n        // it is safe to remove the keyspace metadata\n        delete self.metadata.keyspaces[event.keyspace];\n      };\n      return this.scheduleObjectRefresh(handler, event.keyspace, null, processNow, callback);\n    }\n    return this.scheduleKeyspaceRefresh(event.keyspace, processNow, callback);\n  }\n  const ksInfo = this.metadata.keyspaces[event.keyspace];\n  if (!ksInfo) {\n    // it hasn't been loaded and it is not part of the metadata, don't mind\n    return;\n  }\n  if (event.table) {\n    cqlObject = event.table;\n    handler = function clearTableState() {\n      delete ksInfo.tables[event.table];\n      delete ksInfo.views[event.table];\n    };\n  }\n  else if (event.udt) {\n    cqlObject = event.udt;\n    handler = function clearUdtState() {\n      delete ksInfo.udts[event.udt];\n    };\n  }\n  else if (event.functionName) {\n    cqlObject = event.functionName;\n    handler = function clearFunctionState() {\n      delete ksInfo.functions[event.functionName];\n    };\n  }\n  else if (event.aggregate) {\n    cqlObject = event.aggregate;\n    handler = function clearKeyspaceState() {\n      delete ksInfo.aggregates[event.aggregate];\n    };\n  }\n  if (handler) {\n    // is a cql object change clean the internal cache\n    this.scheduleObjectRefresh(handler, event.keyspace, cqlObject, processNow, callback);\n  }\n};\n\n/**\n * @param {Function} handler\n * @param {String} keyspaceName\n * @param {String} cqlObject\n * @param {Boolean} processNow\n * @param {Function} [callback]\n */\nControlConnection.prototype.scheduleObjectRefresh = function (handler, keyspaceName, cqlObject, processNow, callback) {\n  this.debouncer.eventReceived({ handler, keyspace: keyspaceName, cqlObject: cqlObject, callback }, processNow);\n};\n\n/**\n * @param {String} keyspaceName\n * @param {Boolean} processNow\n * @param {Function} [callback]\n */\nControlConnection.prototype.scheduleKeyspaceRefresh = function (keyspaceName, processNow, callback) {\n  this.debouncer.eventReceived({\n    handler: cb => this.metadata.refreshKeyspace(keyspaceName, cb),\n    keyspace: keyspaceName,\n    callback\n  }, processNow);\n};\n\n/**\n * @param {Function} [callback]\n */\nControlConnection.prototype.scheduleRefreshHosts = function (callback) {\n  this.debouncer.eventReceived({\n    handler: cb => this.refreshHosts(false, false, cb),\n    all: true,\n    callback\n  }, false);\n};\n\n/**\n * Sets the information for the host used by the control connection.\n * @param {Boolean} initializing\n * @param {Connection} c\n * @param {Boolean} setCurrentHost Determines if the host retrieved must be set as the current host\n * @param result\n */\nControlConnection.prototype.setLocalInfo = function (initializing, setCurrentHost, c, result) {\n  if (!result || !result.rows || !result.rows.length) {\n    this.log('warning', 'No local info could be obtained');\n    return;\n  }\n\n  const row = result.rows[0];\n\n  let localHost;\n\n  const endpoint = c.endpoint;\n\n  if (initializing) {\n    localHost = new Host(endpoint, this.protocolVersion, this.options, this.metadata);\n    this.hosts.set(endpoint, localHost);\n    this.log('info', `Adding host ${endpoint}`);\n  } else {\n    localHost = this.hosts.get(endpoint);\n\n    if (!localHost) {\n      this.log('error', 'Localhost could not be found');\n      return;\n    }\n  }\n\n  localHost.datacenter = row['data_center'];\n  localHost.rack = row['rack'];\n  localHost.tokens = row['tokens'];\n  localHost.hostId = row['host_id'];\n  localHost.cassandraVersion = row['release_version'];\n  this.metadata.setPartitioner(row['partitioner']);\n  this.log('info', 'Local info retrieved');\n\n  if (setCurrentHost) {\n    // Set the host as the one being used by the ControlConnection.\n    this.host = localHost;\n  }\n};\n\n/**\n * @param {Boolean} initializing Determines whether this function was called in order to initialize the control\n * connection the first time.\n * @param {Error} err\n * @param {ResultSet} result\n * @param {Function} callback\n */\nControlConnection.prototype.setPeersInfo = function (initializing, err, result, callback) {\n  if (!result || !result.rows || err) {\n    return callback(err);\n  }\n\n  // A map of peers, could useful for in case there are discrepancies\n  const peers = {};\n  const port = this.options.protocolOptions.port;\n  const foundDataCenters = new Set();\n\n  if (this.host && this.host.datacenter) {\n    foundDataCenters.add(this.host.datacenter);\n  }\n\n  const self = this;\n\n  utils.eachSeries(result.rows, function eachPeer(row, next) {\n    self.getAddressForPeerHost(row, port, function getAddressForPeerCallback(endPoint) {\n      if (!endPoint) {\n        return next();\n      }\n\n      peers[endPoint] = true;\n      let host = self.hosts.get(endPoint);\n      let isNewHost = !host;\n\n      if (isNewHost) {\n        host = new Host(endPoint, self.protocolVersion, self.options, self.metadata);\n        self.log('info', 'Adding host ' + endPoint);\n        isNewHost = true;\n      }\n\n      host.datacenter = row['data_center'];\n      host.rack = row['rack'];\n      host.tokens = row['tokens'];\n      host.hostId = row['host_id'];\n      host.cassandraVersion = row['release_version'];\n\n      if (host.datacenter) {\n        foundDataCenters.add(host.datacenter);\n      }\n\n      if (isNewHost) {\n        // Add it to the map (and trigger events) after all the properties\n        // were set to avoid race conditions\n        self.hosts.set(endPoint, host);\n\n        if (!initializing) {\n          // Set the distance at Host level, that way the connection pool is created with the correct settings\n          self.profileManager.getDistance(host);\n\n          // When we are not initializing, we start with the node set as DOWN\n          host.setDown();\n        }\n      }\n\n      next();\n    });\n  }, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    //Is there a difference in number between peers + local != hosts\n    if (self.hosts.length > result.rows.length + 1) {\n      //There are hosts in the current state that don't belong (nodes removed or wrong contactPoints)\n      self.log('info', 'Removing nodes from the pool');\n      const toRemove = [];\n      self.hosts.forEach(function (h) {\n        //It is not a peer and it is not local host\n        if (!peers[h.address] && h !== self.host) {\n          self.log('info', 'Removing host ' + h.address);\n          toRemove.push(h.address);\n          h.shutdown(true);\n        }\n      });\n      self.hosts.removeMultiple(toRemove);\n    }\n    if (initializing && self.options.localDataCenter) {\n      const localDc = self.options.localDataCenter;\n\n      if (!foundDataCenters.has(localDc)) {\n        return callback(new errors.ArgumentError('localDataCenter was configured as \\'' + localDc + '\\', but only found' +\n          ' hosts in data centers: [' + Array.from(foundDataCenters).join(', ') + ']'));\n      }\n    }\n    self.log('info', 'Peers info retrieved');\n    callback();\n  });\n};\n\n/**\n * @param {Object|Row} row\n * @param {Number} defaultPort\n * @param {Function} callback The callback to invoke with the string representation of the host endpoint,\n *  containing the ip address and port.\n */\nControlConnection.prototype.getAddressForPeerHost = function (row, defaultPort, callback) {\n  let address = row['rpc_address'];\n  const peer = row['peer'];\n  const bindAllAddress = '0.0.0.0';\n  if (!address) {\n    this.log('error', f('No rpc_address found for host %s in %s\\'s peers system table. %s will be ignored.',\n      peer, this.host.address, peer));\n    return callback(null);\n  }\n  if (address.toString() === bindAllAddress) {\n    this.log('warning', f('Found host with 0.0.0.0 as rpc_address, using listen_address (%s) to contact it instead.' +\n      ' If this is incorrect you should avoid the use of 0.0.0.0 server side.', peer));\n    address = peer;\n  }\n  this.addressTranslator.translate(address.toString(), defaultPort, callback);\n};\n\n/**\n * Waits for a connection to be available. If timeout expires before getting a connection it callbacks in error.\n * @param {Function} callback\n */\nControlConnection.prototype.waitForReconnection = function (callback) {\n  // eslint-disable-next-line prefer-const\n  let timeout;\n  const self = this;\n  function newConnectionListener(err) {\n    clearTimeout(timeout);\n    callback(err);\n  }\n  this.once('newConnection', newConnectionListener);\n  timeout = setTimeout(function waitTimeout() {\n    self.removeListener('newConnection', newConnectionListener);\n    callback(new errors.OperationTimedOutError('A connection could not be acquired before timeout.'));\n  }, metadataQueryAbortTimeout);\n};\n\n/**\n * Executes a query using the active connection\n * @param {String|Request} cqlQuery\n * @param {Boolean} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not\n * connected at the moment. Default: true.\n * @param {Function} callback\n */\nControlConnection.prototype.query = function (cqlQuery, waitReconnect, callback) {\n  if (typeof waitReconnect === 'function') {\n    callback = waitReconnect;\n    waitReconnect = true;\n  }\n\n  const self = this;\n\n  function queryOnConnection() {\n    if (!self.connection || self.isShuttingDown) {\n      return callback(new errors.NoHostAvailableError({}, 'ControlConnection is not connected at the time'));\n    }\n\n    const request = typeof cqlQuery === 'string' ? new requests.QueryRequest(cqlQuery, null, null) : cqlQuery;\n    self.connection.sendStream(request, null, callback);\n  }\n\n  if (!this.connection && waitReconnect) {\n    // Wait until its reconnected (or timer elapses)\n    return this.waitForReconnection(function waitCallback(err) {\n      if (err) {\n        //it was not able to reconnect in time\n        return callback(err);\n      }\n      queryOnConnection();\n    });\n  }\n\n  queryOnConnection();\n};\n\n/** @returns {Encoder} The encoder used by the current connection */\nControlConnection.prototype.getEncoder = function () {\n  if (!this.encoder) {\n    throw new errors.DriverInternalError('Encoder is not defined');\n  }\n  return this.encoder;\n};\n\nControlConnection.prototype.shutdown = function () {\n  // no need for callback as it all sync\n  this.isShuttingDown = true;\n  this.debouncer.shutdown();\n  // Emit a \"newConnection\" event with Error, as it may clear timeouts that were waiting new connections\n  this.emit('newConnection', new errors.DriverError('ControlConnection is being shutdown'));\n  // Cancel timers\n  clearTimeout(this.topologyChangeTimeout);\n  clearTimeout(this.nodeStatusChangeTimeout);\n  clearTimeout(this.reconnectionTimeout);\n};\n\n/**\n * Resets the Connection to its initial state.\n */\nControlConnection.prototype.reset = function (callback) {\n  // Reset the internal state of the ControlConnection for future initialization attempts\n  const currentHosts = this.hosts.clear();\n  // Set the shutting down flag temporarily to avoid reconnects.\n  this.isShuttingDown = true;\n  const self = this;\n  // Ignore any shutdown error\n  utils.each(currentHosts, (h, next) => h.shutdown(false, () => next()), function shuttingDownFinished() {\n    self.initialized = false;\n    self.isShuttingDown = false;\n    callback();\n  });\n};\n\n/**\n * Gets a Map containing the original contact points and the addresses that each one resolved to.\n */\nControlConnection.prototype.getResolvedContactPoints = function () {\n  return this._resolvedContactPoints;\n};\n\n/**\n * Gets the local IP address to which the control connection socket is bound to.\n * @returns {String|undefined}\n */\nControlConnection.prototype.getLocalAddress = function () {\n  if (!this.connection) {\n    return undefined;\n  }\n\n  return this.connection.getLocalAddress();\n};\n\n/**\n * Gets the address and port of host the control connection is connected to.\n * @returns {String|undefined}\n */\nControlConnection.prototype.getEndpoint = function () {\n  if (!this.connection) {\n    return undefined;\n  }\n\n  return this.connection.endpoint;\n};\n\n/**\n * Uses the DNS protocol to resolve a IPv4 and IPv6 addresses (A and AAAA records) for the hostname\n * @private\n * @param name\n * @param callback\n */\nfunction resolveAll(name, callback) {\n  const addresses = [];\n  utils.parallel([\n    function resolve4(next) {\n      dns.resolve4(name, function resolve4Callback(err, arr) {\n        if (arr) {\n          arr.forEach(address => addresses.push({ address, isIPv6: false }));\n        }\n        // Ignore error\n        next();\n      });\n    },\n    function resolve6(next) {\n      dns.resolve6(name, function resolve6Callback(err, arr) {\n        if (arr) {\n          arr.forEach(address => addresses.push({ address, isIPv6: true }));\n        }\n        // Ignore error\n        next();\n      });\n    }\n  ], function resolveAllCallback() {\n    if (addresses.length === 0) {\n      // In case dns.resolve*() methods don't yield a valid address for the host name\n      // Use system call getaddrinfo() that might resolve according to host system definitions\n      return dns.lookup(name, function (err, address, family) {\n        if (err) {\n          return callback(err);\n        }\n\n        addresses.push({ address, isIPv6: family === 6 });\n        callback(null, addresses);\n      });\n    }\n    callback(null, addresses);\n  });\n}\n\nmodule.exports = ControlConnection;\n","\"use strict\";\nconst util = require('util');\n\nconst types = require('./types');\nconst dataTypes = types.dataTypes;\nconst Long = types.Long;\nconst Integer = types.Integer;\nconst BigDecimal = types.BigDecimal;\nconst MutableLong = require('./types/mutable-long');\nconst utils = require('./utils');\nconst token = require('./token');\n\nconst uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\nconst buffers = {\n  int16Zero: utils.allocBufferFromArray([0, 0]),\n  int32Zero: utils.allocBufferFromArray([0, 0, 0, 0]),\n  int8Zero: utils.allocBufferFromArray([0]),\n  int8One: utils.allocBufferFromArray([1]),\n  int8MaxValue: utils.allocBufferFromArray([0xff])\n};\n\n// BigInt: Avoid using literals (e.g., 32n) as we must be able to compile with older engines\nconst isBigIntSupported = typeof BigInt !== 'undefined';\nconst bigInt32 = isBigIntSupported ? BigInt(32) : null;\nconst bigInt8 = isBigIntSupported ? BigInt(8) : null;\nconst bigInt0 = isBigIntSupported ? BigInt(0) : null;\nconst bigIntMinus1 = isBigIntSupported ? BigInt(-1) : null;\nconst bigInt32BitsOn = isBigIntSupported ? BigInt(0xffffffff) : null;\nconst bigInt8BitsOn = isBigIntSupported ? BigInt(0xff) : null;\n\nconst complexTypeNames = Object.freeze({\n  list      : 'org.apache.cassandra.db.marshal.ListType',\n  set       : 'org.apache.cassandra.db.marshal.SetType',\n  map       : 'org.apache.cassandra.db.marshal.MapType',\n  udt       : 'org.apache.cassandra.db.marshal.UserType',\n  tuple     : 'org.apache.cassandra.db.marshal.TupleType',\n  frozen    : 'org.apache.cassandra.db.marshal.FrozenType',\n  reversed  : 'org.apache.cassandra.db.marshal.ReversedType',\n  composite : 'org.apache.cassandra.db.marshal.CompositeType',\n  empty     : 'org.apache.cassandra.db.marshal.EmptyType',\n  collection: 'org.apache.cassandra.db.marshal.ColumnToCollectionType'\n});\nconst cqlNames = Object.freeze({\n  frozen: 'frozen',\n  list: 'list',\n  'set': 'set',\n  map: 'map',\n  tuple: 'tuple',\n  empty: 'empty',\n  duration: 'duration'\n});\nconst singleTypeNames = Object.freeze({\n  'org.apache.cassandra.db.marshal.UTF8Type':           dataTypes.varchar,\n  'org.apache.cassandra.db.marshal.AsciiType':          dataTypes.ascii,\n  'org.apache.cassandra.db.marshal.UUIDType':           dataTypes.uuid,\n  'org.apache.cassandra.db.marshal.TimeUUIDType':       dataTypes.timeuuid,\n  'org.apache.cassandra.db.marshal.Int32Type':          dataTypes.int,\n  'org.apache.cassandra.db.marshal.BytesType':          dataTypes.blob,\n  'org.apache.cassandra.db.marshal.FloatType':          dataTypes.float,\n  'org.apache.cassandra.db.marshal.DoubleType':         dataTypes.double,\n  'org.apache.cassandra.db.marshal.BooleanType':        dataTypes.boolean,\n  'org.apache.cassandra.db.marshal.InetAddressType':    dataTypes.inet,\n  'org.apache.cassandra.db.marshal.SimpleDateType':     dataTypes.date,\n  'org.apache.cassandra.db.marshal.TimeType':           dataTypes.time,\n  'org.apache.cassandra.db.marshal.ShortType':          dataTypes.smallint,\n  'org.apache.cassandra.db.marshal.ByteType':           dataTypes.tinyint,\n  'org.apache.cassandra.db.marshal.DateType':           dataTypes.timestamp,\n  'org.apache.cassandra.db.marshal.TimestampType':      dataTypes.timestamp,\n  'org.apache.cassandra.db.marshal.LongType':           dataTypes.bigint,\n  'org.apache.cassandra.db.marshal.DecimalType':        dataTypes.decimal,\n  'org.apache.cassandra.db.marshal.IntegerType':        dataTypes.varint,\n  'org.apache.cassandra.db.marshal.CounterColumnType':  dataTypes.counter\n});\nconst singleFqTypeNamesLength = Object.keys(singleTypeNames).reduce(function (previous, current) {\n  return current.length > previous ? current.length : previous;\n}, 0);\nconst durationTypeName = 'org.apache.cassandra.db.marshal.DurationType';\nconst nullValueBuffer = utils.allocBufferFromArray([255, 255, 255, 255]);\nconst unsetValueBuffer = utils.allocBufferFromArray([255, 255, 255, 254]);\n\n/**\n * For backwards compatibility, empty buffers as text/blob/custom values are supported.\n * In the case of other types, they are going to be decoded as a <code>null</code> value.\n * @type {Set}\n */\nconst zeroLengthTypesSupported = new Set([\n  dataTypes.text,\n  dataTypes.ascii,\n  dataTypes.varchar,\n  dataTypes.custom,\n  dataTypes.blob\n]);\n\n/**\n * Serializes and deserializes to and from a CQL type and a Javascript Type.\n * @param {Number} protocolVersion\n * @param {ClientOptions} options\n * @constructor\n */\nfunction Encoder(protocolVersion, options) {\n  this.encodingOptions = options.encoding || utils.emptyObject;\n  defineInstanceMembers.call(this);\n  this.setProtocolVersion(protocolVersion);\n  setEncoders.call(this);\n  if (this.encodingOptions.copyBuffer) {\n    this.handleBuffer = handleBufferCopy;\n  }\n  else {\n    this.handleBuffer = handleBufferRef;\n  }\n}\n\n/**\n * Declares the privileged instance members.\n * @private\n */\nfunction defineInstanceMembers() {\n  /**\n   * Sets the protocol version and the encoding/decoding methods depending on the protocol version\n   * @param {Number} value\n   * @ignore\n   * @internal\n   */\n  this.setProtocolVersion = function (value) {\n    this.protocolVersion = value;\n    //Set the collection serialization based on the protocol version\n    this.decodeCollectionLength = decodeCollectionLengthV3;\n    this.getLengthBuffer = getLengthBufferV3;\n    this.collectionLengthSize = 4;\n    if (!types.protocolVersion.uses4BytesCollectionLength(this.protocolVersion)) {\n      this.decodeCollectionLength = decodeCollectionLengthV2;\n      this.getLengthBuffer = getLengthBufferV2;\n      this.collectionLengthSize = 2;\n    }\n  };\n  const customDecoders = {};\n  const customEncoders = {};\n  // Decoding methods\n  this.decodeBlob = function (bytes) {\n    return this.handleBuffer(bytes);\n  };\n  this.decodeCustom = function (bytes, typeName) {\n    const handler = customDecoders[typeName];\n    if (handler) {\n      return handler.call(this, bytes);\n    }\n    return this.handleBuffer(bytes);\n  };\n  this.decodeDuration = function (bytes) {\n    return types.Duration.fromBuffer(bytes);\n  };\n  this.decodeUtf8String = function (bytes) {\n    return bytes.toString('utf8');\n  };\n  this.decodeAsciiString = function (bytes) {\n    return bytes.toString('ascii');\n  };\n  this.decodeBoolean = function (bytes) {\n    return !!bytes.readUInt8(0);\n  };\n  this.decodeDouble = function (bytes) {\n    return bytes.readDoubleBE(0);\n  };\n  this.decodeFloat = function (bytes) {\n    return bytes.readFloatBE(0);\n  };\n  this.decodeInt = function (bytes) {\n    return bytes.readInt32BE(0);\n  };\n  this.decodeSmallint = function (bytes) {\n    return bytes.readInt16BE(0);\n  };\n  this.decodeTinyint = function (bytes) {\n    return bytes.readInt8(0);\n  };\n\n  this._decodeCqlLongAsLong = function (bytes) {\n    return Long.fromBuffer(bytes);\n  };\n\n  this._decodeCqlLongAsBigInt = function (bytes) {\n    return BigInt.asIntN(64, (BigInt(bytes.readUInt32BE(0)) << bigInt32) | BigInt(bytes.readUInt32BE(4)));\n  };\n\n  this.decodeLong = this.encodingOptions.useBigIntAsLong\n    ? this._decodeCqlLongAsBigInt\n    : this._decodeCqlLongAsLong;\n\n  this._decodeVarintAsInteger = function (bytes) {\n    return Integer.fromBuffer(bytes);\n  };\n\n  this._decodeVarintAsBigInt = function decodeVarintAsBigInt(bytes) {\n    let result = bigInt0;\n    if (bytes[0] <= 0x7f) {\n      for (let i = 0; i < bytes.length; i++) {\n        const b = BigInt(bytes[bytes.length - 1 - i]);\n        result = result | (b << BigInt(i * 8));\n      }\n    } else {\n      for (let i = 0; i < bytes.length; i++) {\n        const b = BigInt(bytes[bytes.length - 1 - i]);\n        result = result | ((~b & bigInt8BitsOn) << BigInt(i * 8));\n      }\n      result = ~result;\n    }\n\n    return result;\n  };\n\n  this.decodeVarint = this.encodingOptions.useBigIntAsVarint\n    ? this._decodeVarintAsBigInt\n    : this._decodeVarintAsInteger;\n\n  this.decodeDecimal = function(bytes) {\n    return BigDecimal.fromBuffer(bytes);\n  };\n  this.decodeTimestamp = function(bytes) {\n    return new Date(this._decodeCqlLongAsLong(bytes).toNumber());\n  };\n  this.decodeDate = function (bytes) {\n    return types.LocalDate.fromBuffer(bytes);\n  };\n  this.decodeTime = function (bytes) {\n    return types.LocalTime.fromBuffer(bytes);\n  };\n  /*\n   * Reads a list from bytes\n   */\n  this.decodeList = function (bytes, subtype) {\n    const totalItems = this.decodeCollectionLength(bytes, 0);\n    let offset = this.collectionLengthSize;\n    const list = new Array(totalItems);\n    for (let i = 0; i < totalItems; i++) {\n      //bytes length of the item\n      const length = this.decodeCollectionLength(bytes, offset);\n      offset += this.collectionLengthSize;\n      //slice it\n      list[i] = this.decode(bytes.slice(offset, offset+length), subtype);\n      offset += length;\n    }\n    return list;\n  };\n  /*\n   * Reads a Set from bytes\n   */\n  this.decodeSet = function (bytes, subtype) {\n    const arr = this.decodeList(bytes, subtype);\n    if (this.encodingOptions.set) {\n      const setConstructor = this.encodingOptions.set;\n      return new setConstructor(arr);\n    }\n    return arr;\n  };\n  /*\n   * Reads a map (key / value) from bytes\n   */\n  this.decodeMap = function (bytes, subtypes) {\n    let map;\n    const totalItems = this.decodeCollectionLength(bytes, 0);\n    let offset = this.collectionLengthSize;\n    const self = this;\n    function readValues(callback, thisArg) {\n      for (let i = 0; i < totalItems; i++) {\n        const keyLength = self.decodeCollectionLength(bytes, offset);\n        offset += self.collectionLengthSize;\n        const key = self.decode(bytes.slice(offset, offset + keyLength), subtypes[0]);\n        offset += keyLength;\n        const valueLength = self.decodeCollectionLength(bytes, offset);\n        offset += self.collectionLengthSize;\n        if (valueLength < 0) {\n          callback.call(thisArg, key, null);\n          continue;\n        }\n        const value = self.decode(bytes.slice(offset, offset + valueLength), subtypes[1]);\n        offset += valueLength;\n        callback.call(thisArg, key, value);\n      }\n    }\n    if (this.encodingOptions.map) {\n      const mapConstructor = this.encodingOptions.map;\n      map = new mapConstructor();\n      readValues(map.set, map);\n    }\n    else {\n      map = {};\n      readValues(function (key, value) {\n        map[key] = value;\n      });\n    }\n    return map;\n  };\n  this.decodeUuid = function (bytes) {\n    return new types.Uuid(this.handleBuffer(bytes));\n  };\n  this.decodeTimeUuid = function (bytes) {\n    return new types.TimeUuid(this.handleBuffer(bytes));\n  };\n  this.decodeInet = function (bytes) {\n    return new types.InetAddress(this.handleBuffer(bytes));\n  };\n  /**\n   * Decodes a user defined type into an object\n   * @param {Buffer} bytes\n   * @param {{fields: Array}} udtInfo\n   * @private\n   */\n  this.decodeUdt = function (bytes, udtInfo) {\n    const result = {};\n    let offset = 0;\n    for (let i = 0; i < udtInfo.fields.length && offset < bytes.length; i++) {\n      //bytes length of the field value\n      const length = bytes.readInt32BE(offset);\n      offset += 4;\n      //slice it\n      const field = udtInfo.fields[i];\n      if (length < 0) {\n        result[field.name] = null;\n        continue;\n      }\n      result[field.name] = this.decode(bytes.slice(offset, offset+length), field.type);\n      offset += length;\n    }\n    return result;\n  };\n  this.decodeTuple = function (bytes, tupleInfo) {\n    const elements = new Array(tupleInfo.length);\n    let offset = 0;\n    for (let i = 0; i < tupleInfo.length; i++) {\n      const length = bytes.readInt32BE(offset);\n      offset += 4;\n      if (length < 0) {\n        elements[i] = null;\n        continue;\n      }\n      elements[i] = this.decode(bytes.slice(offset, offset+length), tupleInfo[i]);\n      offset += length;\n    }\n    return new types.Tuple(elements);\n  };\n  //Encoding methods\n  this.encodeFloat = function (value) {\n    if (typeof value !== 'number') {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    const buf = utils.allocBufferUnsafe(4);\n    buf.writeFloatBE(value, 0);\n    return buf;\n  };\n  this.encodeDouble = function (value) {\n    if (typeof value !== 'number') {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    const buf = utils.allocBufferUnsafe(8);\n    buf.writeDoubleBE(value, 0);\n    return buf;\n  };\n  /**\n   * @param {Date|String|Long|Number} value\n   * @private\n   */\n  this.encodeTimestamp = function (value) {\n    const originalValue = value;\n    if (typeof value === 'string') {\n      value = new Date(value);\n    }\n    if (value instanceof Date) {\n      //milliseconds since epoch\n      value = value.getTime();\n      if (isNaN(value)) {\n        throw new TypeError('Invalid date: ' + originalValue);\n      }\n    }\n    return this.encodeLong(value);\n  };\n  /**\n   * @param {Date|String|LocalDate} value\n   * @returns {Buffer}\n   * @throws {TypeError}\n   * @private\n   */\n  this.encodeDate = function (value) {\n    const originalValue = value;\n    try {\n      if (typeof value === 'string') {\n        value = types.LocalDate.fromString(value);\n      }\n      if (value instanceof Date) {\n        value = types.LocalDate.fromDate(value);\n      }\n    }\n    catch (err) {\n      //Wrap into a TypeError\n      throw new TypeError('LocalDate could not be parsed ' + err);\n    }\n    if (!(value instanceof types.LocalDate)) {\n      throw new TypeError('Expected Date/String/LocalDate, obtained ' + util.inspect(originalValue));\n    }\n    return value.toBuffer();\n  };\n  /**\n   * @param {String|LocalDate} value\n   * @returns {Buffer}\n   * @throws {TypeError}\n   * @private\n   */\n  this.encodeTime = function (value) {\n    const originalValue = value;\n    try {\n      if (typeof value === 'string') {\n        value = types.LocalTime.fromString(value);\n      }\n    }\n    catch (err) {\n      //Wrap into a TypeError\n      throw new TypeError('LocalTime could not be parsed ' + err);\n    }\n    if (!(value instanceof types.LocalTime)) {\n      throw new TypeError('Expected String/LocalTime, obtained ' + util.inspect(originalValue));\n    }\n    return value.toBuffer();\n  };\n  /**\n   * @param {Uuid|String|Buffer} value\n   * @private\n   */\n  this.encodeUuid = function (value) {\n    if (typeof value === 'string') {\n      try {\n        value = types.Uuid.fromString(value).getBuffer();\n      }\n      catch (err) {\n        throw new TypeError(err.message);\n      }\n    } else if (value instanceof types.Uuid) {\n      value = value.getBuffer();\n    } else {\n      throw new TypeError('Not a valid Uuid, expected Uuid/String/Buffer, obtained ' + util.inspect(value));\n    }\n\n    return value;\n  };\n  /**\n   * @param {String|InetAddress|Buffer} value\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeInet = function (value) {\n    if (typeof value === 'string') {\n      value = types.InetAddress.fromString(value);\n    }\n    if (value instanceof types.InetAddress) {\n      value = value.getBuffer();\n    }\n    if (!(value instanceof Buffer)) {\n      throw new TypeError('Not a valid Inet, expected InetAddress/Buffer, obtained ' + util.inspect(value));\n    }\n    return value;\n  };\n\n  /**\n   * @param {Long|Buffer|String|Number} value\n   * @private\n   */\n  this._encodeBigIntFromLong = function (value) {\n    if (typeof value === 'number') {\n      value = Long.fromNumber(value);\n    } else if (typeof value === 'string') {\n      value = Long.fromString(value);\n    }\n\n    let buf = null;\n\n    if (value instanceof Long) {\n      buf = Long.toBuffer(value);\n    } else if (value instanceof MutableLong) {\n      buf = Long.toBuffer(value.toImmutable());\n    }\n\n    if (buf === null) {\n      throw new TypeError('Not a valid bigint, expected Long/Number/String/Buffer, obtained ' + util.inspect(value));\n    }\n\n    return buf;\n  };\n\n  this._encodeBigIntFromBigInt = function (value) {\n    // eslint-disable-next-line valid-typeof\n    if (typeof value !== 'bigint') {\n      // Only BigInt values are supported\n      throw new TypeError('Not a valid BigInt value, obtained ' + util.inspect(value));\n    }\n\n    const buffer = utils.allocBufferUnsafe(8);\n    buffer.writeUInt32BE(Number(value >> bigInt32) >>> 0, 0);\n    buffer.writeUInt32BE(Number(value & bigInt32BitsOn), 4);\n    return buffer;\n  };\n\n  this.encodeLong = this.encodingOptions.useBigIntAsLong\n    ? this._encodeBigIntFromBigInt\n    : this._encodeBigIntFromLong;\n\n  /**\n   * @param {Integer|Buffer|String|Number} value\n   * @returns {Buffer}\n   * @private\n   */\n  this._encodeVarintFromInteger = function (value) {\n    if (typeof value === 'number') {\n      value = Integer.fromNumber(value);\n    }\n    if (typeof value === 'string') {\n      value = Integer.fromString(value);\n    }\n    let buf = null;\n    if (value instanceof Buffer) {\n      buf = value;\n    }\n    if (value instanceof Integer) {\n      buf = Integer.toBuffer(value);\n    }\n    if (buf === null) {\n      throw new TypeError('Not a valid varint, expected Integer/Number/String/Buffer, obtained ' + util.inspect(value));\n    }\n    return buf;\n  };\n\n  this._encodeVarintFromBigInt = function (value) {\n    // eslint-disable-next-line valid-typeof\n    if (typeof value !== 'bigint') {\n      throw new TypeError('Not a valid varint, expected BigInt, obtained ' + util.inspect(value));\n    }\n\n    if (value === bigInt0) {\n      return buffers.int8Zero;\n\n    }\n    else if (value === bigIntMinus1) {\n      return buffers.int8MaxValue;\n    }\n\n    const parts = [];\n\n    if (value > bigInt0){\n      while (value !== bigInt0) {\n        parts.unshift(Number(value & bigInt8BitsOn));\n        value = value >> bigInt8;\n      }\n\n      if (parts[0] > 0x7f) {\n        // Positive value needs a padding\n        parts.unshift(0);\n      }\n    } else {\n      while (value !== bigIntMinus1) {\n        parts.unshift(Number(value & bigInt8BitsOn));\n        value = value >> bigInt8;\n      }\n\n      if (parts[0] <= 0x7f) {\n        // Negative value needs a padding\n        parts.unshift(0xff);\n      }\n    }\n\n    return utils.allocBufferFromArray(parts);\n  };\n\n  this.encodeVarint = this.encodingOptions.useBigIntAsVarint\n    ? this._encodeVarintFromBigInt\n    : this._encodeVarintFromInteger;\n\n  /**\n   * @param {BigDecimal|Buffer|String|Number} value\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeDecimal = function (value) {\n    if (typeof value === 'number') {\n      value = BigDecimal.fromNumber(value);\n    } else if (typeof value === 'string') {\n      value = BigDecimal.fromString(value);\n    }\n\n    let buf = null;\n\n    if (value instanceof BigDecimal) {\n      buf = BigDecimal.toBuffer(value);\n    } else {\n      throw new TypeError('Not a valid varint, expected BigDecimal/Number/String/Buffer, obtained ' + util.inspect(value));\n    }\n\n    return buf;\n  };\n  this.encodeString = function (value, encoding) {\n    if (typeof value !== 'string') {\n      throw new TypeError('Not a valid text value, expected String obtained ' + util.inspect(value));\n    }\n    return utils.allocBufferFromString(value, encoding);\n  };\n  this.encodeUtf8String = function (value) {\n    return this.encodeString(value, 'utf8');\n  };\n  this.encodeAsciiString = function (value) {\n    return this.encodeString(value, 'ascii');\n  };\n  this.encodeBlob = function (value) {\n    if (!(value instanceof Buffer)) {\n      throw new TypeError('Not a valid blob, expected Buffer obtained ' + util.inspect(value));\n    }\n    return value;\n  };\n  this.encodeCustom = function (value, name) {\n    const handler = customEncoders[name];\n    if (handler) {\n      return handler.call(this, value);\n    }\n    throw new TypeError('No encoding handler found for type ' + name);\n  };\n  this.encodeDuration = function (value) {\n    if (!(value instanceof types.Duration)) {\n      throw new TypeError('Not a valid duration, expected Duration/Buffer obtained ' + util.inspect(value));\n    }\n    return value.toBuffer();\n  };\n  /**\n   * @param {Boolean} value\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeBoolean = function (value) {\n    return value ? buffers.int8One : buffers.int8Zero;\n  };\n  /**\n   * @param {Number|String} value\n   * @private\n   */\n  this.encodeInt = function (value) {\n    if (isNaN(value)) {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    const buf = utils.allocBufferUnsafe(4);\n    buf.writeInt32BE(value, 0);\n    return buf;\n  };\n  /**\n   * @param {Number|String} value\n   * @private\n   */\n  this.encodeSmallint = function (value) {\n    if (isNaN(value)) {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    const buf = utils.allocBufferUnsafe(2);\n    buf.writeInt16BE(value, 0);\n    return buf;\n  };\n  /**\n   * @param {Number|String} value\n   * @private\n   */\n  this.encodeTinyint = function (value) {\n    if (isNaN(value)) {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    const buf = utils.allocBufferUnsafe(1);\n    buf.writeInt8(value, 0);\n    return buf;\n  };\n  this.encodeList = function (value, subtype) {\n    if (!util.isArray(value)) {\n      throw new TypeError('Not a valid list value, expected Array obtained ' + util.inspect(value));\n    }\n    if (value.length === 0) {\n      return null;\n    }\n    const parts = [];\n    parts.push(this.getLengthBuffer(value));\n    for (let i = 0;i < value.length;i++) {\n      const val = value[i];\n      if (val === null || typeof val === 'undefined' || val === types.unset) {\n        throw new TypeError('A collection can\\'t contain null or unset values');\n      }\n      const bytes = this.encode(val, subtype);\n      //include item byte length\n      parts.push(this.getLengthBuffer(bytes));\n      //include item\n      parts.push(bytes);\n    }\n    return Buffer.concat(parts);\n  };\n  this.encodeSet = function (value, subtype) {\n    if (this.encodingOptions.set && value instanceof this.encodingOptions.set) {\n      const arr = [];\n      value.forEach(function (x) {\n        arr.push(x);\n      });\n      return this.encodeList(arr, subtype);\n    }\n    return this.encodeList(value, subtype);\n  };\n  /**\n   * Serializes a map into a Buffer\n   * @param value\n   * @param {Array} [subtypes]\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeMap = function (value, subtypes) {\n    const parts = [];\n    let propCounter = 0;\n    let keySubtype = null;\n    let valueSubtype = null;\n    const self = this;\n    if (subtypes) {\n      keySubtype = subtypes[0];\n      valueSubtype = subtypes[1];\n    }\n    function addItem(val, key) {\n      if (key === null || typeof key === 'undefined' || key === types.unset) {\n        throw new TypeError('A map can\\'t contain null or unset keys');\n      }\n      if (val === null || typeof val === 'undefined' || val === types.unset) {\n        throw new TypeError('A map can\\'t contain null or unset values');\n      }\n      const keyBuffer = self.encode(key, keySubtype);\n      //include item byte length\n      parts.push(self.getLengthBuffer(keyBuffer));\n      //include item\n      parts.push(keyBuffer);\n      //value\n      const valueBuffer = self.encode(val, valueSubtype);\n      //include item byte length\n      parts.push(self.getLengthBuffer(valueBuffer));\n      //include item\n      if (valueBuffer !== null) {\n        parts.push(valueBuffer);\n      }\n      propCounter++;\n    }\n    if (this.encodingOptions.map && value instanceof this.encodingOptions.map) {\n      //Use Map#forEach() method to iterate\n      value.forEach(addItem);\n    }\n    else {\n      //Use object\n      for (const key in value) {\n        if (!value.hasOwnProperty(key)) {\n          continue;\n        }\n        const val = value[key];\n        addItem(val, key);\n      }\n    }\n\n    parts.unshift(this.getLengthBuffer(propCounter));\n    return Buffer.concat(parts);\n  };\n  this.encodeUdt = function (value, udtInfo) {\n    const parts = [];\n    let totalLength = 0;\n    for (let i = 0; i < udtInfo.fields.length; i++) {\n      const field = udtInfo.fields[i];\n      const item = this.encode(value[field.name], field.type);\n      if (!item) {\n        parts.push(nullValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      if (item === types.unset) {\n        parts.push(unsetValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      const lengthBuffer = utils.allocBufferUnsafe(4);\n      lengthBuffer.writeInt32BE(item.length, 0);\n      parts.push(lengthBuffer);\n      parts.push(item);\n      totalLength += item.length + 4;\n    }\n    return Buffer.concat(parts, totalLength);\n  };\n  this.encodeTuple = function (value, tupleInfo) {\n    const parts = [];\n    let totalLength = 0;\n    for (let i = 0; i < tupleInfo.length; i++) {\n      const type = tupleInfo[i];\n      const item = this.encode(value.get(i), type);\n      if (!item) {\n        parts.push(nullValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      if (item === types.unset) {\n        parts.push(unsetValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      const lengthBuffer = utils.allocBufferUnsafe(4);\n      lengthBuffer.writeInt32BE(item.length, 0);\n      parts.push(lengthBuffer);\n      parts.push(item);\n      totalLength += item.length + 4;\n    }\n    return Buffer.concat(parts, totalLength);\n  };\n\n  /**\n   * If not provided, it uses the array of buffers or the parameters and hints to build the routingKey\n   * @param {Array} params\n   * @param {ExecutionOptions} execOptions\n   * @param [keys] parameter keys and positions in the params array\n   * @throws TypeError\n   * @internal\n   * @ignore\n   */\n  this.setRoutingKeyFromUser = function (params, execOptions, keys) {\n    let totalLength = 0;\n    const userRoutingKey = execOptions.getRoutingKey();\n    if (util.isArray(userRoutingKey)) {\n      if (userRoutingKey.length === 1) {\n        execOptions.setRoutingKey(userRoutingKey[0]);\n        return;\n      }\n\n      // Its a composite routing key\n      totalLength = 0;\n      for (let i = 0; i < userRoutingKey.length; i++) {\n        const item = userRoutingKey[i];\n        if (!item) {\n          // Invalid routing key part provided by the user, clear the value\n          execOptions.setRoutingKey(null);\n          return;\n        }\n        totalLength += item.length + 3;\n      }\n\n      execOptions.setRoutingKey(concatRoutingKey(userRoutingKey, totalLength));\n      return;\n    }\n    // If routingKey is present, ensure it is a Buffer, Token, or TokenRange.  Otherwise throw an error.\n    if (userRoutingKey) {\n      if (userRoutingKey instanceof Buffer || userRoutingKey instanceof token.Token\n        || userRoutingKey instanceof token.TokenRange) {\n        return;\n      }\n\n      throw new TypeError(`Unexpected routingKey '${util.inspect(userRoutingKey)}' provided. ` +\n        `Expected Buffer, Array<Buffer>, Token, or TokenRange.`);\n    }\n\n    // If no params are present, return as routing key cannot be determined.\n    if (!params || params.length === 0) {\n      return;\n    }\n\n    let routingIndexes = execOptions.getRoutingIndexes();\n    if (execOptions.getRoutingNames()) {\n      routingIndexes = execOptions.getRoutingNames().map(k => keys[k]);\n    }\n    if (!routingIndexes) {\n      return;\n    }\n\n    const parts = [];\n    const hints = execOptions.getHints() || utils.emptyArray;\n\n    const encodeParam = !keys ?\n      (i => this.encode(params[i], hints[i])) :\n      (i => this.encode(params[i].value, hints[i]));\n\n    try {\n      totalLength = this._encodeRoutingKeyParts(parts, routingIndexes, encodeParam);\n    } catch (e) {\n      // There was an error encoding a parameter that is part of the routing key,\n      // ignore now to fail afterwards\n    }\n\n    if (totalLength === 0) {\n      return;\n    }\n\n    execOptions.setRoutingKey(concatRoutingKey(parts, totalLength));\n  };\n\n  /**\n   * Sets the routing key in the options based on the prepared statement metadata.\n   * @param {Object} meta Prepared metadata\n   * @param {Array} params Array of parameters\n   * @param {ExecutionOptions} execOptions\n   * @throws TypeError\n   * @internal\n   * @ignore\n   */\n  this.setRoutingKeyFromMeta = function (meta, params, execOptions) {\n    const routingIndexes = execOptions.getRoutingIndexes();\n    if (!routingIndexes) {\n      return;\n    }\n    const parts = new Array(routingIndexes.length);\n    const encodeParam = i => {\n      const columnInfo = meta.columns[i];\n      return this.encode(params[i], columnInfo ? columnInfo.type : null);\n    };\n\n    let totalLength = 0;\n\n    try {\n      totalLength = this._encodeRoutingKeyParts(parts, routingIndexes, encodeParam);\n    } catch (e) {\n      // There was an error encoding a parameter that is part of the routing key,\n      // ignore now to fail afterwards\n    }\n\n    if (totalLength === 0) {\n      return;\n    }\n\n    execOptions.setRoutingKey(concatRoutingKey(parts, totalLength));\n  };\n\n  /**\n   * @param {Array} parts\n   * @param {Array} routingIndexes\n   * @param {Function} encodeParam\n   * @returns {Number} The total length\n   * @private\n   */\n  this._encodeRoutingKeyParts = function (parts, routingIndexes, encodeParam) {\n    let totalLength = 0;\n    for (let i = 0; i < routingIndexes.length; i++) {\n      const paramIndex = routingIndexes[i];\n      if (paramIndex === undefined) {\n        // Bad input from the user, ignore\n        return 0;\n      }\n\n      const item = encodeParam(paramIndex);\n      if (item === null || item === undefined || item === types.unset) {\n        // The encoded partition key should an instance of Buffer\n        // Let it fail later in the pipeline for null/undefined parameter values\n        return 0;\n      }\n\n      // Per each part of the routing key, 3 extra bytes are needed\n      totalLength += item.length + 3;\n      parts[i] = item;\n    }\n    return totalLength;\n  };\n\n  /**\n   * Parses a CQL name string into data type information\n   * @param {String} keyspace\n   * @param {String} typeName\n   * @param {Number} startIndex\n   * @param {Number|null} length\n   * @param {Function} udtResolver\n   * @param {Function} callback Callback invoked with err and  {{code: number, info: Object|Array|null, options: {frozen: Boolean}}}\n   * @internal\n   * @ignore\n   */\n  this.parseTypeName = function (keyspace, typeName, startIndex, length, udtResolver, callback) {\n    startIndex = startIndex || 0;\n    if (!length) {\n      length = typeName.length;\n    }\n    const dataType = {\n      code: 0,\n      info: null,\n      options: {\n        frozen: false\n      }\n    };\n    let innerTypes;\n    if (typeName.indexOf(\"'\", startIndex) === startIndex) {\n      //If quoted, this is a custom type.\n      dataType.info = typeName.substr(startIndex+1, length-2);\n      return callback(null, dataType);\n    }\n    if (!length) {\n      length = typeName.length;\n    }\n    if (typeName.indexOf(cqlNames.frozen, startIndex) === startIndex) {\n      //Remove the frozen token\n      startIndex += cqlNames.frozen.length + 1;\n      length -= cqlNames.frozen.length + 2;\n      dataType.options.frozen = true;\n    }\n    if (typeName.indexOf(cqlNames.list, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.list.length + 1;\n      length -= cqlNames.list.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      if (innerTypes.length !== 1) {\n        return callback(new TypeError('Not a valid type ' + typeName));\n      }\n      dataType.code = dataTypes.list;\n      return this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver, function (err, childType) {\n        if (err) {\n          return callback(err);\n        }\n        dataType.info = childType;\n        callback(null, dataType);\n      });\n    }\n    if (typeName.indexOf(cqlNames.set, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.set.length + 1;\n      length -= cqlNames.set.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      if (innerTypes.length !== 1) {\n        return callback(new TypeError('Not a valid type ' + typeName));\n      }\n      dataType.code = dataTypes.set;\n      return this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver, function (err, childType) {\n        if (err) {\n          return callback(err);\n        }\n        dataType.info = childType;\n        callback(null, dataType);\n      });\n    }\n    if (typeName.indexOf(cqlNames.map, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.map.length + 1;\n      length -= cqlNames.map.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      //It should contain the key and value types\n      if (innerTypes.length !== 2) {\n        return callback(new TypeError('Not a valid type ' + typeName));\n      }\n      dataType.code = dataTypes.map;\n      return this._parseChildTypes(keyspace, dataType, innerTypes, udtResolver, callback);\n    }\n    if (typeName.indexOf(cqlNames.tuple, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.tuple.length + 1;\n      length -= cqlNames.tuple.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      if (innerTypes.length < 1) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.tuple;\n      return this._parseChildTypes(keyspace, dataType, innerTypes, udtResolver, callback);\n    }\n    const quoted = typeName.indexOf('\"', startIndex) === startIndex;\n    if (quoted) {\n      //Remove quotes\n      startIndex++;\n      length -= 2;\n    }\n    //Quick check if its a single type\n    if (startIndex > 0) {\n      typeName = typeName.substr(startIndex, length);\n    }\n    // Un-escape double quotes if quoted.\n    if (quoted) {\n      typeName = typeName.replace('\"\"', '\"');\n    }\n    const typeCode = dataTypes[typeName];\n    if (typeof typeCode === 'number') {\n      dataType.code = typeCode;\n      return callback(null, dataType);\n    }\n    if (typeName === cqlNames.duration) {\n      dataType.info = durationTypeName;\n      return callback(null, dataType);\n    }\n    if (typeName === cqlNames.empty) {\n      //set as custom\n      dataType.info = 'empty';\n      return callback(null, dataType);\n    }\n    udtResolver(keyspace, typeName, function (err, udtInfo) {\n      if (err) {\n        return callback(err);\n      }\n      if (udtInfo) {\n        dataType.code = dataTypes.udt;\n        dataType.info = udtInfo;\n        return callback(null, dataType);\n      }\n      callback(new TypeError('Not a valid type \"' + typeName + '\"'));\n    });\n  };\n  /**\n   * @param {String} keyspace\n   * @param dataType\n   * @param {Array} typeNames\n   * @param {Function} udtResolver\n   * @param {Function} callback\n   * @private\n   */\n  this._parseChildTypes = function (keyspace, dataType, typeNames, udtResolver, callback) {\n    const self = this;\n    utils.mapSeries(typeNames, function (name, next) {\n      self.parseTypeName(keyspace, name.trim(), 0, null, udtResolver, next);\n    }, function (err, childTypes) {\n      if (err) {\n        return callback(err);\n      }\n      dataType.info = childTypes;\n      callback(null, dataType);\n    });\n  };\n\n  /**\n   * Parses a Cassandra fully-qualified class name string into data type information\n   * @param {String} typeName\n   * @param {Number} [startIndex]\n   * @param {Number} [length]\n   * @throws TypeError\n   * @returns {{code: number, info: Object|Array|null, options: {frozen: Boolean, reversed: Boolean}}}\n   * @internal\n   * @ignore\n   */\n  this.parseFqTypeName = function (typeName, startIndex, length) {\n    const dataType = {\n      code: 0,\n      info: null,\n      options: {\n        reversed: false,\n        frozen: false\n      }\n    };\n    startIndex = startIndex || 0;\n    let innerTypes;\n    if (!length) {\n      length = typeName.length;\n    }\n    if (length > complexTypeNames.reversed.length && typeName.indexOf(complexTypeNames.reversed) === startIndex) {\n      //Remove the reversed token\n      startIndex += complexTypeNames.reversed.length + 1;\n      length -= complexTypeNames.reversed.length + 2;\n      dataType.options.reversed = true;\n    }\n    if (length > complexTypeNames.frozen.length &&\n        typeName.indexOf(complexTypeNames.frozen, startIndex) === startIndex) {\n      //Remove the frozen token\n      startIndex += complexTypeNames.frozen.length + 1;\n      length -= complexTypeNames.frozen.length + 2;\n      dataType.options.frozen = true;\n    }\n    if (typeName === complexTypeNames.empty) {\n      //set as custom\n      dataType.info = 'empty';\n      return dataType;\n    }\n    //Quick check if its a single type\n    if (length <= singleFqTypeNamesLength) {\n      if (startIndex > 0) {\n        typeName = typeName.substr(startIndex, length);\n      }\n      const typeCode = singleTypeNames[typeName];\n      if (typeof typeCode === 'number') {\n        dataType.code = typeCode;\n        return dataType;\n      }\n      throw new TypeError('Not a valid type \"' + typeName + '\"');\n    }\n    if (typeName.indexOf(complexTypeNames.list, startIndex) === startIndex) {\n      //Its a list\n      //org.apache.cassandra.db.marshal.ListType(innerType)\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.list.length + 1;\n      length -= complexTypeNames.list.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      if (innerTypes.length !== 1) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.list;\n      dataType.info = this.parseFqTypeName(innerTypes[0]);\n      return dataType;\n    }\n    if (typeName.indexOf(complexTypeNames.set, startIndex) === startIndex) {\n      //Its a set\n      //org.apache.cassandra.db.marshal.SetType(innerType)\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.set.length + 1;\n      length -= complexTypeNames.set.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      if (innerTypes.length !== 1)\n      {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.set;\n      dataType.info = this.parseFqTypeName(innerTypes[0]);\n      return dataType;\n    }\n    if (typeName.indexOf(complexTypeNames.map, startIndex) === startIndex) {\n      //org.apache.cassandra.db.marshal.MapType(keyType,valueType)\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.map.length + 1;\n      length -= complexTypeNames.map.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      //It should contain the key and value types\n      if (innerTypes.length !== 2) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.map;\n      dataType.info = [this.parseFqTypeName(innerTypes[0]), this.parseFqTypeName(innerTypes[1])];\n      return dataType;\n    }\n    if (typeName.indexOf(complexTypeNames.udt, startIndex) === startIndex) {\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.udt.length + 1;\n      length -= complexTypeNames.udt.length + 2;\n      return this._parseUdtName(typeName, startIndex, length);\n    }\n    if (typeName.indexOf(complexTypeNames.tuple, startIndex) === startIndex) {\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.tuple.length + 1;\n      length -= complexTypeNames.tuple.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      if (innerTypes.length < 1) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.tuple;\n      dataType.info = innerTypes.map(x => this.parseFqTypeName(x));\n      return dataType;\n    }\n\n    // Assume custom type if cannot be parsed up to this point.\n    dataType.info = typeName.substr(startIndex, length);\n    return dataType;\n  };\n  /**\n   * Parses type names with composites\n   * @param {String} typesString\n   * @returns {{types: Array, isComposite: Boolean, hasCollections: Boolean}}\n   * @internal\n   * @ignore\n   */\n  this.parseKeyTypes = function (typesString) {\n    let i = 0;\n    let length = typesString.length;\n    const isComposite = typesString.indexOf(complexTypeNames.composite) === 0;\n    if (isComposite) {\n      i = complexTypeNames.composite.length + 1;\n      length--;\n    }\n    const types = [];\n    let startIndex = i;\n    let nested = 0;\n    let inCollectionType = false;\n    let hasCollections = false;\n    //as collection types are not allowed, it is safe to split by ,\n    while (++i < length) {\n      switch (typesString[i]) {\n        case ',':\n          if (nested > 0) {\n            break;\n          }\n          if (inCollectionType) {\n            //remove type id\n            startIndex = typesString.indexOf(':', startIndex) + 1;\n          }\n          types.push(typesString.substring(startIndex, i));\n          startIndex = i + 1;\n          break;\n        case '(':\n          if (nested === 0 && typesString.indexOf(complexTypeNames.collection, startIndex) === startIndex) {\n            inCollectionType = true;\n            hasCollections = true;\n            //skip collection type\n            i++;\n            startIndex = i;\n            break;\n          }\n          nested++;\n          break;\n        case ')':\n          if (inCollectionType && nested === 0){\n            types.push(typesString.substring(typesString.indexOf(':', startIndex) + 1, i));\n            startIndex = i + 1;\n            break;\n          }\n          nested--;\n          break;\n      }\n    }\n    if (startIndex < length) {\n      types.push(typesString.substring(startIndex, length));\n    }\n    return {\n      types: types.map(name => this.parseFqTypeName(name)),\n      hasCollections: hasCollections,\n      isComposite: isComposite\n    };\n  };\n  this._parseUdtName = function (typeName, startIndex, length) {\n    const udtParams = parseParams(typeName, startIndex, length);\n    if (udtParams.length < 2) {\n      //It should contain at least the keyspace, name of the udt and a type\n      throw new TypeError('Not a valid type ' + typeName);\n    }\n    const dataType = {\n      code: dataTypes.udt,\n      info: null\n    };\n    const udtInfo = {\n      keyspace: udtParams[0],\n      name: utils.allocBufferFromString(udtParams[1], 'hex').toString(),\n      fields: []\n    };\n    for (let i = 2; i < udtParams.length; i++) {\n      const p = udtParams[i];\n      const separatorIndex = p.indexOf(':');\n      const fieldType = this.parseFqTypeName(p, separatorIndex + 1, p.length - (separatorIndex + 1));\n      udtInfo.fields.push({\n        name: utils.allocBufferFromString(p.substr(0, separatorIndex), 'hex').toString(),\n        type: fieldType\n      });\n    }\n    dataType.info = udtInfo;\n    return dataType;\n  };\n\n  customDecoders[durationTypeName] = this.decodeDuration;\n  customEncoders[durationTypeName] = this.encodeDuration;\n}\n\n/**\n * Sets the encoder and decoder methods for this instance\n * @private\n */\nfunction setEncoders() {\n  this.decoders = {\n    [dataTypes.custom]: this.decodeCustom,\n    [dataTypes.ascii]: this.decodeAsciiString,\n    [dataTypes.bigint]: this.decodeLong,\n    [dataTypes.blob]: this.decodeBlob,\n    [dataTypes.boolean]: this.decodeBoolean,\n    [dataTypes.counter]: this.decodeLong,\n    [dataTypes.decimal]: this.decodeDecimal,\n    [dataTypes.double]: this.decodeDouble,\n    [dataTypes.float]: this.decodeFloat,\n    [dataTypes.int]: this.decodeInt,\n    [dataTypes.text]: this.decodeUtf8String,\n    [dataTypes.timestamp]: this.decodeTimestamp,\n    [dataTypes.uuid]: this.decodeUuid,\n    [dataTypes.varchar]: this.decodeUtf8String,\n    [dataTypes.varint]: this.decodeVarint,\n    [dataTypes.timeuuid]: this.decodeTimeUuid,\n    [dataTypes.inet]: this.decodeInet,\n    [dataTypes.date]: this.decodeDate,\n    [dataTypes.time]: this.decodeTime,\n    [dataTypes.smallint]: this.decodeSmallint,\n    [dataTypes.tinyint]: this.decodeTinyint,\n    [dataTypes.list]: this.decodeList,\n    [dataTypes.map]: this.decodeMap,\n    [dataTypes.set]: this.decodeSet,\n    [dataTypes.udt]: this.decodeUdt,\n    [dataTypes.tuple]: this.decodeTuple\n  };\n\n  this.encoders = {\n    [dataTypes.custom]: this.encodeCustom,\n    [dataTypes.ascii]: this.encodeAsciiString,\n    [dataTypes.bigint]: this.encodeLong,\n    [dataTypes.blob]: this.encodeBlob,\n    [dataTypes.boolean]: this.encodeBoolean,\n    [dataTypes.counter]: this.encodeLong,\n    [dataTypes.decimal]: this.encodeDecimal,\n    [dataTypes.double]: this.encodeDouble,\n    [dataTypes.float]: this.encodeFloat,\n    [dataTypes.int]: this.encodeInt,\n    [dataTypes.text]: this.encodeUtf8String,\n    [dataTypes.timestamp]: this.encodeTimestamp,\n    [dataTypes.uuid]: this.encodeUuid,\n    [dataTypes.varchar]: this.encodeUtf8String,\n    [dataTypes.varint]: this.encodeVarint,\n    [dataTypes.timeuuid]: this.encodeUuid,\n    [dataTypes.inet]: this.encodeInet,\n    [dataTypes.date]: this.encodeDate,\n    [dataTypes.time]: this.encodeTime,\n    [dataTypes.smallint]: this.encodeSmallint,\n    [dataTypes.tinyint]: this.encodeTinyint,\n    [dataTypes.list]: this.encodeList,\n    [dataTypes.map]: this.encodeMap,\n    [dataTypes.set]: this.encodeSet,\n    [dataTypes.udt]: this.encodeUdt,\n    [dataTypes.tuple]: this.encodeTuple\n  };\n}\n\n/**\n * Decodes Cassandra bytes into Javascript values.\n * <p>\n * This is part of an <b>experimental</b> API, this can be changed future releases.\n * </p>\n * @param {Buffer} buffer Raw buffer to be decoded.\n * @param {Object} type An object containing the data type <code>code</code> and <code>info</code>.\n * @param {Number} type.code Type code.\n * @param {Object} [type.info] Additional information on the type for complex / nested types.\n */\nEncoder.prototype.decode = function (buffer, type) {\n  if (buffer === null || (buffer.length === 0 && !zeroLengthTypesSupported.has(type.code))) {\n    return null;\n  }\n\n  const decoder = this.decoders[type.code];\n\n  if (!decoder) {\n    throw new Error('Unknown data type: ' + type.code);\n  }\n\n  return decoder.call(this, buffer, type.info);\n};\n\n/**\n * Encodes Javascript types into Buffer according to the Cassandra protocol.\n * <p>\n * This is part of an <b>experimental</b> API, this can be changed future releases.\n * </p>\n * @param {*} value The value to be converted.\n * @param {{code: number, info: *|Object}|String|Number} [typeInfo] The type information.\n * <p>It can be either a:</p>\n * <ul>\n *   <li>A <code>String</code> representing the data type.</li>\n *   <li>A <code>Number</code> with one of the values of {@link module:types~dataTypes dataTypes}.</li>\n *   <li>An <code>Object</code> containing the <code>type.code</code> as one of the values of\n *   {@link module:types~dataTypes dataTypes} and <code>type.info</code>.\n *   </li>\n * </ul>\n * @returns {Buffer}\n * @throws {TypeError} When there is an encoding error\n */\nEncoder.prototype.encode = function (value, typeInfo) {\n  if (value === undefined) {\n    value = this.encodingOptions.useUndefinedAsUnset && this.protocolVersion >= 4 ? types.unset : null;\n  }\n\n  if (value === types.unset) {\n    if (!types.protocolVersion.supportsUnset(this.protocolVersion)) {\n      throw new TypeError('Unset value can not be used for this version of Cassandra, protocol version: ' +\n        this.protocolVersion);\n    }\n\n    return value;\n  }\n\n  if (value === null || value instanceof Buffer) {\n    return value;\n  }\n\n  /** @type {{code: Number, info: object}} */\n  let type = {\n    code: null,\n    info: null\n  };\n\n  if (typeInfo) {\n    if (typeof typeInfo === 'number') {\n      type.code = typeInfo;\n    }\n    else if (typeof typeInfo === 'string') {\n      type = dataTypes.getByName(typeInfo);\n    }\n    if (typeof typeInfo.code === 'number') {\n      type.code = typeInfo.code;\n      type.info = typeInfo.info;\n    }\n    if (typeof type.code !== 'number') {\n      throw new TypeError('Type information not valid, only String and Number values are valid hints');\n    }\n  }\n  else {\n    //Lets guess\n    type = Encoder.guessDataType(value);\n    if (!type) {\n      throw new TypeError('Target data type could not be guessed, you should use prepared statements for accurate type mapping. Value: ' + util.inspect(value));\n    }\n  }\n\n  const encoder = this.encoders[type.code];\n\n  if (!encoder) {\n    throw new Error('Type not supported ' + type.code);\n  }\n\n  return encoder.call(this, value, type.info);\n};\n\n/**\n * Try to guess the Cassandra type to be stored, based on the javascript value type\n * @param value\n * @returns {{code: number, info: object}|null}\n * @ignore\n * @internal\n */\nEncoder.guessDataType = function (value) {\n  let code = null;\n  let info = null;\n  const esTypeName = (typeof value);\n  if (esTypeName === 'number') {\n    code = dataTypes.double;\n  }\n  else if (esTypeName === 'string') {\n    code = dataTypes.text;\n    if (value.length === 36 && uuidRegex.test(value)){\n      code = dataTypes.uuid;\n    }\n  }\n  else if (esTypeName === 'boolean') {\n    code = dataTypes.boolean;\n  }\n  else if (value instanceof Buffer) {\n    code = dataTypes.blob;\n  }\n  else if (value instanceof Date) {\n    code = dataTypes.timestamp;\n  }\n  else if (value instanceof Long) {\n    code = dataTypes.bigint;\n  }\n  else if (value instanceof Integer) {\n    code = dataTypes.varint;\n  }\n  else if (value instanceof BigDecimal) {\n    code = dataTypes.decimal;\n  }\n  else if (value instanceof types.Uuid) {\n    code = dataTypes.uuid;\n  }\n  else if (value instanceof types.InetAddress) {\n    code = dataTypes.inet;\n  }\n  else if (value instanceof types.Tuple) {\n    code = dataTypes.tuple;\n  }\n  else if (value instanceof types.LocalDate) {\n    code = dataTypes.date;\n  }\n  else if (value instanceof types.LocalTime) {\n    code = dataTypes.time;\n  }\n  else if (value instanceof types.Duration) {\n    code = dataTypes.custom;\n    info = durationTypeName;\n  }\n  else if (util.isArray(value)) {\n    code = dataTypes.list;\n  }\n  if (code === null) {\n    return null;\n  }\n  return { code: code, info: info };\n};\n\n/**\n * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v2 and below\n * @param {Buffer|Number} value\n * @returns {Buffer}\n * @private\n */\nfunction getLengthBufferV2(value) {\n  if (!value) {\n    return buffers.int16Zero;\n  }\n  const lengthBuffer = utils.allocBufferUnsafe(2);\n  if (typeof value === 'number') {\n    lengthBuffer.writeUInt16BE(value, 0);\n  }\n  else {\n    lengthBuffer.writeUInt16BE(value.length, 0);\n  }\n  return lengthBuffer;\n}\n\n/**\n * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v3 and above\n * @param {Buffer|Number} value\n * @returns {Buffer}\n * @private\n */\nfunction getLengthBufferV3(value) {\n  if (!value) {\n    return buffers.int32Zero;\n  }\n  const lengthBuffer = utils.allocBufferUnsafe(4);\n  if (typeof value === 'number') {\n    lengthBuffer.writeInt32BE(value, 0);\n  }\n  else {\n    lengthBuffer.writeInt32BE(value.length, 0);\n  }\n  return lengthBuffer;\n}\n\n/**\n * @param {Buffer} buffer\n * @private\n */\nfunction handleBufferCopy(buffer) {\n  if (buffer === null) {\n    return null;\n  }\n  return utils.copyBuffer(buffer);\n}\n\n/**\n * @param {Buffer} buffer\n * @private\n */\nfunction handleBufferRef(buffer) {\n  return buffer;\n}\n/**\n * Decodes collection length for protocol v3 and above\n * @param bytes\n * @param offset\n * @returns {Number}\n * @private\n */\nfunction decodeCollectionLengthV3(bytes, offset) {\n  return bytes.readInt32BE(offset);\n}\n/**\n * Decodes collection length for protocol v2 and below\n * @param bytes\n * @param offset\n * @returns {Number}\n * @private\n */\nfunction decodeCollectionLengthV2(bytes, offset) {\n  return bytes.readUInt16BE(offset);\n}\n\n/**\n * @param {String} value\n * @param {Number} startIndex\n * @param {Number} length\n * @param {String} [open]\n * @param {String} [close]\n * @returns {Array}\n * @private\n */\nfunction parseParams(value, startIndex, length, open, close) {\n  open = open || '(';\n  close = close || ')';\n  const types = [];\n  let paramStart = startIndex;\n  let level = 0;\n  for (let i = startIndex; i < startIndex + length; i++) {\n    const c = value[i];\n    if (c === open) {\n      level++;\n    }\n    if (c === close) {\n      level--;\n    }\n    if (level === 0 && c === ',') {\n      types.push(value.substr(paramStart, i - paramStart));\n      paramStart = i + 1;\n    }\n  }\n  //Add the last one\n  types.push(value.substr(paramStart, length - (paramStart - startIndex)));\n  return types;\n}\n\n/**\n * @param {Array.<Buffer>} parts\n * @param {Number} totalLength\n * @returns {Buffer}\n * @private\n */\nfunction concatRoutingKey(parts, totalLength) {\n  if (totalLength === 0) {\n    return null;\n  }\n  if (parts.length === 1) {\n    return parts[0];\n  }\n  const routingKey = utils.allocBufferUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < parts.length; i++) {\n    const item = parts[i];\n    routingKey.writeUInt16BE(item.length, offset);\n    offset += 2;\n    item.copy(routingKey, offset);\n    offset += item.length;\n    routingKey[offset] = 0;\n    offset++;\n  }\n  return routingKey;\n}\n\nmodule.exports = Encoder;\n","\"use strict\";\nconst util = require('util');\n\n/**\n * Contains the error classes exposed by the driver.\n * @module errors\n */\n\n/**\n * Base Error\n * @private\n */\nfunction DriverError (message) {\n  Error.call(this, message);\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.info = 'Cassandra Driver Error';\n  // Explicitly set the message property as the Error.call() doesn't set the property on v8\n  this.message = message;\n}\n\nutil.inherits(DriverError, Error);\n\n/**\n * Represents an error when a query cannot be performed because no host is available or could be reached by the driver.\n * @param {Object} innerErrors An object map containing the error per host tried\n * @param {String} [message]\n * @constructor\n */\nfunction NoHostAvailableError(innerErrors, message) {\n  DriverError.call(this, message);\n  this.innerErrors = innerErrors;\n  this.info = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.';\n  if (!message) {\n    this.message = 'All host(s) tried for query failed.';\n    if (innerErrors) {\n      const hostList = Object.keys(innerErrors);\n      if (hostList.length > 0) {\n        const host = hostList[0];\n        this.message += util.format(' First host tried, %s: %s. See innerErrors.', host, innerErrors[host]);\n      }\n    }\n  }\n}\n\nutil.inherits(NoHostAvailableError, DriverError);\n\n/**\n * Represents an error message from the server\n * @param {Number} code Cassandra exception code\n * @param {String} message\n * @constructor\n */\nfunction ResponseError(code, message) {\n  DriverError.call(this, message);\n  /**\n   * The error code as defined in [responseErrorCodes]{@link module:types~responseErrorCodes}.\n   * @type {Number}\n   */\n  this.code = code;\n  this.info = 'Represents an error message from the server';\n}\n\nutil.inherits(ResponseError, DriverError);\n\n/**\n * Represents a bug inside the driver or in a Cassandra host.\n * @param {String} message\n * @constructor\n */\nfunction DriverInternalError(message) {\n  DriverError.call(this, message);\n  this.info = 'Represents a bug inside the driver or in a Cassandra host.';\n}\n\nutil.inherits(DriverInternalError, DriverError);\n\n/**\n * Represents an error when trying to authenticate with auth-enabled host\n * @param {String} message\n * @constructor\n */\nfunction AuthenticationError(message) {\n  DriverError.call(this, message);\n  this.info = 'Represents an authentication error from the driver or from a Cassandra node.';\n}\n\nutil.inherits(AuthenticationError, DriverError);\n\n/**\n * Represents an error that is raised when one of the arguments provided to a method is not valid\n * @param {String} message\n * @constructor\n */\nfunction ArgumentError(message) {\n  DriverError.call(this, message);\n  this.info = 'Represents an error that is raised when one of the arguments provided to a method is not valid.';\n}\n\nutil.inherits(ArgumentError, DriverError);\n\n/**\n * Represents a client-side error that is raised when the client didn't hear back from the server within\n * {@link ClientOptions.socketOptions.readTimeout}.\n * @param {String} message The error message.\n * @param {String} [host] Address of the server host that caused the operation to time out.\n * @constructor\n */\nfunction OperationTimedOutError(message, host) {\n  DriverError.call(this, message, this.constructor);\n  this.info = 'Represents a client-side error that is raised when the client did not hear back from the server ' +\n    'within socketOptions.readTimeout';\n\n  /**\n   * When defined, it gets the address of the host that caused the operation to time out.\n   * @type {String|undefined}\n   */\n  this.host = host;\n}\n\nutil.inherits(OperationTimedOutError, DriverError);\n\n/**\n * Represents an error that is raised when a feature is not supported in the driver or in the current Cassandra version.\n * @param message\n * @constructor\n */\nfunction NotSupportedError(message) {\n  DriverError.call(this, message, this.constructor);\n  this.info = 'Represents a feature that is not supported in the driver or in the Cassandra version.';\n}\n\nutil.inherits(NotSupportedError, DriverError);\n\n/**\n * Represents a client-side error indicating that all connections to a certain host have reached\n * the maximum amount of in-flight requests supported.\n * @param {String} address\n * @param {Number} maxRequestsPerConnection\n * @param {Number} connectionLength\n * @constructor\n */\nfunction BusyConnectionError(address, maxRequestsPerConnection, connectionLength) {\n  const message = util.format('All connections to host %s are busy, %d requests are in-flight on %s',\n    address, maxRequestsPerConnection, connectionLength === 1 ? 'a single connection': 'each connection');\n  DriverError.call(this, message, this.constructor);\n  this.info = 'Represents a client-side error indicating that all connections to a certain host have reached ' +\n    'the maximum amount of in-flight requests supported (pooling.maxRequestsPerConnection)';\n}\n\nutil.inherits(BusyConnectionError, DriverError);\n\nexports.ArgumentError = ArgumentError;\nexports.AuthenticationError = AuthenticationError;\nexports.BusyConnectionError = BusyConnectionError;\nexports.DriverError = DriverError;\nexports.OperationTimedOutError = OperationTimedOutError;\nexports.DriverInternalError = DriverInternalError;\nexports.NoHostAvailableError = NoHostAvailableError;\nexports.NotSupportedError = NotSupportedError;\nexports.ResponseError = ResponseError;","'use strict';\n\nconst utils = require('./utils');\nconst types = require('./types');\nconst errors = require('./errors');\n\n/**\n * A base class that represents a wrapper around the user provided query options with getter methods and proper\n * default values.\n * <p>\n *   Note that getter methods might return <code>undefined</code> when not set on the query options or default\n *  {@link Client} options.\n * </p>\n */\nclass ExecutionOptions {\n\n  /**\n   * Creates a new instance of {@link ExecutionOptions}.\n   */\n  constructor() {\n  }\n\n  /**\n   * Creates an empty instance, where all methods return undefined, used internally.\n   * @ignore\n   * @return {ExecutionOptions}\n   */\n  static empty() {\n    return new ExecutionOptions();\n  }\n\n  /**\n   * Determines if the stack trace before the query execution should be maintained.\n   * @abstract\n   * @returns {Boolean}\n   */\n  getCaptureStackTrace() {\n\n  }\n\n  /**\n   * Gets the [Consistency level]{@link module:types~consistencies} to be used for the execution.\n   * @abstract\n   * @returns {Number}\n   */\n  getConsistency() {\n\n  }\n\n  /**\n   * Key-value payload to be passed to the server. On the server side, implementations of QueryHandler can use\n   * this data.\n   * @abstract\n   * @returns {Object}\n   */\n  getCustomPayload() {\n\n  }\n\n  /**\n   * Gets the amount of rows to retrieve per page.\n   * @abstract\n   * @returns {Number}\n   */\n  getFetchSize() {\n\n  }\n\n  /**\n   * When a fixed host is set on the query options and the query plan for the load-balancing policy is not used, it\n   * gets the host that should handle the query.\n   * @returns {Host}\n   */\n  getFixedHost() {\n\n  }\n\n  /**\n   * Gets the type hints for parameters given in the query, ordered as for the parameters.\n   * @abstract\n   * @returns {Array|Array<Array>}\n   */\n  getHints() {\n\n  }\n\n  /**\n   * Determines whether the driver must retrieve the following result pages automatically.\n   * <p>\n   *   This setting is only considered by the [Client#eachRow()]{@link Client#eachRow} method.\n   * </p>\n   * @abstract\n   * @returns {Boolean}\n   */\n  isAutoPage() {\n\n  }\n\n  /**\n   * Determines whether its a counter batch. Only valid for [Client#batch()]{@link Client#batch}, it will be ignored by\n   * other methods.\n   * @abstract\n   * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.\n   */\n  isBatchCounter() {\n\n  }\n\n  /**\n   * Determines whether the batch should be written to the batchlog. Only valid for\n   * [Client#batch()]{@link Client#batch}, it will be ignored by other methods.\n   * @abstract\n   * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.\n   */\n  isBatchLogged() {\n\n  }\n\n  /**\n   * Determines whether the query can be applied multiple times without changing the result beyond the initial\n   * application.\n   * @abstract\n   * @returns {Boolean}\n   */\n  isIdempotent() {\n\n  }\n\n  /**\n   * Determines whether the query must be prepared beforehand.\n   * @abstract\n   * @returns {Boolean} A <code>Boolean</code> value, it can't be <code>undefined</code>.\n   */\n  isPrepared() {\n\n  }\n\n  /**\n   * Determines whether query tracing is enabled for the execution.\n   * @abstract\n   * @returns {Boolean}\n   */\n  isQueryTracing() {\n\n  }\n\n  /**\n   * Gets the keyspace for the query when set at query options level.\n   * <p>\n   *   Note that this method will return <code>undefined</code> when the keyspace is not set at query options level.\n   *   It will only return the keyspace name when the user provided a different keyspace than the current\n   *   {@link Client} keyspace.\n   * </p>\n   * @abstract\n   * @returns {String}\n   */\n  getKeyspace() {\n\n  }\n\n  /**\n   * Gets the load balancing policy used for this execution.\n   * @returns {LoadBalancingPolicy} A <code>LoadBalancingPolicy</code> instance, it can't be <code>undefined</code>.\n   */\n  getLoadBalancingPolicy() {\n\n  }\n\n  /**\n   * Gets the Buffer representing the paging state.\n   * @abstract\n   * @returns {Buffer}\n   */\n  getPageState() {\n\n  }\n\n  /**\n   * Gets the query options as provided to the execution method without setting the default values.\n   * @returns {QueryOptions}\n   */\n  getRawQueryOptions() {\n\n  }\n\n  /**\n   * Gets the timeout in milliseconds to be used for the execution per coordinator.\n   * <p>\n   *   A value of <code>0</code> disables client side read timeout for the execution. Default: <code>undefined</code>.\n   * </p>\n   * @abstract\n   * @returns {Number}\n   */\n  getReadTimeout() {\n\n  }\n\n  /**\n   * Gets the [retry policy]{@link module:policies/retry} to be used.\n   * @abstract\n   * @returns {RetryPolicy} A <code>RetryPolicy</code> instance, it can't be <code>undefined</code>.\n   */\n  getRetryPolicy() {\n\n  }\n\n  /**\n   * Internal method to obtain the row callback, for \"by row\" results.\n   * @abstract\n   * @ignore\n   */\n  getRowCallback() {\n\n  }\n\n  /**\n   * Internal method to get or generate a timestamp for the request execution.\n   * @ignore\n   * @returns {Long|null}\n   */\n  getOrGenerateTimestamp() {\n\n  }\n\n  /**\n   * Gets the index of the parameters that are part of the partition key to determine the routing.\n   * @abstract\n   * @ignore\n   * @returns {Array}\n   */\n  getRoutingIndexes() {\n\n  }\n\n  /**\n   * Gets the partition key(s) to determine which coordinator should be used for the query.\n   * @abstract\n   * @returns {Buffer|Array<Buffer>}\n   */\n  getRoutingKey() {\n\n  }\n\n  /**\n   * Gets the array of the parameters names that are part of the partition key to determine the\n   * routing. Only valid for non-prepared requests.\n   * @abstract\n   * @ignore\n   */\n  getRoutingNames() {\n\n  }\n\n  /**\n   * Gets the the consistency level to be used for the serial phase of conditional updates.\n   * @abstract\n   * @returns {Number}\n   */\n  getSerialConsistency() {\n\n  }\n\n  /**\n   * Gets the provided timestamp for the execution in microseconds from the unix epoch (00:00:00, January 1st, 1970).\n   * <p>When a timestamp generator is used, this method returns <code>undefined</code>.</p>\n   * @abstract\n   * @returns {Number|Long|undefined|null}\n   */\n  getTimestamp() {\n\n  }\n\n  /**\n   * @param {Array} hints\n   * @abstract\n   * @ignore\n   */\n  setHints(hints) {\n\n  }\n\n  /**\n   * Sets the keyspace for the execution.\n   * @ignore\n   * @abstract\n   * @param {String} keyspace\n   */\n  setKeyspace(keyspace) {\n\n  }\n\n  /**\n   * @abstract\n   * @ignore\n   */\n  setPageState() {\n\n  }\n\n  /**\n   * Sets the index of the parameters that are part of the partition key to determine the routing.\n   * @param {Array} routingIndexes\n   * @abstract\n   * @ignore\n   */\n  setRoutingIndexes(routingIndexes) {\n\n  }\n\n  /**\n   * Sets the routing key.\n   * @abstract\n   * @ignore\n   */\n  setRoutingKey(value) {\n\n  }\n}\n\n/**\n * Internal implementation of {@link ExecutionOptions} that uses the value from the client options and execution\n * profile into account.\n * @ignore\n */\nclass DefaultExecutionOptions extends ExecutionOptions {\n  /**\n   * Creates a new instance of {@link ExecutionOptions}.\n   * @param {QueryOptions} queryOptions\n   * @param {Client} client\n   * @param {Function|null} rowCallback\n   */\n  constructor(queryOptions, client, rowCallback) {\n    super();\n    this._queryOptions = queryOptions;\n    this._rowCallback = rowCallback;\n    this._routingKey = this._queryOptions.routingKey;\n    this._hints = this._queryOptions.hints;\n    this._keyspace = this._queryOptions.keyspace;\n    this._routingIndexes = this._queryOptions.routingIndexes;\n    this._pageState = typeof this._queryOptions.pageState === 'string' ?\n      utils.allocBufferFromString(this._queryOptions.pageState, 'hex') : this._queryOptions.pageState;\n\n    this._client = client;\n    this._defaultQueryOptions = client.options.queryOptions;\n    this._profile = client.profileManager.getProfile(this._queryOptions.executionProfile);\n\n    if (!this._profile) {\n      throw new errors.ArgumentError(`Execution profile \"${this._queryOptions.executionProfile}\" not found`);\n    }\n  }\n\n  /**\n   * Creates a new instance {@link ExecutionOptions}, based on the query options.\n   * @param {QueryOptions|null} queryOptions\n   * @param {Client} client\n   * @param {Function|null} [rowCallback]\n   * @ignore\n   * @return {ExecutionOptions}\n   */\n  static create(queryOptions, client, rowCallback) {\n    if (!queryOptions || typeof queryOptions === 'function') {\n      // queryOptions can be null/undefined and could be of type function when is an optional parameter\n      queryOptions = utils.emptyObject;\n    }\n    return new DefaultExecutionOptions(queryOptions, client, rowCallback);\n  }\n\n  getCaptureStackTrace() {\n    return ifUndefined(this._queryOptions.captureStackTrace, this._defaultQueryOptions.captureStackTrace);\n  }\n\n  getConsistency() {\n    return ifUndefined3(this._queryOptions.consistency, this._profile.consistency,\n      this._defaultQueryOptions.consistency);\n  }\n\n  getCustomPayload() {\n    return ifUndefined(this._queryOptions.customPayload, this._defaultQueryOptions.customPayload);\n  }\n\n  getFetchSize() {\n    return ifUndefined(this._queryOptions.fetchSize, this._defaultQueryOptions.fetchSize);\n  }\n\n  getFixedHost() {\n    return this._queryOptions.host;\n  }\n\n  getHints() {\n    return this._hints;\n  }\n\n  isAutoPage() {\n    return ifUndefined(this._queryOptions.autoPage, this._defaultQueryOptions.autoPage);\n  }\n\n  isBatchCounter() {\n    return ifUndefined(this._queryOptions.counter, false);\n  }\n\n  isBatchLogged() {\n    return ifUndefined3(this._queryOptions.logged, this._defaultQueryOptions.logged, true);\n  }\n\n  isIdempotent() {\n    return ifUndefined(this._queryOptions.isIdempotent, this._defaultQueryOptions.isIdempotent);\n  }\n\n  /**\n   * Determines if the query execution must be prepared beforehand.\n   * @return {Boolean}\n   */\n  isPrepared() {\n    return ifUndefined(this._queryOptions.prepare, this._defaultQueryOptions.prepare);\n  }\n\n  isQueryTracing() {\n    return ifUndefined(this._queryOptions.traceQuery, this._defaultQueryOptions.traceQuery);\n  }\n\n  getKeyspace() {\n    return this._keyspace;\n  }\n\n  getLoadBalancingPolicy() {\n    return this._profile.loadBalancing;\n  }\n\n  getOrGenerateTimestamp() {\n    let result = this.getTimestamp();\n\n    if (result === undefined) {\n      const generator = this._client.options.policies.timestampGeneration;\n\n      if ( types.protocolVersion.supportsTimestamp(this._client.controlConnection.protocolVersion) && generator) {\n        result = generator.next(this._client);\n      } else {\n        result = null;\n      }\n    }\n\n    return typeof result === 'number' ? types.Long.fromNumber(result) : result;\n  }\n\n  getPageState() {\n    return this._pageState;\n  }\n\n  getRawQueryOptions() {\n    return this._queryOptions;\n  }\n\n  getReadTimeout() {\n    return ifUndefined3(this._queryOptions.readTimeout, this._profile.readTimeout,\n      this._client.options.socketOptions.readTimeout);\n  }\n\n  getRetryPolicy() {\n    return ifUndefined3(this._queryOptions.retry, this._profile.retry, this._client.options.policies.retry);\n  }\n\n  getRoutingIndexes() {\n    return this._routingIndexes;\n  }\n\n  getRoutingKey() {\n    return this._routingKey;\n  }\n\n  getRoutingNames() {\n    return this._queryOptions.routingNames;\n  }\n\n  /**\n   * Internal method to obtain the row callback, for \"by row\" results.\n   * @ignore\n   */\n  getRowCallback() {\n    return this._rowCallback;\n  }\n\n  getSerialConsistency() {\n    return ifUndefined3(\n      this._queryOptions.serialConsistency, this._profile.serialConsistency, this._defaultQueryOptions.serialConsistency);\n  }\n\n  getTimestamp() {\n    return this._queryOptions.timestamp;\n  }\n\n  /**\n   * @param {Array} hints\n   */\n  setHints(hints) {\n    this._hints = hints;\n  }\n\n  /**\n   * @param {String} keyspace\n   */\n  setKeyspace(keyspace) {\n    this._keyspace = keyspace;\n  }\n\n  /**\n   * @param {Buffer} pageState\n   */\n  setPageState(pageState) {\n    this._pageState = pageState;\n  }\n\n  /**\n   * @param {Array} routingIndexes\n   */\n  setRoutingIndexes(routingIndexes) {\n    this._routingIndexes = routingIndexes;\n  }\n\n  setRoutingKey(value) {\n    this._routingKey = value;\n  }\n}\n\nfunction ifUndefined(v1, v2) {\n  return v1 !== undefined ? v1 : v2;\n}\n\nfunction ifUndefined3(v1, v2, v3) {\n  if (v1 !== undefined) {\n    return v1;\n  }\n  return v2 !== undefined ? v2 : v3;\n}\n\nmodule.exports = { ExecutionOptions, DefaultExecutionOptions };","\"use strict\";\nconst utils = require('./utils');\nconst types = require('./types');\n\n/**\n * Creates a new instance of {@link ExecutionProfile}.\n * @classdesc\n * Represents a set configurations to be used in a statement execution to be used for a single {@link Client} instance.\n * <p>\n *   An {@link ExecutionProfile} instance should not be shared across different {@link Client} instances.\n * </p>\n * @param {String} name Name of the execution profile.\n * <p>\n *   Use <code>'default'</code> to specify that the new instance should be the default {@link ExecutionProfile} if no\n *   profile is specified in the execution.\n * </p>\n * @param {Object} [options] Profile options, when any of the options is not specified the {@link Client} will the use\n * the ones defined in the default profile.\n * @param {Number} [options.consistency] The consistency level to use for this profile.\n * @param {LoadBalancingPolicy} [options.loadBalancing] The load-balancing policy to use for this profile.\n * @param {Number} [options.readTimeout] The client per-host request timeout to use for this profile.\n * @param {RetryPolicy} [options.retry] The retry policy to use for this profile.\n * @param {Number} [options.serialConsistency] The serial consistency level to use for this profile.\n * @constructor\n */\nfunction ExecutionProfile(name, options) {\n  if (typeof name !== 'string') {\n    throw new TypeError('Execution profile name must be a string');\n  }\n  options = options || utils.emptyObject;\n  /**\n   * Name of the execution profile.\n   * @type {String}\n   */\n  this.name = name;\n  /**\n   * Consistency level.\n   * @type {Number}\n   */\n  this.consistency = options.consistency;\n  /**\n   * Load-balancing policy\n   * @type {LoadBalancingPolicy}\n   */\n  this.loadBalancing = options.loadBalancing;\n  /**\n   * Client read timeout.\n   * @type {Number}\n   */\n  this.readTimeout = options.readTimeout;\n  /**\n   * Retry policy.\n   * @type {RetryPolicy}\n   */\n  this.retry = options.retry;\n  /**\n   * Serial consistency level.\n   * @type {Number}\n   */\n  this.serialConsistency = options.serialConsistency;\n}\n\n/**\n * @param {ClientOptions} options\n * @constructor\n * @ignore\n */\nfunction ProfileManager(options) {\n  this._profiles = options.profiles || [];\n  this._setDefault(options);\n  // A array of unique load balancing policies\n  this._loadBalancingPolicies = [];\n  // A dictionary of name keys and profile values\n  this._profilesMap = {};\n  this._profiles.forEach(function (p) {\n    this._profilesMap[p.name] = p;\n    // Set required properties\n    p.loadBalancing = p.loadBalancing || this._defaultProfile.loadBalancing;\n    // Using array indexOf is not very efficient (O(n)) but the amount of profiles should be limited\n    // and a handful of load-balancing policies (no hashcode for load-Balancing policies)\n    if (this._loadBalancingPolicies.indexOf(p.loadBalancing) === -1) {\n      this._loadBalancingPolicies.push(p.loadBalancing);\n    }\n    return p;\n  }, this);\n}\n\n/**\n * @param {Client} client\n * @param {HostMap} hosts\n * @param {Function} callback\n */\nProfileManager.prototype.init = function (client, hosts, callback) {\n  utils.eachSeries(this._loadBalancingPolicies, function (policy, next) {\n    policy.init(client, hosts, next);\n  }, callback);\n};\n\n/**\n * Uses the load-balancing policies to get the relative distance to the host and return the closest one.\n * @param {Host} host\n */\nProfileManager.prototype.getDistance = function (host) {\n  let distance = types.distance.ignored;\n  // this is performance critical: we can't use any other language features than for-loop :(\n  for (let i = 0; i < this._loadBalancingPolicies.length; i++) {\n    const d = this._loadBalancingPolicies[i].getDistance(host);\n    if (d < distance) {\n      distance = d;\n      if (distance === types.distance.local) {\n        break;\n      }\n    }\n  }\n  host.setDistance(distance);\n  return distance;\n};\n\n/**\n * @param {String|ExecutionProfile} name\n * @returns {ExecutionProfile|undefined} It returns the execution profile by name or the default profile when name is\n * undefined. It returns undefined when the profile does not exist.\n */\nProfileManager.prototype.getProfile = function (name) {\n  if (name instanceof ExecutionProfile) {\n    return name;\n  }\n  return this._profilesMap[name || 'default'];\n};\n\n/** @returns {ExecutionProfile} */\nProfileManager.prototype.getDefault = function () {\n  return this._defaultProfile;\n};\n\n/** @returns {LoadBalancingPolicy} */\nProfileManager.prototype.getDefaultLoadBalancing = function () {\n  return this._defaultProfile.loadBalancing;\n};\n\n/**\n * @private\n * @param {ClientOptions} options\n */\nProfileManager.prototype._setDefault = function (options) {\n  this._defaultProfile = this._profiles.filter(function (p) { return p.name === 'default'; })[0];\n  if (!this._defaultProfile) {\n    this._profiles.push(this._defaultProfile = new ExecutionProfile('default'));\n  }\n  // set the required properties\n  this._defaultProfile.loadBalancing = this._defaultProfile.loadBalancing || options.policies.loadBalancing;\n  this._defaultProfile.retry = this._defaultProfile.retry || options.policies.retry;\n};\n\nexports.ProfileManager = ProfileManager;\nexports.ExecutionProfile = ExecutionProfile;\n","\"use strict\";\nconst util = require('util');\nconst events = require('events');\n\nconst Connection = require('./connection');\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst defaultOptions = require('./client-options').defaultOptions();\n\n// Used to get the index of the connection with less in-flight requests\nlet connectionIndex = 0;\nconst connectionIndexOverflow = Math.pow(2, 15);\n\n/**\n * Represents the possible states of the pool.\n * Possible state transitions:\n *  - From initial to closing: The pool must be closed because the host is ignored.\n *  - From initial to shuttingDown: The pool is being shutdown as a result of a client shutdown.\n *  - From closing to initial state: The pool finished closing connections (is now ignored) and it resets to\n *    initial state in case the host is marked as local/remote in the future.\n *  - From closing to shuttingDown (rare): It was marked as ignored, now the client is being shutdown.\n *  - From shuttingDown to shutdown: Finished shutting down, the pool should not be reused.\n * @private\n */\nconst state = {\n  // Initial state: open / opening / ready to be opened\n  initial: 0,\n  // When the pool is being closed as part of a distance change\n  closing: 1,\n  // When the pool is being shutdown for good\n  shuttingDown: 2,\n  // When the pool has being shutdown\n  shutDown: 4\n};\n\n/**\n * Represents a pool of connections to a host\n */\nclass HostConnectionPool extends events.EventEmitter {\n  /**\n   * Creates a new instance of HostConnectionPool.\n   * @param {Host} host\n   * @param {Number} protocolVersion Initial protocol version\n   * @extends EventEmitter\n   */\n  constructor(host, protocolVersion) {\n    super();\n    this._address = host.address;\n    this._newConnectionTimeout = null;\n    this._creating = false;\n    this._state = state.initial;\n    this.responseCounter = 0;\n    this.options = host.options;\n    this.protocolVersion = protocolVersion;\n    this.coreConnectionsLength = 1;\n    /**\n     * An immutable array of connections\n     * @type {Array.<Connection>}\n     */\n    this.connections = utils.emptyArray;\n    this.setMaxListeners(0);\n    this.log = utils.log;\n  }\n\n  /**\n   * Borrows a connection from the pool.\n   * @param {String} keyspace\n   * @param {Function} callback\n   */\n  createAndBorrowConnection(keyspace, callback) {\n    this.create(false, err => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.borrowConnection(keyspace, null, callback);\n    });\n  }\n\n  getInFlight() {\n    const length = this.connections.length;\n    if (length === 1) {\n      return this.connections[0].getInFlight();\n    }\n\n    let sum = 0;\n    for (let i = 0; i < length; i++) {\n      sum += this.connections[i].getInFlight();\n    }\n    return sum;\n  }\n\n  /**\n   * Tries to borrow one of the existing connections from the pool.\n   * @param {Connection} previousConnection When provided, the pool should try to provide a different connection.\n   * @param {String} keyspace\n   * @param {Function} callback\n   */\n  borrowConnection(keyspace, previousConnection, callback) {\n    if (this.connections.length === 0) {\n      return callback(new Error('No connection available'));\n    }\n\n    const maxRequests = this.options.pooling.maxRequestsPerConnection;\n    const c = HostConnectionPool.minInFlight(this.connections, maxRequests, previousConnection);\n\n    if (c.getInFlight() >= maxRequests) {\n      return callback(new errors.BusyConnectionError(this._address, maxRequests, this.connections.length));\n    }\n\n    if (!keyspace || keyspace === c.keyspace) {\n      // Connection is ready to be used\n      return callback(null, c);\n    }\n\n    c.changeKeyspace(keyspace, (err) => {\n      callback(err, c);\n    });\n  }\n\n  /**\n   * Gets the connection with the minimum number of in-flight requests.\n   * Only checks for 2 connections (round-robin) and gets the one with minimum in-flight requests, as long as\n   * the amount of in-flight requests is lower than maxRequests.\n   * @param {Array.<Connection>} connections\n   * @param {Number} maxRequests\n   * @param {Connection} previousConnection\n   * @returns {Connection}\n   */\n  static minInFlight(connections, maxRequests, previousConnection) {\n    const length = connections.length;\n    if (length === 1) {\n      return connections[0];\n    }\n\n    // Use a single index for all hosts as a simplified way to balance the load between connections\n    connectionIndex++;\n    if (connectionIndex >= connectionIndexOverflow) {\n      connectionIndex = 0;\n    }\n\n    let current;\n    for (let index = connectionIndex; index < connectionIndex + length; index++) {\n      current = connections[index % length];\n      if (current === previousConnection) {\n        // Increment the index and skip\n        current = connections[(++index) % length];\n      }\n\n      let next = connections[(index + 1) % length];\n      if (next === previousConnection) {\n        // Skip\n        next = connections[(index + 2) % length];\n      }\n\n      if (next.getInFlight() < current.getInFlight()) {\n        current = next;\n      }\n\n      if (current.getInFlight() < maxRequests) {\n        // Check as few connections as possible, as long as the amount of in-flight\n        // requests is lower than maxRequests\n        break;\n      }\n    }\n    return current;\n  }\n\n  /**\n   * Create the min amount of connections, if the pool is empty.\n   * @param {Boolean} warmup Determines if all connections must be created before invoking the callback\n   * @param {Function} callback\n   */\n  create(warmup, callback) {\n    if (this.isClosing()) {\n      return callback(new Error('Pool is being closed when calling create'));\n    }\n    // The value of this.coreConnectionsLength can change over time\n    // when an existing pool is being resized (by setting the distance).\n    if (this.connections.length >= this.coreConnectionsLength) {\n      return callback();\n    }\n    if (!warmup && this.connections.length > 0) {\n      // we already have a valid connection\n      // let the connection grow continue in the background\n      this.increaseSize();\n      return callback();\n    }\n    this.once('creation', callback);\n    if (this._creating) {\n      // wait for the pool to be creating\n      return;\n    }\n    this._creating = true;\n    let connectionsToCreate = this.coreConnectionsLength;\n    if (!warmup) {\n      connectionsToCreate = 1;\n    }\n    const self = this;\n    utils.whilst(\n      function condition() {\n        return self.connections.length < connectionsToCreate;\n      },\n      function iterator(next) {\n        self._attemptNewConnection(next);\n      }, function whilstEnded(err) {\n        self._creating = false;\n        if (err) {\n          if (self.isClosing()) {\n            self.log('info', 'Connection pool created but it was being closed');\n            self._closeAllConnections();\n            err = new Error('Pool is being closed');\n          }\n          else {\n            // there was an error and no connections could be successfully opened\n            self.log('warning', util.format('Connection pool to host %s could not be created', self._address), err);\n          }\n          return self.emit('creation', err);\n        }\n        self.log('info', util.format('Connection pool to host %s created with %d connection(s)',\n          self._address, self.connections.length));\n        self.emit('creation');\n        self.increaseSize();\n      });\n  }\n\n  /** @returns {Connection} */\n  _createConnection() {\n    const c = new Connection(this._address, this.protocolVersion, this.options);\n    this._addListeners(c);\n    return c;\n  }\n\n  /** @param {Connection} c */\n  _addListeners(c) {\n    c.on('responseDequeued', () => this.responseCounter++);\n\n    const self = this;\n    function connectionErrorCallback() {\n      // The socket is not fully open / can not send heartbeat\n      self.remove(c);\n    }\n    c.on('idleRequestError', connectionErrorCallback);\n    c.on('socketClose', connectionErrorCallback);\n  }\n\n  addExistingConnection(c) {\n    this._addListeners(c);\n    // Use a copy of the connections array\n    this.connections = this.connections.slice(0);\n    this.connections.push(c);\n  }\n\n  /**\n   * Prevents reconnection timeout from triggering\n   */\n  clearNewConnectionAttempt() {\n    if (!this._newConnectionTimeout) {\n      return;\n    }\n    clearTimeout(this._newConnectionTimeout);\n    this._newConnectionTimeout = null;\n  }\n\n  /**\n   * @param {Function} callback\n   */\n  _attemptNewConnection(callback) {\n    const c = this._createConnection();\n    const self = this;\n    this.once('open', callback);\n    if (this._opening) {\n      // wait for the event to fire\n      return;\n    }\n    this._opening = true;\n    c.open(function attemptOpenCallback(err) {\n      self._opening = false;\n      if (err) {\n        self.log('warning', util.format('Connection to %s could not be created: %s', self._address, err), err);\n        c.close();\n        return self.emit('open', err);\n      }\n      if (self.isClosing()) {\n        self.log('info', util.format('Connection to %s opened successfully but pool was being closed', self._address));\n        c.close();\n        return self.emit('open', new Error('Connection closed'));\n      }\n      // use a copy of the connections array\n      const newConnections = self.connections.slice(0);\n      newConnections.push(c);\n      self.connections = newConnections;\n      self.log('info', util.format('Connection to %s opened successfully', self._address));\n      self.emit('open', null, c);\n    });\n  }\n\n  attemptNewConnectionImmediate() {\n    const self = this;\n    function openConnection() {\n      self.clearNewConnectionAttempt();\n      self.scheduleNewConnectionAttempt(0);\n    }\n    if (this._state === state.initial) {\n      return openConnection();\n    }\n    if (this._state === state.closing) {\n      return this.once('close', openConnection);\n    }\n    // In the case the pool its being / has been shutdown for good\n    // Do not attempt to create a new connection.\n  }\n\n  /**\n   * Closes the connection and removes a connection from the pool.\n   * @param {Connection} connection\n   */\n  remove(connection) {\n    // locating an object by position in the array is O(n), but normally there should be between 1 to 8 connections.\n    const index = this.connections.indexOf(connection);\n    if (index < 0) {\n      // it was already removed from the connections and it's closing\n      return;\n    }\n    // remove the connection from the pool, using an pool copy\n    const newConnections = this.connections.slice(0);\n    newConnections.splice(index, 1);\n    this.connections = newConnections;\n    // close the connection\n    setImmediate(function removeClose() {\n      connection.close();\n    });\n    this.emit('remove');\n  }\n\n  /**\n   * @param {Number} delay\n   */\n  scheduleNewConnectionAttempt(delay) {\n    if (this.isClosing()) {\n      return;\n    }\n    const self = this;\n    this._newConnectionTimeout = setTimeout(function newConnectionTimeoutExpired() {\n      self._newConnectionTimeout = null;\n      if (self.connections.length >= self.coreConnectionsLength) {\n        // new connection can be scheduled while a new connection is being opened\n        // the pool has the appropriate size\n        return;\n      }\n      self._attemptNewConnection(utils.noop);\n    }, delay);\n  }\n\n  hasScheduledNewConnection() {\n    return !!this._newConnectionTimeout || this._opening;\n  }\n\n  /**\n   * Increases the size of the connection pool in the background, if needed.\n   */\n  increaseSize() {\n    if (this.connections.length < this.coreConnectionsLength && !this.hasScheduledNewConnection()) {\n      // schedule the next connection in the background\n      this.scheduleNewConnectionAttempt(0);\n    }\n  }\n\n  /**\n   * Gets the amount of responses and resets the internal counter.\n   * @returns {number}\n   */\n  getAndResetResponseCounter() {\n    const temp = this.responseCounter;\n    this.responseCounter = 0;\n    return temp;\n  }\n\n  /**\n   * Gets a boolean indicating if the pool is being closed / shutting down or has been shutdown.\n   */\n  isClosing() {\n    return this._state !== state.initial;\n  }\n\n  /**\n   * Gracefully waits for all in-flight requests to finish and closes the pool.\n   */\n  drainAndShutdown() {\n    if (this.isClosing()) {\n      // Its already closing / shutting down\n      return;\n    }\n    this._state = state.closing;\n    this.clearNewConnectionAttempt();\n    const self = this;\n    if (this.connections.length === 0) {\n      return this._afterClosing();\n    }\n    const connections = this.connections;\n    this.connections = utils.emptyArray;\n    let closedConnections = 0;\n    this.log('info', util.format('Draining and closing %d connections to %s', connections.length, this._address));\n    let wasClosed = false;\n    // eslint-disable-next-line prefer-const\n    let checkShutdownTimeout;\n    for (let i = 0; i < connections.length; i++) {\n      const c = connections[i];\n      if (c.getInFlight() === 0) {\n        getDelayedClose(c)();\n        continue;\n      }\n      c.emitDrain = true;\n      c.once('drain', getDelayedClose(c));\n    }\n    function getDelayedClose(connection) {\n      return (function delayedClose() {\n        connection.close();\n        if (++closedConnections < connections.length) {\n          return;\n        }\n        if (wasClosed) {\n          return;\n        }\n        wasClosed = true;\n        if (checkShutdownTimeout) {\n          clearTimeout(checkShutdownTimeout);\n        }\n        self._afterClosing();\n      });\n    }\n    // Check that after sometime (readTimeout + 100ms) the connections have been drained\n    const delay = (this.options.socketOptions.readTimeout || defaultOptions.socketOptions.readTimeout) + 100;\n    checkShutdownTimeout = setTimeout(function checkShutdown() {\n      wasClosed = true;\n      connections.forEach(function connectionEach(c) {\n        c.close();\n      });\n      self._afterClosing();\n    }, delay);\n  }\n\n  _afterClosing() {\n    const self = this;\n    function resetState() {\n      if (self._state === state.shuttingDown) {\n        self._state = state.shutDown;\n      }\n      else {\n        self._state = state.initial;\n      }\n      self.emit('close');\n    }\n    if (this._creating) {\n      // The pool is being created, reset the state back to init once the creation finished (without any new connection)\n      return this.once('creation', resetState);\n    }\n    if (this._opening) {\n      // The pool is growing, reset the state back to init once the open finished (without any new connection)\n      return this.once('open', resetState);\n    }\n    resetState();\n  }\n\n  /**\n   * @param {Function} callback\n   */\n  shutdown(callback) {\n    this.clearNewConnectionAttempt();\n    if (!this.connections.length) {\n      this._state = state.shutDown;\n      return callback();\n    }\n    const previousState = this._state;\n    this._state = state.shuttingDown;\n    if (previousState === state.closing) {\n      return this.once('close', callback);\n    }\n    this.once('shutdown', callback);\n    if (previousState === state.shuttingDown) {\n      // Its going to be emitted\n      return;\n    }\n    const self = this;\n    this._closeAllConnections(function closeAllCallback() {\n      self._state = state.shutDown;\n      self.emit('shutdown');\n    });\n  }\n\n  /** @param {Function} [callback] */\n  _closeAllConnections(callback) {\n    callback = callback || utils.noop;\n    const connections = this.connections;\n    // point to an empty array\n    this.connections = utils.emptyArray;\n    if (connections.length === 0) {\n      return callback();\n    }\n    this.log('info', util.format('Closing %d connections to %s', connections.length, this._address));\n    utils.each(connections, function closeEach(c, next) {\n      c.close(function closedCallback() {\n        //ignore errors\n        next();\n      });\n    }, callback);\n  }\n}\n\nmodule.exports = HostConnectionPool;","\"use strict\";\nconst util = require('util');\nconst events = require('events');\n\nconst utils = require('./utils');\nconst types = require('./types');\nconst HostConnectionPool = require('./host-connection-pool');\nconst PrepareHandler = require('./prepare-handler');\n\nconst healthResponseCountInterval = 200;\n\n/**\n * Creates a new Host instance.\n * @classdesc\n * Represents a Cassandra node.\n * @extends EventEmitter\n * @constructor\n */\nfunction Host(address, protocolVersion, options, metadata) {\n  events.EventEmitter.call(this);\n  /**\n   * Gets ip address and port number of the node separated by `:`.\n   * @type {String}\n   */\n  this.address = address;\n  this.setDownAt = 0;\n\n  /**\n   * Gets the timestamp of the moment when the Host was marked as UP.\n   * @type {Number|null}\n   * @ignore\n   * @internal\n   */\n  this.isUpSince = null;\n\n  Object.defineProperty(this, 'options', { value: options, enumerable: false, writable: false});\n\n  /**\n   * The host pool.\n   * @internal\n   * @ignore\n   * @type {HostConnectionPool}\n   */\n  Object.defineProperty(this, 'pool', { value: new HostConnectionPool(this, protocolVersion), enumerable: false});\n\n  const self = this;\n  this.pool.on('open', this._onNewConnectionOpen.bind(this));\n  this.pool.on('remove', function onConnectionRemovedFromPool() {\n    self._checkPoolState();\n  });\n  /**\n   * Gets string containing the Cassandra version.\n   * @type {String}\n   */\n  this.cassandraVersion = null;\n  /**\n   * Gets data center name of the node.\n   * @type {String}\n   */\n  this.datacenter = null;\n  /**\n   * Gets rack name of the node.\n   * @type {String}\n   */\n  this.rack = null;\n  /**\n   * Gets the tokens assigned to the node.\n   * @type {Array}\n   */\n  this.tokens = null;\n\n  /**\n   * Gets the id of the host.\n   * <p>This identifier is used by the server for internal communication / gossip.</p>\n   * @type {Uuid}\n   */\n  this.hostId = null;\n\n  // the distance as last set using the load balancing policy\n  this._distance = types.distance.ignored;\n  this._healthResponseCounter = 0;\n\n  // Make some of the private instance variables not enumerable to prevent from showing when inspecting\n  Object.defineProperty(this, '_metadata', { value: metadata, enumerable: false });\n  Object.defineProperty(this, '_healthResponseCountTimer', { value: null, enumerable: false, writable: true });\n\n  this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();\n  this.reconnectionDelay = 0;\n}\n\nutil.inherits(Host, events.EventEmitter);\n\n/**\n * Marks this host as not available for query coordination, when the host was previously marked as UP, otherwise its\n * a no-op.\n * @internal\n * @ignore\n */\nHost.prototype.setDown = function() {\n  // Multiple events signaling that a host is failing could cause multiple calls to this method\n  if (this.setDownAt !== 0) {\n    // the host is already marked as Down\n    return;\n  }\n\n  if (this.pool.isClosing()) {\n    // the pool is being closed/shutdown, don't mind\n    return;\n  }\n\n  this.setDownAt = Date.now();\n\n  if (this.pool.coreConnectionsLength > 0) {\n    // According to the distance, there should be connections open to it => issue a warning\n    this.log('warning', `Host ${this.address} considered as DOWN. Reconnection delay ${this.reconnectionDelay}ms.`);\n  } else {\n    this.log('info', `Host ${this.address} considered as DOWN.`);\n  }\n\n  this.emit('down');\n  this._checkPoolState();\n};\n\n/**\n * Marks this host as available for querying.\n * @param {Boolean} [clearReconnection]\n * @internal\n * @ignore\n */\nHost.prototype.setUp = function (clearReconnection) {\n  if (!this.setDownAt) {\n    //The host is already marked as UP\n    return;\n  }\n  this.log('info', util.format('Setting host %s as UP', this.address));\n  this.setDownAt = 0;\n  this.isUpSince = Date.now();\n  //if it was unhealthy and now it is not, lets reset the reconnection schedule.\n  this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();\n  if (clearReconnection) {\n    this.pool.clearNewConnectionAttempt();\n  }\n  this.emit('up');\n};\n\n/**\n * Resets the reconnectionSchedule and tries to issue a reconnection immediately.\n * @internal\n * @ignore\n */\nHost.prototype.checkIsUp = function () {\n  if (this.isUp()) {\n    return;\n  }\n  this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();\n  this.reconnectionDelay = 0;\n  this.pool.attemptNewConnectionImmediate();\n};\n\n/**\n * @param {Boolean} waitForPending When true, it waits for in-flight operations to be finish before closing the\n * connections.\n * @param {Function} [callback]\n * @internal\n * @ignore\n */\nHost.prototype.shutdown = function (waitForPending, callback) {\n  callback = callback || utils.noop;\n\n  if (this._healthResponseCountTimer) {\n    clearInterval(this._healthResponseCountTimer);\n  }\n\n  if (waitForPending) {\n    this.pool.drainAndShutdown();\n    // Gracefully draining and shutting down the pool is being done in the background, it's not required\n    // for the shutting down to be over to callback\n    return callback();\n  }\n\n  this.pool.shutdown(callback);\n};\n\n/**\n * Determines if the node is UP now (seen as UP by the driver).\n * @returns {boolean}\n */\nHost.prototype.isUp = function () {\n  return !this.setDownAt;\n};\n\n/**\n * Determines if the host can be considered as UP\n * @returns {boolean}\n */\nHost.prototype.canBeConsideredAsUp = function () {\n  const self = this;\n  function hasTimePassed() {\n    return new Date().getTime() - self.setDownAt >= self.reconnectionDelay;\n  }\n  return !this.setDownAt || hasTimePassed();\n};\n\n/**\n * Sets the distance of the host relative to the client using the load balancing policy.\n * @param {Number} distance\n * @internal\n * @ignore\n */\nHost.prototype.setDistance = function (distance) {\n  const previousDistance = this._distance;\n  this._distance = distance || types.distance.local;\n  if (this.options.pooling.coreConnectionsPerHost) {\n    this.pool.coreConnectionsLength = this.options.pooling.coreConnectionsPerHost[this._distance] || 0;\n  }\n  else {\n    this.pool.coreConnectionsLength = 1;\n  }\n  if (this._distance === previousDistance) {\n    return this._distance;\n  }\n\n  if (this._healthResponseCountTimer) {\n    clearInterval(this._healthResponseCountTimer);\n  }\n\n  if (this._distance === types.distance.ignored) {\n    // this host was local/remote and now must be ignored\n    this.emit('ignore');\n    this.pool.drainAndShutdown();\n  }\n  else {\n    if (!this.isUp()) {\n      this.checkIsUp();\n    }\n\n    // Reset the health check timer\n    this._healthResponseCountTimer = setInterval(() => {\n      this._healthResponseCounter = this.pool.getAndResetResponseCounter();\n    }, healthResponseCountInterval);\n  }\n\n  return this._distance;\n};\n\n/**\n * Changes the protocol version of a given host\n * @param {Number} value\n * @internal\n * @ignore\n */\nHost.prototype.setProtocolVersion = function (value) {\n  this.pool.protocolVersion = value;\n};\n\n/**\n * It gets an open connection to the host.\n * If there isn't an available connections, it will open a new one according to the pooling options.\n * @param {String} keyspace The keyspace that the connection must be using. When the keyspace provided is null, no\n * keyspace check is performed.\n * @param {Connection} previousConnection The previous connection. When provided, the pool should try to provide a\n * different connection.\n * @param {Function} callback\n * @internal\n * @ignore\n */\nHost.prototype.borrowConnection = function (keyspace, previousConnection, callback) {\n  if (previousConnection) {\n    // Obtain one of the existing connections\n    return this.pool.borrowConnection(keyspace, previousConnection, callback);\n  }\n\n  this.pool.createAndBorrowConnection(keyspace, callback);\n};\n\n/**\n * Creates all the connection in the pool.\n * @param {Function} callback\n * @internal\n * @ignore\n */\nHost.prototype.warmupPool = function (callback) {\n  this.pool.create(true, callback);\n};\n\n/**\n * Gets any connection that is already opened or null if not found.\n * @returns {Connection}\n * @internal\n * @ignore\n */\nHost.prototype.getActiveConnection = function () {\n  if (!this.isUp() || !this.pool.connections.length) {\n    return null;\n  }\n  return this.pool.connections[0];\n};\n\n/**\n * Internal method to get the amount of responses dequeued in the last interval (between 200ms and 400ms) on all\n * connections to the host.\n * @returns {Number}\n * @internal\n * @ignore\n */\nHost.prototype.getResponseCount = function () {\n  // Last interval plus the current count\n  return this._healthResponseCounter + this.pool.responseCounter;\n};\n\n/**\n * Checks the health of a connection in the pool\n * @param {Connection} connection\n * @internal\n * @ignore\n */\nHost.prototype.checkHealth = function (connection) {\n  if (connection.timedOutOperations <= this.options.socketOptions.defunctReadTimeoutThreshold) {\n    return;\n  }\n  this.removeFromPool(connection);\n};\n\n/**\n * @param {Connection} connection\n * @internal\n * @ignore\n */\nHost.prototype.removeFromPool = function (connection) {\n  this.pool.remove(connection);\n  this._checkPoolState();\n};\n\n/**\n * Internal method that gets the amount of in-flight requests on all connections to the host.\n * @internal\n * @ignore\n */\nHost.prototype.getInFlight = function () {\n  return this.pool.getInFlight();\n};\n\n/**\n * Validates that the internal state of the connection pool.\n * If the pool size is smaller than expected, schedule a new connection attempt.\n * If the amount of connections is 0 for not ignored hosts, the host must be down.\n * @private\n */\nHost.prototype._checkPoolState = function () {\n  if (this.pool.isClosing()) {\n    return;\n  }\n\n  if (this.pool.connections.length < this.pool.coreConnectionsLength) {\n    // the pool needs to grow / reconnect\n    if (!this.pool.hasScheduledNewConnection()) {\n      this.reconnectionDelay = this.reconnectionSchedule.next().value;\n      this.pool.scheduleNewConnectionAttempt(this.reconnectionDelay);\n    }\n  }\n\n  const shouldHaveConnections = this._distance !== types.distance.ignored && this.pool.coreConnectionsLength > 0;\n\n  if (shouldHaveConnections && this.pool.connections.length === 0) {\n    // Mark as DOWN, if its UP\n    this.setDown();\n  }\n};\n\n/**\n * Executed after an scheduled new connection attempt finished\n * @private\n */\nHost.prototype._onNewConnectionOpen = function (err) {\n  if (err) {\n    this._checkPoolState();\n    return;\n  }\n  const self = this;\n  function setUpAndContinue(err) {\n    if (err) {\n      self.log('warning', util.format('Failed re-preparing on host %s: %s', self.address, err), err);\n    }\n    self.setUp();\n    self.pool.increaseSize();\n  }\n  if (this.isUp() || !this.options.rePrepareOnUp) {\n    return setUpAndContinue();\n  }\n  this.log('info', util.format('Re-preparing all queries on host %s before setting it as UP', this.address));\n  const allPrepared = this._metadata.getAllPrepared();\n  PrepareHandler.prepareAllQueries(this, allPrepared, setUpAndContinue);\n};\n\n/**\n * Returns an array containing the Cassandra Version as an Array of Numbers having the major version in the first\n * position.\n * @returns {Array.<Number>}\n */\nHost.prototype.getCassandraVersion = function () {\n  if (!this.cassandraVersion) {\n    return utils.emptyArray;\n  }\n  return this.cassandraVersion.split('-')[0].split('.').map(x => parseInt(x, 10));\n};\n\nHost.prototype.log = utils.log;\n\n/**\n * Represents an associative-array of {@link Host hosts} that can be iterated.\n * It creates an internal copy when adding or removing, making it safe to iterate using the values() method within async operations.\n * @extends events.EventEmitter\n * @constructor\n */\nfunction HostMap() {\n  events.EventEmitter.call(this);\n  this._items = {};\n  this._values = null;\n  Object.defineProperty(this, 'length', { get: function () { return this.values().length; }, enumerable: true });\n}\n\nutil.inherits(HostMap, events.EventEmitter);\n\n/**\n * Emitted when a host is added to the map\n * @event HostMap#add\n */\n/**\n * Emitted when a host is removed from the map\n * @event HostMap#remove\n */\n\n/**\n * Executes a provided function once per map element.\n * @param callback\n */\nHostMap.prototype.forEach = function (callback) {\n  //Use a new reference, allowing the map to be modified.\n  const items = this._items;\n  for (const key in items) {\n    if (!items.hasOwnProperty(key)) {\n      continue;\n    }\n    callback(items[key], key);\n  }\n};\n\n/**\n * Gets a {@link Host host} by key or undefined if not found.\n * @param {String} key\n * @returns {Host}\n */\nHostMap.prototype.get = function (key) {\n  return this._items[key];\n};\n\n/**\n * Returns an array of host addresses.\n * @returns {Array.<String>}\n */\nHostMap.prototype.keys = function () {\n  return Object.keys(this._items);\n};\n\n/**\n * Removes an item from the map.\n * @param {String} key The key of the host\n * @fires HostMap#remove\n */\nHostMap.prototype.remove = function (key) {\n  if (!this._items.hasOwnProperty(key)) {\n    //it's not part of it, do nothing\n    return;\n  }\n  //clear cache\n  this._values = null;\n  //copy the values\n  const copy = utils.extend({}, this._items);\n  const h = copy[key];\n  delete copy[key];\n  this._items = copy;\n  this.emit('remove', h);\n};\n\n/**\n * Removes multiple hosts from the map.\n * @param {Array.<String>} keys\n * @fires HostMap#remove\n */\nHostMap.prototype.removeMultiple = function (keys) {\n  //clear value cache\n  this._values = null;\n  //copy the values\n  const copy = utils.extend({}, this._items);\n  const removedHosts = [];\n  for (let i = 0; i < keys.length; i++) {\n    const h = copy[keys[i]];\n    if (!h) {\n      continue;\n    }\n    removedHosts.push(h);\n    delete copy[keys[i]];\n  }\n  this._items = copy;\n  removedHosts.forEach(function (h) {\n    this.emit('remove', h);\n  }, this);\n};\n\n/**\n * Adds a new item to the map.\n * @param {String} key The key of the host\n * @param {Host} value The host to be added\n * @fires HostMap#remove\n * @fires HostMap#add\n */\nHostMap.prototype.set = function (key, value) {\n  //clear values cache\n  this._values = null;\n  const originalValue = this._items[key];\n  if (originalValue) {\n    //The internal structure does not change\n    this._items[key] = value;\n    //emit a remove followed by a add\n    this.emit('remove', originalValue);\n    this.emit('add', value);\n    return;\n  }\n  //copy the values\n  const copy = utils.extend({}, this._items);\n  copy[key] = value;\n  this._items = copy;\n  this.emit('add', value);\n  return value;\n};\n\n/**\n * Returns a shallow copy of a portion of the items into a new array object.\n * Backward-compatibility.\n * @param {Number} [begin]\n * @param {Number} [end]\n * @returns {Array}\n * @ignore\n */\nHostMap.prototype.slice = function (begin, end) {\n  if (!begin && !end) {\n    //avoid making a copy of the copy\n    return this.values();\n  }\n  begin = begin || 0;\n  return this.values().slice(begin, end);\n};\n//Backward-compatibility\nHostMap.prototype.push = HostMap.prototype.set;\n\n/**\n * Returns a shallow copy of the values of the map.\n * @returns {Array.<Host>}\n */\nHostMap.prototype.values = function () {\n  if (!this._values) {\n    //cache the values\n    const values = [];\n    for (const key in this._items) {\n      if (!this._items.hasOwnProperty(key)) {\n        continue;\n      }\n      values.push(this._items[key]);\n    }\n    this._values = Object.freeze(values);\n  }\n  return this._values;\n};\n\n/**\n * Removes all items from the map.\n * @returns {Array.<Host>} The previous items\n */\nHostMap.prototype.clear = function () {\n  const previousItems = this.values();\n  // Clear cache\n  this._values = null;\n  // Clear items\n  this._items = {};\n  for (let i = 0; i < previousItems.length; i++) {\n    this.emit('remove', previousItems[i]);\n  }\n  return previousItems;\n};\n\nHostMap.prototype.inspect = function() {\n  return this._items;\n};\n\nHostMap.prototype.toJSON = function() {\n  return this._items;\n};\n\nexports.Host = Host;\nexports.HostMap = HostMap;\n","'use strict';\n\nconst qModule = require('./q');\nconst QueryOperator = qModule.QueryOperator;\nconst QueryAssignment = qModule.QueryAssignment;\n\n/**\n * Provides utility methods for obtaining a caching keys based on the specifics of the Mapper methods.\n * @ignore\n */\nclass Cache {\n  /**\n   * Gets an iterator of keys to uniquely identify a document shape for a select query.\n   * @param {Array<String>} docKeys\n   * @param {Object} doc\n   * @param {{fields, limit, orderBy}} docInfo\n   * @returns {Iterator}\n   */\n  static *getSelectKey(docKeys, doc, docInfo) {\n    yield* Cache._yieldKeyAndOperators(docKeys, doc);\n\n    yield* Cache._getSelectDocInfo(docInfo);\n  }\n  /**\n   * Gets an iterator of keys to uniquely identify a shape for a select all query.\n   * @param {{fields, limit, orderBy}} docInfo\n   * @returns {Iterator}\n   */\n  static *getSelectAllKey(docInfo) {\n    yield 'root';\n\n    yield* Cache._getSelectDocInfo(docInfo);\n  }\n\n  /**\n   * Gets the parts of the key for a select query related to the docInfo.\n   * @param {{fields, limit, orderBy}} docInfo\n   * @private\n   */\n  static *_getSelectDocInfo(docInfo) {\n    if (docInfo) {\n      if (docInfo.fields && docInfo.fields.length > 0) {\n        // Use a separator from properties\n        yield '|f|';\n        yield* docInfo.fields;\n      }\n\n      if (typeof docInfo.limit === 'number') {\n        yield '|l|';\n      }\n\n      if (docInfo.orderBy && docInfo.orderBy.length > 0) {\n        yield '|o|';\n        yield* docInfo.orderBy;\n      }\n    }\n  }\n\n  /**\n   * Gets an iterator of keys to uniquely identify a document shape for an insert query.\n   * @param {Array<String>} docKeys\n   * @param {{ifNotExists, ttl, fields}} docInfo\n   */\n  static *getInsertKey(docKeys, docInfo) {\n    // No operator supported on INSERT values\n    yield* docKeys;\n\n    if (docInfo) {\n      if (docInfo.fields && docInfo.fields.length > 0) {\n        // Use a separator from properties\n        yield '|f|';\n        yield* docInfo.fields;\n      }\n\n      if (typeof docInfo.ttl === 'number') {\n        yield '|t|';\n      }\n\n      if (docInfo.ifNotExists) {\n        yield '|e|';\n      }\n    }\n  }\n\n  /**\n   * Gets an iterator of keys to uniquely identify a document shape for an UPDATE query.\n   * @param {Array<String>} docKeys\n   * @param {Object} doc\n   * @param {{ifExists, when, ttl, fields}} docInfo\n   */\n  static *getUpdateKey(docKeys, doc, docInfo) {\n    yield* Cache._yieldKeyAndAllQs(docKeys, doc);\n\n    if (docInfo) {\n      if (docInfo.fields && docInfo.fields.length > 0) {\n        // Use a separator from properties\n        yield '|f|';\n        yield* docInfo.fields;\n      }\n\n      if (typeof docInfo.ttl === 'number') {\n        yield '|t|';\n      }\n\n      if (docInfo.ifExists) {\n        yield '|e|';\n      }\n\n      if (docInfo.when) {\n        yield* Cache._yieldKeyAndOperators(Object.keys(docInfo.when), docInfo.when);\n      }\n    }\n  }\n\n  /**\n   * Gets an iterator of keys to uniquely identify a document shape for a DELETE query.\n   * @param {Array<String>} docKeys\n   * @param {Object} doc\n   * @param {{ifExists, when, fields, deleteOnlyColumns}} docInfo\n   */\n  static *getRemoveKey(docKeys, doc, docInfo) {\n    yield* Cache._yieldKeyAndOperators(docKeys, doc);\n\n    if (docInfo) {\n      if (docInfo.fields && docInfo.fields.length > 0) {\n        // Use a separator from properties\n        yield '|f|';\n        yield* docInfo.fields;\n      }\n\n      if (docInfo.ifExists) {\n        yield '|e|';\n      }\n\n      if (docInfo.deleteOnlyColumns) {\n        yield '|dc|';\n      }\n\n      if (docInfo.when) {\n        yield* Cache._yieldKeyAndOperators(Object.keys(docInfo.when), docInfo.when);\n      }\n    }\n  }\n\n  static *_yieldKeyAndOperators(keys, obj) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      yield key;\n      yield* Cache._yieldOperators(obj[key]);\n    }\n  }\n\n  static *_yieldOperators(value) {\n    if (value !== null && value !== undefined && value instanceof QueryOperator) {\n      yield value.key;\n      if (value.hasChildValues) {\n        yield* Cache._yieldOperators(value.value[0]);\n        yield '|/|';\n        yield* Cache._yieldOperators(value.value[1]);\n      }\n    }\n  }\n\n  static *_yieldKeyAndAllQs(keys, obj) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      yield key;\n      const value = obj[key];\n      if (value !== null && value !== undefined) {\n        if (value instanceof QueryOperator) {\n          yield* Cache._yieldOperators(value);\n        }\n        else if (value instanceof QueryAssignment) {\n          yield value.sign;\n          yield value.inverted;\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = Cache;","'use strict';\n\nconst errors = require('../errors');\nconst utils = require('../utils');\n\n/**\n * Provides utility methods to adapt and map user provided docInfo and executionOptions to a predictable object format.\n * @ignore\n */\nclass DocInfoAdapter {\n  /**\n   * Returns an Array where each item contains the property name, the column name and the property value (to obtain\n   * the operator).\n   * When docInfo.fields is specified, it uses that array to obtain the information.\n   * @param {Array<String>} docKeys\n   * @param {null|{fields}} docInfo\n   * @param {Object} doc\n   * @param {ModelMappingInfo} mappingInfo\n   * @returns {Array}\n   */\n  static getPropertiesInfo(docKeys, docInfo, doc, mappingInfo) {\n    let propertyKeys = docKeys;\n    if (docInfo && docInfo.fields && docInfo.fields.length > 0) {\n      propertyKeys = docInfo.fields;\n    }\n\n    return propertyKeys.map(propertyName => ({\n      propertyName, columnName: mappingInfo.getColumnName(propertyName), value: doc[propertyName]\n    }));\n  }\n\n  /**\n   * @param {{orderBy}} docInfo\n   * @param {ModelMappingInfo} mappingInfo\n   * @returns {Array<String>}\n   */\n  static adaptOrderBy(docInfo, mappingInfo){\n    if (!docInfo || !docInfo.orderBy) {\n      return utils.emptyArray;\n    }\n    return Object.keys(docInfo.orderBy).map(key => {\n      const value = docInfo.orderBy[key];\n      const ordering = typeof value === 'string' ? value.toUpperCase() : value;\n      if (ordering !== 'ASC' && ordering !== 'DESC') {\n        throw new errors.ArgumentError('Order must be either \"ASC\" or \"DESC\", obtained: ' + value);\n      }\n      return [ mappingInfo.getColumnName(key), ordering ];\n    });\n  }\n\n  /**\n   * Returns the QueryOptions for an INSERT/UPDATE/DELETE statement.\n   * @param {Object|String|undefined} executionOptions\n   * @param {Boolean} isIdempotent\n   */\n  static adaptOptions(executionOptions, isIdempotent) {\n    const options = {\n      prepare: true,\n      executionProfile: undefined,\n      timestamp: undefined,\n      isIdempotent: isIdempotent\n    };\n\n    if (typeof executionOptions === 'string') {\n      options.executionProfile = executionOptions;\n    }\n    else if (executionOptions !== null && executionOptions !== undefined) {\n      options.executionProfile = executionOptions.executionProfile;\n      options.timestamp = executionOptions.timestamp;\n\n      if (executionOptions.isIdempotent !== undefined) {\n        options.isIdempotent = executionOptions.isIdempotent;\n      }\n    }\n    return options;\n  }\n\n  /**\n   * Returns the QueryOptions for a SELECT statement.\n   * @param {Object|String|undefined} executionOptions\n   * @param {Boolean} [overrideIdempotency]\n   */\n  static adaptAllOptions(executionOptions, overrideIdempotency) {\n    const options = {\n      prepare: true,\n      executionProfile: undefined,\n      fetchSize: undefined,\n      pageState: undefined,\n      timestamp: undefined,\n      isIdempotent: undefined\n    };\n\n    if (typeof executionOptions === 'string') {\n      options.executionProfile = executionOptions;\n    }\n    else if (executionOptions !== null && executionOptions !== undefined) {\n      options.executionProfile = executionOptions.executionProfile;\n      options.fetchSize = executionOptions.fetchSize;\n      options.pageState = executionOptions.pageState;\n      options.timestamp = executionOptions.timestamp;\n      options.isIdempotent = executionOptions.isIdempotent;\n    }\n\n    if (overrideIdempotency) {\n      options.isIdempotent = true;\n    }\n\n    return options;\n  }\n\n  /**\n   * Returns the QueryOptions for a batch statement.\n   * @param {Object|String|undefined} executionOptions\n   * @param {Boolean} isIdempotent\n   * @param {Boolean} isCounter\n   */\n  static adaptBatchOptions(executionOptions, isIdempotent, isCounter) {\n    const options = {\n      prepare: true,\n      executionProfile: undefined,\n      timestamp: undefined,\n      logged: undefined,\n      isIdempotent: isIdempotent,\n      counter: isCounter\n    };\n\n    if (typeof executionOptions === 'string') {\n      options.executionProfile = executionOptions;\n    }\n    else if (executionOptions !== null && executionOptions !== undefined) {\n      options.executionProfile = executionOptions.executionProfile;\n      options.timestamp = executionOptions.timestamp;\n      options.logged = executionOptions.logged !== false;\n\n      if (executionOptions.isIdempotent !== undefined) {\n        options.isIdempotent = executionOptions.isIdempotent;\n      }\n    }\n    return options;\n  }\n}\n\nmodule.exports = DocInfoAdapter;","'use strict';\n\n/**\n * Module containing classes and fields related to the Mapper.\n * @module mapping\n */\n\nexports.Mapper = require('./mapper');\nexports.ModelMapper = require('./model-mapper');\nexports.ModelBatchMapper = require('./model-batch-mapper');\nexports.ModelBatchItem = require('./model-batch-item');\nexports.Result = require('./result');\nconst tableMappingsModule = require('./table-mappings');\nexports.TableMappings = tableMappingsModule.TableMappings;\nexports.DefaultTableMappings = tableMappingsModule.DefaultTableMappings;\nexports.UnderscoreCqlToCamelCaseMappings = tableMappingsModule.UnderscoreCqlToCamelCaseMappings;\nexports.q = require('./q').q;","'use strict';\n\nconst ModelMapper = require('./model-mapper');\nconst MappingHandler = require('./mapping-handler');\nconst DocInfoAdapter = require('./doc-info-adapter');\nconst errors = require('../errors');\nconst Result = require('./result');\nconst ResultMapper = require('./result-mapper');\nconst ModelMappingInfo = require('./model-mapping-info');\nconst ModelBatchItem = require('./model-batch-item');\n\n/**\n * Represents an object mapper for Apache Cassandra and DataStax Enterprise.\n * @alias module:mapping~Mapper\n * @example <caption>Creating a Mapper instance with some options for the model 'User'</caption>\n * const mappingOptions = {\n *   models: {\n *     'User': {\n *       tables: ['users'],\n *       mappings: new UnderscoreCqlToCamelCaseMappings(),\n *       columnNames: {\n *         'userid': 'id'\n *       }\n *     }\n *   }\n * };\n * const mapper = new Mapper(client, mappingOptions);\n * @example <caption>Creating a Mapper instance with other possible options for a model</caption>\n * const mappingOptions = {\n *   models: {\n *     'Video': {\n *       tables: ['videos', 'user_videos', 'latest_videos', { name: 'my_videos_view', isView: true }],\n *       mappings: new UnderscoreCqlToCamelCaseMappings(),\n *       columnNames: {\n *         'videoid': 'id'\n *       },\n *       keyspace: 'ks1'\n *     }\n *   }\n * };\n * const mapper = new Mapper(client, mappingOptions);\n */\nclass Mapper {\n  /**\n   * Creates a new instance of Mapper.\n   * @param {Client} client The Client instance to use to execute the queries and fetch the metadata.\n   * @param {MappingOptions} [options] The [MappingOptions]{@link module:mapping~MappingOptions} containing the\n   * information of the models and table mappings.\n   */\n  constructor(client, options) {\n    if (!client) {\n      throw new Error('client must be defined');\n    }\n\n    /**\n     * The Client instance used to create this Mapper instance.\n     * @type {Client}\n     */\n    this.client = client;\n\n    this._modelMappingInfos = ModelMappingInfo.parse(options, client.keyspace);\n    this._modelMappers = new Map();\n  }\n\n  /**\n   * Gets a [ModelMapper]{@link module:mapping~ModelMapper} that is able to map documents of a certain model into\n   * CQL rows.\n   * @param {String} name The name to identify the model. Note that the name is case-sensitive.\n   * @returns {ModelMapper} A [ModelMapper]{@link module:mapping~ModelMapper} instance.\n   */\n  forModel(name) {\n    let modelMapper = this._modelMappers.get(name);\n\n    if (modelMapper === undefined) {\n      let mappingInfo = this._modelMappingInfos.get(name);\n\n      if (mappingInfo === undefined) {\n        if (!this.client.keyspace) {\n          throw new Error(\n            'You must set the Client keyspace or specify the keyspace of the model in the MappingOptions');\n        }\n\n        mappingInfo = ModelMappingInfo.createDefault(name, this.client.keyspace);\n      }\n\n      modelMapper = new ModelMapper(name, new MappingHandler(this.client, mappingInfo));\n      this._modelMappers.set(name, modelMapper);\n    }\n\n    return modelMapper;\n  }\n\n  /**\n   * Executes a batch of queries represented in the items.\n   * @param {Array<ModelBatchItem>} items\n   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests\n   * execution or a string representing the name of the execution profile.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without\n   * changing the result beyond the initial application.\n   * <p>\n   *   The mapper uses the generated queries to determine the default value. When an UPDATE is generated with a\n   *   counter column or appending/prepending to a list column, the execution is marked as not idempotent.\n   * </p>\n   * <p>\n   *   Additionally, the mapper uses the safest approach for queries with lightweight transactions (Compare and\n   *   Set) by considering them as non-idempotent. Lightweight transactions at client level with transparent retries can\n   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.\n   * </p>\n   * @param {Boolean} [executionOptions.logged=true] Determines whether the batch should be written to the batchlog.\n   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the\n   * unix epoch (00:00:00, January 1st, 1970).\n   * @returns {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result}.\n   */\n  batch(items, executionOptions) {\n    if (!Array.isArray(items) || !(items.length > 0)) {\n      return Promise.reject(\n        new errors.ArgumentError('First parameter items should be an Array with 1 or more ModelBatchItem instances'));\n    }\n\n    const queries = [];\n    let isIdempotent = true;\n    let isCounter;\n\n    return Promise\n      .all(items\n        .map(item => {\n          if (!(item instanceof ModelBatchItem)) {\n            return Promise.reject(new Error(\n              'Batch items must be instances of ModelBatchItem, use modelMapper.batching object to create each item'));\n          }\n\n          return item.pushQueries(queries)\n            .then(options => {\n              // The batch is idempotent when all the queries contained are idempotent\n              isIdempotent = isIdempotent && options.isIdempotent;\n\n              // Let it fail at server level when there is a mix of counter and normal mutations\n              isCounter = options.isCounter;\n            });\n        }))\n      .then(() =>\n        this.client.batch(queries, DocInfoAdapter.adaptBatchOptions(executionOptions, isIdempotent, isCounter)))\n      .then(rs => {\n        // Results should only be adapted when the batch contains LWT (single table)\n        const info = items[0].getMappingInfo();\n        return new Result(rs, info, ResultMapper.getMutationAdapter(rs));\n      });\n  }\n}\n\n/**\n * Represents the mapping options.\n * @typedef {Object} module:mapping~MappingOptions\n * @property {Object<String, ModelOptions>} models An associative array containing the\n * name of the model as key and the table and column information as value.\n */\n\n/**\n * Represents a set of options that applies to a certain model.\n * @typedef {Object} module:mapping~ModelOptions\n * @property {Array<String>|Array<{name, isView}>} tables An Array containing the name of the tables or An Array\n * containing the name and isView property to describe the table.\n * @property {TableMappings} mappings The TableMappings implementation instance that is used to convert from column\n * names to property names and the other way around.\n * @property {Object.<String, String>} [columnNames] An associative array containing the name of the columns and\n * properties that doesn't follow the convention defined in the <code>TableMappings</code>.\n * @property {String} [keyspace] The name of the keyspace. Only mandatory when the Client is not using a keyspace.\n */\n\nmodule.exports = Mapper;","'use strict';\n\nconst utils = require('../utils');\nconst QueryGenerator = require('./query-generator');\nconst ResultMapper = require('./result-mapper');\nconst Result = require('./result');\nconst Cache = require('./cache');\nconst Tree = require('./tree');\nconst ObjectSelector = require('./object-selector');\nconst DocInfoAdapter = require('./doc-info-adapter');\n\nconst cacheHighWaterMark = 100;\n\n/**\n * @ignore\n */\nclass MappingHandler {\n  /**\n   * @param {Client} client\n   * @param {ModelMappingInfo} mappingInfo\n   */\n  constructor(client, mappingInfo) {\n    this._client = client;\n    this._cache = {\n      select: new Tree().on('add', length => this._validateCacheLength(length)),\n      selectAll: new Tree().on('add', length => this._validateCacheLength(length)),\n      insert: new Tree().on('add', length => this._validateCacheLength(length)),\n      update: new Tree().on('add', length => this._validateCacheLength(length)),\n      remove: new Tree().on('add', length => this._validateCacheLength(length)),\n      customQueries: new Map()\n    };\n\n    /**\n     * Gets the mapping information of the document.\n     * @type {ModelMappingInfo}\n     */\n    this.info = mappingInfo;\n  }\n\n  /**\n   * Gets a function to be used to execute SELECT the query using the document.\n   * @param {Object} doc\n   * @param {{fields, orderBy, limit}} docInfo\n   * @param {Boolean} allPKsDefined Determines whether all primary keys must be defined in the doc for the query to\n   * be valid.\n   * @return {Promise<Function>}\n   */\n  getSelectExecutor(doc, docInfo, allPKsDefined) {\n    const docKeys = Object.keys(doc);\n    if (docKeys.length === 0) {\n      return Promise.reject(new Error('Expected object with keys'));\n    }\n\n    const cacheKey = Cache.getSelectKey(docKeys, doc, docInfo);\n    // Cache the executor and the result mapper under the same key\n    // That way, those can get evicted together\n    const cacheItem = this._cache.select.getOrCreate(cacheKey, () => ({ executor: null, resultAdapter: null }));\n\n    if (cacheItem.executor !== null) {\n      return Promise.resolve(cacheItem.executor);\n    }\n\n    const propertiesInfo = DocInfoAdapter.getPropertiesInfo(docKeys, null, doc, this.info);\n    const fieldsInfo = DocInfoAdapter.getPropertiesInfo(utils.emptyArray, docInfo, doc, this.info);\n    const orderByColumns = DocInfoAdapter.adaptOrderBy(docInfo, this.info);\n    const limit = docInfo && docInfo.limit;\n\n    return this._client.connect()\n      .then(() =>\n        ObjectSelector.getForSelect(this._client, this.info, allPKsDefined, propertiesInfo, fieldsInfo, orderByColumns))\n      .then(tableName => {\n        // Part of the closure\n        const query = QueryGenerator.getSelect(tableName, this.info.keyspace, propertiesInfo, fieldsInfo,\n          orderByColumns, limit);\n        const paramsGetter = QueryGenerator.selectParamsGetter(propertiesInfo, limit);\n        const self = this;\n\n        cacheItem.executor = function selectExecutor(doc, docInfo, executionOptions) {\n          return self._executeSelect(query, paramsGetter, doc, docInfo, executionOptions, cacheItem);\n        };\n\n        return cacheItem.executor;\n      });\n  }\n\n  getSelectAllExecutor(docInfo) {\n    const cacheKey = Cache.getSelectAllKey(docInfo);\n    const cacheItem = this._cache.selectAll.getOrCreate(cacheKey, () => ({ executor: null, resultAdapter: null }));\n\n    if (cacheItem.executor !== null) {\n      return cacheItem.executor;\n    }\n\n    const fieldsInfo = DocInfoAdapter.getPropertiesInfo(utils.emptyArray, docInfo, utils.emptyObject, this.info);\n    const orderByColumns = DocInfoAdapter.adaptOrderBy(docInfo, this.info);\n    const limit = docInfo && docInfo.limit;\n\n    const tableName = ObjectSelector.getForSelectAll(this.info);\n\n    // Part of the closure\n    const query = QueryGenerator.getSelect(\n      tableName, this.info.keyspace, utils.emptyArray, fieldsInfo, orderByColumns, limit);\n    const paramsGetter = QueryGenerator.selectParamsGetter(utils.emptyArray, limit);\n    const self = this;\n\n    cacheItem.executor = function selectAllExecutor(docInfo, executionOptions) {\n      return self._executeSelect(query, paramsGetter, null, docInfo, executionOptions, cacheItem);\n    };\n\n    return cacheItem.executor;\n  }\n\n  /**\n   * Executes a SELECT query and returns the adapted results.\n   * When a result adapter is not yet created, it gets a new one and caches it.\n   * @private\n   */\n  _executeSelect(query, paramsGetter, doc, docInfo, executionOptions, cacheItem) {\n    const options = DocInfoAdapter.adaptAllOptions(executionOptions, true);\n\n    return this._client.execute(query, paramsGetter(doc, docInfo), options)\n      .then(rs => {\n        if (cacheItem.resultAdapter === null) {\n          cacheItem.resultAdapter = ResultMapper.getSelectAdapter(this.info, rs);\n        }\n        return new Result(rs, this.info, cacheItem.resultAdapter);\n      });\n  }\n\n  /**\n   * Gets a function to be used to execute INSERT the query using the document.\n   * @param {Object} doc\n   * @param {{ifNotExists, ttl, fields}} docInfo\n   * @return {Promise<Function>}\n   */\n  getInsertExecutor(doc, docInfo) {\n    const docKeys = Object.keys(doc);\n    if (docKeys.length === 0) {\n      return Promise.reject(new Error('Expected object with keys'));\n    }\n\n    const cacheKey = Cache.getInsertKey(docKeys, docInfo);\n    const cacheItem = this._cache.insert.getOrCreate(cacheKey, () => ({ executor: null }));\n\n    if (cacheItem.executor !== null) {\n      return Promise.resolve(cacheItem.executor);\n    }\n\n    return this.createInsertQueries(docKeys, doc, docInfo)\n      .then(queries => {\n        if (queries.length === 1) {\n          return this._setSingleExecutor(cacheItem, queries[0]);\n        }\n\n        return this._setBatchExecutor(cacheItem, queries);\n      });\n  }\n\n  /**\n   * Creates an Array containing the query and the params getter function for each table affected by the INSERT.\n   * @param {Array<String>} docKeys\n   * @param {Object} doc\n   * @param {{ifNotExists, ttl, fields}} docInfo\n   * @returns {Promise<Array<{query, paramsGetter}>>}\n   */\n  createInsertQueries(docKeys, doc, docInfo) {\n    const propertiesInfo = DocInfoAdapter.getPropertiesInfo(docKeys, docInfo, doc, this.info);\n    const ifNotExists = docInfo && docInfo.ifNotExists;\n\n    // Get all the tables affected\n    return this._client.connect()\n      .then(() => ObjectSelector.getForInsert(this._client, this.info, propertiesInfo))\n      .then(tables => {\n\n        if (tables.length > 1 && ifNotExists) {\n          throw new Error('Batch with ifNotExists conditions cannot span multiple tables');\n        }\n\n        // For each tables affected, Generate query and parameter getters\n        return tables.map(table =>\n          QueryGenerator.getInsert(table, this.info.keyspace, propertiesInfo, docInfo,ifNotExists));\n      });\n  }\n\n  /**\n   * Gets a function to be used to execute the UPDATE queries with the provided document.\n   * @param {Object} doc\n   * @param {{ifExists, when, ttl, fields}} docInfo\n   * @return {Promise<Function>}\n   */\n  getUpdateExecutor(doc, docInfo) {\n    const docKeys = Object.keys(doc);\n    if (docKeys.length === 0) {\n      return Promise.reject(new Error('Expected object with keys'));\n    }\n\n    const cacheKey = Cache.getUpdateKey(docKeys, doc, docInfo);\n    const cacheItem = this._cache.update.getOrCreate(cacheKey, () => ({ executor: null }));\n\n    if (cacheItem.executor !== null) {\n      return Promise.resolve(cacheItem.executor);\n    }\n\n    return this.createUpdateQueries(docKeys, doc, docInfo)\n      .then(queries => {\n        if (queries.length === 1) {\n          return this._setSingleExecutor(cacheItem, queries[0]);\n        }\n\n        return this._setBatchExecutor(cacheItem, queries);\n      });\n  }\n\n  /**\n   * Creates an Array containing the query and the params getter function for each table affected by the UPDATE.\n   * @param {Array<String>} docKeys\n   * @param {Object} doc\n   * @param {Object} docInfo\n   * @returns {Promise<Array<{query, paramsGetter, isIdempotent}>>}\n   */\n  createUpdateQueries(docKeys, doc, docInfo) {\n    const propertiesInfo = DocInfoAdapter.getPropertiesInfo(docKeys, docInfo, doc, this.info);\n    const ifExists = docInfo && docInfo.ifExists;\n    const when = docInfo && docInfo.when\n      ? DocInfoAdapter.getPropertiesInfo(Object.keys(docInfo.when), null, docInfo.when, this.info)\n      : utils.emptyArray;\n\n    if (when.length > 0 && ifExists) {\n      throw new Error('Both when and ifExists conditions can not be applied to the same statement');\n    }\n\n    // Get all the tables affected\n    return this._client.connect()\n      .then(() => ObjectSelector.getForUpdate(this._client, this.info, propertiesInfo, when))\n      .then(tables => {\n\n        if (tables.length > 1 && (when.length > 0 || ifExists)) {\n          throw new Error('Batch with when or ifExists conditions cannot span multiple tables');\n        }\n\n        // For each table affected, Generate query and parameter getters\n        return tables.map(table =>\n          QueryGenerator.getUpdate(table, this.info.keyspace, propertiesInfo, docInfo, when, ifExists));\n      });\n  }\n\n  /**\n   * Gets a function to be used to execute the DELETE queries with the provided document.\n   * @param {Object} doc\n   * @param {{when, ifExists, fields, deleteOnlyColumns}} docInfo\n   * @return {Promise<Function>}\n   */\n  getDeleteExecutor(doc, docInfo) {\n    const docKeys = Object.keys(doc);\n    if (docKeys.length === 0) {\n      return Promise.reject(new Error('Expected object with keys'));\n    }\n\n    const cacheKey = Cache.getRemoveKey(docKeys, doc, docInfo);\n    const cacheItem = this._cache.remove.getOrCreate(cacheKey, () => ({ executor: null }));\n\n    if (cacheItem.executor !== null) {\n      return Promise.resolve(cacheItem.executor);\n    }\n\n    return this.createDeleteQueries(docKeys, doc, docInfo)\n      .then(queries => {\n        if (queries.length === 1) {\n          return this._setSingleExecutor(cacheItem, queries[0]);\n        }\n\n        return this._setBatchExecutor(cacheItem, queries);\n      });\n  }\n\n  /**\n   * Creates an Array containing the query and the params getter function for each table affected by the DELETE.\n   * @param {Array<String>} docKeys\n   * @param {Object} doc\n   * @param {{when, ifExists, fields, deleteOnlyColumns}} docInfo\n   * @returns {Promise<Array<{query, paramsGetter}>>}\n   */\n  createDeleteQueries(docKeys, doc, docInfo) {\n    const propertiesInfo = DocInfoAdapter.getPropertiesInfo(docKeys, docInfo, doc, this.info);\n    const ifExists = docInfo && docInfo.ifExists;\n    const when = docInfo && docInfo.when\n      ? DocInfoAdapter.getPropertiesInfo(Object.keys(docInfo.when), null, docInfo.when, this.info)\n      : utils.emptyArray;\n\n    if (when.length > 0 && ifExists) {\n      throw new Error('Both when and ifExists conditions can not be applied to the same statement');\n    }\n\n    // Get all the tables affected\n    return this._client.connect()\n      .then(() => ObjectSelector.getForDelete(this._client, this.info, propertiesInfo, when))\n      .then(tables => {\n\n        if (tables.length > 1 && (when.length > 0 || ifExists)) {\n          throw new Error('Batch with when or ifExists conditions cannot span multiple tables');\n        }\n\n        // For each tables affected, Generate query and parameter getters\n        return tables.map(table =>\n          QueryGenerator.getDelete(table, this.info.keyspace, propertiesInfo, docInfo, when, ifExists));\n      });\n  }\n\n  getExecutorFromQuery(query, paramsHandler, commonExecutionOptions) {\n    // Use the current instance in the closure\n    // as there is no guarantee of how the returned function will be invoked\n    const self = this;\n    const commonOptions = commonExecutionOptions ? DocInfoAdapter.adaptAllOptions(commonExecutionOptions) : null;\n\n    return (function queryMappedExecutor(doc, executionOptions) {\n      // When the executionOptions were already specified,\n      // use it and skip the ones provided in each invocation\n      const options = commonOptions\n        ? commonOptions\n        : DocInfoAdapter.adaptAllOptions(executionOptions);\n\n      return self._client.execute(query, paramsHandler(doc), options).then(rs => {\n        // Cache the resultAdapter based on the query\n        let resultAdapter = self._cache.customQueries.get(query);\n\n        if (resultAdapter === undefined) {\n          const resultAdapterInfo = ResultMapper.getCustomQueryAdapter(self.info, rs);\n          resultAdapter = resultAdapterInfo.fn;\n          if (resultAdapterInfo.canCache) {\n            // Avoid caching conditional updates results as the amount of columns change\n            // depending on the parameter values.\n            self._cache.customQueries.set(query, resultAdapter);\n\n            if (self._cache.customQueries.size === cacheHighWaterMark) {\n              self._client.log('warning',\n                `Custom queries cache reached ${cacheHighWaterMark} items, this could be caused by ` +\n                `hard-coding parameter values inside the query, which should be avoided`);\n            }\n          }\n        }\n\n        return new Result(rs, self.info, resultAdapter);\n      });\n    });\n  }\n\n  _setSingleExecutor(cacheItem, queryInfo) {\n    // Parameters and this instance are part of the closure\n    const self = this;\n\n    // Set the function to execute the request in the cache\n    cacheItem.executor = function singleExecutor(doc, docInfo, executionOptions) {\n      const options = DocInfoAdapter.adaptOptions(executionOptions, queryInfo.isIdempotent);\n\n      return self._client.execute(queryInfo.query, queryInfo.paramsGetter(doc, docInfo), options)\n        .then(rs => new Result(rs, self.info, ResultMapper.getMutationAdapter(rs)));\n    };\n\n    return cacheItem.executor;\n  }\n\n  _setBatchExecutor(cacheItem, queries) {\n    // Parameters and the following fields are part of the closure\n    const self = this;\n    const isIdempotent = queries.reduce((acc, q) => acc && q.isIdempotent, true);\n\n    // Set the function to execute the batch request in the cache\n    cacheItem.executor = function batchExecutor(doc, docInfo, executionOptions) {\n      // Use the params getter function to obtain the parameters each time\n      const queryAndParams = queries.map(q => ({\n        query: q.query,\n        params: q.paramsGetter(doc, docInfo)\n      }));\n\n      const options = DocInfoAdapter.adaptOptions(executionOptions, isIdempotent);\n\n      // Execute using a Batch\n      return self._client.batch(queryAndParams, options)\n        .then(rs => new Result(rs, self.info, ResultMapper.getMutationAdapter(rs)));\n    };\n\n    return cacheItem.executor;\n  }\n\n  _validateCacheLength(length) {\n    if (length !== cacheHighWaterMark) {\n      return;\n    }\n\n    this._client.log('warning', `ModelMapper cache reached ${cacheHighWaterMark} items, this could be caused by ` +\n      `building the object to map in different ways (with different shapes) each time. Use the same or few object ` +\n      `structures for a model and represent unset values with undefined or types.unset`);\n  }\n}\n\nmodule.exports = MappingHandler;","'use strict';\n\n/**\n * Represents a query or a set of queries used to perform a mutation in a batch.\n * @alias module:mapping~ModelBatchItem\n */\nclass ModelBatchItem {\n  /**\n   * @param {Promise<Array>} queries\n   * @param {Object} doc\n   * @param {Object} docInfo\n   * @param {ModelMappingInfo} mappingInfo\n   */\n  constructor(queries, doc, docInfo, mappingInfo) {\n    this._queries = queries;\n    this._doc = doc;\n    this._docInfo = docInfo;\n    this._mappingInfo = mappingInfo;\n  }\n\n  /**\n   * Pushes the queries and parameters represented by this instance to the provided array.\n   * @internal\n   * @ignore\n   * @param {Array} arr\n   * @return {Promise<{isIdempotent, isCounter}>}\n   */\n  pushQueries(arr) {\n    let isIdempotent = true;\n    let isCounter;\n    return this._queries.then(queries => {\n      queries.forEach(q => {\n        // It's idempotent if all the queries contained are idempotent\n        isIdempotent = isIdempotent && q.isIdempotent;\n\n        // Either all queries are counter mutation or we let it fail at server level\n        isCounter = q.isCounter;\n\n        arr.push({ query: q.query, params: q.paramsGetter(this._doc, this._docInfo) });\n      });\n\n      return { isIdempotent, isCounter };\n    });\n  }\n\n  /**\n   * Gets the mapping information for this batch item.\n   * @internal\n   * @ignore\n   */\n  getMappingInfo() {\n    return this._mappingInfo;\n  }\n}\n\nmodule.exports = ModelBatchItem;","'use strict';\n\nconst Cache = require('./cache');\nconst Tree = require('./tree');\nconst ModelBatchItem = require('./model-batch-item');\n\n/**\n * Provides utility methods to group multiple mutations on a single batch.\n * @alias module:mapping~ModelBatchMapper\n */\nclass ModelBatchMapper {\n  /**\n   * Creates a new instance of model batch mapper.\n   * <p>\n   *   An instance of this class is exposed as a singleton in the <code>batching</code> field of the\n   *   [ModelMapper]{@link module:mapping~ModelMapper}. Note that new instances should not be create with this\n   *   constructor.\n   * </p>\n   * @param {MappingHandler} handler\n   * @ignore\n   */\n  constructor(handler) {\n    this._handler = handler;\n    this._cache = {\n      insert: new Tree(),\n      update: new Tree(),\n      remove: new Tree()\n    };\n  }\n\n  /**\n   * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem} containing the queries for the INSERT mutation to be\n   * used in a batch execution.\n   * @param {Object} doc An object containing the properties to insert.\n   * @param {Object} [docInfo] An object containing the additional document information.\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * INSERT cql statements generated. If specified, it must include the columns to insert and the primary keys.\n   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.\n   * @param {Boolean} [docInfo.ifNotExists] When set, it only inserts if the row does not exist prior to the insertion.\n   * <p>Please note that using IF NOT EXISTS will incur a non negligible performance cost so this should be used\n   * sparingly.</p>\n   * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query\n   * or a set of queries to be included in a batch.\n   */\n  insert(doc, docInfo) {\n    const docKeys = Object.keys(doc);\n    const cacheKey = Cache.getInsertKey(docKeys, docInfo);\n    const cacheItem = this._cache.insert.getOrCreate(cacheKey, () => ({ queries: null }));\n\n    if (cacheItem.queries === null) {\n      cacheItem.queries = this._handler.createInsertQueries(docKeys, doc, docInfo);\n    }\n\n    return new ModelBatchItem(cacheItem.queries, doc, docInfo, this._handler.info);\n  }\n\n  /**\n   * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem} containing the queries for the UPDATE mutation to be\n   * used in a batch execution.\n   * @param {Object} doc An object containing the properties to update.\n   * @param {Object} [docInfo] An object containing the additional document information.\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * UPDATE cql statements generated. If specified, it must include the columns to update and the primary keys.\n   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.\n   * @param {Boolean} [docInfo.ifExists] When set, it only updates if the row already exists on the server.\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the UPDATE to occur.\n   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query\n   * or a set of queries to be included in a batch.\n   */\n  update(doc, docInfo) {\n    const docKeys = Object.keys(doc);\n    const cacheKey = Cache.getUpdateKey(docKeys, doc, docInfo);\n    const cacheItem = this._cache.update.getOrCreate(cacheKey, () => ({ queries: null }));\n\n    if (cacheItem.queries === null) {\n      cacheItem.queries = this._handler.createUpdateQueries(docKeys, doc, docInfo);\n    }\n\n    return new ModelBatchItem(cacheItem.queries, doc, docInfo, this._handler.info);\n  }\n\n  /**\n   * Gets a [ModelBatchItem]{@link module:mapping~ModelBatchItem}  containing the queries for the DELETE mutation to be\n   * used in a batch execution.\n   * @param {Object} doc A document containing the primary keys values of the document to delete.\n   * @param {Object} [docInfo] An object containing the additional doc information.\n   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the DELETE to occur.\n   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).\n   * When the CQL query is generated, this would be used to generate the `IF` clause.\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @param {Boolean} [docInfo.ifExists] When set, it only issues the DELETE command if the row already exists on the\n   * server.\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * DELETE cql statement generated. If specified, it must include the columns to delete and the primary keys.\n   * @param {Boolean} [docInfo.deleteOnlyColumns] Determines that, when more document properties are specified\n   * besides the primary keys, the generated DELETE statement should be used to delete some column values but leave\n   * the row. When this is enabled and more properties are specified, a DELETE statement will have the following form:\n   * \"DELETE col1, col2 FROM table1 WHERE pk1 = ? AND pk2 = ?\"\n   * @returns {ModelBatchItem} A [ModelBatchItem]{@link module:mapping~ModelBatchItem} instance representing a query\n   * or a set of queries to be included in a batch.\n   */\n  remove(doc, docInfo) {\n    const docKeys = Object.keys(doc);\n    const cacheKey = Cache.getRemoveKey(docKeys, doc, docInfo);\n    const cacheItem = this._cache.remove.getOrCreate(cacheKey, () => ({ queries: null }));\n\n    if (cacheItem.queries === null) {\n      cacheItem.queries = this._handler.createDeleteQueries(docKeys, doc, docInfo);\n    }\n\n    return new ModelBatchItem(cacheItem.queries, doc, docInfo, this._handler.info);\n  }\n}\n\nmodule.exports = ModelBatchMapper;","'use strict';\n\nconst ModelBatchMapper = require('./model-batch-mapper');\n\n/**\n * Represents an object mapper for a specific model.\n * @alias module:mapping~ModelMapper\n */\nclass ModelMapper {\n  constructor(name, handler) {\n    /**\n     * Gets the name identifier of the model.\n     * @type {String}\n     */\n    this.name = name;\n    this._handler = handler;\n    /**\n     * Gets a [ModelBatchMapper]{@link module:mapping~ModelBatchMapper} instance containing utility methods to group\n     * multiple doc mutations in a single batch.\n     * @type {ModelBatchMapper}\n     */\n    this.batching = new ModelBatchMapper(this._handler);\n  }\n\n  /**\n   * Gets the first document matching the provided filter or null when not found.\n   * <p>\n   *   Note that all partition and clustering keys must be defined in order to use this method.\n   * </p>\n   * @param {Object} doc The object containing the properties that map to the primary keys.\n   * @param {Object} [docInfo] An object containing the additional document information.\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * SELECT cql statement generated, in order to restrict the amount of columns retrieved.\n   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests\n   * execution or a string representing the name of the execution profile.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @return {Promise<Object>}\n   * @example <caption>Get a video by id</caption>\n   * videoMapper.get({ id })\n   * @example <caption>Get a video by id, selecting specific columns</caption>\n   * videoMapper.get({ id }, fields: ['name', 'description'])\n   */\n  get(doc, docInfo, executionOptions) {\n    if (executionOptions === undefined && typeof docInfo === 'string') {\n      executionOptions = docInfo;\n      docInfo = null;\n    }\n\n    return this._handler.getSelectExecutor(doc, docInfo, true)\n      .then(executor => executor(doc, docInfo, executionOptions))\n      .then(result => result.first());\n  }\n\n  /**\n   * Executes a SELECT query based on the filter and returns the result as an iterable of documents.\n   * @param {Object} doc An object containing the properties that map to the primary keys to filter.\n   * @param {Object} [docInfo] An object containing the additional document information.\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * SELECT cql statement generated, in order to restrict the amount of columns retrieved.\n   * @param {Object<String, String>} [docInfo.orderBy] An associative array containing the column names as key and\n   * the order string (asc or desc) as value used to set the order of the results server-side.\n   * @param {Number} [docInfo.limit] Restricts the result of the query to a maximum number of rows on the\n   * server.\n   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests\n   * execution or a string representing the name of the execution profile.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @param {Number} [executionOptions.fetchSize] The amount of rows to retrieve per page.\n   * @param {Number} [executionOptions.pageState] A Buffer instance or a string token representing the paging state.\n   * <p>When provided, the query will be executed starting from a given paging state.</p>\n   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.\n   * @example <caption>Get user's videos</caption>\n   * const result = await videoMapper.find({ userId });\n   * for (let video of result) {\n   *   console.log(video.name);\n   * }\n   * @example <caption>Get user's videos from a certain date</caption>\n   * videoMapper.find({ userId, addedDate: q.gte(date)});\n   * @example <caption>Get user's videos in reverse order</caption>\n   * videoMapper.find({ userId }, { orderBy: { addedDate: 'desc' }});\n   */\n  find(doc, docInfo, executionOptions) {\n    if (executionOptions === undefined && typeof docInfo === 'string') {\n      executionOptions = docInfo;\n      docInfo = null;\n    }\n\n    return this._handler.getSelectExecutor(doc, docInfo, false)\n      .then(executor => executor(doc, docInfo, executionOptions));\n  }\n\n  /**\n   * Executes a SELECT query without a filter and returns the result as an iterable of documents.\n   * <p>\n   *   This is only recommended to be used for tables with a limited amount of results. Otherwise, breaking up the\n   *   token ranges on the client side should be used.\n   * </p>\n   * @param {Object} [docInfo] An object containing the additional document information.\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * SELECT cql statement generated, in order to restrict the amount of columns retrieved.\n   * @param {Object<String, String>} [docInfo.orderBy] An associative array containing the column names as key and\n   * the order string (asc or desc) as value used to set the order of the results server-side.\n   * @param {Number} [docInfo.limit] Restricts the result of the query to a maximum number of rows on the\n   * server.\n   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests\n   * execution or a string representing the name of the execution profile.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @param {Number} [executionOptions.fetchSize] The mount of rows to retrieve per page.\n   * @param {Number} [executionOptions.pageState] A Buffer instance or a string token representing the paging state.\n   * <p>When provided, the query will be executed starting from a given paging state.</p>\n   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.\n   */\n  findAll(docInfo, executionOptions) {\n    if (executionOptions === undefined && typeof docInfo === 'string') {\n      executionOptions = docInfo;\n      docInfo = null;\n    }\n\n    const executor = this._handler.getSelectAllExecutor(docInfo);\n    return executor(docInfo, executionOptions);\n  }\n\n  /**\n   * Inserts a document.\n   * <p>\n   *   When the model is mapped to multiple tables, it will insert a row in each table when all the primary keys\n   *   are specified.\n   * </p>\n   * @param {Object} doc An object containing the properties to insert.\n   * @param {Object} [docInfo] An object containing the additional document information.\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * INSERT cql statements generated. If specified, it must include the columns to insert and the primary keys.\n   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.\n   * @param {Boolean} [docInfo.ifNotExists] When set, it only inserts if the row does not exist prior to the insertion.\n   * <p>Please note that using IF NOT EXISTS will incur a non negligible performance cost so this should be used\n   * sparingly.</p>\n   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests\n   * execution or a string representing the name of the execution profile.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without\n   * changing the result beyond the initial application.\n   * <p>\n   *   By default all generated INSERT statements are considered idempotent, except in the case of lightweight\n   *   transactions. Lightweight transactions at client level with transparent retries can\n   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.\n   * </p>\n   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the\n   * unix epoch (00:00:00, January 1st, 1970).\n   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>\n   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.\n   * @example <caption>Insert a video</caption>\n   * videoMapper.insert({ id, name });\n   */\n  insert(doc, docInfo, executionOptions) {\n    if (executionOptions === undefined && typeof docInfo === 'string') {\n      executionOptions = docInfo;\n      docInfo = null;\n    }\n\n    return this._handler.getInsertExecutor(doc, docInfo)\n      .then(executor => executor(doc, docInfo, executionOptions));\n  }\n\n  /**\n   * Updates a document.\n   * <p>\n   *   When the model is mapped to multiple tables, it will update a row in each table when all the primary keys\n   *   are specified.\n   * </p>\n   * @param {Object} doc An object containing the properties to update.\n   * @param {Object} [docInfo] An object containing the additional document information.\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * UPDATE cql statements generated. If specified, it must include the columns to update and the primary keys.\n   * @param {Number} [docInfo.ttl] Specifies an optional Time To Live (in seconds) for the inserted values.\n   * @param {Boolean} [docInfo.ifExists] When set, it only updates if the row already exists on the server.\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the UPDATE to occur.\n   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests\n   * execution or a string representing the name of the execution profile.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without\n   * changing the result beyond the initial application.\n   * <p>\n   *   The mapper uses the generated queries to determine the default value. When an UPDATE is generated with a\n   *   counter column or appending/prepending to a list column, the execution is marked as not idempotent.\n   * </p>\n   * <p>\n   *   Additionally, the mapper uses the safest approach for queries with lightweight transactions (Compare and\n   *   Set) by considering them as non-idempotent. Lightweight transactions at client level with transparent retries can\n   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.\n   * </p>\n   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the\n   * unix epoch (00:00:00, January 1st, 1970).\n   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>\n   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.\n   * @example <caption>Update the name of a video</caption>\n   * videoMapper.update({ id, name });\n   */\n  update(doc, docInfo, executionOptions) {\n    if (executionOptions === undefined && typeof docInfo === 'string') {\n      executionOptions = docInfo;\n      docInfo = null;\n    }\n\n    return this._handler.getUpdateExecutor(doc, docInfo)\n      .then(executor => executor(doc, docInfo, executionOptions));\n  }\n\n  /**\n   * Deletes a document.\n   * @param {Object} doc A document containing the primary keys values of the document to delete.\n   * @param {Object} [docInfo] An object containing the additional doc information.\n   * @param {Object} [docInfo.when] A document that act as the condition that has to be met for the DELETE to occur.\n   * Use this property only in the case you want to specify a conditional clause for lightweight transactions (CAS).\n   * When the CQL query is generated, this would be used to generate the `IF` clause.\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @param {Boolean} [docInfo.ifExists] When set, it only issues the DELETE command if the row already exists on the\n   * server.\n   * <p>\n   *   Please note that using IF conditions will incur a non negligible performance cost on the server-side so this\n   *   should be used sparingly.\n   * </p>\n   * @param {Array<String>} [docInfo.fields] An Array containing the name of the properties that will be used in the\n   * DELETE cql statement generated. If specified, it must include the columns to delete and the primary keys.\n   * @param {Boolean} [docInfo.deleteOnlyColumns] Determines that, when more document properties are specified\n   * besides the primary keys, the generated DELETE statement should be used to delete some column values but leave\n   * the row. When this is enabled and more properties are specified, a DELETE statement will have the following form:\n   * \"DELETE col1, col2 FROM table1 WHERE pk1 = ? AND pk2 = ?\"\n   * @param {Object|String} [executionOptions] An object containing the options to be used for the requests\n   * execution or a string representing the name of the execution profile.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times without\n   * changing the result beyond the initial application.\n   * <p>\n   *   By default all generated DELETE statements are considered idempotent, except in the case of lightweight\n   *   transactions. Lightweight transactions at client level with transparent retries can\n   *   break linearizability. If that is not an issue for your application, you can manually set this field to true.\n   * </p>\n   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the\n   * unix epoch (00:00:00, January 1st, 1970).\n   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>\n   * @return {Promise<Result>} A Promise that resolves to a [Result]{@link module:mapping~Result} instance.\n   * @example <caption>Delete a video</caption>\n   * videoMapper.remove({ id });\n   */\n  remove(doc, docInfo, executionOptions) {\n    if (executionOptions === undefined && typeof docInfo === 'string') {\n      executionOptions = docInfo;\n      docInfo = null;\n    }\n\n    return this._handler.getDeleteExecutor(doc, docInfo)\n      .then(executor => executor(doc, docInfo, executionOptions));\n  }\n\n  /**\n   * Uses the provided query and param getter function to execute a query and map the results.\n   * Gets a function that takes the document, executes the query and returns the mapped results.\n   * @param {String} query The query to execute.\n   * @param {Function} paramsHandler The function to execute to extract the parameters of a document.\n   * @param {Object|String} [executionOptions] When provided, the options for all executions generated with this\n   * method will use the provided options and it will not consider the executionOptions per call.\n   * @param {String} [executionOptions.executionProfile] The name of the execution profile.\n   * @param {Number} [executionOptions.fetchSize] Amount of rows to retrieve per page.\n   * @param {Boolean} [executionOptions.isIdempotent] Defines whether the query can be applied multiple times\n   * without changing the result beyond the initial application.\n   * @param {Number} [executionOptions.pageState] Buffer or string token representing the paging state.\n   * <p>When provided, the query will be executed starting from a given paging state.</p>\n   * @param {Number|Long} [executionOptions.timestamp] The default timestamp for the query in microseconds from the\n   * unix epoch (00:00:00, January 1st, 1970).\n   * <p>When provided, this will replace the client generated and the server side assigned timestamp.</p>\n   * @return {Function} Returns a function that takes the document and execution options as parameters and returns a\n   * Promise the resolves to a [Result]{@link module:mapping~Result} instance.\n   */\n  mapWithQuery(query, paramsHandler, executionOptions) {\n    return this._handler.getExecutorFromQuery(query, paramsHandler, executionOptions);\n  }\n}\n\nmodule.exports = ModelMapper;","'use strict';\n\nconst tableMappingsModule = require('./table-mappings');\nconst TableMappings = tableMappingsModule.TableMappings;\nconst DefaultTableMappings = tableMappingsModule.DefaultTableMappings;\n\n/**\n * Represents the parsed user information of the table mappings of a model.\n * @ignore\n */\nclass ModelMappingInfo {\n  /**\n   * @param {String} keyspace\n   * @param {Array<{name, isView}>} tables\n   * @param {TableMappings} mappings\n   * @param {Map<String,String>} columns\n   */\n  constructor(keyspace, tables, mappings, columns) {\n    this.keyspace = keyspace;\n    this.tables = tables;\n    this._mappings = mappings;\n    this._columns = columns;\n    this._documentProperties = new Map();\n    columns.forEach((propName, columnName) => this._documentProperties.set(propName, columnName));\n  }\n\n  getColumnName(propName) {\n    const columnName = this._documentProperties.get(propName);\n    if (columnName !== undefined) {\n      // There is an specific name transformation between the column name and the property name\n      return columnName;\n    }\n    // Rely on the TableMappings (i.e. maybe there is a convention defined for this property)\n    return this._mappings.getColumnName(propName);\n  }\n\n  getPropertyName(columnName) {\n    const propName = this._columns.get(columnName);\n    if (propName !== undefined) {\n      // There is an specific name transformation between the column name and the property name\n      return propName;\n    }\n    // Rely on the TableMappings (i.e. maybe there is a convention defined for this column)\n    return this._mappings.getPropertyName(columnName);\n  }\n\n  newInstance() {\n    return this._mappings.newObjectInstance();\n  }\n\n  /**\n   * Parses the user options into a map of model names and ModelMappingInfo.\n   * @param {MappingOptions} options\n   * @param {String} currentKeyspace\n   * @returns {Map<String, ModelMappingInfo>}\n   */\n  static parse(options, currentKeyspace) {\n    const result = new Map();\n    if (!options || !options.models) {\n      return result;\n    }\n\n    Object.keys(options.models).forEach(modelName => {\n      const modelOptions = options.models[modelName];\n      result.set(modelName, ModelMappingInfo._create(modelName, currentKeyspace, modelOptions));\n    });\n\n    return result;\n  }\n\n  static _create(modelName, currentKeyspace, modelOptions) {\n    if (!currentKeyspace && (!modelOptions || !modelOptions.keyspace)) {\n      throw new Error(\n        'You should specify the keyspace of the model in the MappingOptions when the Client is not using a keyspace');\n    }\n\n    if (!modelOptions) {\n      return ModelMappingInfo.createDefault(modelName, currentKeyspace);\n    }\n\n    let tables;\n\n    if (modelOptions.tables && modelOptions.tables.length > 0) {\n      tables = modelOptions.tables.map(item => {\n        const table = { name: null, isView: false };\n        if (typeof item === 'string') {\n          table.name = item;\n        } else if (item) {\n          table.name = item.name;\n          table.isView = !!item.isView;\n        }\n\n        if (!table.name) {\n          throw new Error(`Table name not specified for model '${modelName}'`);\n        }\n\n        return table;\n      });\n    } else {\n      tables = [ { name: modelName, isView: false }];\n    }\n\n    if (modelOptions.mappings && !(modelOptions.mappings instanceof TableMappings)) {\n      throw new Error('mappings should be an instance of TableMappings');\n    }\n\n    const columns = new Map();\n    if (modelOptions.columns !== null && typeof modelOptions.columns === 'object') {\n      Object.keys(modelOptions.columns).forEach(columnName => {\n        columns.set(columnName, modelOptions.columns[columnName]);\n      });\n    }\n\n    return new ModelMappingInfo(\n      modelOptions.keyspace || currentKeyspace,\n      tables,\n      modelOptions.mappings || new DefaultTableMappings(),\n      columns\n    );\n  }\n\n  static createDefault(modelName, currentKeyspace) {\n    return new ModelMappingInfo(\n      currentKeyspace,\n      [ { name: modelName, isView: false }],\n      new DefaultTableMappings(),\n      new Map());\n  }\n}\n\nmodule.exports = ModelMappingInfo;","'use strict';\n\n/**\n * Provides utility methods to choose the correct tables and views that should be included in a statement.\n * @ignore\n */\nclass ObjectSelector {\n  /**\n   * Gets the table/view that should be used to execute the SELECT query.\n   * @param {Client} client\n   * @param {ModelMappingInfo} info\n   * @param {Boolean} allPKsDefined\n   * @param {Array} propertiesInfo\n   * @param {Array} fieldsInfo\n   * @param {Array<Array<String>>} orderByColumns\n   * @return {Promise<String>} A promise that resolves to a table names.\n   */\n  static getForSelect(client, info, allPKsDefined, propertiesInfo, fieldsInfo, orderByColumns) {\n    return Promise.all(\n      info.tables.map(t => {\n        if (t.isView) {\n          return client.metadata.getMaterializedView(info.keyspace, t.name);\n        }\n        return client.metadata.getTable(info.keyspace, t.name);\n      }))\n      .then(tables => {\n        for (let i = 0; i < tables.length; i++) {\n          const table = tables[i];\n          if (table === null) {\n            throw new Error(`Table \"${info.tables[i].name}\" could not be retrieved`);\n          }\n\n          const allPartitionKeysAreIncluded = table.partitionKeys\n            .reduce((acc, c) => acc && contains(propertiesInfo, p => p.columnName === c.name), true);\n\n          if (!allPartitionKeysAreIncluded) {\n            // Not all the partition keys are covered\n            continue;\n          }\n\n          if (allPKsDefined) {\n            const allClusteringKeysAreIncluded = table.clusteringKeys\n              .reduce((acc, c) => acc && contains(propertiesInfo, p => p.columnName === c.name), true);\n            if (!allClusteringKeysAreIncluded) {\n              // All clustering keys should be included as allPKsDefined flag is set\n              continue;\n            }\n          }\n\n          if (propertiesInfo.length > table.partitionKeys.length) {\n            // Check that the Where clause is composed by partition and clustering keys\n            const allPropertiesArePrimaryKeys = propertiesInfo\n              .reduce(\n                (acc, p) => acc && (\n                  contains(table.partitionKeys, c => c.name === p.columnName) ||\n                  contains(table.clusteringKeys, c => c.name === p.columnName)\n                ),\n                true);\n\n            if (!allPropertiesArePrimaryKeys) {\n              continue;\n            }\n          }\n\n          // All fields must be contained\n          const containsAllFields = fieldsInfo\n            .reduce((acc, p) => acc && table.columnsByName[p.columnName] !== undefined, true);\n\n          if (!containsAllFields) {\n            continue;\n          }\n\n          // ORDER BY fields must be part of the clustering keys\n          // On the mapper we only validate that are part of the table\n          const containsAllOrderByColumns = orderByColumns\n            .reduce((acc, order) => acc && table.columnsByName[order[0]] !== undefined, true);\n\n          if (!containsAllOrderByColumns) {\n            continue;\n          }\n\n          return table.name;\n        }\n\n        let message = `No table matches the filter (${allPKsDefined ? 'all PKs have to be specified' : 'PKs'}): [${\n          propertiesInfo.map(p => p.columnName)}]`;\n\n        if (fieldsInfo.length > 0) {\n          message += `; fields: [${fieldsInfo.map(p => p.columnName)}]`;\n        }\n        if (orderByColumns.length > 0) {\n          message += `; orderBy: [${orderByColumns.map(item => item[0])}]`;\n        }\n\n        throw new Error(message);\n      });\n  }\n\n  /** Returns the name of the first table */\n  static getForSelectAll(info) {\n    return info.tables[0].name;\n  }\n\n  /**\n   * Gets the tables that should be used to execute the INSERT query.\n   * @param {Client} client\n   * @param {ModelMappingInfo} info\n   * @param {Array} propertiesInfo\n   * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.\n   */\n  static getForInsert(client, info, propertiesInfo) {\n    return Promise.all(info.tables.filter(t => !t.isView).map(t => client.metadata.getTable(info.keyspace, t.name)))\n      .then(tables => {\n        const filteredTables = tables\n          .filter((table, i) => {\n            if (table === null) {\n              throw new Error(`Table \"${info.tables[i].name}\" could not be retrieved`);\n            }\n\n            // All partition and clustering keys from the table should be included in the document\n            const keyNames = table.partitionKeys.concat(table.clusteringKeys).map(k => k.name);\n            const columns = propertiesInfo.map(m => m.columnName);\n\n            for (let i = 0; i < keyNames.length; i++) {\n              if (columns.indexOf(keyNames[i]) === -1) {\n                return false;\n              }\n            }\n\n            return true;\n          });\n\n        if (filteredTables.length === 0) {\n          throw new Error(`No table matches (all PKs have to be specified) fields: [${\n            propertiesInfo.map(p => p.columnName)}]`);\n        }\n\n        return filteredTables;\n      });\n  }\n\n  /**\n   * Gets the tables that should be used to execute the UPDATE query.\n   * @param {Client} client\n   * @param {ModelMappingInfo} info\n   * @param {Array} propertiesInfo\n   * @param {Array} when\n   * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.\n   */\n  static getForUpdate(client, info, propertiesInfo, when) {\n    return Promise.all(info.tables.filter(t => !t.isView).map(t => client.metadata.getTable(info.keyspace, t.name)))\n      .then(tables => {\n        const filteredTables = tables\n          .filter((table, i) => {\n            if (table === null) {\n              throw new Error(`Table \"${info.tables[i].name}\" could not be retrieved`);\n            }\n\n            // All partition and clustering keys from the table should be included in the document\n            const keyNames = table.partitionKeys.concat(table.clusteringKeys).map(k => k.name);\n            const columns = new Set(propertiesInfo.map(p => p.columnName));\n            const allPrimaryKeysAreContained = keyNames.reduce((acc, key) => acc && columns.has(key), true);\n\n            if (!allPrimaryKeysAreContained) {\n              return false;\n            }\n\n            const applicableColumns = propertiesInfo\n              .reduce((acc, p) => acc + (table.columnsByName[p.columnName] !== undefined ? 1 : 0), 0);\n\n            if (applicableColumns <= keyNames.length) {\n              // No SET columns are defined\n              return false;\n            }\n\n            // \"when\" conditions should be contained in the table\n            return when.reduce((acc, p) => acc && table.columnsByName[p.columnName] !== undefined, true);\n          });\n\n        if (filteredTables.length === 0) {\n          let message = `No table matches (all PKs and columns to set have to be specified) fields: [${\n            propertiesInfo.map(p => p.columnName)}]`;\n\n          if (when.length > 0) {\n            message += `; condition: [${when.map(p => p.columnName)}]`;\n          }\n\n          throw new Error(message);\n        }\n\n        return filteredTables;\n      });\n  }\n\n  /**\n   * Gets the tables that should be used to execute the DELETE query.\n   * @param {Client} client\n   * @param {ModelMappingInfo} info\n   * @param {Array} propertiesInfo\n   * @param {Array} when\n   * @return {Promise<Array<TableMetadata>>} A promise that resolves to an Array of tables.\n   */\n  static getForDelete(client, info, propertiesInfo, when) {\n    return Promise.all(info.tables.filter(t => !t.isView).map(t => client.metadata.getTable(info.keyspace, t.name)))\n      .then(tables => {\n        const filteredTables = tables\n          .filter((table, i) => {\n            if (table === null) {\n              throw new Error(`Table \"${info.tables[i].name}\" could not be retrieved`);\n            }\n\n            // All partition and clustering keys from the table should be included in the document\n            const keyNames = table.partitionKeys.concat(table.clusteringKeys).map(k => k.name);\n            const columns = propertiesInfo.map(p => p.columnName);\n\n            for (let i = 0; i < keyNames.length; i++) {\n              if (columns.indexOf(keyNames[i]) === -1) {\n                return false;\n              }\n            }\n\n            // \"when\" conditions should be contained in the table\n            return when.reduce((acc, p) => acc && table.columnsByName[p.columnName] !== undefined, true);\n          });\n\n        if (filteredTables.length === 0) {\n          let message = `No table matches (all PKs have to be specified) fields: [${\n            propertiesInfo.map(p => p.columnName)}]`;\n\n          if (when.length > 0) {\n            message += `; condition: [${when.map(p => p.columnName)}]`;\n          }\n\n          throw new Error(message);\n        }\n\n        return filteredTables;\n      });\n  }\n}\n\nfunction contains(arr, fn) {\n  return arr.filter(fn).length > 0;\n}\n\nmodule.exports = ObjectSelector;","'use strict';\n\nconst errors = require('../errors');\n\n/**\n * Represents a CQL query operator, like >=, IN, <, ...\n * @ignore\n */\nclass QueryOperator {\n  /**\n   * Creates a new instance of <code>QueryOperator</code>.\n   * @param {String} key\n   * @param value\n   * @param [hasChildValues]\n   */\n  constructor(key, value, hasChildValues) {\n    /**\n     * The CQL key representing the operator\n     * @type {string}\n     */\n    this.key = key;\n\n    /**\n     * The value to be used as parameter.\n     */\n    this.value = value;\n\n    /**\n     * Determines whether a query operator can have child values or operators (AND, OR)\n     */\n    this.hasChildValues = hasChildValues;\n  }\n}\n\n/**\n * Represents a CQL assignment operation, like col = col + x.\n * @ignore\n */\nclass QueryAssignment {\n  constructor(sign, value, inverted) {\n    /**\n     * Gets the sign of the assignment operation.\n     */\n    this.sign = sign;\n\n    /**\n     * Gets the value to be assigned.\n     */\n    this.value = value;\n\n    /**\n     * Determines whether the assignment should be inverted (prepends), e.g: col = x + col\n     * @type {boolean}\n     */\n    this.inverted = !!inverted;\n  }\n}\n\n/**\n * Contains functions that represents operators in a query.\n * @alias module:mapping~q\n * @type {Object}\n * @property {function} in_ Represents the CQL operator \"IN\".\n * @property {function} gt Represents the CQL operator greater than \">\".\n * @property {function} gte Represents the CQL operator greater than or equals to \">=\" .\n * @property {function} lt Represents the CQL operator less than \"<\" .\n * @property {function} lte Represents the CQL operator less than or equals to \"<=\" .\n * @property {function} notEq Represents the CQL operator not equals to \"!=\" .\n * @property {function} and When applied to a property, it represents two CQL conditions on the same column separated\n * by the logical AND operator, e.g: \"col1 >= x col < y\"\n * @property {function} incr Represents the CQL increment assignment used for counters, e.g: \"col = col + x\"\n * @property {function} decr Represents the CQL decrement assignment used for counters, e.g: \"col = col - x\"\n * @property {function} append Represents the CQL append assignment used for collections, e.g: \"col = col + x\"\n * @property {function} prepend Represents the CQL prepend assignment used for lists, e.g: \"col = x + col\"\n * @property {function} remove Represents the CQL remove assignment used for collections, e.g: \"col = col - x\"\n */\nconst q = {\n  in_: function in_(arr) {\n    if (!Array.isArray(arr)) {\n      throw new errors.ArgumentError('IN operator supports only Array values');\n    }\n    return new QueryOperator('IN', arr);\n  },\n\n  gt: function gt(value) {\n    return new QueryOperator('>', value);\n  },\n\n  gte: function gte(value) {\n    return new QueryOperator('>=', value);\n  },\n\n  lt: function lt(value) {\n    return new QueryOperator('<', value);\n  },\n\n  lte: function lte(value) {\n    return new QueryOperator('<=', value);\n  },\n\n  notEq: function notEq(value) {\n    return new QueryOperator('!=', value);\n  },\n\n  and: function (condition1, condition2) {\n    return new QueryOperator('AND', [ condition1, condition2 ], true);\n  },\n\n  incr: function incr(value) {\n    return new QueryAssignment('+', value);\n  },\n\n  decr: function decr(value) {\n    return new QueryAssignment('-', value);\n  },\n\n  append: function append(value) {\n    return new QueryAssignment('+', value);\n  },\n\n  prepend: function prepend(value) {\n    return new QueryAssignment('+', value, true);\n  },\n\n  remove: function remove(value) {\n    return new QueryAssignment('-', value);\n  }\n};\n\nexports.q = q;\nexports.QueryAssignment = QueryAssignment;\nexports.QueryOperator = QueryOperator;","'use strict';\n\nconst vm = require('vm');\nconst qModule = require('./q');\nconst QueryOperator = qModule.QueryOperator;\nconst QueryAssignment = qModule.QueryAssignment;\nconst types = require('../types');\nconst dataTypes = types.dataTypes;\n\nconst vmFileName = 'gen-param-getter.js';\n\n/**\n * Provides methods to generate a query and parameter handlers.\n * @ignore\n */\nclass QueryGenerator {\n  /**\n   * Gets the SELECT query given the doc.\n   * @param {String} tableName\n   * @param {String} keyspace\n   * @param {Array} propertiesInfo\n   * @param {Array} fieldsInfo\n   * @param {Array} orderByColumns\n   * @param {Number|undefined} limit\n   * @return {string}\n   */\n  static getSelect(tableName, keyspace, propertiesInfo, fieldsInfo, orderByColumns, limit) {\n    let query = 'SELECT ';\n    query += fieldsInfo.length > 0 ? fieldsInfo.map(p => p.columnName).join(', ') : '*';\n    query += ` FROM ${keyspace}.${tableName}`;\n\n    if (propertiesInfo.length > 0) {\n      query += ' WHERE ';\n      query += QueryGenerator._getConditionWithOperators(propertiesInfo);\n    }\n\n    if (orderByColumns.length > 0) {\n      query += ' ORDER BY ';\n      query += orderByColumns.map(order => order[0] + ' ' + order[1]).join(', ');\n    }\n\n    if (typeof limit === 'number') {\n      query += ' LIMIT ?';\n    }\n\n    return query;\n  }\n\n  static selectParamsGetter(propertiesInfo, limit) {\n    let scriptText = '(function getParametersSelect(doc, docInfo) {\\n';\n    scriptText += '  return [';\n\n    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo);\n\n    if (typeof limit === 'number') {\n      if (propertiesInfo.length > 0) {\n        scriptText += ', ';\n      }\n      scriptText += `docInfo['limit']`;\n    }\n\n    // Finish return statement\n    scriptText += '];\\n})';\n\n    const script = new vm.Script(scriptText);\n    return script.runInThisContext({ filename: vmFileName});\n  }\n\n  /**\n   * Gets the INSERT query and function to obtain the parameters, given the doc.\n   * @param {TableMetadata} table\n   * @param {String} keyspace\n   * @param {Array} propertiesInfo\n   * @param {Object} docInfo\n   * @param {Boolean|undefined} ifNotExists\n   * @return {{query: String, paramsGetter: Function, isIdempotent: Boolean}}\n   */\n  static getInsert(table, keyspace, propertiesInfo, docInfo, ifNotExists) {\n    const ttl = docInfo && docInfo.ttl;\n\n    // Not all columns are contained in the table\n    const filteredPropertiesInfo = propertiesInfo\n      .filter(pInfo => table.columnsByName[pInfo.columnName] !== undefined);\n\n    return ({\n      query: QueryGenerator._getInsertQuery(table.name, keyspace, filteredPropertiesInfo, ifNotExists, ttl),\n      paramsGetter: QueryGenerator._insertParamsGetter(filteredPropertiesInfo, docInfo),\n      isIdempotent: !ifNotExists\n    });\n  }\n\n  /**\n   * Gets the query for an insert statement.\n   * @param {String} tableName\n   * @param {String} keyspace\n   * @param {Array} propertiesInfo\n   * @param {Boolean} ifNotExists\n   * @param {Number|undefined} ttl\n   * @return {String}\n   */\n  static _getInsertQuery(tableName, keyspace, propertiesInfo, ifNotExists, ttl) {\n    let query = `INSERT INTO ${keyspace}.${tableName} (`;\n    query += propertiesInfo.map(pInfo => pInfo.columnName).join(', ');\n    query += ') VALUES (';\n    query += propertiesInfo.map(() => '?').join(', ');\n    query += ')';\n\n    if (ifNotExists === true) {\n      query += ' IF NOT EXISTS';\n    }\n\n    if (typeof ttl === 'number') {\n      query += ' USING TTL ?';\n    }\n    return query;\n  }\n\n  static _insertParamsGetter(propertiesInfo, docInfo) {\n    let scriptText = '(function getParametersInsert(doc, docInfo) {\\n';\n    scriptText += '  return [';\n\n    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo);\n\n    if (docInfo && typeof docInfo.ttl === 'number') {\n      scriptText += `, docInfo['ttl']`;\n    }\n\n    // Finish return statement\n    scriptText += '];\\n})';\n\n    const script = new vm.Script(scriptText);\n    return script.runInThisContext({ filename: vmFileName});\n  }\n\n  /**\n   * Gets the UPDATE query and function to obtain the parameters, given the doc.\n   * @param {TableMetadata} table\n   * @param {String} keyspace\n   * @param {Array} propertiesInfo\n   * @param {Object} docInfo\n   * @param {Array} when\n   * @param {Boolean|undefined} ifExists\n   * @return {{query: String, paramsGetter: Function, isIdempotent: Boolean, isCounter}}\n   */\n  static getUpdate(table, keyspace, propertiesInfo, docInfo, when, ifExists) {\n    const ttl = docInfo && docInfo.ttl;\n    const primaryKeys = new Set(table.partitionKeys.concat(table.clusteringKeys).map(c => c.name));\n    let isIdempotent = true;\n    let isCounter = false;\n\n    // Not all columns are contained in the table\n    const filteredPropertiesInfo = propertiesInfo.filter(pInfo => {\n      const column = table.columnsByName[pInfo.columnName];\n      if (column === undefined) {\n        return false;\n      }\n\n      if (column.type.code === dataTypes.list && pInfo.value instanceof QueryAssignment) {\n        // Its not idempotent when list append/prepend\n        isIdempotent = false;\n      } else if (column.type.code === dataTypes.counter) {\n        // Any update on a counter table is not idempotent\n        isIdempotent = false;\n        isCounter = true;\n      }\n\n      return true;\n    });\n\n    if (filteredPropertiesInfo.length <= primaryKeys.size) {\n      throw new Error('UPDATE statement does not contain columns to SET');\n    }\n\n    return {\n      query: QueryGenerator._getUpdateQuery(\n        table.name, keyspace, primaryKeys, filteredPropertiesInfo, when, ifExists, ttl),\n      isIdempotent: isIdempotent && when.length === 0 && !ifExists,\n      paramsGetter: QueryGenerator._updateParamsGetter(primaryKeys, filteredPropertiesInfo, when, ttl),\n      isCounter\n    };\n  }\n\n  /**\n   * Gets the query for an UPDATE statement.\n   * @param {String} tableName\n   * @param {String} keyspace\n   * @param {Set} primaryKeys\n   * @param {Array} propertiesInfo\n   * @param {Object} when\n   * @param {Boolean} ifExists\n   * @param {Number|undefined} ttl\n   */\n  static _getUpdateQuery(tableName, keyspace, primaryKeys, propertiesInfo, when, ifExists, ttl) {\n    let query = `UPDATE ${keyspace}.${tableName} SET `;\n\n    query += propertiesInfo\n      .filter(p => !primaryKeys.has(p.columnName))\n      .map(p => {\n        if (p.value instanceof QueryAssignment) {\n          if (p.value.inverted) {\n            // e.g: prepend \"col1 = ? + col1\"\n            return `${p.columnName} = ? ${p.value.sign} ${p.columnName}`;\n          }\n          // e.g: increment \"col1 = col1 + ?\"\n          return `${p.columnName} = ${p.columnName} ${p.value.sign} ?`;\n        }\n\n        return p.columnName + ' = ?';\n      })\n      .join(', ');\n\n    query += ' WHERE ';\n    query += propertiesInfo.filter(p => primaryKeys.has(p.columnName)).map(p => p.columnName + ' = ?').join(' AND ');\n\n    if (ifExists === true) {\n      query += ' IF EXISTS';\n    }\n    else if (when.length > 0) {\n      query += ' IF ' + QueryGenerator._getConditionWithOperators(when);\n    }\n\n    if (typeof ttl === 'number') {\n      query += ' USING TTL ?';\n    }\n\n    return query;\n  }\n\n  /**\n   * Returns a function to obtain the parameter values from a doc for an UPDATE statement.\n   * @param {Set} primaryKeys\n   * @param {Array} propertiesInfo\n   * @param {Array} when\n   * @param {Number|undefined} ttl\n   * @returns {Function}\n   */\n  static _updateParamsGetter(primaryKeys, propertiesInfo, when, ttl) {\n    let scriptText = '(function getParametersUpdate(doc, docInfo) {\\n';\n    scriptText += '  return [';\n\n    // Assignment clause\n    scriptText += QueryGenerator._assignmentGetterExpression(propertiesInfo.filter(p => !primaryKeys.has(p.columnName)));\n    scriptText += ', ';\n    // Where clause\n    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo.filter(p => primaryKeys.has(p.columnName)));\n\n    // Condition clause\n    if (when.length > 0) {\n      scriptText += ', ' + QueryGenerator._valueGetterExpression(when, 'docInfo.when');\n    }\n\n    if (typeof ttl === 'number') {\n      scriptText += `, docInfo['ttl']`;\n    }\n\n    // Finish return statement\n    scriptText += '];\\n})';\n\n    const script = new vm.Script(scriptText);\n    return script.runInThisContext({ filename: vmFileName});\n  }\n\n  /**\n   * Gets the DELETE query and function to obtain the parameters, given the doc.\n   * @param {TableMetadata} table\n   * @param {String} keyspace\n   * @param {Array} propertiesInfo\n   * @param {Object} docInfo\n   * @param {Array} when\n   * @param {Boolean|undefined} ifExists\n   * @return {{query: String, paramsGetter: Function, isIdempotent}}\n   */\n  static getDelete(table, keyspace, propertiesInfo, docInfo, when, ifExists) {\n    const deleteOnlyColumns = docInfo && docInfo.deleteOnlyColumns;\n    const primaryKeys = new Set(table.partitionKeys.concat(table.clusteringKeys).map(c => c.name));\n\n    const filteredPropertiesInfo = propertiesInfo\n      .filter(pInfo => table.columnsByName[pInfo.columnName] !== undefined);\n\n\n    return ({\n      query: QueryGenerator._getDeleteQuery(\n        table.name, keyspace, primaryKeys, filteredPropertiesInfo, when, ifExists, deleteOnlyColumns),\n      paramsGetter: QueryGenerator._deleteParamsGetter(primaryKeys, filteredPropertiesInfo, when),\n      isIdempotent: when.length === 0 && !ifExists\n    });\n  }\n\n  /**\n   * Gets the query for an UPDATE statement.\n   * @param {String} tableName\n   * @param {String} keyspace\n   * @param {Set} primaryKeys\n   * @param {Array} propertiesInfo\n   * @param {Array} when\n   * @param {Boolean} ifExists\n   * @param {Boolean} deleteOnlyColumns\n   * @private\n   * @return {String}\n   */\n  static _getDeleteQuery(tableName, keyspace, primaryKeys, propertiesInfo, when, ifExists, deleteOnlyColumns) {\n    let query = 'DELETE';\n\n    if (deleteOnlyColumns) {\n      const columnsToDelete = propertiesInfo.filter(p => !primaryKeys.has(p.columnName))\n        .map(p => p.columnName)\n        .join(', ');\n\n      if (columnsToDelete !== '') {\n        query += ' ' + columnsToDelete;\n      }\n    }\n\n    query += ` FROM ${keyspace}.${tableName} WHERE `;\n    query += propertiesInfo.filter(p => primaryKeys.has(p.columnName)).map(p => p.columnName + ' = ?').join(' AND ');\n\n    if (ifExists === true) {\n      query += ' IF EXISTS';\n    }\n    else if (when.length > 0) {\n      query += ' IF ' + QueryGenerator._getConditionWithOperators(when);\n    }\n\n    return query;\n  }\n  /**\n   * Returns a function to obtain the parameter values from a doc for an UPDATE statement.\n   * @param {Set} primaryKeys\n   * @param {Array} propertiesInfo\n   * @param {Array} when\n   * @returns {Function}\n   */\n  static _deleteParamsGetter(primaryKeys, propertiesInfo, when) {\n    let scriptText = '(function getParametersDelete(doc, docInfo) {\\n';\n    scriptText += '  return [';\n\n    // Where clause\n    scriptText += QueryGenerator._valueGetterExpression(propertiesInfo.filter(p => primaryKeys.has(p.columnName)));\n\n    // Condition clause\n    if (when.length > 0) {\n      scriptText += ', ' + QueryGenerator._valueGetterExpression(when, 'docInfo.when');\n    }\n\n    // Finish return statement\n    scriptText += '];\\n})';\n\n    const script = new vm.Script(scriptText);\n    return script.runInThisContext({ filename: vmFileName});\n  }\n\n  /**\n   * Gets a string containing the doc properties to get.\n   * @param {Array} propertiesInfo\n   * @param {String} [objectName='doc']\n   * @return {string}\n   * @private\n   */\n  static _valueGetterExpression(propertiesInfo, objectName) {\n    objectName = objectName || 'doc';\n\n    return propertiesInfo\n      .map(p => QueryGenerator._valueGetterSingle(`${objectName}['${p.propertyName}']`, p.value))\n      .join(', ');\n  }\n\n  static _valueGetterSingle(prefix, value) {\n    if (value instanceof QueryOperator) {\n      if (value.hasChildValues) {\n        return `${QueryGenerator._valueGetterSingle(`${prefix}.value[0]`, value.value[0])}` +\n          `, ${QueryGenerator._valueGetterSingle(`${prefix}.value[1]`, value.value[1])}`;\n      }\n      return `${prefix}.value`;\n    }\n\n    return prefix;\n  }\n\n  /**\n   * Gets a string containing the doc properties to SET, considering QueryAssignment instances.\n   * @param {Array} propertiesInfo\n   * @param {String} [prefix='doc']\n   * @return {string}\n   * @private\n   */\n  static _assignmentGetterExpression(propertiesInfo, prefix) {\n    prefix = prefix || 'doc';\n\n    return propertiesInfo\n      .map(p => `${prefix}['${p.propertyName}']${p.value instanceof QueryAssignment ? '.value' : ''}`)\n      .join(', ');\n  }\n\n  static _getConditionWithOperators(propertiesInfo) {\n    return propertiesInfo\n      .map(p => QueryGenerator._getSingleCondition(p.columnName, p.value))\n      .join(' AND ');\n  }\n\n  static _getSingleCondition(columnName, value) {\n    if (value instanceof QueryOperator) {\n      if (value.hasChildValues) {\n        return `${QueryGenerator._getSingleCondition(columnName, value.value[0])}` +\n          ` ${value.key} ${QueryGenerator._getSingleCondition(columnName, value.value[1])}`;\n      }\n      return `${columnName} ${value.key} ?`;\n    }\n    return `${columnName} = ?`;\n  }\n}\n\nmodule.exports = QueryGenerator;","'use strict';\n\nconst vm = require('vm');\nconst utils = require('../utils');\nconst types = require('../types');\n\n/**\n * @ignore\n */\nclass ResultMapper {\n  /**\n   * Gets a generated function to adapt the row to a document.\n   * @param {ModelMappingInfo} info\n   * @param {ResultSet} rs\n   * @returns {Function}\n   */\n  static getSelectAdapter(info, rs) {\n    const columns = rs.columns;\n    if (!columns) {\n      throw new Error('Expected ROWS result obtained VOID');\n    }\n\n    let scriptText = '(function rowAdapter(row, info) {\\n' +\n      '  const item = info.newInstance();\\n';\n\n    scriptText += columns.map(c => `  item['${info.getPropertyName(c.name)}'] = row['${c.name}'];`).join('\\n');\n\n    scriptText += '\\n  return item;\\n})';\n\n    const script = new vm.Script(scriptText);\n    return script.runInThisContext({ filename: 'gen-result-mapper.js'});\n  }\n\n  /**\n   * Gets a function used to adapt VOID results or conditional updates.\n   * @param {ResultSet} rs\n   * @returns {Function}\n   */\n  static getMutationAdapter(rs) {\n    if (rs.columns === null) {\n      // VOID result\n      return utils.noop;\n    }\n\n    if (\n      rs.columns.length === 1 && rs.columns[0].name === '[applied]' &&\n      rs.columns[0].type.code === types.dataTypes.boolean) {\n      return utils.noop;\n    }\n\n    return ResultMapper._getConditionalRowAdapter(rs);\n  }\n\n  static _getConditionalRowAdapter(rs) {\n    return (function conditionalRowAdapter(row, info) {\n      const item = info.newInstance();\n\n      // Skip the first column (\"[applied]\")\n      for (let i = 1; i < rs.columns.length; i++) {\n        const c = rs.columns[i];\n        item[info.getPropertyName(c.name)] = row[c.name];\n      }\n\n      return item;\n    });\n  }\n\n  /**\n   * @param {ModelMappingInfo} info\n   * @param {ResultSet} rs\n   * @returns {{canCache: Boolean, fn: Function}}\n   */\n  static getCustomQueryAdapter(info, rs) {\n    if (rs.columns === null || rs.columns.length === 0) {\n      // VOID result\n      return { canCache: true, fn: utils.noop };\n    }\n\n    if (rs.columns[0].name === '[applied]' && rs.columns[0].type.code === types.dataTypes.boolean) {\n      // Conditional update results adapter functions should not be cached\n      return { canCache: false, fn: ResultMapper._getConditionalRowAdapter(rs) };\n    }\n\n    return { canCache: true, fn: ResultMapper.getSelectAdapter(info, rs) };\n  }\n}\n\nmodule.exports = ResultMapper;","'use strict';\n\nconst util = require('util');\nconst utils = require('../utils');\nconst inspectMethod = util.inspect.custom || 'inspect';\n\n/**\n * Represents the result of an execution as an iterable of objects in the Mapper.\n * @alias module:mapping~Result\n */\nclass Result {\n  /**\n   * Creates a new instance of Result.\n   * @param {ResultSet} rs\n   * @param {ModelMappingInfo} info\n   * @param {Function} rowAdapter\n   */\n  constructor(rs, info, rowAdapter) {\n    this._rs = rs;\n    this._info = info;\n    this._rowAdapter = rowAdapter;\n\n    /**\n     * When there is a single cell containing the result of the a LWT operation, hide the result from the user.\n     * @private\n     */\n    this._isEmptyLwt = (rs.columns !== null\n      && rs.columns.length === 1 && this._rs.rowLength === 1 && rs.columns[0].name === '[applied]');\n\n    /**\n     * Gets the amount of the documents contained in this Result instance.\n     * <p>\n     *   When the results are paged, it returns the length of the current paged results not the total amount of\n     *   rows in the table matching the query.\n     * </p>\n     * @type {Number}\n     */\n    this.length = this._isEmptyLwt ? 0 : (rs.rowLength || 0);\n\n    /**\n     * A string token representing the current page state of query.\n     * <p>\n     *   When provided, it can be used in the following executions to continue paging and retrieve the remained of the\n     *   result for the query.\n     * </p>\n     * @type {String}\n     * @default null\n     */\n    this.pageState = rs.pageState;\n  }\n\n  /**\n   * When this instance is the result of a conditional update query, it returns whether it was successful.\n   * Otherwise, it returns <code>true</code>.\n   * <p>\n   *   For consistency, this method always returns <code>true</code> for non-conditional queries (although there is\n   *   no reason to call the method in that case). This is also the case for conditional DDL statements\n   *   (CREATE KEYSPACE... IF NOT EXISTS, CREATE TABLE... IF NOT EXISTS), for which the server doesn't return\n   *   information whether it was applied or not.\n   * </p>\n   */\n  wasApplied() {\n    return this._rs.wasApplied();\n  }\n\n  /**\n   * Gets the first document in this result or null when the result is empty.\n   */\n  first() {\n    if (!this._rs.rowLength || this._isEmptyLwt) {\n      return null;\n    }\n    return this._rowAdapter(this._rs.rows[0], this._info);\n  }\n\n  /**\n   * Returns a new Iterator object that contains the document values.\n   */\n  *[Symbol.iterator]() {\n    if (this._isEmptyLwt) {\n      // Empty iterator\n      return;\n    }\n\n    for (let i = 0; i < this._rs.rows.length; i++) {\n      yield this._rowAdapter(this._rs.rows[i], this._info);\n    }\n  }\n\n  /**\n   * Converts the current instance to an Array of documents.\n   * @return {Array<Object>}\n   */\n  toArray() {\n    if (this._isEmptyLwt) {\n      return utils.emptyArray;\n    }\n\n    return this._rs.rows.map(row => this._rowAdapter(row, this._info));\n  }\n\n  /**\n   * Executes a provided function once per result element.\n   * @param {Function} callback Function to execute for each element, taking two arguments: currentValue and index.\n   * @param {Object} [thisArg] Value to use as <code>this</code> when executing callback.\n   */\n  forEach(callback, thisArg) {\n    let index = 0;\n    thisArg = thisArg || this;\n    for (const doc of this) {\n      callback.call(thisArg, doc, index++);\n    }\n  }\n\n  [inspectMethod]() {\n    return this.toArray();\n  }\n}\n\nmodule.exports = Result;","'use strict';\n\n/**\n * Contains a set of methods to represent a row into a document and a document into a row.\n * @alias module:mapping~TableMappings\n * @interface\n */\nclass TableMappings {\n  /**\n   * Method that is called by the mapper to create the instance of the document.\n   * @return {Object}\n   */\n  newObjectInstance() {\n    return {};\n  }\n\n  /**\n   * Gets the name of the column based on the document property name.\n   * @param {String} propName The name of the property.\n   * @returns {String}\n   */\n  getColumnName(propName) {\n    return propName;\n  }\n\n  /**\n   * Gets the name of the document property based on the column name.\n   * @param {String} columnName The name of the column.\n   * @returns {String}\n   */\n  getPropertyName(columnName) {\n    return columnName;\n  }\n}\n\n/**\n * A [TableMappings]{@link module:mapping~TableMappings} implementation that converts CQL column names in all-lowercase\n * identifiers with underscores (snake case) to camel case (initial lowercase letter) property names.\n * <p>\n *   The conversion is performed without any checks for the source format, you should make sure that the source\n *   format is snake case for CQL identifiers and camel case for properties.\n * </p>\n * @alias module:mapping~UnderscoreCqlToCamelCaseMappings\n * @implements {module:mapping~TableMappings}\n */\nclass UnderscoreCqlToCamelCaseMappings extends TableMappings {\n  /**\n   * Creates a new instance of {@link UnderscoreCqlToCamelCaseMappings}\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Converts a property name in camel case to snake case.\n   * @param {String} propName Name of the property to convert to snake case.\n   * @return {String}\n   */\n  getColumnName(propName) {\n    return propName.replace(/[a-z][A-Z]/g, (match, offset) => match.charAt(0) + '_' + match.charAt(1)).toLowerCase();\n  }\n\n  /**\n   * Converts a column name in snake case to camel case.\n   * @param {String} columnName The column name to convert to camel case.\n   * @return {String}\n   */\n  getPropertyName(columnName) {\n    return columnName.replace(/_[a-z]/g, (match, offset) => ((offset === 0) ? match : match.substr(1).toUpperCase()));\n  }\n}\n\n/**\n * Default implementation of [TableMappings]{@link module:mapping~TableMappings} that doesn't perform any conversion.\n * @alias module:mapping~DefaultTableMappings\n * @implements {module:mapping~TableMappings}\n */\nclass DefaultTableMappings extends TableMappings {\n  /**\n   * Creates a new instance of {@link DefaultTableMappings}.\n   */\n  constructor() {\n    super();\n  }\n\n  /**  @override */\n  getColumnName(propName) {\n    return super.getColumnName(propName);\n  }\n\n  /** @override */\n  getPropertyName(columnName) {\n    return super.getPropertyName(columnName);\n  }\n\n  /**\n   * Creates a new object instance, using object initializer.\n   */\n  newObjectInstance() {\n    return super.newObjectInstance();\n  }\n}\n\nexports.TableMappings = TableMappings;\nexports.UnderscoreCqlToCamelCaseMappings = UnderscoreCqlToCamelCaseMappings;\nexports.DefaultTableMappings = DefaultTableMappings;","'use strict';\n\nconst EventEmitter = require('events');\n\n/**\n * Represents a tree node where the key is composed by 1 or more strings.\n * @ignore\n */\nclass Node extends EventEmitter {\n  /**\n   * Creates a new instance of {@link Node}.\n   * @param {Array<String>} key\n   * @param {Object} value\n   * @param {Array} [edges]\n   */\n  constructor(key, value, edges) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.edges = edges || [];\n  }\n}\n\n/**\n * A radix tree where each node contains a key, a value and edges.\n * @ignore\n */\nclass Tree extends Node {\n  constructor() {\n    super([], null);\n    this.length = 0;\n  }\n\n  /**\n   * Gets the existing item in the tree or creates a new one with the value provided by valueHandler\n   * @param {Iterator} keyIterator\n   * @param {Function} valueHandler\n   * @return {Object}\n   */\n  getOrCreate(keyIterator, valueHandler) {\n    if (typeof keyIterator.next !== 'function') {\n      keyIterator = keyIterator[Symbol.iterator]();\n    }\n    let node = this;\n    let isMatch = false;\n    let item = keyIterator.next();\n    while (true) {\n      let newBranch;\n      // Check node keys at position 1 and above\n      for (let i = 1; i < node.key.length; i++) {\n        if (item.done || node.key[i] !== item.value) {\n          // We should branch out\n          newBranch = this._createBranch(node, i, item.done, valueHandler);\n          break;\n        }\n        item = keyIterator.next();\n      }\n\n      if (item.done) {\n        isMatch = true;\n        break;\n      }\n\n      if (newBranch !== undefined) {\n        break;\n      }\n\n      const edges = node.edges;\n      let nextNode;\n      for (let i = 0; i < edges.length; i++) {\n        const e = edges[i];\n        if (e.key[0] === item.value) {\n          // its a match\n          nextNode = e;\n          item = keyIterator.next();\n          break;\n        }\n      }\n\n      if (nextNode === undefined) {\n        // Current node is the root for a new leaf\n        break;\n      }\n      else {\n        node = nextNode;\n      }\n    }\n\n    if (!isMatch) {\n      // Create using \"node\" as the root\n      const value = valueHandler();\n      node.edges.push(new Node(iteratorToArray(item.value, keyIterator), value));\n      this._onItemAdded();\n      return value;\n    }\n    return node.value;\n  }\n\n  _createBranch(node, index, useNewValue, valueHandler) {\n    const newBranch = new Node(node.key.slice(index), node.value, node.edges);\n    node.key = node.key.slice(0, index);\n    node.edges = [ newBranch ];\n    if (useNewValue) {\n      // The previous node value has moved to a leaf\n      // The node containing the new leaf should use the new value\n      node.value = valueHandler();\n      this._onItemAdded();\n    }\n    else {\n      // Clear the value as it was copied in the branch\n      node.value = null;\n    }\n    return newBranch;\n  }\n\n  _onItemAdded() {\n    this.length++;\n    this.emit('add', this.length);\n  }\n}\n\nfunction iteratorToArray(value, iterator) {\n  const values = [ value ];\n  let item = iterator.next();\n  while (!item.done) {\n    values.push(item.value);\n    item = iterator.next();\n  }\n  return values;\n}\n\nmodule.exports = Tree;","\"use strict\";\n\n/**\n * Creates a new Aggregate.\n * @classdesc Describes a CQL aggregate.\n * @alias module:metadata~Aggregate\n * @constructor\n */\nfunction Aggregate() {\n  /**\n   * Name of the aggregate.\n   * @type {String}\n   */\n  this.name = null;\n  /**\n   * Name of the keyspace where the aggregate is declared.\n   */\n  this.keyspaceName = null;\n  /**\n   * Signature of the aggregate.\n   * @type {Array.<String>}\n   */\n  this.signature = null;\n  /**\n   * List of the CQL aggregate argument types.\n   * @type {Array.<{code, info}>}\n   */\n  this.argumentTypes = null;\n  /**\n   * State Function.\n   * @type {String}\n   */\n  this.stateFunction = null;\n  /**\n   * State Type.\n   * @type {{code, info}}\n   */\n  this.stateType = null;\n  /**\n   * Final Function.\n   * @type {String}\n   */\n  this.finalFunction = null;\n  this.initConditionRaw = null;\n  /**\n   * Initial state value of this aggregate.\n   * @type {String}\n   */\n  this.initCondition = null;\n  /**\n   * Type of the return value.\n   * @type {{code: number, info: (Object|Array|null)}}\n   */\n  this.returnType = null;\n}\n\nmodule.exports = Aggregate;","'use strict';\n\nconst util = require('util');\nconst errors = require('../errors');\n\n/**\n * Creates a new instance of <code>ClientState</code>.\n * @classdesc\n * Represents the state of a {@link Client}.\n * <p>\n * Exposes information on the connections maintained by a Client at a specific time.\n * </p>\n * @alias module:metadata~ClientState\n * @param {Array<Host>} hosts\n * @param {Object.<String, Number>} openConnections\n * @param {Object.<String, Number>} inFlightQueries\n * @constructor\n */\nfunction ClientState(hosts, openConnections, inFlightQueries) {\n  this._hosts = hosts;\n  this._openConnections = openConnections;\n  this._inFlightQueries = inFlightQueries;\n}\n\n/**\n * Creates a new instance from the provided client.\n * @param {Client} client\n * @internal\n * @ignore\n */\nClientState.from = function (client) {\n  const openConnections = {};\n  const inFlightQueries = {};\n  const hostArray = [];\n  client.hosts.forEach(function each(host) {\n    if (host.pool.connections.length === 0) {\n      return;\n    }\n\n    hostArray.push(host);\n    openConnections[host.address] = host.pool.connections.length;\n    inFlightQueries[host.address] = host.getInFlight();\n  });\n  return new ClientState(hostArray, openConnections, inFlightQueries);\n};\n\n/**\n * Get an array of hosts to which the client is connected to.\n * @return {Array<Host>}\n */\nClientState.prototype.getConnectedHosts = function () {\n  return this._hosts;\n};\n\n/**\n * Gets the amount of open connections to a given host.\n * @param {Host} host\n * @return {Number}\n */\nClientState.prototype.getOpenConnections = function (host) {\n  if (!host) {\n    throw new errors.ArgumentError('Host is not defined');\n  }\n  return this._openConnections[host.address] || 0;\n};\n\n/**\n * Gets the amount of queries that are currently being executed through a given host.\n * <p>\n * This corresponds to the number of queries that have been sent by the Client to server Host on one of its connections\n * but haven't yet obtained a response.\n * </p>\n * @param {Host} host\n * @return {Number}\n */\nClientState.prototype.getInFlightQueries = function (host) {\n  if (!host) {\n    throw new errors.ArgumentError('Host is not defined');\n  }\n  return this._inFlightQueries[host.address] || 0;\n};\n\n/**\n * Returns the string representation of the instance.\n */\nClientState.prototype.toString = function () {\n  return util.format(\n    '{\"hosts\": %j, \"openConnections\": %j, \"inFlightQueries\": %j}',\n    this._hosts.map(function (h) { return h.address; }),\n    this._openConnections,\n    this._inFlightQueries\n  );\n};\n\nmodule.exports = ClientState;","\"use strict\";\nconst util = require('util');\nconst events = require('events');\n/**\n * Creates a new instance of DataCollection\n * @param {String} name Name of the data object.\n * @classdesc Describes a table or a view\n * @alias module:metadata~DataCollection\n * @constructor\n * @abstract\n */\nfunction DataCollection(name) {\n  events.EventEmitter.call(this);\n  this.setMaxListeners(0);\n  //private\n  Object.defineProperty(this, 'loading', { value: false, enumerable: false, writable: true });\n  Object.defineProperty(this, 'loaded', { value: false, enumerable: false, writable: true });\n  /**\n   * Name of the object\n   * @type {String}\n   */\n  this.name = name;\n  /**\n   * False-positive probability for SSTable Bloom filters.\n   * @type {number}\n   */\n  this.bloomFilterFalsePositiveChance = 0;\n  /**\n   * Level of caching: all, keys_only, rows_only, none\n   * @type {String}\n   */\n  this.caching = null;\n  /**\n   * A human readable comment describing the table.\n   * @type {String}\n   */\n  this.comment = null;\n  /**\n   * Specifies the time to wait before garbage collecting tombstones (deletion markers)\n   * @type {number}\n   */\n  this.gcGraceSeconds = 0;\n  /**\n   * Compaction strategy class used for the table.\n   * @type {String}\n   */\n  this.compactionClass = null;\n  /**\n   * Associative-array containing the compaction options keys and values.\n   * @type {Object}\n   */\n  this.compactionOptions = null;\n  /**\n   * Associative-array containing the compression options.\n   * @type {Object}\n   */\n  this.compression = null;\n  /**\n   * Specifies the probability of read repairs being invoked over all replicas in the current data center.\n   * @type {number}\n   */\n  this.localReadRepairChance = 0;\n  /**\n   * Specifies the probability with which read repairs should be invoked on non-quorum reads. The value must be\n   * between 0 and 1.\n   * @type {number}\n   */\n  this.readRepairChance = 0;\n  /**\n   * An associative Array containing extra metadata for the table.\n   * <p>\n   * For Apache Cassandra versions prior to 3.0.0, this method always returns <code>null</code>.\n   * </p>\n   * @type {Object}\n   */\n  this.extensions = null;\n  /**\n   * When compression is enabled, this option defines the probability\n   * with which checksums for compressed blocks are checked during reads.\n   * The default value for this options is 1.0 (always check).\n   * <p>\n   *   For Apache Cassandra versions prior to 3.0.0, this method always returns <code>null</code>.\n   * </p>\n   * @type {Number|null}\n   */\n  this.crcCheckChance = null;\n  /**\n   * Whether the populate I/O cache on flush is set on this table.\n   * @type {Boolean}\n   */\n  this.populateCacheOnFlush = false;\n  /**\n   * Returns the default TTL for this table.\n   * @type {Number}\n   */\n  this.defaultTtl = 0;\n  /**\n   * * Returns the speculative retry option for this table.\n   * @type {String}\n   */\n  this.speculativeRetry = 'NONE';\n  /**\n   * Returns the minimum index interval option for this table.\n   * <p>\n   *   Note: this option is available in Apache Cassandra 2.1 and above, and will return <code>null</code> for\n   *   earlier versions.\n   * </p>\n   * @type {Number|null}\n   */\n  this.minIndexInterval = 128;\n  /**\n   * Returns the maximum index interval option for this table.\n   * <p>\n   * Note: this option is available in Apache Cassandra 2.1 and above, and will return <code>null</code> for\n   * earlier versions.\n   * </p>\n   * @type {Number|null}\n   */\n  this.maxIndexInterval = 2048;\n  /**\n   * Array describing the table columns.\n   * @type {Array}\n   */\n  this.columns = null;\n  /**\n   * An associative Array of columns by name.\n   * @type {Object}\n   */\n  this.columnsByName = null;\n  /**\n   * Array describing the columns that are part of the partition key.\n   * @type {Array}\n   */\n  this.partitionKeys = [];\n  /**\n   * Array describing the columns that form the clustering key.\n   * @type {Array}\n   */\n  this.clusteringKeys = [];\n  /**\n   * Array describing the clustering order of the columns in the same order as the clusteringKeys.\n   * @type {Array}\n   */\n  this.clusteringOrder = [];\n}\n\nutil.inherits(DataCollection, events.EventEmitter);\n\nmodule.exports = DataCollection;","\"use strict\";\n\nconst util = require('util');\nconst utils = require('../utils');\n\nconst _queueOverflowThreshold = 1000;\n\n/**\n * Debounce protocol events by acting on those events with a sliding delay.\n * @param {Number} delay\n * @param {Function} logger\n * @ignore\n * @constructor\n */\nfunction EventDebouncer(delay, logger) {\n  this._delay = delay;\n  this._logger = logger;\n  this._queue = null;\n  this._timeout = null;\n}\n\n/**\n * Adds a new event to the queue and moves the delay.\n * @param {{ handler: Function, all: boolean|undefined, keyspace: String|undefined, cqlObject: String|null|undefined,\n * callback: Function|undefined }} event\n * @param {Boolean} processNow\n */\nEventDebouncer.prototype.eventReceived = function (event, processNow) {\n  event.callback = event.callback || utils.noop;\n  this._queue = this._queue || { callbacks: [], keyspaces: {} };\n  const delay = !processNow ? this._delay : 0;\n  if (event.all) {\n    // when an event marked with all is received, it supersedes all the rest of events\n    // a full update (hosts + keyspaces + tokens) is going to be made\n    this._queue.mainEvent = event;\n  }\n  if (this._queue.callbacks.length === _queueOverflowThreshold) {\n    // warn once\n    this._logger('warn', util.format('Event debouncer queue exceeded %d events', _queueOverflowThreshold));\n  }\n  this._queue.callbacks.push(event.callback);\n  if (this._queue.mainEvent) {\n    // a full refresh is scheduled and the callback was added, nothing else to do.\n    return this._slideDelay(delay);\n  }\n  // Insert at keyspace level\n  let keyspaceEvents = this._queue.keyspaces[event.keyspace];\n  if (!keyspaceEvents) {\n    keyspaceEvents = this._queue.keyspaces[event.keyspace] = { events: [] };\n  }\n  if (event.cqlObject === undefined) {\n    // a full refresh of the keyspace, supersedes all child keyspace events\n    keyspaceEvents.mainEvent = event;\n  }\n  keyspaceEvents.events.push(event);\n  this._slideDelay(delay);\n};\n\n/**\n * @param {Number} delay\n * @private\n * */\nEventDebouncer.prototype._slideDelay = function (delay) {\n  const self = this;\n  function process() {\n    const q = self._queue;\n    self._queue = null;\n    self._timeout = null;\n    processQueue(q);\n  }\n  if (delay === 0) {\n    // no delay, process immediately\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n    return process();\n  }\n  const previousTimeout = this._timeout;\n  // add the new timeout before removing the previous one performs better\n  this._timeout = setTimeout(process, delay);\n  if (previousTimeout) {\n    clearTimeout(previousTimeout);\n  }\n};\n\n/**\n * Clears the timeout and invokes all pending callback.\n */\nEventDebouncer.prototype.shutdown = function () {\n  if (!this._queue) {\n    return;\n  }\n  this._queue.callbacks.forEach(function (cb) {\n    cb();\n  });\n  this._queue = null;\n  clearTimeout(this._timeout);\n  this._timeout = null;\n};\n\n/**\n * @param {{callbacks: Array, keyspaces: Object, mainEvent: Object}} q\n * @private\n */\nfunction processQueue (q) {\n  if (q.mainEvent) {\n    // refresh all by invoking 1 handler and invoke all pending callbacks\n    return q.mainEvent.handler(function invokeCallbacks(err) {\n      for (let i = 0; i < q.callbacks.length; i++) {\n        q.callbacks[i](err);\n      }\n    });\n  }\n  utils.each(Object.keys(q.keyspaces), function eachKeyspace(name, next) {\n    const keyspaceEvents = q.keyspaces[name];\n    if (keyspaceEvents.mainEvent) {\n      // refresh a keyspace\n      return keyspaceEvents.mainEvent.handler(function mainEventCallback(err) {\n        for (let i = 0; i < keyspaceEvents.events.length; i++) {\n          keyspaceEvents.events[i].callback(err);\n        }\n        next();\n      });\n    }\n    // deal with individual handlers and callbacks\n    keyspaceEvents.events.forEach(function eachEvent(event) {\n      // sync handlers\n      event.handler();\n      event.callback();\n    });\n    next();\n  });\n}\n\nmodule.exports = EventDebouncer;","\"use strict\";\nconst events = require('events');\nconst util = require('util');\n/**\n * Module containing classes and fields related to metadata.\n * @module metadata\n */\nconst t = require('../tokenizer');\nconst utils = require('../utils');\nconst errors = require('../errors');\nconst types = require('../types');\nconst requests = require('../requests');\nconst schemaParserFactory = require('./schema-parser');\nconst TokenRange = require('../token').TokenRange;\nconst ExecutionOptions = require('../execution-options').ExecutionOptions;\n\n/**\n * @const\n * @private\n */\nconst _selectTraceSession = \"SELECT * FROM system_traces.sessions WHERE session_id=%s\";\n/**\n * @const\n * @private\n */\nconst _selectTraceEvents = \"SELECT * FROM system_traces.events WHERE session_id=%s\";\n/**\n * @const\n * @private\n */\nconst _selectSchemaVersionPeers = \"SELECT schema_version FROM system.peers\";\n/**\n * @const\n * @private\n */\nconst _selectSchemaVersionLocal = \"SELECT schema_version FROM system.local\";\n/**\n * @const\n * @private\n */\nconst _traceMaxAttemps = 5;\n/**\n * @const\n * @private\n */\nconst _traceAttemptDelay = 200;\n\n/**\n * Represents cluster and schema information.\n * The metadata class acts as a internal state of the driver.\n * @param {ClientOptions} options\n * @param {ControlConnection} controlConnection Control connection used to retrieve information.\n * @constructor\n */\nfunction Metadata (options, controlConnection) {\n  if (!options) {\n    throw new errors.ArgumentError('Options are not defined');\n  }\n  Object.defineProperty(this, 'options', { value: options, enumerable: false, writable: false});\n  Object.defineProperty(this, 'controlConnection', { value: controlConnection, enumerable: false, writable: false});\n  this.keyspaces = {};\n  this.initialized = false;\n  this._schemaParser = schemaParserFactory.getByVersion(options, controlConnection, this.getUdt.bind(this));\n  const self = this;\n  this._preparedQueries = new PreparedQueries(options.maxPrepared, function () {\n    self.log.apply(self, arguments);\n  });\n}\n\n/**\n * Sets the cassandra version\n * @internal\n * @ignore\n * @param {Array.<Number>} version\n */\nMetadata.prototype.setCassandraVersion = function (version) {\n  this._schemaParser = schemaParserFactory.getByVersion(\n    this.options, this.controlConnection, this.getUdt.bind(this), version, this._schemaParser);\n};\n\n/**\n * @ignore\n * @param {String} partitionerName\n */\nMetadata.prototype.setPartitioner = function (partitionerName) {\n  if (/RandomPartitioner$/.test(partitionerName)) {\n    return this.tokenizer = new t.RandomTokenizer();\n  }\n  if (/ByteOrderedPartitioner$/.test(partitionerName)) {\n    return this.tokenizer = new t.ByteOrderedTokenizer();\n  }\n  return this.tokenizer = new t.Murmur3Tokenizer();\n};\n\n/**\n * Populates the information regarding primary replica per token, datacenters (+ racks) and sorted token ring.\n * @ignore\n * @param {HostMap} hosts\n */\nMetadata.prototype.buildTokens = function (hosts) {\n  if (!this.tokenizer) {\n    return this.log('error', 'Tokenizer could not be determined');\n  }\n  //Get a sorted array of tokens\n  const allSorted = [];\n  //Get a map of <token, primaryHost>\n  const primaryReplicas = {};\n  //Depending on the amount of tokens, this could be an expensive operation\n  const hostArray = hosts.values();\n  const stringify = this.tokenizer.stringify;\n  const datacenters = {};\n  hostArray.forEach((h) => {\n    if (!h.tokens) {\n      return;\n    }\n    h.tokens.forEach((tokenString) => {\n      const token = this.tokenizer.parse(tokenString);\n      utils.insertSorted(allSorted, token, (t1, t2) => t1.compare(t2));\n      primaryReplicas[stringify(token)] = h;\n    });\n    let dc = datacenters[h.datacenter];\n    if (!dc) {\n      dc = datacenters[h.datacenter] = {\n        hostLength: 0,\n        racks: new utils.HashSet()\n      };\n    }\n    dc.hostLength++;\n    dc.racks.add(h.rack);\n  });\n  //Primary replica for given token\n  this.primaryReplicas = primaryReplicas;\n  //All the tokens in ring order\n  this.ring = allSorted;\n\n  // Build TokenRanges.\n  const tokenRanges = new Set();\n  if(this.ring.length === 1) {\n    // If there is only one token, return the range ]minToken, minToken]\n    const min = this.tokenizer.minToken();\n    tokenRanges.add(new TokenRange(min, min, this.tokenizer));\n  } else {\n    for (let i = 0; i < this.ring.length; i++) {\n      const start = this.ring[i];\n      const end = this.ring[(i + 1) % this.ring.length];\n      tokenRanges.add(new TokenRange(start, end, this.tokenizer));\n    }\n  }\n  this.tokenRanges = tokenRanges;\n\n  //Compute string versions as it's potentially expensive and frequently reused later\n  this.ringTokensAsStrings = new Array(allSorted.length);\n  for (let i = 0; i < allSorted.length; i++) {\n    this.ringTokensAsStrings[i] = stringify(allSorted[i]);\n  }\n  //Datacenter metadata (host length and racks)\n  this.datacenters = datacenters;\n};\n\n/**\n * Gets the keyspace metadata information and updates the internal state of the driver.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the keyspaces metadata refresh completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * @param {String} name Name of the keyspace.\n * @param {Function} [callback] Optional callback.\n */\nMetadata.prototype.refreshKeyspace = function (name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._refreshKeyspaceCb(name, cb);\n  });\n};\n\n/**\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._refreshKeyspaceCb = function (name, callback) {\n  if (!this.initialized) {\n    return callback(this._uninitializedError(), null);\n  }\n  this.log('info', util.format('Retrieving keyspace %s metadata', name));\n  const self = this;\n  this._schemaParser.getKeyspace(name, function (err, ksInfo) {\n    if (err) {\n      self.log('error', 'There was an error while trying to retrieve keyspace information', err);\n      return callback(err);\n    }\n    if (!ksInfo) {\n      // the keyspace was dropped\n      delete self.keyspaces[name];\n      return callback();\n    }\n    // tokens are lazily init on the keyspace, once a replica from that keyspace is retrieved.\n    self.keyspaces[ksInfo.name] = ksInfo;\n    callback(null, ksInfo);\n  });\n};\n\n/**\n * Gets the metadata information of all the keyspaces and updates the internal state of the driver.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the keyspace metadata refresh completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * @param {Boolean|Function} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not\n * connected at the moment. Default: true.\n * @param {Function} [callback] Optional callback.\n */\nMetadata.prototype.refreshKeyspaces = function (waitReconnect, callback) {\n  if (typeof waitReconnect === 'function' || typeof waitReconnect === 'undefined') {\n    callback = waitReconnect;\n    waitReconnect = true;\n  }\n\n  return this._refreshKeyspaces(waitReconnect, false, callback);\n};\n\n/**\n * @param {Boolean} waitReconnect\n * @param {Boolean} internal Whether or not this was called by driver (i.e. control connection)\n * @param {Function} [callback] \n * @private\n */\nMetadata.prototype._refreshKeyspaces = function (waitReconnect, internal, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._refreshKeyspacesCb(waitReconnect, internal, cb);\n  });\n};\n\n/**\n * @param {Boolean} waitReconnect\n * @param {Boolean} internal\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._refreshKeyspacesCb = function (waitReconnect, internal, callback) {\n  if (!internal && !this.initialized) {\n    return callback(this._uninitializedError(), null);\n  }\n  this.log('info', 'Retrieving keyspaces metadata');\n  const self = this;\n  this._schemaParser.getKeyspaces(waitReconnect, function getKeyspacesCallback(err, keyspaces) {\n    if (err) {\n      self.log('error', 'There was an error while trying to retrieve keyspaces information', err);\n      return callback(err);\n    }\n    self.keyspaces = keyspaces;\n    callback(null, keyspaces);\n  });\n};\n\nMetadata.prototype._getKeyspaceReplicas = function (keyspace) {\n  if (!keyspace.replicas) {\n    //Calculate replicas the first time for the keyspace\n    keyspace.replicas =\n      keyspace.tokenToReplica(this.tokenizer, this.ringTokensAsStrings, this.primaryReplicas, this.datacenters);\n  }\n  return keyspace.replicas;\n};\n\n/**\n * Gets the host list representing the replicas that contain the given partition key, token or token range.\n * <p>\n *   It uses the pre-loaded keyspace metadata to retrieve the replicas for a token for a given keyspace.\n *   When the keyspace metadata has not been loaded, it returns null.\n * </p>\n * @param {String} keyspaceName\n * @param {Buffer|Token|TokenRange} token Can be Buffer (serialized partition key), Token or TokenRange\n * @returns {Array}\n */\nMetadata.prototype.getReplicas = function (keyspaceName, token) {\n  if (!this.ring) {\n    return null;\n  }\n  if (Buffer.isBuffer(token)) {\n    token = this.tokenizer.hash(token);\n  }\n  if (token instanceof TokenRange) {\n    token = token.end;\n  }\n\n  let keyspace;\n  if (keyspaceName) {\n    keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      // the keyspace was not found, the metadata should be loaded beforehand\n      return null;\n    }\n  }\n  let i = utils.binarySearch(this.ring, token, (t1, t2) => t1.compare(t2));\n  if (i < 0) {\n    i = ~i;\n  }\n  if (i >= this.ring.length) {\n    //it circled back\n    i = i % this.ring.length;\n  }\n  const closestToken = this.ringTokensAsStrings[i];\n\n  if (!keyspaceName) {\n    return [this.primaryReplicas[closestToken]];\n  }\n\n  const replicas = this._getKeyspaceReplicas(keyspace);\n  return replicas[closestToken];\n};\n\n/**\n * Gets the token ranges that define data distribution in the ring.\n *\n * @returns {Set<TokenRange>} The ranges of the ring or empty set if schema metadata is not enabled.\n */\nMetadata.prototype.getTokenRanges = function () {\n  return this.tokenRanges;\n};\n\n/**\n * Gets the token ranges that are replicated on the given host, for\n * the given keyspace.\n *\n * @param {String} keyspaceName The name of the keyspace to get ranges for.\n * @param {Host} host The host.\n * @returns {Set<TokenRange>|null} Ranges for the keyspace on this host or null if keyspace isn't found or hasn't been loaded.\n */\nMetadata.prototype.getTokenRangesForHost = function (keyspaceName, host) {\n  if (!this.ring) {\n    return null;\n  }\n  let keyspace;\n  if (keyspaceName) {\n    keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      // the keyspace was not found, the metadata should be loaded beforehand\n      return null;\n    }\n  }\n\n  // If the ring has only 1 token, just return the ranges as we should only have a single node cluster.\n  if (this.ring.length === 1) {\n    return this.getTokenRanges();\n  }\n\n  const replicas = this._getKeyspaceReplicas(keyspace);\n  const ranges = new Set();\n\n  // for each range, find replicas for end token, if replicas include host, add range.\n  this.tokenRanges.forEach((tokenRange) => {\n    const replicasForToken = replicas[this.tokenizer.stringify(tokenRange.end)];\n    if (replicasForToken.indexOf(host) !== -1) {\n      ranges.add(tokenRange);\n    }\n  });\n  return ranges;\n};\n\n/**\n * Constructs a Token from the input buffer(s) or string input.  If a string is passed in\n * it is assumed this matches the token representation reported by cassandra.\n * @param {Array<Buffer>|Buffer|String} components\n * @returns {Token} constructed token from the input buffer.\n */\nMetadata.prototype.newToken = function (components) {\n  if (!this.tokenizer) {\n    throw new Error('Partitioner not established.  This should only happen if metadata was disabled or you have not connected yet.');\n  }\n  if (util.isArray(components)) {\n    return this.tokenizer.hash(Buffer.concat(components));\n  } else if (util.isString(components)) {\n    return this.tokenizer.parse(components);\n  }\n  return this.tokenizer.hash(components);\n};\n\n/**\n * Constructs a TokenRange from the given start and end tokens.\n * @param {Token} start \n * @param {Token} end \n * @returns TokenRange build range spanning from start (exclusive) to end (inclusive).\n */\nMetadata.prototype.newTokenRange = function(start, end) {\n  if (!this.tokenizer) {\n    throw new Error('Partitioner not established.  This should only happen if metadata was disabled or you have not connected yet.');\n  }\n  return new TokenRange(start, end, this.tokenizer);\n};\n\nMetadata.prototype.log = utils.log;\n\n/**\n * Gets the metadata information already stored associated to a prepared statement\n * @param {String} keyspaceName\n * @param {String} query\n * @internal\n * @ignore\n */\nMetadata.prototype.getPreparedInfo = function (keyspaceName, query) {\n  //overflow protection\n  return this._preparedQueries.getOrAdd(keyspaceName, query);\n};\n\n/**\n * Clears the internal state related to the prepared statements.\n * Following calls to the Client using the prepare flag will re-prepare the statements.\n */\nMetadata.prototype.clearPrepared = function () {\n  this._preparedQueries.clear();\n};\n\n/** @ignore */\nMetadata.prototype.getPreparedById = function (id) {\n  return this._preparedQueries.getById(id);\n};\n\n/** @ignore */\nMetadata.prototype.setPreparedById = function (info) {\n  return this._preparedQueries.setById(info);\n};\n\n/** @ignore */\nMetadata.prototype.getAllPrepared = function () {\n  return this._preparedQueries.getAll();\n};\n\n/** @ignore */\nMetadata.prototype._uninitializedError = function () {\n  return new Error('Metadata has not been initialized.  This could only happen if you have not connected yet.');\n};\n\n/**\n * Gets the definition of an user-defined type.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same UDT definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace.\n * @param {String} name Name of the UDT.\n * @param {Function} [callback] The callback to invoke when retrieval completes.\n */\nMetadata.prototype.getUdt = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getUdtCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getUdtCb = function (keyspaceName, name, callback) {\n  if (!this.initialized) {\n    return callback(this._uninitializedError(), null);\n  }\n  let cache;\n  if (this.options.isMetadataSyncEnabled) {\n    const keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = keyspace.udts;\n  }\n  this._schemaParser.getUdt(keyspaceName, name, cache, callback);\n};\n\n/**\n * Gets the definition of a table.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same table definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace.\n * @param {String} name Name of the Table.\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link TableMetadata} as\n * second parameter.\n */\nMetadata.prototype.getTable = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getTableCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getTableCb = function (keyspaceName, name, callback) {\n  if (!this.initialized) {\n    return callback(this._uninitializedError(), null);\n  }\n  let cache;\n  let virtual;\n  if (this.options.isMetadataSyncEnabled) {\n    const keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = keyspace.tables;\n    virtual = keyspace.virtual;\n  }\n  this._schemaParser.getTable(keyspaceName, name, cache, virtual, callback);\n};\n\n/**\n * Gets the definition of CQL functions for a given name.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace.\n * @param {String} name Name of the Function.\n * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link SchemaFunction}\n * as second parameter.\n */\nMetadata.prototype.getFunctions = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getFunctionsCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getFunctionsCb = function (keyspaceName, name, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('Callback is not a function');\n  }\n  if (!keyspaceName || !name) {\n    return callback(\n      new errors.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata'));\n  }\n  this._getFunctions(keyspaceName, name, false, function (err, functionsMap) {\n    if (err) {\n      return callback(err, null);\n    }\n    callback(null, utils.objectValues(functionsMap));\n  });\n};\n\n/**\n * Gets a definition of CQL function for a given name and signature.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the Function\n * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link SchemaFunction} as second\n * parameter.\n */\nMetadata.prototype.getFunction = function (keyspaceName, name, signature, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getSingleFunctionCb(keyspaceName, name, signature, false, cb);\n  });\n};\n\n/**\n * Gets the definition of CQL aggregate for a given name.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same aggregates definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the Function\n * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link Aggregate} as\n * second parameter.\n */\nMetadata.prototype.getAggregates = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getAggregatesCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getAggregatesCb = function (keyspaceName, name, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('Callback is not a function');\n  }\n  if (!keyspaceName || !name) {\n    return callback(new errors.ArgumentError('You must provide the keyspace name and cql aggregate name to retrieve the metadata'));\n  }\n  this._getFunctions(keyspaceName, name, true, function (err, functionsMap) {\n    if (err) {\n      return callback(err, null);\n    }\n    callback(null, utils.objectValues(functionsMap));\n  });\n};\n\n/**\n * Gets a definition of CQL aggregate for a given name and signature.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same aggregate definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the aggregate\n * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link Aggregate} as second parameter.\n */\nMetadata.prototype.getAggregate = function (keyspaceName, name, signature, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getSingleFunctionCb(keyspaceName, name, signature, true, cb);\n  });\n};\n\n/**\n * Gets the definition of a CQL materialized view for a given name.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n *   Note that, unlike the rest of the {@link Metadata} methods, this method does not cache the result for following\n *   calls, as the current version of the Cassandra native protocol does not support schema change events for\n *   materialized views. Each call to this method will produce one or more queries to the cluster.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the materialized view\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link MaterializedView} as\n * second parameter.\n */\nMetadata.prototype.getMaterializedView = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getMaterializedViewCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getMaterializedViewCb = function (keyspaceName, name, callback) {\n  if (!this.initialized) {\n    return callback(this._uninitializedError(), null);\n  }\n  let cache;\n  if (this.options.isMetadataSyncEnabled) {\n    const keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = keyspace.views;\n  }\n  this._schemaParser.getMaterializedView(keyspaceName, name, cache, callback);\n};\n\n/**\n * Gets a map of cql function definitions or aggregates based on signature.\n * @param {String} keyspaceName\n * @param {String} name Name of the function or aggregate\n * @param {Boolean} aggregate\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getFunctions = function (keyspaceName, name, aggregate, callback) {\n  if (!this.initialized) {\n    return callback(this._uninitializedError(), null);\n  }\n  let cache;\n  if (this.options.isMetadataSyncEnabled) {\n    const keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = aggregate ? keyspace.aggregates : keyspace.functions;\n  }\n  this._schemaParser.getFunctions(keyspaceName, name, aggregate, cache, callback);\n};\n\n/**\n * Gets a single cql function or aggregate definition\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Array} signature\n * @param {Boolean} aggregate\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getSingleFunctionCb = function (keyspaceName, name, signature, aggregate, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('Callback is not a function');\n  }\n  if (!keyspaceName || !name) {\n    return callback(\n      new errors.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata'));\n  }\n  if (!util.isArray(signature)) {\n    return callback(new errors.ArgumentError('Signature must be an array of types'));\n  }\n  try {\n    signature = signature.map(function (item) {\n      if (typeof item === 'string') {\n        return item;\n      }\n      return types.getDataTypeNameByCode(item);\n    });\n  }\n  catch (err) {\n    return callback(err);\n  }\n  this._getFunctions(keyspaceName, name, aggregate, function (err, functionsMap) {\n    if (err) {\n      return callback(err, null);\n    }\n    let f;\n    if (functionsMap) {\n      f = functionsMap['(' + signature.join(',') + ')'];\n    }\n    callback(null, f || null);\n  });\n};\n\n/**\n * Gets the trace session generated by Cassandra when query tracing is enabled for the\n * query. The trace itself is stored in Cassandra in the <code>sessions</code> and\n * <code>events</code> table in the <code>system_traces</code> keyspace and can be\n * retrieve manually using the trace identifier.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * @param {Uuid} traceId Identifier of the trace session.\n * @param {Number} [consistency] The consistency level to obtain the trace.\n * @param {Function} [callback] The callback with the err as first parameter and the query trace as second parameter.\n */\nMetadata.prototype.getTrace = function (traceId, consistency, callback) {\n  if (!callback && typeof consistency === 'function') {\n    // Both callback and consistency are optional parameters\n    // In this case, the second parameter is the callback\n    callback = consistency;\n    consistency = null;\n  }\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    this._getTraceCb(traceId, consistency, cb);\n  });\n};\n\n/**\n * @param {Uuid} traceId\n * @param {Number} consistency\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getTraceCb = function (traceId, consistency, callback) {\n  if (!this.initialized) {\n    return callback(this._uninitializedError(), null);\n  }\n  let trace;\n  let attempts = 0;\n  const info = ExecutionOptions.empty();\n  info.getConsistency = () => consistency;\n  const sessionRequest = new requests.QueryRequest(util.format(_selectTraceSession, traceId), null, info);\n  const eventsRequest = new requests.QueryRequest(util.format(_selectTraceEvents, traceId), null, info);\n  const self = this;\n\n  utils.whilst(function condition() {\n    return !trace && (attempts++ < _traceMaxAttemps);\n  }, function iterator(next) {\n    self.controlConnection.query(sessionRequest, function (err, result) {\n      if (err) {\n        return next(err);\n      }\n      const sessionRow = result.rows[0];\n      if (!sessionRow || !sessionRow['duration']) {\n        return setTimeout(next, _traceAttemptDelay);\n      }\n      trace = {\n        requestType: sessionRow['request'],\n        coordinator: sessionRow['coordinator'],\n        parameters: sessionRow['parameters'],\n        startedAt: sessionRow['started_at'],\n        duration: sessionRow['duration'],\n        clientAddress: sessionRow['client'],\n        events: []\n      };\n      self.controlConnection.query(eventsRequest, function (err, result) {\n        if (err) {\n          return next(err);\n        }\n        result.rows.forEach(function (row) {\n          trace.events.push({\n            id: row['event_id'],\n            activity: row['activity'],\n            source: row['source'],\n            elapsed: row['source_elapsed'],\n            thread: row['thread']\n          });\n        });\n        next();\n      });\n    });\n  }, function getTraceEnded(err) {\n    if (!err && !trace) {\n      err = new Error(util.format('Trace %s could not fully retrieved after %d attempts', traceId, _traceMaxAttemps));\n    }\n    callback(err, trace);\n  });\n};\n\n/**\n * Checks whether hosts that are currently up agree on the schema definition.\n * <p>\n *   This method performs a one-time check only, without any form of retry; therefore\n *   <code>protocolOptions.maxSchemaAgreementWaitSeconds</code> setting does not apply in this case.\n * </p>\n * @param {Function} [callback] A function that is invoked with a value\n * <code>true</code> when all hosts agree on the schema and <code>false</code> when there is no agreement or when\n * the check could not be performed (for example, if the control connection is down).\n * @returns {Promise} Returns a <code>Promise</code> when a callback is not provided. The promise resolves to\n * <code>true</code> when all hosts agree on the schema and <code>false</code> when there is no agreement or when\n * the check could not be performed (for example, if the control connection is down).\n */\nMetadata.prototype.checkSchemaAgreement = function (callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, function handler(cb) {\n    const connection = this.controlConnection.connection;\n    if (!connection) {\n      return cb(null, false);\n    }\n\n    this.compareSchemaVersions(connection, (err, agreement) => {\n      // The error is never thrown\n      cb(null, !err && agreement);\n    });\n  });\n};\n\n/**\n * Uses the metadata to fill the user provided parameter hints\n * @param {String} keyspace\n * @param {Array} hints\n * @param {Function} callback\n * @internal\n * @ignore\n */\nMetadata.prototype.adaptUserHints = function (keyspace, hints, callback) {\n  if (!util.isArray(hints)) {\n    return callback();\n  }\n  const udts = [];\n  //check for udts and get the metadata\n  function checkUdtTypes(type) {\n    if (type.code === types.dataTypes.udt) {\n      const udtName = type.info.split('.');\n      type.info = {\n        keyspace: udtName[0],\n        name: udtName[1]\n      };\n      if (!type.info.name) {\n        if (!keyspace) {\n          throw new TypeError('No keyspace specified for udt: ' + udtName.join('.'));\n        }\n        //use the provided keyspace\n        type.info.name = type.info.keyspace;\n        type.info.keyspace = keyspace;\n      }\n      udts.push(type);\n      return;\n    }\n    if (!type.info) {\n      return;\n    }\n    if (type.code === types.dataTypes.list || type.code === types.dataTypes.set) {\n      return checkUdtTypes(type.info);\n    }\n    if (type.code === types.dataTypes.map) {\n      checkUdtTypes(type.info[0]);\n      checkUdtTypes(type.info[1]);\n    }\n  }\n  for (let i = 0; i < hints.length; i++) {\n    const hint = hints[i];\n    if (typeof hint !== 'string') {\n      continue;\n    }\n    try {\n      const type = types.dataTypes.getByName(hint);\n      checkUdtTypes(type);\n      hints[i] = type;\n    }\n    catch (err) {\n      return callback(err);\n    }\n  }\n  const self = this;\n  utils.each(udts, function (type, next) {\n    self.getUdt(type.info.keyspace, type.info.name, function (err, udtInfo) {\n      if (err) {\n        return next(err);\n      }\n      if (!udtInfo) {\n        return next(new TypeError('User defined type not found: ' + type.info.keyspace + '.' + type.info.name));\n      }\n      type.info = udtInfo;\n      next();\n    });\n  }, callback);\n};\n\n/**\n * Uses the provided connection to query the schema versions and compare them.\n * @param {Connection} connection\n * @param {Function} callback\n * @internal\n * @ignore\n */\nMetadata.prototype.compareSchemaVersions = function (connection, callback) {\n  const versions = new Set();\n\n  utils.series([\n    next => {\n      const request = new requests.QueryRequest(_selectSchemaVersionLocal, null, null);\n      connection.sendStream(request, null, function (err, result) {\n        if (!err && result && result.rows && result.rows.length === 1) {\n          versions.add(result.rows[0]['schema_version'].toString());\n        }\n        next(err);\n      });\n    },\n    next => {\n      const request = new requests.QueryRequest(_selectSchemaVersionPeers, null, null);\n      connection.sendStream(request, null, function (err, result) {\n        if (!err && result && result.rows) {\n          for (const row of result.rows) {\n            const value = row['schema_version'];\n            if (!value) {\n              continue;\n            }\n            versions.add(value.toString());\n          }\n        }\n        next(err);\n      });\n    }\n  ], (err) => {\n    callback(err, versions.size === 1);\n  });\n};\n\n/**\n * Allows to store prepared queries and retrieval by query or query id.\n * @param {Number} maxPrepared\n * @param {Function} logger\n * @constructor\n * @ignore\n */\nfunction PreparedQueries(maxPrepared, logger) {\n  this.length = 0;\n  this._maxPrepared = maxPrepared;\n  this._mapByKey = {};\n  this._mapById = {};\n  this._logger = logger;\n}\n\nPreparedQueries.prototype._getKey = function (keyspace, query) {\n  return ( keyspace || '' ) + query;\n};\n\nPreparedQueries.prototype.getOrAdd = function (keyspace, query) {\n  const key = this._getKey(keyspace, query);\n  let info = this._mapByKey[key];\n  if (info) {\n    return info;\n  }\n  this._validateOverflow();\n  info = new events.EventEmitter();\n  info.setMaxListeners(0);\n  info.query = query;\n  // The keyspace in which it was prepared\n  info.keyspace = keyspace;\n  this._mapByKey[key] = info;\n  this.length++;\n  return info;\n};\n\nPreparedQueries.prototype._validateOverflow = function () {\n  if (this.length < this._maxPrepared) {\n    return;\n  }\n  const toRemove = [];\n  this._logger('warning',\n    'Prepared statements exceeded maximum. This could be caused by preparing queries that contain parameters');\n  const existingKeys = Object.keys(this._mapByKey);\n  for (let i = 0; i < existingKeys.length && this.length - toRemove.length < this._maxPrepared; i++) {\n    const info = this._mapByKey[existingKeys[i]];\n    if (!info.queryId) {\n      // Only remove queries that contain queryId\n      continue;\n    }\n    toRemove.push(info);\n  }\n  toRemove.forEach(function (item) {\n    delete this._mapByKey[item.query];\n    delete this._mapById[item.queryId];\n    this.length--;\n  }, this);\n};\n\nPreparedQueries.prototype.setById = function (info) {\n  this._mapById[info.queryId.toString('hex')] = info;\n};\n\nPreparedQueries.prototype.getById = function (id) {\n  return this._mapById[id.toString('hex')];\n};\n\nPreparedQueries.prototype.clear = function () {\n  this._mapByKey = {};\n  this._mapById = {};\n  this.length = 0;\n};\n\nPreparedQueries.prototype.getAll = function () {\n  return utils.objectValues(this._mapByKey).filter(function (info) {\n    return !!info.queryId;\n  });\n};\n\nmodule.exports = Metadata;\n","\"use strict\";\nconst util = require('util');\nconst DataCollection = require('./data-collection');\n/**\n * Creates a new MaterializedView.\n * @param {String} name Name of the View.\n * @classdesc Describes a CQL materialized view.\n * @alias module:metadata~MaterializedView\n * @augments {module:metadata~DataCollection}\n * @constructor\n */\nfunction MaterializedView(name) {\n  DataCollection.call(this, name);\n  /**\n   * Name of the table.\n   * @type {String}\n   */\n  this.tableName = null;\n  /**\n   * View where clause.\n   * @type {String}\n   */\n  this.whereClause = null;\n  /**\n   * Determines if all the table columns where are included in the view.\n   * @type {boolean}\n   */\n  this.includeAllColumns = false;\n}\n\nutil.inherits(MaterializedView, DataCollection);\n\nmodule.exports = MaterializedView;","\"use strict\";\n\n/**\n * Creates a new SchemaFunction.\n * @classdesc Describes a CQL function.\n * @alias module:metadata~SchemaFunction\n * @constructor\n */\nfunction SchemaFunction() {\n  /**\n   * Name of the cql function.\n   * @type {String}\n   */\n  this.name = null;\n  /**\n   * Name of the keyspace where the cql function is declared.\n   */\n  this.keyspaceName = null;\n  /**\n   * Signature of the function.\n   * @type {Array.<String>}\n   */\n  this.signature = null;\n  /**\n   * List of the function argument names.\n   * @type {Array.<String>}\n   */\n  this.argumentNames = null;\n  /**\n   * List of the function argument types.\n   * @type {Array.<{code, info}>}\n   */\n  this.argumentTypes = null;\n  /**\n   * Body of the function.\n   * @type {String}\n   */\n  this.body = null;\n  /**\n   * Determines if the function is called when the input is null.\n   * @type {Boolean}\n   */\n  this.calledOnNullInput = null;\n  /**\n   * Name of the programming language, for example: java, javascript, ...\n   * @type {String}\n   */\n  this.language = null;\n  /**\n   * Type of the return value.\n   * @type {{code: number, info: (Object|Array|null)}}\n   */\n  this.returnType = null;\n}\n\nmodule.exports = SchemaFunction;","\"use strict\";\nconst util = require('util');\nconst utils = require('../utils');\nconst types = require('../types');\n\n/** @private */\nconst kind = {\n  custom: 0,\n  keys: 1,\n  composites: 2\n};\n/**\n * Creates a new Index instance.\n * @classdesc Describes a CQL index.\n * @param {String} name\n * @param {String} target\n * @param {Number|String} kind\n * @param {Object} options\n * @alias module:metadata~Index\n * @constructor\n */\nfunction Index(name, target, kind, options) {\n  /**\n   * Name of the index.\n   * @type {String}\n   */\n  this.name = name;\n  /**\n   * Target of the index.\n   * @type {String}\n   */\n  this.target = target;\n  /**\n   * A numeric value representing index kind (0: custom, 1: keys, 2: composite);\n   * @type {Number}\n   */\n  this.kind = typeof kind === 'string' ? getKindByName(kind) : kind;\n  /**\n   * An associative array containing the index options\n   * @type {Object}\n   */\n  this.options = options;\n}\n\n/**\n * Determines if the index is of composites kind\n * @returns {Boolean}\n */\nIndex.prototype.isCompositesKind = function () {\n  return this.kind === kind.composites;\n};\n\n/**\n * Determines if the index is of keys kind\n * @returns {Boolean}\n */\nIndex.prototype.isKeysKind = function () {\n  return this.kind === kind.keys;\n};\n\n/**\n * Determines if the index is of custom kind\n * @returns {Boolean}\n */\nIndex.prototype.isCustomKind = function () {\n  return this.kind === kind.custom;\n};\n\n/**\n * Parses Index information from rows in the 'system_schema.indexes' table\n * @deprecated It will be removed in the next major version.\n * @param {Array.<Row>} indexRows\n * @returns {Array.<Index>}\n */\nIndex.fromRows = function (indexRows) {\n  if (!indexRows || indexRows.length === 0) {\n    return utils.emptyArray;\n  }\n  return indexRows.map(function (row) {\n    const options = row['options'];\n    return new Index(row['index_name'], options['target'], getKindByName(row['kind']), options);\n  });\n};\n\n/**\n * Parses Index information from rows in the legacy 'system.schema_columns' table.\n * @deprecated It will be removed in the next major version.\n * @param {Array.<Row>} columnRows\n * @param {Object.<String, {name, type}>} columnsByName\n * @returns {Array.<Index>}\n */\nIndex.fromColumnRows = function (columnRows, columnsByName) {\n  const result = [];\n  for (let i = 0; i < columnRows.length; i++) {\n    const row = columnRows[i];\n    const indexName = row['index_name'];\n    if (!indexName) {\n      continue;\n    }\n    const c = columnsByName[row['column_name']];\n    let target;\n    const options = JSON.parse(row['index_options']);\n    if (options !== null && options['index_keys'] !== undefined) {\n      target = util.format(\"keys(%s)\", c.name);\n    }\n    else if (options !== null && options['index_keys_and_values'] !== undefined) {\n      target = util.format(\"entries(%s)\", c.name);\n    }\n    else if (c.type.options.frozen && (c.type.code === types.dataTypes.map || c.type.code === types.dataTypes.list ||\n      c.type.code === types.dataTypes.set)) {\n      target = util.format(\"full(%s)\", c.name);\n    }\n    else {\n      target = c.name;\n    }\n    result.push(new Index(indexName, target, getKindByName(row['index_type']), options));\n  }\n  return result;\n};\n\n/**\n * Gets the number representing the kind based on the name\n * @param {String} name\n * @returns {Number}\n * @private\n */\nfunction getKindByName(name) {\n  if (!name) {\n    return kind.custom;\n  }\n  return kind[name.toLowerCase()];\n}\n\nmodule.exports = Index;","\"use strict\";\nconst util = require('util');\nconst events = require('events');\nconst types = require('../types');\nconst utils = require('../utils');\nconst errors = require('../errors');\nconst TableMetadata = require('./table-metadata');\nconst Aggregate = require('./aggregate');\nconst SchemaFunction = require('./schema-function');\nconst Index = require('./schema-index');\nconst MaterializedView = require('./materialized-view');\n/**\n * @module metadata/schemaParser\n * @ignore\n */\n\nconst _selectAllKeyspacesV1 = \"SELECT * FROM system.schema_keyspaces\";\nconst _selectSingleKeyspaceV1 = \"SELECT * FROM system.schema_keyspaces where keyspace_name = '%s'\";\nconst _selectAllKeyspacesV2 = \"SELECT * FROM system_schema.keyspaces\";\nconst _selectSingleKeyspaceV2 = \"SELECT * FROM system_schema.keyspaces where keyspace_name = '%s'\";\nconst _selectTableV1 = \"SELECT * FROM system.schema_columnfamilies WHERE keyspace_name='%s' AND columnfamily_name='%s'\";\nconst _selectTableV2 = \"SELECT * FROM system_schema.tables WHERE keyspace_name='%s' AND table_name='%s'\";\nconst _selectColumnsV1 = \"SELECT * FROM system.schema_columns WHERE keyspace_name='%s' AND columnfamily_name='%s'\";\nconst _selectColumnsV2 = \"SELECT * FROM system_schema.columns WHERE keyspace_name='%s' AND table_name='%s'\";\nconst _selectIndexesV2 = \"SELECT * FROM system_schema.indexes WHERE keyspace_name='%s' AND table_name='%s'\";\nconst _selectUdtV1 = \"SELECT * FROM system.schema_usertypes WHERE keyspace_name='%s' AND type_name='%s'\";\nconst _selectUdtV2 = \"SELECT * FROM system_schema.types WHERE keyspace_name='%s' AND type_name='%s'\";\nconst _selectFunctionsV1 = \"SELECT * FROM system.schema_functions WHERE keyspace_name = '%s' AND function_name = '%s'\";\nconst _selectFunctionsV2 = \"SELECT * FROM system_schema.functions WHERE keyspace_name = '%s' AND function_name = '%s'\";\nconst _selectAggregatesV1 = \"SELECT * FROM system.schema_aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'\";\nconst _selectAggregatesV2 = \"SELECT * FROM system_schema.aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'\";\nconst _selectMaterializedViewV2 = \"SELECT * FROM system_schema.views WHERE keyspace_name = '%s' AND view_name = '%s'\";\n\nconst _selectAllVirtualKeyspaces = \"SELECT * FROM system_virtual_schema.keyspaces\";\nconst _selectSingleVirtualKeyspace = \"SELECT * FROM system_virtual_schema.keyspaces where keyspace_name = '%s'\";\nconst _selectVirtualTable = \"SELECT * FROM system_virtual_schema.tables where keyspace_name = '%s' and table_name='%s'\";\nconst _selectVirtualColumns = \"SELECT * FROM system_virtual_schema.columns where keyspace_name = '%s' and table_name='%s'\";\n\n\n/**\n * @abstract\n * @param {ClientOptions} options The client options\n * @param {ControlConnection} cc\n * @constructor\n * @ignore\n */\nfunction SchemaParser(options, cc) {\n  this.cc = cc;\n  this.encodingOptions = options.encoding;\n  this.selectTable = null;\n  this.selectColumns = null;\n  this.selectIndexes = null;\n  this.selectUdt = null;\n  this.selectAggregates = null;\n  this.selectFunctions = null;\n  this.supportsVirtual = false;\n}\n\n/**\n * @param name\n * @param durableWrites\n * @param strategy\n * @param strategyOptions\n * @param virtual\n * @returns {{name, durableWrites, strategy, strategyOptions, tokenToReplica, udts, tables, functions, aggregates}|null}\n * @protected\n */\nSchemaParser.prototype._createKeyspace = function (name, durableWrites, strategy, strategyOptions, virtual) {\n  const ksInfo = {\n    name: name,\n    durableWrites: durableWrites,\n    strategy: strategy,\n    strategyOptions: strategyOptions,\n    tokenToReplica: null,\n    virtual: virtual === true,\n    udts: {},\n    tables: {},\n    functions: {},\n    aggregates: {},\n    views: {}\n  };\n  ksInfo.tokenToReplica = getTokenToReplicaMapper(strategy, strategyOptions);\n  return ksInfo;\n};\n\n/**\n * @abstract\n * @param {String} name\n * @param {Function} callback\n */\nSchemaParser.prototype.getKeyspace = function (name, callback) {\n};\n\n/**\n * @abstract\n * @param {Boolean} waitReconnect\n * @param {Function} callback\n */\nSchemaParser.prototype.getKeyspaces = function (waitReconnect, callback) {\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Object} cache\n * @param {Boolean} virtual\n * @param {Function} callback\n */\nSchemaParser.prototype.getTable = function (keyspaceName, name, cache, virtual, callback) {\n  let tableInfo = cache && cache[name];\n  if (!tableInfo) {\n    tableInfo = new TableMetadata(name);\n    if (cache) {\n      cache[name] = tableInfo;\n    }\n  }\n  if (tableInfo.loaded) {\n    return callback(null, tableInfo);\n  }\n  tableInfo.once('load', callback);\n  if (tableInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  // its not cached and not being retrieved\n  tableInfo.loading = true;\n  let tableRow, columnRows, indexRows;\n  const self = this;\n  let virtualTable = virtual;\n  utils.series([\n    function getTableRow(next) {\n      const selectTable = virtualTable ? _selectVirtualTable : self.selectTable; \n      const query = util.format(selectTable, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        tableRow = response.rows[0];\n        next();\n      });\n    },\n    function getVirtualTableRow(next) {\n      // if we weren't sure if table was virtual or not, query virtual schema.\n      if (!tableRow && self.supportsVirtual && virtualTable === undefined) {\n        const query = util.format(_selectVirtualTable, keyspaceName, name);\n        self.cc.query(query, function (err, response) {\n          if (err) {\n            // we can't error here as we can't be sure if the node\n            // supports virtual tables, in this case it is adequate\n            // to act as if there was no matching table.\n            return next();\n          }\n          tableRow = response.rows[0];\n          // if we got a result, this is a virtual table\n          if (tableRow) {\n            virtualTable = true;\n          }\n          next();\n        });\n      } else {\n        return next();\n      }\n    },\n    function getColumnRows (next) {\n      if (!tableRow) {\n        return next();\n      }\n      const selectColumns = virtualTable ? _selectVirtualColumns : self.selectColumns;\n      const query = util.format(selectColumns, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        columnRows = response.rows;\n        next();\n      });\n    },\n    function getIndexes(next) {\n      if (!tableRow || !self.selectIndexes || virtualTable) {\n        //either the table does not exists or it does not support indexes schema table\n        return next();\n      }\n      const query = util.format(self.selectIndexes, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        indexRows = response.rows;\n        next();\n      });\n    }\n  ], function afterQuery (err) {\n    if (err || !tableRow) {\n      tableInfo.loading = false;\n      return tableInfo.emit('load', err, null);\n    }\n    self._parseTableOrView(tableInfo, tableRow, columnRows, indexRows, virtualTable, function (err) {\n      tableInfo.loading = false;\n      tableInfo.loaded = !err;\n      tableInfo.emit('load', err, tableInfo);\n    });\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Object} cache\n * @param {Function} callback\n */\nSchemaParser.prototype.getUdt = function (keyspaceName, name, cache, callback) {\n  let udtInfo = cache && cache[name];\n  if (!udtInfo) {\n    udtInfo = new events.EventEmitter();\n    if (cache) {\n      cache[name] = udtInfo;\n    }\n    udtInfo.setMaxListeners(0);\n    udtInfo.loading = false;\n    udtInfo.name = name;\n    udtInfo.fields = null;\n  }\n  if (udtInfo.fields) {\n    return callback(null, udtInfo);\n  }\n  udtInfo.once('load', callback);\n  if (udtInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  udtInfo.loading = true;\n  //it is not cached, try to query for it\n  const query = util.format(this.selectUdt, keyspaceName, name);\n  const self = this;\n  this.cc.query(query, function (err, response) {\n    if (err) {\n      return udtInfo.emit('load', err);\n    }\n    const row = response.rows[0];\n    if (!row) {\n      udtInfo.loading = false;\n      return udtInfo.emit('load', null, null);\n    }\n    self._parseUdt(udtInfo, row, function (err) {\n      udtInfo.loading = false;\n      if (err) {\n        return udtInfo.emit('load', err);\n      }\n      return udtInfo.emit('load', null, udtInfo);\n    });\n  });\n};\n\n/**\n * Parses the udt information from the row\n * @param udtInfo\n * @param {Row} row\n * @param {Function} callback Callback to be invoked with the err and {{fields: Array}}|null\n * @abstract\n */\nSchemaParser.prototype._parseUdt = function (udtInfo, row, callback) {\n};\n\n/**\n * Builds the metadata based on the table and column rows\n * @abstract\n * @param {module:metadata~TableMetadata} tableInfo\n * @param {Row} tableRow\n * @param {Array.<Row>} columnRows\n * @param {Array.<Row>} indexRows\n * @param {Boolean} virtual\n * @param {Function} callback\n * @throws {Error}\n */\nSchemaParser.prototype._parseTableOrView = function (tableInfo, tableRow, columnRows, indexRows, virtual, callback) {\n};\n\n\n/**\n * @abstract\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Object} cache\n * @param {Function} callback\n */\nSchemaParser.prototype.getMaterializedView = function (keyspaceName, name, cache, callback) {\n\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Boolean} aggregate\n * @param {Object} cache\n * @param {Function} callback\n */\nSchemaParser.prototype.getFunctions = function (keyspaceName, name, aggregate, cache, callback) {\n  /** @type {String} */\n  let query = this.selectFunctions;\n  let parser = this._parseFunction.bind(this);\n  if (aggregate) {\n    query = this.selectAggregates;\n    parser = this._parseAggregate.bind(this);\n  }\n  //if not already loaded\n  //get all functions with that name\n  //cache it by name and, within name, by signature\n  let functionsInfo = cache && cache[name];\n  if (!functionsInfo) {\n    functionsInfo = new events.EventEmitter();\n    if (cache) {\n      cache[name] = functionsInfo;\n    }\n    functionsInfo.setMaxListeners(0);\n  }\n  if (functionsInfo.values) {\n    return callback(null, functionsInfo.values);\n  }\n  functionsInfo.once('load', callback);\n  if (functionsInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  functionsInfo.loading = true;\n  //it is not cached, try to query for it\n  query = util.format(query, keyspaceName, name);\n  this.cc.query(query, function (err, response) {\n    functionsInfo.loading = false;\n    if (err || response.rows.length === 0) {\n      return functionsInfo.emit('load', err, null);\n    }\n    if (response.rows.length > 0) {\n      functionsInfo.values = {};\n    }\n    utils.each(response.rows, function (row, next) {\n      parser(row, function (err, func) {\n        if (err) {\n          return next(err);\n        }\n        functionsInfo.values['(' + func.signature.join(',') + ')'] = func;\n        next();\n      });\n    }, function (err) {\n      if (err) {\n        return functionsInfo.emit('load', err);\n      }\n      functionsInfo.emit('load', null, functionsInfo.values);\n    });\n  });\n};\n\n/**\n * @abstract\n * @param {Row} row\n * @param {Function} callback\n */\nSchemaParser.prototype._parseAggregate = function (row, callback) {\n};\n\n/**\n * @abstract\n * @param {Row} row\n * @param {Function} callback\n */\nSchemaParser.prototype._parseFunction = function (row, callback) {\n};\n\n/** @returns {Map} */\nSchemaParser.prototype._asMap = function (obj) {\n  if (!obj) {\n    return new Map();\n  }\n\n  if (this.encodingOptions.map && obj instanceof this.encodingOptions.map) {\n    // Its already a Map or a polyfill of a Map\n    return obj;\n  }\n\n  return new Map(Object.keys(obj).map(k => [ k, obj[k]]));\n};\n\nSchemaParser.prototype._mapAsObject = function (map) {\n  if (!map) {\n    return map;\n  }\n\n  if (this.encodingOptions.map && map instanceof this.encodingOptions.map) {\n    const result = {};\n    map.forEach((value, key) => result[key] = value);\n    return result;\n  }\n\n  return map;\n};\n\n/**\n * Used to parse schema information for Cassandra versions 1.2.x, and 2.x\n * @param {ClientOptions} options The client options\n * @param {ControlConnection} cc\n * @constructor\n * @ignore\n */\nfunction SchemaParserV1(options, cc) {\n  SchemaParser.call(this, options, cc);\n  this.selectTable = _selectTableV1;\n  this.selectColumns = _selectColumnsV1;\n  this.selectUdt = _selectUdtV1;\n  this.selectAggregates = _selectAggregatesV1;\n  this.selectFunctions = _selectFunctionsV1;\n}\n\nutil.inherits(SchemaParserV1, SchemaParser);\n\n/** @override */\nSchemaParserV1.prototype.getKeyspaces = function (waitReconnect, callback) {\n  const self = this;\n  const keyspaces = {};\n  this.cc.query(_selectAllKeyspacesV1, waitReconnect, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    for (let i = 0; i < result.rows.length; i++) {\n      const row = result.rows[i];\n      const ksInfo = self._createKeyspace(\n        row['keyspace_name'],\n        row['durable_writes'],\n        row['strategy_class'],\n        JSON.parse(row['strategy_options'] || null));\n      keyspaces[ksInfo.name] = ksInfo;\n    }\n    callback(null, keyspaces);\n  });\n};\n\n/** @override */\nSchemaParserV1.prototype.getKeyspace = function (name, callback) {\n  const self = this;\n  this.cc.query(util.format(_selectSingleKeyspaceV1, name), function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    const row = result.rows[0];\n    if (!row) {\n      return callback(null, null);\n    }\n    callback(null, self._createKeyspace(\n      row['keyspace_name'],\n      row['durable_writes'],\n      row['strategy_class'],\n      JSON.parse(row['strategy_options'])));\n  });\n};\n\n/** @override */\nSchemaParserV1.prototype._parseTableOrView = function (tableInfo, tableRow, columnRows, indexRows, virtual, callback) {\n  let i, c, name, types;\n  const encoder = this.cc.getEncoder();\n  const columnsKeyed = {};\n  let partitionKeys = [];\n  let clusteringKeys = [];\n  tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];\n  tableInfo.caching = tableRow['caching'];\n  tableInfo.comment = tableRow['comment'];\n  tableInfo.compactionClass = tableRow['compaction_strategy_class'];\n  tableInfo.compactionOptions = JSON.parse(tableRow['compaction_strategy_options']);\n  tableInfo.compression = JSON.parse(tableRow['compression_parameters']);\n  tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];\n  tableInfo.localReadRepairChance = tableRow['local_read_repair_chance'];\n  tableInfo.readRepairChance = tableRow['read_repair_chance'];\n  tableInfo.populateCacheOnFlush = tableRow['populate_io_cache_on_flush'] || tableInfo.populateCacheOnFlush;\n  tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;\n  tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;\n  tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;\n  tableInfo.indexInterval = tableRow['index_interval'] || tableInfo.indexInterval;\n  if (typeof tableRow['min_index_interval'] !== 'undefined') {\n    //Cassandra 2.1+\n    tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;\n    tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;\n  }\n  else {\n    //set to null\n    tableInfo.minIndexInterval = null;\n    tableInfo.maxIndexInterval = null;\n  }\n  if (typeof tableRow['replicate_on_write'] !== 'undefined') {\n    //leave the default otherwise\n    tableInfo.replicateOnWrite = tableRow['replicate_on_write'];\n  }\n  tableInfo.columns = [];\n  try {\n    (function parseColumns() {\n      //function context\n      for (i = 0; i < columnRows.length; i++) {\n        const row = columnRows[i];\n        const type = encoder.parseFqTypeName(row['validator']);\n        c = {\n          name: row['column_name'],\n          type: type\n        };\n        tableInfo.columns.push(c);\n        columnsKeyed[c.name] = c;\n        switch (row['type']) {\n          case 'partition_key':\n            partitionKeys.push({c: c, index: (row['component_index'] || 0)});\n            break;\n          case 'clustering_key':\n            clusteringKeys.push({\n              c: c,\n              index: (row['component_index'] || 0),\n              order: c.type.options.reversed ? 'DESC' : 'ASC'\n            });\n            break;\n        }\n      }\n    })();\n    if (partitionKeys.length > 0) {\n      tableInfo.partitionKeys = partitionKeys.sort(utils.propCompare('index')).map(function (item) {\n        return item.c;\n      });\n      clusteringKeys.sort(utils.propCompare('index'));\n      tableInfo.clusteringKeys = clusteringKeys.map(function (item) {\n        return item.c;\n      });\n      tableInfo.clusteringOrder = clusteringKeys.map(function (item) {\n        return item.order;\n      });\n    }\n    //In C* 1.2, keys are not stored on the schema_columns table\n    const keysStoredInTableRow = (tableInfo.partitionKeys.length === 0);\n    if (keysStoredInTableRow && tableRow['key_aliases']) {\n      //In C* 1.2, keys are not stored on the schema_columns table\n      partitionKeys = JSON.parse(tableRow['key_aliases']);\n      types = encoder.parseKeyTypes(tableRow['key_validator']).types;\n      for (i = 0; i < partitionKeys.length; i++) {\n        name = partitionKeys[i];\n        c = columnsKeyed[name];\n        if (!c) {\n          c = {\n            name: name,\n            type: types[i]\n          };\n          tableInfo.columns.push(c);\n        }\n        tableInfo.partitionKeys.push(c);\n      }\n    }\n    const comparator = encoder.parseKeyTypes(tableRow['comparator']);\n    if (keysStoredInTableRow && tableRow['column_aliases']) {\n      clusteringKeys = JSON.parse(tableRow['column_aliases']);\n      for (i = 0; i < clusteringKeys.length; i++) {\n        name = clusteringKeys[i];\n        c = columnsKeyed[name];\n        if (!c) {\n          c = {\n            name: name,\n            type: comparator.types[i]\n          };\n          tableInfo.columns.push(c);\n        }\n        tableInfo.clusteringKeys.push(c);\n        tableInfo.clusteringOrder.push(c.type.options.reversed ? 'DESC' : 'ASC');\n      }\n    }\n    tableInfo.isCompact = !!tableRow['is_dense'];\n    if (!tableInfo.isCompact) {\n      //is_dense column does not exist in previous versions of Cassandra\n      //also, compact pk, ck and val appear as is_dense false\n      // clusteringKeys != comparator types - 1\n      // or not composite (comparator)\n      tableInfo.isCompact = (\n        //clustering keys are not marked as composite\n        !comparator.isComposite ||\n        //only 1 column not part of the partition or clustering keys\n        (!comparator.hasCollections && tableInfo.clusteringKeys.length !== comparator.types.length - 1)\n      );\n    }\n    name = tableRow['value_alias'];\n    if (tableInfo.isCompact && name && !columnsKeyed[name]) {\n      //additional column in C* 1.2 as value_alias\n      c = {\n        name: name,\n        type: encoder.parseFqTypeName(tableRow['default_validator'])\n      };\n      tableInfo.columns.push(c);\n      columnsKeyed[name] = c;\n    }\n    tableInfo.columnsByName = columnsKeyed;\n    tableInfo.indexes = Index.fromColumnRows(columnRows, tableInfo.columnsByName);\n  }\n  catch (err) {\n    return callback(err);\n  }\n  //All the tableInfo parsing in V1 is sync, it uses a callback because the super defines one\n  //to support other versions.\n  callback();\n};\n\n/** @override */\nSchemaParserV1.prototype.getMaterializedView = function (keyspaceName, name, cache, callback) {\n  callback(new errors.NotSupportedError('Materialized views are not supported on Cassandra versions below 3.0'));\n};\n\n/** @override */\nSchemaParserV1.prototype._parseAggregate = function (row, callback) {\n  const encoder = this.cc.getEncoder();\n  const aggregate = new Aggregate();\n  aggregate.name = row['aggregate_name'];\n  aggregate.keyspaceName = row['keyspace_name'];\n  aggregate.signature = row['signature'] || utils.emptyArray;\n  aggregate.stateFunction = row['state_func'];\n  aggregate.finalFunction = row['final_func'];\n  aggregate.initConditionRaw = row['initcond'];\n  try {\n    aggregate.argumentTypes = (row['argument_types'] || utils.emptyArray).map(function (name) {\n      return encoder.parseFqTypeName(name);\n    });\n    aggregate.stateType = encoder.parseFqTypeName(row['state_type']);\n    const initConditionValue = encoder.decode(aggregate.initConditionRaw, aggregate.stateType);\n    if (initConditionValue !== null && typeof initConditionValue !== 'undefined') {\n      aggregate.initCondition = initConditionValue.toString();\n    }\n    aggregate.returnType = encoder.parseFqTypeName(row['return_type']);\n  }\n  catch (err) {\n    return callback(err);\n  }\n  callback(null, aggregate);\n};\n\n/** @override */\nSchemaParserV1.prototype._parseFunction = function (row, callback) {\n  const encoder = this.cc.getEncoder();\n  const func = new SchemaFunction();\n  func.name = row['function_name'];\n  func.keyspaceName = row['keyspace_name'];\n  func.signature = row['signature'] || utils.emptyArray;\n  func.argumentNames = row['argument_names'] || utils.emptyArray;\n  func.body = row['body'];\n  func.calledOnNullInput = row['called_on_null_input'];\n  func.language = row['language'];\n  try {\n    func.argumentTypes = (row['argument_types'] || utils.emptyArray).map(function (name) {\n      return encoder.parseFqTypeName(name);\n    });\n    func.returnType = encoder.parseFqTypeName(row['return_type']);\n  }\n  catch (err) {\n    return callback(err);\n  }\n  callback(null, func);\n};\n\n/** @override */\nSchemaParserV1.prototype._parseUdt = function (udtInfo, row, callback) {\n  const encoder = this.cc.getEncoder();\n  const fieldNames = row['field_names'];\n  const fieldTypes = row['field_types'];\n  const fields = new Array(fieldNames.length);\n  try {\n    for (let i = 0; i < fieldNames.length; i++) {\n      fields[i] = {\n        name: fieldNames[i],\n        type: encoder.parseFqTypeName(fieldTypes[i])\n      };\n    }\n  }\n  catch (err) {\n    return callback(err);\n  }\n  udtInfo.fields = fields;\n  callback(null, udtInfo);\n};\n\n/**\n * Used to parse schema information for Cassandra versions 3.x and above\n * @param {ClientOptions} options The client options\n * @param {ControlConnection} cc The control connection to be used\n * @param {Function} udtResolver The function to be used to retrieve the udts.\n * @constructor\n * @ignore\n */\nfunction SchemaParserV2(options, cc, udtResolver) {\n  SchemaParser.call(this, options, cc);\n  this.udtResolver = udtResolver;\n  this.selectTable = _selectTableV2;\n  this.selectColumns = _selectColumnsV2;\n  this.selectUdt = _selectUdtV2;\n  this.selectAggregates = _selectAggregatesV2;\n  this.selectFunctions = _selectFunctionsV2;\n  this.selectIndexes = _selectIndexesV2;\n}\n\nutil.inherits(SchemaParserV2, SchemaParser);\n\n/** @override */\nSchemaParserV2.prototype.getKeyspaces = function (waitReconnect, callback) {\n  const self = this;\n  const keyspaces = {};\n  this.cc.query(_selectAllKeyspacesV2, waitReconnect, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    for (let i = 0; i < result.rows.length; i++) {\n      const ksInfo = self._parseKeyspace(result.rows[i]);\n      keyspaces[ksInfo.name] = ksInfo;\n    }\n    callback(null, keyspaces);\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype.getKeyspace = function (name, callback) {\n  const self = this;\n  this.cc.query(util.format(_selectSingleKeyspaceV2, name), function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    const row = result.rows[0];\n    if (!row) {\n      return callback(null, null);\n    }\n    callback(null, self._parseKeyspace(row));\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype.getMaterializedView = function (keyspaceName, name, cache, callback) {\n  let viewInfo = cache && cache[name];\n  if (!viewInfo) {\n    viewInfo = new MaterializedView(name);\n    if (cache) {\n      cache[name] = viewInfo;\n    }\n  }\n  if (viewInfo.loaded) {\n    return callback(null, viewInfo);\n  }\n  viewInfo.once('load', callback);\n  if (viewInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  viewInfo.loading = true;\n  let tableRow, columnRows;\n  //it is not cached, try to query for it\n  const self = this;\n  utils.series([\n    function getTableRow(next) {\n      const query = util.format(_selectMaterializedViewV2, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        tableRow = response.rows[0];\n        next();\n      });\n    },\n    function getColumnRows (next) {\n      if (!tableRow) {\n        return next();\n      }\n      const query = util.format(self.selectColumns, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        columnRows = response.rows;\n        next();\n      });\n    }\n  ], function afterQuery (err) {\n    viewInfo.loading = false;\n    if (err || !tableRow) {\n      return viewInfo.emit('load', err, null);\n    }\n    self._parseTableOrView(viewInfo, tableRow, columnRows, null, false, function (err) {\n      viewInfo.loading = false;\n      viewInfo.loaded = !err;\n      viewInfo.emit('load', err, viewInfo);\n    });\n  });\n\n};\n\nSchemaParserV2.prototype._parseKeyspace = function (row, virtual) {\n  const replication = row['replication'];\n  let strategy;\n  let strategyOptions;\n  if (replication) {\n    strategy = replication['class'];\n    strategyOptions = {};\n    for (const key in replication) {\n      if (!replication.hasOwnProperty(key) || key === 'class') {\n        continue;\n      }\n      strategyOptions[key] = replication[key];\n    }\n  }\n  return this._createKeyspace(\n    row['keyspace_name'],\n    row['durable_writes'],\n    strategy,\n    strategyOptions,\n    virtual);\n};\n\n/** @override */\nSchemaParserV2.prototype._parseTableOrView = function (tableInfo, tableRow, columnRows, indexRows, virtual, callback) {\n  const encoder = this.cc.getEncoder();\n  const columnsKeyed = {};\n  const partitionKeys = [];\n  const clusteringKeys = [];\n  const self = this;\n\n  // maps column rows to columnInfo and also populates columnsKeyed\n  const columnRowMapper = (row, next) => {\n    encoder.parseTypeName(tableRow['keyspace_name'], row['type'], 0, null, self.udtResolver, function (err, type) {\n      if (err) {\n        return next(err);\n      }\n      const c = {\n        name: row['column_name'],\n        type: type,\n        isStatic: false\n      };\n      columnsKeyed[c.name] = c;\n      switch (row['kind']) {\n        case 'partition_key':\n          partitionKeys.push({ c: c, index: (row['position'] || 0)});\n          break;\n        case 'clustering':\n          clusteringKeys.push({ c: c, index: (row['position'] || 0), order: row['clustering_order'] === 'desc' ? 'DESC' : 'ASC'});\n          break;\n        case 'static':\n          c.isStatic = true;\n          break;\n      }\n      next(null, c);\n    });\n  };\n\n  // is table is virtual, the only relevant information to parse is the columns as the table itself has no configuration.\n  if (virtual) {\n    tableInfo.virtual = true;\n    utils.map(columnRows, columnRowMapper, function (err, columns) {\n      if (err) {\n        return callback(err);\n      }\n      tableInfo.columns = columns;\n      tableInfo.columnsByName = columnsKeyed;\n      tableInfo.partitionKeys = partitionKeys.sort(utils.propCompare('index')).map(function (item) {\n        return item.c;\n      });\n      clusteringKeys.sort(utils.propCompare('index'));\n      tableInfo.clusteringKeys = clusteringKeys.map(function (item) {\n        return item.c;\n      });\n      tableInfo.clusteringOrder = clusteringKeys.map(function (item) {\n        return item.order;\n      });\n      callback();\n    });\n    return;\n  }\n\n  const isView = tableInfo instanceof MaterializedView;\n  tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];\n  tableInfo.caching = JSON.stringify(tableRow['caching']);\n  tableInfo.comment = tableRow['comment'];\n\n  // Regardless of the encoding options, use always an Object to represent an associative Array\n  const compaction = this._asMap(tableRow['compaction']);\n  if (compaction) {\n    // compactionOptions as an Object<String, String>\n    tableInfo.compactionOptions = {};\n    tableInfo.compactionClass = compaction.get('class');\n    compaction.forEach((value, key) => {\n      if (key === 'class') {\n        return;\n      }\n      tableInfo.compactionOptions[key] = compaction.get(key);\n    });\n  }\n\n  // Convert compression to an Object<String, String>\n  tableInfo.compression = this._mapAsObject(tableRow['compression']);\n\n  tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];\n  tableInfo.localReadRepairChance = tableRow['dclocal_read_repair_chance'];\n  tableInfo.readRepairChance = tableRow['read_repair_chance'];\n  tableInfo.extensions = this._mapAsObject(tableRow['extensions']);\n  tableInfo.crcCheckChance = tableRow['crc_check_chance'];\n  tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;\n  tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;\n  tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;\n  tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;\n  tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;\n  if (!isView) {\n    const cdc = tableRow['cdc'];\n    if (cdc !== undefined) {\n      tableInfo.cdc = cdc;\n    }\n  }\n\n  // Map all columns asynchronously\n  utils.map(columnRows, columnRowMapper, (err, columns) => {\n    if (err) {\n      return callback(err);\n    }\n    tableInfo.columns = columns;\n    tableInfo.columnsByName = columnsKeyed;\n    tableInfo.partitionKeys = partitionKeys.sort(utils.propCompare('index')).map(function (item) {\n      return item.c;\n    });\n    clusteringKeys.sort(utils.propCompare('index'));\n    tableInfo.clusteringKeys = clusteringKeys.map(function (item) {\n      return item.c;\n    });\n    tableInfo.clusteringOrder = clusteringKeys.map(function (item) {\n      return item.order;\n    });\n\n    if (isView) {\n      tableInfo.tableName = tableRow['base_table_name'];\n      tableInfo.whereClause = tableRow['where_clause'];\n      tableInfo.includeAllColumns = tableRow['include_all_columns'];\n      return callback();\n    }\n\n    tableInfo.indexes = this._getIndexes(indexRows);\n\n    // flags can be an instance of Array or Set (real or polyfill)\n    let flags = tableRow['flags'];\n    if (Array.isArray(flags)) {\n      flags = new Set(flags);\n    }\n\n    const isDense = flags.has('dense');\n    const isSuper = flags.has('super');\n    const isCompound = flags.has('compound');\n\n    tableInfo.isCompact = isSuper || isDense || !isCompound;\n    //remove the columns related to Thrift\n    const isStaticCompact = !isSuper && !isDense && !isCompound;\n    if(isStaticCompact) {\n      pruneStaticCompactTableColumns(tableInfo);\n    }\n    else if (isDense) {\n      pruneDenseTableColumns(tableInfo);\n    }\n    callback();\n  });\n};\n\nSchemaParserV2.prototype._getIndexes = function (indexRows) {\n  if (!indexRows || indexRows.length === 0) {\n    return utils.emptyArray;\n  }\n\n  return indexRows.map((row) => {\n    const options = this._mapAsObject(row['options']);\n    return new Index(row['index_name'], options['target'], row['kind'], options);\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype._parseAggregate = function (row, callback) {\n  const encoder = this.cc.getEncoder();\n  const aggregate = new Aggregate();\n  aggregate.name = row['aggregate_name'];\n  aggregate.keyspaceName = row['keyspace_name'];\n  aggregate.signature = row['argument_types'] || utils.emptyArray;\n  aggregate.stateFunction = row['state_func'];\n  aggregate.finalFunction = row['final_func'];\n  aggregate.initConditionRaw = row['initcond'];\n  aggregate.initCondition = aggregate.initConditionRaw;\n  const self = this;\n  utils.series([\n    function parseArguments(next) {\n      utils.map(row['argument_types'] || utils.emptyArray, function (name, mapNext) {\n        encoder.parseTypeName(row['keyspace_name'], name, 0, null, self.udtResolver, mapNext);\n      }, function (err, result) {\n        aggregate.argumentTypes = result;\n        next(err);\n      });\n    },\n    function parseStateType(next) {\n      encoder.parseTypeName(row['keyspace_name'], row['state_type'], 0, null, self.udtResolver, function (err, type) {\n        aggregate.stateType = type;\n        next(err);\n      });\n    },\n    function parseReturnType(next) {\n      encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, self.udtResolver, function (err, type) {\n        aggregate.returnType = type;\n        next(err);\n      });\n    }\n  ], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, aggregate);\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype._parseFunction = function (row, callback) {\n  const encoder = this.cc.getEncoder();\n  const func = new SchemaFunction();\n  func.name = row['function_name'];\n  func.keyspaceName = row['keyspace_name'];\n  func.signature = row['argument_types'] || utils.emptyArray;\n  func.argumentNames = row['argument_names'] || utils.emptyArray;\n  func.body = row['body'];\n  func.calledOnNullInput = row['called_on_null_input'];\n  func.language = row['language'];\n  const self = this;\n  utils.series([\n    function parseArguments(next) {\n      utils.map(row['argument_types'] || utils.emptyArray, function (name, mapNext) {\n        encoder.parseTypeName(row['keyspace_name'], name, 0, null, self.udtResolver, mapNext);\n      }, function (err, result) {\n        func.argumentTypes = result;\n        next(err);\n      });\n    },\n    function parseReturnType(next) {\n      encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, self.udtResolver, function (err, type) {\n        func.returnType = type;\n        next(err);\n      });\n    }\n  ], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, func);\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype._parseUdt = function (udtInfo, row, callback) {\n  const encoder = this.cc.getEncoder();\n  const fieldTypes = row['field_types'];\n  const keyspace = row['keyspace_name'];\n  const fields = new Array(fieldTypes.length);\n  const self = this;\n  utils.forEachOf(row['field_names'], function (name, i, next) {\n    encoder.parseTypeName(keyspace, fieldTypes[i], 0, null, self.udtResolver, function (err, type) {\n      if (err) {\n        return next(err);\n      }\n      fields[i] = {\n        name: name,\n        type: type\n      };\n      next();\n    });\n  }, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    udtInfo.fields = fields;\n    callback(null, udtInfo);\n  });\n};\n\n/**\n * Used to parse schema information for Cassandra versions 4.x and above.\n *\n * This parser similar to [SchemaParserV2] expect it also parses virtual\n * keyspaces.\n *\n * @param {ClientOptions} options The client options\n * @param {ControlConnection} cc The control connection to be used\n * @param {Function} udtResolver The function to be used to retrieve the udts.\n * @constructor\n * @ignore\n */\nfunction SchemaParserV3(options, cc, udtResolver) {\n  SchemaParserV2.call(this, options, cc, udtResolver);\n  this.supportsVirtual = true;\n}\n\nutil.inherits(SchemaParserV3, SchemaParserV2);\n\n/** @override */\nSchemaParserV3.prototype.getKeyspaces = function (waitReconnect, callback) {\n  const self = this;\n  const keyspaces = {};\n  const queries = [\n    { query: _selectAllKeyspacesV2, virtual: false },\n    { query: _selectAllVirtualKeyspaces, virtual: true }\n  ];\n  utils.each(queries, (q, cb) => {\n    self.cc.query(q.query, waitReconnect, (err, result) => {\n      if (err) {\n        // only callback in error for non-virtual query as\n        // server reporting C* 4.0 may not actually implement\n        // virtual tables.\n        if (!q.virtual) {\n          return cb(err);\n        }\n        return cb();\n      }\n      for (let i = 0; i < result.rows.length; i++) {\n        const ksInfo = self._parseKeyspace(result.rows[i], q.virtual);\n        keyspaces[ksInfo.name] = ksInfo;\n      }\n      cb();\n    });\n  }, (err) => {\n    callback(err, keyspaces);\n  });\n};\n\n/** @override */\nSchemaParserV3.prototype.getKeyspace = function (name, callback) {\n  this._getKeyspace(_selectSingleKeyspaceV2, name, false, (err, ks) => {\n    if (err) {\n      return callback(err);\n    }\n    if (!ks) {\n      // if not found, attempt to retrieve as virtual keyspace.\n      return this._getKeyspace(_selectSingleVirtualKeyspace, name, true, callback);\n    }\n    return callback(null, ks);\n  });\n};\n\nSchemaParserV3.prototype._getKeyspace = function (query, name, virtual, callback) {\n  this.cc.query(util.format(query, name), (err, result) => {\n    if (err) {\n      // only callback in error for non-virtual query as\n      // server reporting C* 4.0 may not actually implement\n      // virtual tables.\n      if (!virtual) {\n        return callback(err);\n      }\n      return callback(null, null);\n    }\n    const row = result.rows[0];\n    if (!row) {\n      return callback(null, null);\n    }\n    callback(null, this._parseKeyspace(row, virtual));\n  });\n};\n\n/**\n * Upon migration from thrift to CQL, we internally create a pair of surrogate clustering/regular columns\n * for compact static tables. These columns shouldn't be exposed to the user but are currently returned by C*.\n * We also need to remove the static keyword for all other columns in the table.\n * @param {module:metadata~TableMetadata} tableInfo\n*/\nfunction pruneStaticCompactTableColumns(tableInfo) {\n  let i;\n  let c;\n  //remove \"column1 text\" clustering column\n  for (i = 0; i < tableInfo.clusteringKeys.length; i++) {\n    c = tableInfo.clusteringKeys[i];\n    const index = tableInfo.columns.indexOf(c);\n    tableInfo.columns.splice(index, 1);\n    delete tableInfo.columnsByName[c.name];\n  }\n  tableInfo.clusteringKeys = utils.emptyArray;\n  tableInfo.clusteringOrder = utils.emptyArray;\n  //remove regular columns and set the static columns to non-static\n  i = tableInfo.columns.length;\n  while (i--) {\n    c = tableInfo.columns[i];\n    if (!c.isStatic && tableInfo.partitionKeys.indexOf(c) === -1) {\n      // remove \"value blob\" regular column\n      tableInfo.columns.splice(i, 1);\n      delete tableInfo.columnsByName[c.name];\n      continue;\n    }\n    c.isStatic = false;\n  }\n}\n\n/**\n * Upon migration from thrift to CQL, we internally create a surrogate column \"value\" of type custom.\n * This column shouldn't be exposed to the user but is currently returned by C*.\n * @param {module:metadata~TableMetadata} tableInfo\n */\nfunction pruneDenseTableColumns(tableInfo) {\n  let i = tableInfo.columns.length;\n  while (i--) {\n    const c = tableInfo.columns[i];\n    if (!c.isStatic && c.type.code === types.dataTypes.custom && c.type.info === 'empty') {\n      // remove \"value blob\" regular column\n      tableInfo.columns.splice(i, 1);\n      delete tableInfo.columnsByName[c.name];\n      continue;\n    }\n    c.isStatic = false;\n  }\n}\n\nfunction getTokenToReplicaMapper(strategy, strategyOptions) {\n  if (/SimpleStrategy$/.test(strategy)) {\n    const rf = parseInt(strategyOptions['replication_factor'], 10);\n    if (rf > 1) {\n      return getTokenToReplicaSimpleMapper(rf);\n    }\n  }\n  if (/NetworkTopologyStrategy$/.test(strategy)) {\n    return getTokenToReplicaNetworkMapper(strategyOptions);\n  }\n  //default, wrap in an Array\n  return (function noStrategy(tokenizer, ring, primaryReplicas) {\n    const replicas = {};\n    for (const key in primaryReplicas) {\n      if (!primaryReplicas.hasOwnProperty(key)) {\n        continue;\n      }\n      replicas[key] = [primaryReplicas[key]];\n    }\n    return replicas;\n  });\n}\n\n/**\n * @param {Number} replicationFactor\n * @returns {function}\n */\nfunction getTokenToReplicaSimpleMapper(replicationFactor) {\n  return (function tokenSimpleStrategy(tokenizer, ringTokensAsStrings, primaryReplicas) {\n    const ringLength = ringTokensAsStrings.length;\n    const rf = Math.min(replicationFactor, ringLength);\n    const replicas = {};\n    for (let i = 0; i < ringLength; i++) {\n      const key = ringTokensAsStrings[i];\n      const tokenReplicas = [primaryReplicas[key]];\n      for (let j = 1; j < ringLength && tokenReplicas.length < rf; j++) {\n        let nextReplicaIndex = i + j;\n        if (nextReplicaIndex >= ringLength) {\n          //circle back\n          nextReplicaIndex = nextReplicaIndex % ringLength;\n        }\n        const nextReplica = primaryReplicas[ringTokensAsStrings[nextReplicaIndex]];\n        // In the case of vnodes, consecutive sections of the ring can be assigned to the same host.\n        if (tokenReplicas.indexOf(nextReplica) === -1) {\n          tokenReplicas.push(nextReplica);\n        }\n      }\n      replicas[key] = tokenReplicas;\n    }\n    return replicas;\n  });\n}\n\n/**\n * @param {Object} replicationFactors\n * @returns {Function}\n * @private\n */\nfunction getTokenToReplicaNetworkMapper(replicationFactors) {\n  //                A(DC1)\n  //\n  //           H         B(DC2)\n  //                |\n  //      G       --+--       C(DC1)\n  //                |\n  //           F         D(DC2)\n  //\n  //                E(DC1)\n  return (function tokenNetworkStrategy(tokenizer, ringTokensAsStrings, primaryReplicas, datacenters) {\n    const replicas = {};\n    const ringLength = ringTokensAsStrings.length;\n\n    for (let i = 0; i < ringLength; i++) {\n      const key = ringTokensAsStrings[i];\n      const tokenReplicas = [];\n      const replicasByDc = {};\n      const racksPlaced = {};\n      const skippedHosts = [];\n      for (let j = 0; j < ringLength; j++) {\n        let nextReplicaIndex = i + j;\n        if (nextReplicaIndex >= ringLength) {\n          //circle back\n          nextReplicaIndex = nextReplicaIndex % ringLength;\n        }\n        const h = primaryReplicas[ringTokensAsStrings[nextReplicaIndex]];\n        // In the case of vnodes, consecutive sections of the ring can be assigned to the same host.\n        if (tokenReplicas.indexOf(h) !== -1) {\n          continue;\n        }\n        const dc = h.datacenter;\n        //Check if the next replica belongs to one of the targeted dcs\n        let dcRf = parseInt(replicationFactors[dc], 10);\n        if (!dcRf) {\n          continue;\n        }\n        dcRf = Math.min(dcRf, datacenters[dc].hostLength);\n        let dcReplicas = replicasByDc[dc] || 0;\n        //Amount of replicas per dc is greater than rf or the amount of host in the datacenter\n        if (dcReplicas >= dcRf) {\n          continue;\n        }\n        let racksPlacedInDc = racksPlaced[dc];\n        if (!racksPlacedInDc) {\n          racksPlacedInDc = racksPlaced[dc] = new utils.HashSet();\n        }\n        if (h.rack &&\n            racksPlacedInDc.contains(h.rack) &&\n            racksPlacedInDc.length < datacenters[dc].racks.length) {\n          // We already selected a replica for this rack\n          // Skip until replicas in other racks are added\n          if (skippedHosts.length < dcRf - dcReplicas) {\n            skippedHosts.push(h);\n          }\n          continue;\n        }\n        replicasByDc[h.datacenter] = ++dcReplicas;\n        tokenReplicas.push(h);\n        if (h.rack && racksPlacedInDc.add(h.rack) && racksPlacedInDc.length === datacenters[dc].racks.length) {\n          // We finished placing all replicas for all racks in this dc\n          // Add the skipped hosts\n          replicasByDc[dc] += addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts);\n        }\n        if (isDoneForToken(replicationFactors, datacenters, replicasByDc)) {\n          break;\n        }\n      }\n      replicas[key] = tokenReplicas;\n    }\n    return replicas;\n  });\n}\n\n/**\n * @returns {Number} The number of skipped hosts added.\n */\nfunction addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts) {\n  let i;\n  for (i = 0; i < dcRf - dcReplicas && i < skippedHosts.length; i++) {\n    tokenReplicas.push(skippedHosts[i]);\n  }\n  return i;\n}\n\nfunction isDoneForToken(replicationFactors, datacenters, replicasByDc) {\n  const keys = Object.keys(replicationFactors);\n  for (let i = 0; i < keys.length; i++) {\n    const dcName = keys[i];\n    const dc = datacenters[dcName];\n    if (!dc) {\n      // A DC is included in the RF but the DC does not exist in the topology\n      continue;\n    }\n    const rf = Math.min(parseInt(replicationFactors[dcName], 10), dc.hostLength);\n    if (rf > 0 && (!replicasByDc[dcName] || replicasByDc[dcName] < rf)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Creates a new instance if the currentInstance is not valid for the\n * provided Cassandra version\n * @param {ClientOptions} options The client options\n * @param {ControlConnection} cc The control connection to be used\n * @param {Function} udtResolver The function to be used to retrieve the udts.\n * @param {Array.<Number>} [version] The cassandra version\n * @param {SchemaParser} [currentInstance] The current instance\n * @returns {SchemaParser}\n */\nfunction getByVersion(options, cc, udtResolver, version, currentInstance) {\n  let parserConstructor = SchemaParserV1;\n  if (version && version[0] === 3) {\n    parserConstructor = SchemaParserV2;\n  } else if (version && version[0] >= 4) {\n    parserConstructor = SchemaParserV3;\n  }\n  if (!currentInstance || !(currentInstance instanceof parserConstructor)){\n    return new parserConstructor(options, cc, udtResolver);\n  }\n  return currentInstance;\n}\n\nexports.getByVersion = getByVersion;\n","\"use strict\";\n\nconst util = require('util');\nconst DataCollection = require('./data-collection');\n\n/**\n * Creates a new instance of TableMetadata\n * @classdesc Describes a table\n * @param {String} name Name of the Table\n * @augments {module:metadata~DataCollection}\n * @alias module:metadata~TableMetadata\n * @constructor\n */\nfunction TableMetadata(name) {\n  DataCollection.call(this, name);\n  /**\n   * Applies only to counter tables.\n   * When set to true, replicates writes to all affected replicas regardless of the consistency level specified by\n   * the client for a write request. For counter tables, this should always be set to true.\n   * @type {Boolean}\n   */\n  this.replicateOnWrite = true;\n  /**\n   * Returns the memtable flush period (in milliseconds) option for this table.\n   * @type {Number}\n   */\n  this.memtableFlushPeriod = 0;\n  /**\n   * Returns the index interval option for this table.\n   * <p>\n   * Note: this option is only available in Apache Cassandra 2.0. It is deprecated in Apache Cassandra 2.1 and\n   * above, and will therefore return <code>null</code> for 2.1 nodes.\n   * </p>\n   * @type {Number|null}\n   */\n  this.indexInterval = null;\n  /**\n   * Determines  whether the table uses the COMPACT STORAGE option.\n   * @type {Boolean}\n   */\n  this.isCompact = false;\n  /**\n   *\n   * @type {Array.<Index>}\n   */\n  this.indexes = null;\n\n  /**\n   * Determines whether the Change Data Capture (CDC) flag is set for the table.\n   * @type {Boolean|null}\n   */\n  this.cdc = null;\n\n  /**\n   * Determines whether the table is a virtual table or not.\n   * @type {Boolean}\n   */\n  this.virtual = false;\n}\n\nutil.inherits(TableMetadata, DataCollection);\n\nmodule.exports = TableMetadata;","'use strict';\n\n/**\n * Represents a base class that is used to measure events from the server and the client as seen by the driver.\n * @alias module:metrics~ClientMetrics\n * @interface\n */\nclass ClientMetrics {\n  /**\n   * Method invoked when an authentication error is obtained from the server.\n   * @param {AuthenticationError|Error} e The error encountered.\n   */\n  onAuthenticationError(e) {}\n\n  /**\n   * Method invoked when an error (different than a server or client timeout, authentication or connection error) is\n   * encountered when executing a request.\n   * @param {OperationTimedOutError} e The timeout error.\n   */\n  onClientTimeoutError(e) {}\n\n  /**\n   * Method invoked when there is a connection error.\n   * @param {Error} e The error encountered.\n   */\n  onConnectionError(e) {}\n\n  /**\n   * Method invoked when an error (different than a server or client timeout, authentication or connection error) is\n   * encountered when executing a request.\n   * @param {Error} e The error encountered.\n   */\n  onOtherError(e) {}\n\n  /**\n   * Method invoked when a read timeout error is obtained from the server.\n   * @param {ResponseError} e The error encountered.\n   */\n  onReadTimeoutError(e) {}\n\n  /**\n   * Method invoked when a write timeout error is obtained from the server.\n   * @param {ResponseError} e The error encountered.\n   */\n  onWriteTimeoutError(e) {}\n\n  /**\n   * Method invoked when an unavailable error is obtained from the server.\n   * @param {ResponseError} e The error encountered.\n   */\n  onUnavailableError(e) {}\n\n  /**\n   * Method invoked when an execution is retried as a result of a client-level timeout.\n   * @param {Error} e The error that caused the retry.\n   */\n  onClientTimeoutRetry(e) {}\n\n  /**\n   * Method invoked when an error (other than a server or client timeout) is retried.\n   * @param {Error} e The error that caused the retry.\n   */\n  onOtherErrorRetry(e) {}\n\n  /**\n   * Method invoked when an execution is retried as a result of a read timeout from the server (coordinator to replica).\n   * @param {Error} e The error that caused the retry.\n   */\n  onReadTimeoutRetry(e) {}\n\n  /**\n   * Method invoked when an execution is retried as a result of an unavailable error from the server.\n   * @param {Error} e The error that caused the retry.\n   */\n  onUnavailableRetry(e) {}\n\n  /**\n   * Method invoked when an execution is retried as a result of a write timeout from the server (coordinator to\n   * replica).\n   * @param {Error} e The error that caused the retry.\n   */\n  onWriteTimeoutRetry(e) {}\n\n  /**\n   * Method invoked when an error is marked as ignored by the retry policy.\n   * @param {Error} e The error that was ignored by the retry policy.\n   */\n  onIgnoreError(e) {}\n\n  /**\n   * Method invoked when a speculative execution is started.\n   */\n  onSpeculativeExecution() {}\n\n  /**\n   * Method invoked when a response is obtained successfully.\n   * @param {Array<Number>} latency The latency represented in a <code>[seconds, nanoseconds]</code> tuple\n   * Array, where nanoseconds is the remaining part of the real time that can't be represented in second precision.\n   */\n  onSuccessfulResponse(latency) {}\n\n  /**\n   * Method invoked when any response is obtained, the response can be the result of a successful execution or a\n   * server-side error.\n   * @param {Array<Number>} latency The latency represented in a <code>[seconds, nanoseconds]</code> tuple\n   * Array, where nanoseconds is the remaining part of the real time that can't be represented in second precision.\n   */\n  onResponse(latency) {\n\n  }\n}\n\nmodule.exports = ClientMetrics;","'use strict';\n\nconst ClientMetrics = require('./client-metrics');\nconst EventEmitter = require('events');\n\n/**\n * A default implementation of [ClientMetrics]{@link module:metrics~ClientMetrics} that exposes the driver events as\n * Node.js events.\n * <p>\n *   An instance of [DefaultMetrics]{@link module:metrics~DefaultMetrics} is configured by default in the client,\n *   you can access this instance using [Client#metrics]{@link Client#metrics} property.\n * </p>\n * @implements {module:metrics~ClientMetrics}\n * @alias module:metrics~DefaultMetrics\n * @example <caption>Listening to events emitted</caption>\n * defaultMetrics.errors.on('increment', err => totalErrors++);\n * defaultMetrics.errors.clientTimeout.on('increment', () => clientTimeoutErrors++);\n * defaultMetrics.speculativeRetries.on('increment', () => specExecsCount++);\n * defaultMetrics.responses.on('increment', latency => myHistogram.record(latency));\n */\nclass DefaultMetrics extends ClientMetrics {\n  /**\n   * Creates a new instance of [DefaultMetrics]{@link module:metrics~DefaultMetrics}.\n   */\n  constructor() {\n    super();\n\n    /**\n     * Emits all the error events.\n     * <p>Use each of the properties to measure events of specific errors.</p>\n     * @type {EventEmitter}\n     * @property {EventEmitter} authentication Emits the authentication timeout error events.\n     * @property {EventEmitter} clientTimeout Emits the client timeout error events.\n     * @property {EventEmitter} connection Emits the connection error events.\n     * @property {EventEmitter} readTimeout Emits the read timeout error events obtained from the server.\n     * @property {EventEmitter} other Emits the error events, that are not part of the other categories.\n     * @property {EventEmitter} unavailable Emits the unavailable error events obtained from the server.\n     * @property {EventEmitter} writeTimeout Emits the write timeout error events obtained from the server\n     */\n    this.errors = new EventEmitter();\n    this.errors.authentication = new EventEmitter();\n    this.errors.clientTimeout = new EventEmitter();\n    this.errors.connection = new EventEmitter();\n    this.errors.other = new EventEmitter();\n    this.errors.readTimeout = new EventEmitter();\n    this.errors.unavailable = new EventEmitter();\n    this.errors.writeTimeout = new EventEmitter();\n\n    /**\n     * Emits all the retry events.\n     * <p>Use each of the properties to measure events of specific retries.</p>\n     * @type {EventEmitter}\n     * @property {EventEmitter} clientTimeout Emits when an execution is retried as a result of an client timeout.\n     * @property {EventEmitter} other Emits the error events, that are not part of the other categories.\n     * @property {EventEmitter} readTimeout Emits an execution is retried as a result of an read timeout error from the\n     * server (coordinator to replica).\n     * @property {EventEmitter} unavailable Emits an execution is retried as a result of an unavailable error from the\n     * server.\n     * @property {EventEmitter} writeTimeout Emits an execution is retried as a result of a write timeout error from the\n     * server (coordinator to replica).\n     */\n    this.retries = new EventEmitter();\n    this.retries.clientTimeout = new EventEmitter();\n    this.retries.other = new EventEmitter();\n    this.retries.readTimeout = new EventEmitter();\n    this.retries.unavailable = new EventEmitter();\n    this.retries.writeTimeout = new EventEmitter();\n\n    /**\n     * Emits events when a speculative execution is started.\n     * @type {EventEmitter}\n     */\n    this.speculativeExecutions = new EventEmitter();\n\n    /**\n     * Emits events when an error is ignored by the retry policy.\n     * @type {EventEmitter}\n     */\n    this.ignoredErrors = new EventEmitter();\n\n    /**\n     * Emits events when a response message is obtained.\n     * @type {EventEmitter}\n     * @property {EventEmitter} success Emits when a response was obtained as the result of a successful execution.\n     */\n    this.responses = new EventEmitter();\n    this.responses.success = new EventEmitter();\n  }\n\n  /** @override */\n  onAuthenticationError(e) {\n    this.errors.authentication.emit('increment', e);\n    this.errors.emit('increment', e);}\n\n  /** @override */\n  onConnectionError(e) {\n    this.errors.connection.emit('increment', e);\n    this.errors.emit('increment', e);\n  }\n\n  /** @override */\n  onReadTimeoutError(e) {\n    this.errors.readTimeout.emit('increment', e);\n    this.errors.emit('increment', e);\n  }\n\n  /** @override */\n  onWriteTimeoutError(e) {\n    this.errors.writeTimeout.emit('increment', e);\n    this.errors.emit('increment', e);\n  }\n\n  /** @override */\n  onUnavailableError(e) {\n    this.errors.unavailable.emit('increment', e);\n    this.errors.emit('increment', e);\n  }\n\n  /** @override */\n  onClientTimeoutError(e) {\n    this.errors.clientTimeout.emit('increment', e);\n    this.errors.emit('increment', e);\n  }\n\n  /** @override */\n  onOtherError(e) {\n    this.errors.other.emit('increment', e);\n    this.errors.emit('increment', e);\n  }\n\n  /** @override */\n  onClientTimeoutRetry(e) {\n    this.retries.clientTimeout.emit('increment', e);\n    this.retries.emit('increment', e);\n  }\n\n  /** @override */\n  onOtherErrorRetry(e) {\n    this.retries.other.emit('increment', e);\n    this.retries.emit('increment', e);\n  }\n\n  /** @override */\n  onReadTimeoutRetry(e) {\n    this.retries.readTimeout.emit('increment', e);\n    this.retries.emit('increment', e);\n  }\n\n  /** @override */\n  onUnavailableRetry(e) {\n    this.retries.unavailable.emit('increment', e);\n    this.retries.emit('increment', e);\n  }\n\n  /** @override */\n  onWriteTimeoutRetry(e) {\n    this.retries.writeTimeout.emit('increment', e);\n    this.retries.emit('increment', e);\n  }\n\n  /** @override */\n  onIgnoreError(e) {\n    this.ignoredErrors.emit('increment', e);\n  }\n\n  /** @override */\n  onSpeculativeExecution() {\n    this.speculativeExecutions.emit('increment');\n  }\n\n  /** @override */\n  onSuccessfulResponse(latency) {\n    this.responses.success.emit('increment', latency);\n  }\n\n  /** @override */\n  onResponse(latency) {\n    this.responses.emit('increment', latency);\n  }\n}\n\nmodule.exports = DefaultMetrics;","'use strict';\n\nconst ClientMetrics = require('./client-metrics');\nconst DefaultMetrics = require('./default-metrics');\n\n/**\n * The <code>metrics</code> module contains interfaces and implementations used by the driver to expose\n * measurements of its internal behavior and of the server as seen from the driver side.\n * @module metrics\n */\n\nmodule.exports = { ClientMetrics, DefaultMetrics };","'use strict';\n\nconst util = require('util');\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst requests = require('./requests');\nconst ExecuteRequest = requests.ExecuteRequest;\nconst QueryRequest = requests.QueryRequest;\n\nconst state = {\n  init: 0,\n  completed: 1,\n  timedOut: 2,\n  cancelled: 3\n};\n\n/**\n * Maintains the state information of a request inside a Connection.\n */\nclass OperationState {\n  /**\n   * Creates a new instance of OperationState.\n   * @param {Request} request\n   * @param {Function} rowCallback\n   * @param {Function} callback\n   */\n  constructor(request, rowCallback, callback) {\n    this.request = request;\n    this._rowCallback = rowCallback;\n    this._callback = callback;\n    this._timeout = null;\n    this._state = state.init;\n    this._rowIndex = 0;\n    /**\n     * Stream id that is set right before being written.\n     * @type {number}\n     */\n    this.streamId = -1;\n  }\n\n  /**\n   * Marks the operation as cancelled, clearing all callbacks and timeouts.\n   */\n  cancel() {\n    if (this._state !== state.init) {\n      return;\n    }\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout);\n    }\n    this._state = state.cancelled;\n    this._callback = utils.noop;\n  }\n\n  /**\n   * Determines if the operation can be written to the wire (when it hasn't been cancelled or it hasn't timed out).\n   */\n  canBeWritten() {\n    return this._state === state.init;\n  }\n\n  /**\n   * Determines if the response is going to be yielded by row.\n   * @return {boolean}\n   */\n  isByRow() {\n    return this._rowCallback && (this.request instanceof ExecuteRequest || this.request instanceof QueryRequest);\n  }\n\n  /**\n   * Creates the timeout for the request.\n   * @param {ExecutionOptions} execOptions\n   * @param {Number} defaultReadTimeout\n   * @param {String} address\n   * @param {Function} onTimeout The callback to be invoked when it times out.\n   * @param {Function} onResponse The callback to be invoked if a response is obtained after it timed out.\n   */\n  setRequestTimeout(execOptions, defaultReadTimeout, address, onTimeout, onResponse) {\n    if (this._state !== state.init) {\n      // No need to set the timeout\n      return;\n    }\n    const millis = execOptions.getReadTimeout() !== undefined ? execOptions.getReadTimeout() : defaultReadTimeout;\n    if (!(millis > 0)) {\n      // Read timeout disabled\n      return;\n    }\n    const self = this;\n    this._timeout = setTimeout(function requestTimedOut() {\n      onTimeout();\n      const message = util.format('The host %s did not reply before timeout %d ms', address, millis);\n      self._markAsTimedOut(new errors.OperationTimedOutError(message, address), onResponse);\n    }, millis);\n  }\n\n  setResultRow(row, meta, rowLength, flags, header) {\n    this._markAsCompleted();\n    if (!this._rowCallback) {\n      return this.setResult(new errors.DriverInternalError('RowCallback not found for streaming frame handler'));\n    }\n    this._rowCallback(this._rowIndex++, row, rowLength);\n    if (this._rowIndex === rowLength) {\n      this._swapCallbackAndInvoke(null, { rowLength: rowLength, meta: meta, flags: flags }, header.bodyLength);\n    }\n  }\n\n  /**\n   * Marks the current operation as timed out.\n   * @param {Error} err\n   * @param {Function} onResponse\n   * @private\n   */\n  _markAsTimedOut(err, onResponse) {\n    if (this._state !== state.init) {\n      return;\n    }\n    this._state = state.timedOut;\n    this._swapCallbackAndInvoke(err, null, null, onResponse);\n  }\n\n  _markAsCompleted() {\n    if (this._state !== state.init) {\n      return;\n    }\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout);\n    }\n    this._state = state.completed;\n  }\n\n  /**\n   * Sets the result of this operation, declaring that no further input will be processed for this operation.\n   * @param {Error} err\n   * @param {Object} [result]\n   * @param {Number} [length]\n   */\n  setResult(err, result, length) {\n    this._markAsCompleted();\n    this._swapCallbackAndInvoke(err, result, length);\n  }\n\n  _swapCallbackAndInvoke(err, result, length, newCallback) {\n    const callback = this._callback;\n    this._callback = newCallback || utils.noop;\n    callback(err, result, length);\n  }\n}\n\nmodule.exports = OperationState;","\"use strict\";\nconst dns = require('dns');\nconst util = require('util');\nconst utils = require('../utils');\n/** @module policies/addressResolution */\n/**\n * @class\n * @classdesc\n * Translates IP addresses received from Cassandra nodes into locally queryable\n * addresses.\n * <p>\n * The driver auto-detects new Cassandra nodes added to the cluster through server\n * side pushed notifications and through checking the system tables. For each\n * node, the address received will correspond to the address set as\n * <code>rpc_address</code> in the node yaml file. In most case, this is the correct\n * address to use by the driver and that is what is used by default. However,\n * sometimes the addresses received through this mechanism will either not be\n * reachable directly by the driver or should not be the preferred address to use\n * to reach the node (for instance, the <code>rpc_address</code> set on Cassandra nodes\n * might be a private IP, but some clients  may have to use a public IP, or\n * pass by a router to reach that node). This interface allows to deal with\n * such cases, by allowing to translate an address as sent by a Cassandra node\n * to another address to be used by the driver for connection.\n * <p>\n * Please note that the contact points addresses provided while creating the\n * {@link Client} instance are not \"translated\", only IP address retrieve from or sent\n * by Cassandra nodes to the driver are.\n * @constructor\n */\nfunction AddressTranslator() {\n\n}\n\n/**\n * Translates a Cassandra <code>rpc_address</code> to another address if necessary.\n * @param {String} address the address of a node as returned by Cassandra.\n * <p>\n * Note that if the <code>rpc_address</code> of a node has been configured to <code>0.0.0.0</code>\n * server side, then the provided address will be the node <code>listen_address</code>,\n * *not* <code>0.0.0.0</code>.\n * </p>\n * @param {Number} port The port number, as specified in the [protocolOptions]{@link ClientOptions} at Client instance creation (9042 by default).\n * @param {Function} callback Callback to invoke with endpoint as first parameter.\n * The endpoint is an string composed of the IP address and the port number in the format <code>ipAddress:port</code>.\n */\nAddressTranslator.prototype.translate = function (address, port, callback) {\n  callback(address + ':' + port);\n};\n\n/**\n * @class\n * @classdesc\n * {@link AddressTranslator} implementation for multi-region EC2 deployments <strong>where clients are also deployed in EC2</strong>.\n * <p>\n * Its distinctive feature is that it translates addresses according to the location of the Cassandra host:\n * </p>\n * <ul>\n *  <li>addresses in different EC2 regions (than the client) are unchanged</li>\n *  <li>addresses in the same EC2 region are <strong>translated to private IPs</strong></li>\n * </ul>\n * <p>\n * This optimizes network costs, because Amazon charges more for communication over public IPs.\n * </p>\n * @constructor\n */\nfunction EC2MultiRegionTranslator() {\n\n}\n\nutil.inherits(EC2MultiRegionTranslator, AddressTranslator);\n\n/**\n * Addresses in the same EC2 region are translated to private IPs and addresses in\n * different EC2 regions (than the client) are unchanged\n */\nEC2MultiRegionTranslator.prototype.translate = function (address, port, callback) {\n  let newAddress = address;\n  const self = this;\n  let name;\n  utils.series([\n    function resolve(next) {\n      dns.reverse(address, function (err, hostNames) {\n        if (err) {\n          return next(err);\n        }\n        if (!hostNames) {\n          return next();\n        }\n        name = hostNames[0];\n        next();\n      });\n    },\n    function lookup(next) {\n      if (!name) {\n        return next();\n      }\n      dns.lookup(name, function (err, lookupAddress) {\n        if (err) {\n          return next(err);\n        }\n        newAddress = lookupAddress;\n        next();\n      });\n    }], function (err) {\n    if (err) {\n      //there was an issue while doing dns resolution\n      self.logError(address, err);\n    }\n    callback(newAddress + ':' + port);\n  });\n};\n\n/**\n * Log method called to log errors that occurred while performing dns resolution.\n * You can assign your own method to the class instance to do proper logging.\n * @param {String} address\n * @param {Error} err\n */\nEC2MultiRegionTranslator.prototype.logError = function (address, err) {\n  //Do nothing by default\n};\n\nexports.AddressTranslator = AddressTranslator;\nexports.EC2MultiRegionTranslator = EC2MultiRegionTranslator;","'use strict';\n\n/**\n * Contains driver tuning policies to determine [load balancing]{@link module:policies/loadBalancing},\n *  [retrying]{@link module:policies/retry} queries, [reconnecting]{@link module:policies/reconnection} to a node,\n *  [address resolution]{@link module:policies/addressResolution},\n *  [timestamp generation]{@link module:policies/timestampGeneration} and\n *  [speculative execution]{@link module:policies/speculativeExecution}.\n * @module policies\n */\nconst addressResolution = exports.addressResolution = require('./address-resolution');\nconst loadBalancing = exports.loadBalancing = require('./load-balancing');\nconst reconnection = exports.reconnection = require('./reconnection');\nconst retry = exports.retry = require('./retry');\nconst speculativeExecution = exports.speculativeExecution = require('./speculative-execution');\nconst timestampGeneration = exports.timestampGeneration = require('./timestamp-generation');\n\n/**\n * Returns a new instance of the default address translator policy used by the driver.\n * @returns {AddressTranslator}\n */\nexports.defaultAddressTranslator = function () {\n  return new addressResolution.AddressTranslator();\n};\n\n/**\n * Returns a new instance of the default load-balancing policy used by the driver.\n * @returns {LoadBalancingPolicy}\n */\nexports.defaultLoadBalancingPolicy = function () {\n  return new loadBalancing.TokenAwarePolicy(new loadBalancing.DCAwareRoundRobinPolicy());\n};\n\n/**\n * Returns a new instance of the default retry policy used by the driver.\n * @returns {RetryPolicy}\n */\nexports.defaultRetryPolicy = function () {\n  return new retry.RetryPolicy();\n};\n\n/**\n * Returns a new instance of the default reconnection policy used by the driver.\n * @returns {ReconnectionPolicy}\n */\nexports.defaultReconnectionPolicy = function () {\n  return new reconnection.ExponentialReconnectionPolicy(1000, 10 * 60 * 1000, false);\n};\n\n\n/**\n * Returns a new instance of the default speculative execution policy used by the driver.\n * @returns {SpeculativeExecutionPolicy}\n */\nexports.defaultSpeculativeExecutionPolicy = function () {\n  return new speculativeExecution.NoSpeculativeExecutionPolicy();\n};\n\n/**\n * Returns a new instance of the default timestamp generator used by the driver.\n * @returns {TimestampGenerator}\n */\nexports.defaultTimestampGenerator = function () {\n  return new timestampGeneration.MonotonicTimestampGenerator();\n};","\"use strict\";\n\nconst util = require('util');\nconst types = require('../types');\nconst utils = require('../utils.js');\nconst errors = require('../errors.js');\n\nconst doneIteratorObject = Object.freeze({ done: true });\n\n/** @module policies/loadBalancing */\n/**\n * Base class for Load Balancing Policies\n * @constructor\n */\nfunction LoadBalancingPolicy() {\n\n}\n\n/**\n * Initializes the load balancing policy, called after the driver obtained the information of the cluster.\n * @param {Client} client\n * @param {HostMap} hosts\n * @param {Function} callback\n */\nLoadBalancingPolicy.prototype.init = function (client, hosts, callback) {\n  this.client = client;\n  this.hosts = hosts;\n  callback();\n};\n\n/**\n * Returns the distance assigned by this policy to the provided host.\n * @param {Host} host\n */\nLoadBalancingPolicy.prototype.getDistance = function (host) {\n  return types.distance.local;\n};\n\n/**\n * Returns an iterator with the hosts for a new query.\n * Each new query will call this method. The first host in the result will\n * then be used to perform the query.\n * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.\n * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.\n * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as\n * second parameter.\n */\nLoadBalancingPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {\n  callback(new Error('You must implement a query plan for the LoadBalancingPolicy class'));\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nLoadBalancingPolicy.prototype.getOptions = function () {\n  return new Map();\n};\n\n/**\n * This policy yield nodes in a round-robin fashion.\n * @extends LoadBalancingPolicy\n * @constructor\n */\nfunction RoundRobinPolicy() {\n  this.index = 0;\n}\n\nutil.inherits(RoundRobinPolicy, LoadBalancingPolicy);\n\n/**\n * Returns an iterator with the hosts to be used as coordinator for a query.\n * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.\n * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.\n * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as\n * second parameter.\n */\nRoundRobinPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {\n  if (!this.hosts) {\n    return callback(new Error('Load balancing policy not initialized'));\n  }\n  const hosts = this.hosts.values();\n  const self = this;\n  let counter = 0;\n\n  let planIndex = self.index % hosts.length;\n  self.index += 1;\n  if (self.index >= utils.maxInt) {\n    self.index = 0;\n  }\n\n  callback(null, {\n    next: function () {\n      if (++counter > hosts.length) {\n        return doneIteratorObject;\n      }\n      return {value: hosts[planIndex++ % hosts.length], done: false};\n    }\n  });\n};\n\n/**\n * A data-center aware Round-robin load balancing policy.\n * This policy provides round-robin queries over the nodes of the local\n * data center.\n * @param {?String} [localDc] local datacenter name.  This value overrides the 'localDataCenter' Client option \\\n * and is useful for cases where you have multiple execution profiles that you intend on using for routing\n * requests to different data centers.\n * @extends {LoadBalancingPolicy}\n * @constructor\n */\nfunction DCAwareRoundRobinPolicy(localDc) {\n  this.localDc = localDc;\n  this.index = 0;\n  /** @type {Array} */\n  this.localHostsArray = null;\n}\n\nutil.inherits(DCAwareRoundRobinPolicy, LoadBalancingPolicy);\n\n/**\n * Initializes the load balancing policy.\n * @param {Client} client\n * @param {HostMap} hosts\n * @param {Function} callback\n */\nDCAwareRoundRobinPolicy.prototype.init = function (client, hosts, callback) {\n  this.client = client;\n  this.hosts = hosts;\n  hosts.on('add', this._cleanHostCache.bind(this));\n  hosts.on('remove', this._cleanHostCache.bind(this));\n\n  if (client && client.options) {\n    if (this.localDc && !client.options.localDataCenter) {\n      this.client.log('info', 'Local data center \\'' + this.localDc + '\\' was provided as an argument to' +\n        ' DCAwareRoundRobinPolicy. It is more preferable to specify the local data center using \\'localDataCenter\\'' +\n        ' in Client options instead when your application is targeting a single data center.');\n    }\n\n    // If localDc is unset, use value set in client options.\n    this.localDc = this.localDc || client.options.localDataCenter;\n  }\n\n  if (!this.localDc) {\n    return callback(new errors.ArgumentError('\\'localDataCenter\\' is not defined in Client options and also was' +\n      ' not specified in constructor. At least one is required.'));\n  }\n  callback();\n};\n\n/**\n * Returns the distance depending on the datacenter.\n * @param {Host} host\n */\nDCAwareRoundRobinPolicy.prototype.getDistance = function (host) {\n  if (!host.datacenter) {\n    return types.distance.ignored;\n  }\n  if (host.datacenter === this.localDc) {\n    return types.distance.local;\n  }\n  return types.distance.remote;\n};\n\nDCAwareRoundRobinPolicy.prototype._cleanHostCache = function () {\n  this.localHostsArray = null;\n};\n\nDCAwareRoundRobinPolicy.prototype._resolveLocalHosts = function() {\n  const hosts = this.hosts.values();\n  if (this.localHostsArray) {\n    //there were already calculated\n    return;\n  }\n  this.localHostsArray = [];\n  hosts.forEach(function (h) {\n    if (!h.datacenter) {\n      //not a remote dc node\n      return;\n    }\n    if (h.datacenter === this.localDc) {\n      this.localHostsArray.push(h);\n    }\n  }, this);\n};\n\n/**\n * It returns an iterator that yields local nodes.\n * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.\n * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.\n * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as\n * second parameter.\n */\nDCAwareRoundRobinPolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {\n  if (!this.hosts) {\n    return callback(new Error('Load balancing policy not initialized'));\n  }\n  this.index += 1;\n  if (this.index >= utils.maxInt) {\n    this.index = 0;\n  }\n  this._resolveLocalHosts();\n  // Use a local reference of hosts\n  const localHostsArray = this.localHostsArray;\n  let planLocalIndex = this.index;\n  let counter = 0;\n  callback(null, {\n    next: function () {\n      let host;\n      if (counter++ < localHostsArray.length) {\n        host = localHostsArray[planLocalIndex++ % localHostsArray.length];\n        return { value: host, done: false };\n      }\n      return doneIteratorObject;\n    }\n  });\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nDCAwareRoundRobinPolicy.prototype.getOptions = function () {\n  return new Map([\n    ['localDataCenter', this.localDc ]\n  ]);\n};\n\n/**\n * A wrapper load balancing policy that add token awareness to a child policy.\n * @param {LoadBalancingPolicy} childPolicy\n * @extends LoadBalancingPolicy\n * @constructor\n */\nfunction TokenAwarePolicy (childPolicy) {\n  if (!childPolicy) {\n    throw new Error(\"You must specify a child load balancing policy\");\n  }\n  this.childPolicy = childPolicy;\n}\n\nutil.inherits(TokenAwarePolicy, LoadBalancingPolicy);\n\nTokenAwarePolicy.prototype.init = function (client, hosts, callback) {\n  this.client = client;\n  this.hosts = hosts;\n  this.childPolicy.init(client, hosts, callback);\n};\n\nTokenAwarePolicy.prototype.getDistance = function (host) {\n  return this.childPolicy.getDistance(host);\n};\n\n/**\n * Returns the hosts to use for a new query.\n * The returned plan will return local replicas first, if replicas can be determined, followed by the plan of the\n * child policy.\n * @param {String} keyspace Name of currently logged keyspace at <code>Client</code> level.\n * @param {ExecutionOptions|null} executionOptions The information related to the execution of the request.\n * @param {Function} callback The function to be invoked with the error as first parameter and the host iterator as\n * second parameter.\n */\nTokenAwarePolicy.prototype.newQueryPlan = function (keyspace, executionOptions, callback) {\n  let routingKey;\n  if (executionOptions) {\n    routingKey = executionOptions.getRoutingKey();\n    if (executionOptions.getKeyspace()) {\n      keyspace = executionOptions.getKeyspace();\n    }\n  }\n  let replicas;\n  if (routingKey) {\n    replicas = this.client.getReplicas(keyspace, routingKey);\n  }\n  if (!routingKey || !replicas) {\n    return this.childPolicy.newQueryPlan(keyspace, executionOptions, callback);\n  }\n  const iterator = new TokenAwareIterator(keyspace, executionOptions, replicas, this.childPolicy);\n  iterator.iterate(callback);\n};\n\n/**\n * An iterator that holds the context for the subsequent next() calls\n * @param {String} keyspace\n * @param {ExecutionOptions} execOptions\n * @param {Array} replicas\n * @param childPolicy\n * @constructor\n * @ignore\n */\nfunction TokenAwareIterator(keyspace, execOptions, replicas, childPolicy) {\n  this.keyspace = keyspace;\n  this.childPolicy = childPolicy;\n  this.options = execOptions;\n  this.localReplicas = [];\n  this.replicaIndex = 0;\n  this.replicaMap = {};\n  this.childIterator = null;\n  // Memoize the local replicas\n  // The amount of local replicas should be defined before start iterating, in order to select an\n  // appropriate (pseudo random) startIndex\n  for (let i = 0; i < replicas.length; i++) {\n    const host = replicas[i];\n    if (this.childPolicy.getDistance(host) !== types.distance.local) {\n      continue;\n    }\n    this.replicaMap[host.address] = true;\n    this.localReplicas.push(host);\n  }\n  // We use a PRNG to set the replica index\n  // We only care about proportional fair scheduling between replicas of a given token\n  // Math.random() has an extremely short permutation cycle length but we don't care about collisions\n  this.startIndex = Math.floor(Math.random() * this.localReplicas.length);\n}\n\nTokenAwareIterator.prototype.iterate = function (callback) {\n  //Load the child policy hosts\n  const self = this;\n  this.childPolicy.newQueryPlan(this.keyspace, this.options, function (err, iterator) {\n    if (err) {\n      return callback(err);\n    }\n    //get the iterator of the child policy in case is needed\n    self.childIterator = iterator;\n    callback(null, {\n      next: function () { return self.computeNext(); }\n    });\n  });\n};\n\nTokenAwareIterator.prototype.computeNext = function () {\n  let host;\n  if (this.replicaIndex < this.localReplicas.length) {\n    host = this.localReplicas[(this.startIndex + (this.replicaIndex++)) % this.localReplicas.length];\n    return { value: host, done: false };\n  }\n  // Return hosts from child policy\n  let item;\n  while ((item = this.childIterator.next()) && !item.done) {\n    if (this.replicaMap[item.value.address]) {\n      // Avoid yielding local replicas from the child load balancing policy query plan\n      continue;\n    }\n    return item;\n  }\n  return doneIteratorObject;\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nTokenAwarePolicy.prototype.getOptions = function () {\n  const map = new Map([\n    ['childPolicy', this.childPolicy.constructor !== undefined ? this.childPolicy.constructor.name : null ]\n  ]);\n\n  if (this.childPolicy instanceof DCAwareRoundRobinPolicy) {\n    map.set('localDataCenter', this.childPolicy.localDc);\n  }\n\n  return map;\n};\n\n/**\n * Create a new policy that wraps the provided child policy but only \"allow\" hosts\n * from the provided while list.\n * @class\n * @classdesc\n * A load balancing policy wrapper that ensure that only hosts from a provided\n * white list will ever be returned.\n * <p>\n * This policy wraps another load balancing policy and will delegate the choice\n * of hosts to the wrapped policy with the exception that only hosts contained\n * in the white list provided when constructing this policy will ever be\n * returned. Any host not in the while list will be considered ignored\n * and thus will not be connected to.\n * <p>\n * This policy can be useful to ensure that the driver only connects to a\n * predefined set of hosts. Keep in mind however that this policy defeats\n * somewhat the host auto-detection of the driver. As such, this policy is only\n * useful in a few special cases or for testing, but is not optimal in general.\n * If all you want to do is limiting connections to hosts of the local\n * data-center then you should use DCAwareRoundRobinPolicy and *not* this policy\n * in particular.\n * @param {LoadBalancingPolicy} childPolicy the wrapped policy.\n * @param {Array.<string>}  whiteList the white listed hosts address in the format ipAddress:port.\n * Only hosts from this list may get connected\n * to (whether they will get connected to or not depends on the child policy).\n * @extends LoadBalancingPolicy\n * @constructor\n */\nfunction WhiteListPolicy (childPolicy, whiteList) {\n  if (!childPolicy) {\n    throw new Error(\"You must specify a child load balancing policy\");\n  }\n  if (!util.isArray(whiteList)) {\n    throw new Error(\"You must provide the white list of host addresses\");\n  }\n  this.childPolicy = childPolicy;\n  const map = {};\n  whiteList.forEach(function (address) {\n    map[address] = true;\n  });\n  this.whiteList = map;\n}\n\nutil.inherits(WhiteListPolicy, LoadBalancingPolicy);\n\nWhiteListPolicy.prototype.init = function (client, hosts, callback) {\n  this.childPolicy.init(client, hosts, callback);\n};\n\n/**\n * Uses the child policy to return the distance to the host if included in the white list.\n * Any host not in the while list will be considered ignored.\n * @param host\n */\nWhiteListPolicy.prototype.getDistance = function (host) {\n  if (!this._contains(host)) {\n    return types.distance.ignored;\n  }\n  return this.childPolicy.getDistance(host);\n};\n\n/**\n * @param {Host} host\n * @returns {boolean}\n * @private\n */\nWhiteListPolicy.prototype._contains = function (host) {\n  return !!this.whiteList[host.address];\n};\n\n/**\n * Returns the hosts to use for a new query filtered by the white list.\n */\nWhiteListPolicy.prototype.newQueryPlan = function (keyspace, info, callback) {\n  const self = this;\n  this.childPolicy.newQueryPlan(keyspace, info, function (err, iterator) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, self._filter(iterator));\n  });\n};\n\nWhiteListPolicy.prototype._filter = function (childIterator) {\n  const self = this;\n  return {\n    next: function () {\n      const item = childIterator.next();\n      if (!item.done && !self._contains(item.value)) {\n        return this.next();\n      }\n      return item;\n    }\n  };\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nWhiteListPolicy.prototype.getOptions = function () {\n  return new Map([\n    ['childPolicy', this.childPolicy.constructor !== undefined ? this.childPolicy.constructor.name : null ],\n    ['whitelist', Object.keys(this.whiteList)]\n  ]);\n};\n\nexports.DCAwareRoundRobinPolicy = DCAwareRoundRobinPolicy;\nexports.LoadBalancingPolicy = LoadBalancingPolicy;\nexports.RoundRobinPolicy = RoundRobinPolicy;\nexports.TokenAwarePolicy = TokenAwarePolicy;\nexports.WhiteListPolicy = WhiteListPolicy;","'use strict';\nconst util = require('util');\n\n/** @module policies/reconnection */\n/**\n * Base class for Reconnection Policies\n * @constructor\n */\nfunction ReconnectionPolicy() {\n\n}\n\n/**\n * A new reconnection schedule.\n * @returns {{next: function}} An infinite iterator\n */\nReconnectionPolicy.prototype.newSchedule = function () {\n  throw new Error('You must implement a new schedule for the Reconnection class');\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nReconnectionPolicy.prototype.getOptions = function () {\n  return new Map();\n};\n\n/**\n * A reconnection policy that waits a constant time between each reconnection attempt.\n * @param {Number} delay Delay in ms\n * @constructor\n */\nfunction ConstantReconnectionPolicy(delay) {\n  this.delay = delay;\n}\n\nutil.inherits(ConstantReconnectionPolicy, ReconnectionPolicy);\n\n/**\n * A new reconnection schedule that returns the same next delay value\n * @returns {{next: next}} An infinite iterator\n */\nConstantReconnectionPolicy.prototype.newSchedule = function () {\n  const self = this;\n  return {\n    next: function () {\n      return {value: self.delay, done: false};\n    }\n  };\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nConstantReconnectionPolicy.prototype.getOptions = function () {\n  return new Map([['delay', this.delay ]]);\n};\n\n/**\n * A reconnection policy that waits exponentially longer between each\n * reconnection attempt (but keeps a constant delay once a maximum delay is reached).\n * <p>\n *   A random amount of jitter (+/- 15%) will be added to the pure exponential delay value to avoid situations\n *   where many clients are in the reconnection process at exactly the same time. The jitter will never cause the\n *   delay to be less than the base delay, or more than the max delay.\n * </p>\n * @param {Number} baseDelay The base delay in milliseconds to use for the schedules created by this policy.\n * @param {Number} maxDelay The maximum delay in milliseconds to wait between two reconnection attempt.\n * @param {Boolean} startWithNoDelay Determines if the first attempt should be zero delay\n * @constructor\n */\nfunction ExponentialReconnectionPolicy(baseDelay, maxDelay, startWithNoDelay) {\n  this.baseDelay = baseDelay;\n  this.maxDelay = maxDelay;\n  this.startWithNoDelay = startWithNoDelay;\n}\n\nutil.inherits(ExponentialReconnectionPolicy, ReconnectionPolicy);\n\n/**\n * A new schedule that uses an exponentially growing delay between reconnection attempts.\n * @returns {{next: next}} An infinite iterator.\n */\nExponentialReconnectionPolicy.prototype.newSchedule = function* () {\n  let index = this.startWithNoDelay ? -1 : 0;\n\n  while (true) {\n    let delay = 0;\n\n    if (index >= 64) {\n      delay = this.maxDelay;\n    } else if (index !== -1) {\n      delay = Math.min(Math.pow(2, index) * this.baseDelay, this.maxDelay);\n    }\n\n    index++;\n\n    yield this._addJitter(delay);\n  }\n};\n\n/**\n * Adds a random portion of +-15% to the delay provided.\n * Initially, its adds a random value of 15% to avoid reconnection before reaching the base delay.\n * When the schedule reaches max delay, only subtracts a random portion of 15%.\n */\nExponentialReconnectionPolicy.prototype._addJitter = function (value) {\n  if (value === 0) {\n    // Instant reconnection without jitter\n    return value;\n  }\n\n  // Use the formula: 85% + rnd() * 30% to calculate the percentage of the original delay\n  let minPercentage = 0.85;\n  let range = 0.30;\n\n  if (!this.startWithNoDelay && value === this.baseDelay) {\n    // Between 100% to 115% of the original value\n    minPercentage = 1;\n    range = 0.15;\n  } else if (value === this.maxDelay) {\n    // Between 85% to 100% of the original value\n    range = 0.15;\n  }\n\n  return Math.floor(value * (Math.random() * range + minPercentage));\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nExponentialReconnectionPolicy.prototype.getOptions = function () {\n  return new Map([\n    ['baseDelay', this.baseDelay ],\n    ['maxDelay', this.maxDelay ],\n    ['startWithNoDelay', this.startWithNoDelay ]\n  ]);\n};\n\nexports.ReconnectionPolicy = ReconnectionPolicy;\nexports.ConstantReconnectionPolicy = ConstantReconnectionPolicy;\nexports.ExponentialReconnectionPolicy = ExponentialReconnectionPolicy;","\"use strict\";\nconst util = require('util');\n\n/** @module policies/retry */\n/**\n * Base and default RetryPolicy.\n * Determines what to do when the drivers runs into an specific Cassandra exception\n * @constructor\n */\nfunction RetryPolicy() {\n\n}\n\n/**\n * Determines what to do when the driver gets an UnavailableException response from a Cassandra node.\n * @param {OperationInfo} info\n * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Number} required The number of replicas whose response is required to achieve the\n * required [consistency]{@link module:types~consistencies}.\n * @param {Number} alive The number of replicas that were known to be alive when the request had been processed\n * (since an unavailable exception has been triggered, there will be alive &lt; required)\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {\n  if (info.nbRetry > 0) {\n    return this.rethrowResult();\n  }\n  return this.retryResult(undefined, false);\n};\n\n/**\n * Determines what to do when the driver gets a ReadTimeoutException response from a Cassandra node.\n * @param {OperationInfo} info\n * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Number} received The number of nodes having answered the request.\n * @param {Number} blockFor The number of replicas whose response is required to achieve the\n * required [consistency]{@link module:types~consistencies}.\n * @param {Boolean} isDataPresent When <code>false</code>, it means the replica that was asked for data has not responded.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {\n  if (info.nbRetry > 0) {\n    return this.rethrowResult();\n  }\n  return ((received >= blockFor && !isDataPresent) ?\n    this.retryResult() :\n    this.rethrowResult());\n};\n\n/**\n * Determines what to do when the driver gets a WriteTimeoutException response from a Cassandra node.\n * @param {OperationInfo} info\n * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Number} received The number of nodes having acknowledged the request.\n * @param {Number} blockFor The number of replicas whose acknowledgement is required to achieve the required\n * [consistency]{@link module:types~consistencies}.\n * @param {String} writeType A <code>string</code> that describes the type of the write that timed out (\"SIMPLE\"\n * / \"BATCH\" / \"BATCH_LOG\" / \"UNLOGGED_BATCH\" / \"COUNTER\").\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {\n  if (info.nbRetry > 0) {\n    return this.rethrowResult();\n  }\n  // If the batch log write failed, retry the operation as this might just be we were unlucky at picking candidates\n  return writeType === \"BATCH_LOG\" ? this.retryResult() : this.rethrowResult();\n};\n\n/**\n * Defines whether to retry and at which consistency level on an unexpected error.\n * <p>\n * This method might be invoked in the following situations:\n * </p>\n * <ol>\n * <li>On a client timeout, while waiting for the server response\n * (see [socketOptions.readTimeout]{@link ClientOptions}), being the error an instance of\n * [OperationTimedOutError]{@link module:errors~OperationTimedOutError}.</li>\n * <li>On a connection error (socket closed, etc.).</li>\n * <li>When the contacted host replies with an error, such as <code>overloaded</code>, <code>isBootstrapping</code>,\n * </code>serverError, etc. In this case, the error is instance of [ResponseError]{@link module:errors~ResponseError}.\n * </li>\n * </ol>\n * <p>\n * Note that when this method is invoked, <em>the driver cannot guarantee that the mutation has been effectively\n * applied server-side</em>; a retry should only be attempted if the request is known to be idempotent.\n * </p>\n * @param {OperationInfo} info\n * @param {Number|undefined} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Error} err The error that caused this request to fail.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onRequestError = function (info, consistency, err) {\n  // The default implementation triggers a retry on the next host in the query plan with the same consistency level,\n  // regardless of the statement's idempotence, for historical reasons.\n  return this.retryResult(undefined, false);\n};\n\n/**\n * Returns a {@link DecisionInfo} to retry the request with the given [consistency]{@link module:types~consistencies}.\n * @param {Number|undefined} [consistency] When specified, it retries the request with the given consistency.\n * @param {Boolean} [useCurrentHost] When specified, determines if the retry should be made using the same coordinator.\n * Default: true.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.retryResult = function (consistency, useCurrentHost) {\n  return {\n    decision: RetryPolicy.retryDecision.retry,\n    consistency: consistency,\n    useCurrentHost: useCurrentHost !== false\n  };\n};\n\n/**\n * Returns a {@link DecisionInfo} to callback in error when a err is obtained for a given request.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.rethrowResult = function () {\n  return { decision: RetryPolicy.retryDecision.rethrow };\n};\n\n/**\n * Determines the retry decision for the retry policies.\n * @type {Object}\n * @property {Number} rethrow\n * @property {Number} retry\n * @property {Number} ignore\n * @static\n */\nRetryPolicy.retryDecision = {\n  rethrow:  0,\n  retry:    1,\n  ignore:   2\n};\n\n/**\n * Creates a new instance of <code>IdempotenceAwareRetryPolicy</code>.\n * @classdesc\n * A retry policy that avoids retrying non-idempotent statements.\n * <p>\n * In case of write timeouts or unexpected errors, this policy will always return\n * [rethrowResult()]{@link module:policies/retry~RetryPolicy#rethrowResult} if the statement is deemed non-idempotent\n * (see [QueryOptions.isIdempotent]{@link QueryOptions}).\n * <p/>\n * For all other cases, this policy delegates the decision to the child policy.\n * @param {RetryPolicy} [childPolicy] The child retry policy to wrap. When not defined, it will use an instance of\n * [RetryPolicy]{@link module:policies/retry~RetryPolicy} as child policy.\n * @extends module:policies/retry~RetryPolicy\n * @constructor\n * @deprecated since 4.0 non-idempotent operations are never tried for write timeout or request error, use the default\n * retry policy instead.\n */\nfunction IdempotenceAwareRetryPolicy(childPolicy) {\n  this._childPolicy = childPolicy || new RetryPolicy();\n}\n\nutil.inherits(IdempotenceAwareRetryPolicy, RetryPolicy);\n\nIdempotenceAwareRetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {\n  return this._childPolicy.onReadTimeout(info, consistency, received, blockFor, isDataPresent);\n};\n\n/**\n * If the query is not idempotent, it returns a rethrow decision. Otherwise, it relies on the child policy to decide.\n */\nIdempotenceAwareRetryPolicy.prototype.onRequestError = function (info, consistency, err) {\n  if (info.options.isIdempotent) {\n    return this._childPolicy.onRequestError(info, consistency, err);\n  }\n  return this.rethrowResult();\n};\n\nIdempotenceAwareRetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {\n  return this._childPolicy.onUnavailable(info, consistency, required, alive);\n};\n\n/**\n * If the query is not idempotent, it return a rethrow decision. Otherwise, it relies on the child policy to decide.\n */\nIdempotenceAwareRetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {\n  if (info.options.isIdempotent) {\n    return this._childPolicy.onWriteTimeout(info, consistency, received, blockFor, writeType);\n  }\n  return this.rethrowResult();\n};\n\n/**\n * Decision information\n * @typedef {Object} DecisionInfo\n * @property {Number} decision The decision as specified in\n * [retryDecision]{@link module:policies/retry~RetryPolicy.retryDecision}.\n * @property {Number} [consistency] The [consistency level]{@link module:types~consistencies}.\n * @property {useCurrentHost} [useCurrentHost] Determines if it should use the same host to retry the request.\n * <p>\n *   In the case that the current host is not available anymore, it will be retried on the next host even when\n *   <code>useCurrentHost</code> is set to <code>true</code>.\n * </p>\n */\n\n/**\n * Information of the execution to be used to determine whether the operation should be retried.\n * @typedef {Object} OperationInfo\n * @property {String} query The query that was executed.\n * @param {ExecutionOptions} executionOptions The options related to the execution of the request.\n * @property {Number} nbRetry The number of retries already performed for this operation.\n */\n\nexports.RetryPolicy = RetryPolicy;\nexports.IdempotenceAwareRetryPolicy = IdempotenceAwareRetryPolicy;","'use strict';\n\nconst util = require('util');\nconst errors = require('../errors');\n\n/** @module policies/speculativeExecution */\n\n/**\n * @classdesc\n * The policy that decides if the driver will send speculative queries to the next hosts when the current host takes too\n * long to respond.\n * <p>Note that only idempotent statements will be speculatively retried.</p>\n * @constructor\n * @abstract\n */\nfunction SpeculativeExecutionPolicy() {\n  \n}\n\n/**\n * Initialization method that gets invoked on Client startup.\n * @param {Client} client\n * @abstract\n */\nSpeculativeExecutionPolicy.prototype.init = function (client) {\n\n};\n\n/**\n * Gets invoked at client shutdown, giving the opportunity to the implementor to perform cleanup.\n * @abstract\n */\nSpeculativeExecutionPolicy.prototype.shutdown = function () {\n\n};\n\n/**\n * Gets the plan to use for a new query.\n * Returns an object with a <code>nextExecution()</code> method, which returns a positive number representing the\n * amount of milliseconds to delay the next execution or a non-negative number to avoid further executions.\n * @param {String} keyspace The currently logged keyspace.\n * @param {String|Array<String>} queryInfo The query, or queries in the case of batches, for which to build a plan.\n * @return {{nextExecution: function}}\n * @abstract\n */\nSpeculativeExecutionPolicy.prototype.newPlan = function (keyspace, queryInfo) {\n  throw new Error('You must implement newPlan() method in the SpeculativeExecutionPolicy');\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nSpeculativeExecutionPolicy.prototype.getOptions = function () {\n  return new Map();\n};\n\n/**\n * Creates a new instance of NoSpeculativeExecutionPolicy.\n * @classdesc\n * A {@link SpeculativeExecutionPolicy} that never schedules speculative executions.\n * @constructor\n * @extends {SpeculativeExecutionPolicy}\n */\nfunction NoSpeculativeExecutionPolicy() {\n  this._plan = {\n    nextExecution: function () {\n      return -1;\n    }\n  };\n}\n\nutil.inherits(NoSpeculativeExecutionPolicy, SpeculativeExecutionPolicy);\n\nNoSpeculativeExecutionPolicy.prototype.newPlan = function () {\n  return this._plan;\n};\n\n\n/**\n * Creates a new instance of ConstantSpeculativeExecutionPolicy.\n * @classdesc\n * A {@link SpeculativeExecutionPolicy} that schedules a given number of speculative executions,\n * separated by a fixed delay.\n * @constructor\n * @param {Number} delay The delay between each speculative execution.\n * @param {Number} maxSpeculativeExecutions The amount of speculative executions that should be scheduled after the\n * initial execution. Must be strictly positive.\n * @extends {SpeculativeExecutionPolicy}\n */\nfunction ConstantSpeculativeExecutionPolicy(delay, maxSpeculativeExecutions) {\n  if (!(delay >= 0)) {\n    throw new errors.ArgumentError('delay must be a positive number or zero');\n  }\n  if (!(maxSpeculativeExecutions > 0)) {\n    throw new errors.ArgumentError('maxSpeculativeExecutions must be a positive number');\n  }\n  this._delay = delay;\n  this._maxSpeculativeExecutions = maxSpeculativeExecutions;\n}\n\nutil.inherits(ConstantSpeculativeExecutionPolicy, SpeculativeExecutionPolicy);\n\nConstantSpeculativeExecutionPolicy.prototype.newPlan = function () {\n  let executions = 0;\n  const self = this;\n  return {\n    nextExecution: function () {\n      if (executions++ < self._maxSpeculativeExecutions) {\n        return self._delay;\n      }\n      return -1;\n    }\n  };\n};\n\n/**\n * Gets an associative array containing the policy options.\n */\nConstantSpeculativeExecutionPolicy.prototype.getOptions = function () {\n  return new Map([\n    ['delay', this._delay ],\n    ['maxSpeculativeExecutions', this._maxSpeculativeExecutions ]\n  ]);\n};\n\nexports.NoSpeculativeExecutionPolicy = NoSpeculativeExecutionPolicy;\nexports.SpeculativeExecutionPolicy = SpeculativeExecutionPolicy;\nexports.ConstantSpeculativeExecutionPolicy = ConstantSpeculativeExecutionPolicy;","'use strict';\n\nconst util = require('util');\nconst Long = require('../types').Long;\nconst errors = require('../errors');\n\n/** @module policies/timestampGeneration */\n\n/**\n * Defines the maximum date in milliseconds that can be represented in microseconds using Number ((2 ^ 53) / 1000)\n * @const\n * @private\n */\nconst _maxSafeNumberDate = 9007199254740;\n\n/**\n * A long representing the value 1000\n * @const\n * @private\n */\nconst _longOneThousand = Long.fromInt(1000);\n\n/**\n * Creates a new instance of {@link TimestampGenerator}.\n * @classdesc\n * Generates client-side, microsecond-precision query timestamps.\n * <p>\n *   Given that Cassandra uses those timestamps to resolve conflicts, implementations should generate\n *   monotonically increasing timestamps for successive invocations of {@link TimestampGenerator.next()}.\n * </p>\n * @constructor\n */\nfunction TimestampGenerator() {\n\n}\n\n/**\n * Returns the next timestamp.\n * <p>\n *   Implementors should enforce increasing monotonicity of timestamps, that is,\n *   a timestamp returned should always be strictly greater that any previously returned\n *   timestamp.\n * <p/>\n * <p>\n *   Implementors should strive to achieve microsecond precision in the best possible way,\n *   which is usually largely dependent on the underlying operating system's capabilities.\n * </p>\n * @param {Client} client The {@link Client} instance to generate timestamps to.\n * @returns {Long|Number|null} the next timestamp (in microseconds). If it's equals to <code>null</code>, it won't be\n * sent by the driver, letting the server to generate the timestamp.\n * @abstract\n */\nTimestampGenerator.prototype.next = function (client) {\n  throw new Error('next() must be implemented');\n};\n\n/**\n * A timestamp generator that guarantees monotonically increasing timestamps and logs warnings when timestamps\n * drift in the future.\n * <p>\n *   {@link Date} has millisecond precision and client timestamps require microsecond precision. This generator\n *   keeps track of the last generated timestamp, and if the current time is within the same millisecond as the last,\n *   it fills the microsecond portion of the new timestamp with the value of an incrementing counter.\n * </p>\n * @param {Number} [warningThreshold] Determines how far in the future timestamps are allowed to drift before a\n * warning is logged, expressed in milliseconds. Default: <code>1000</code>.\n * @param {Number} [minLogInterval] In case of multiple log events, it determines the time separation between log\n * events, expressed in milliseconds. Use 0 to disable. Default: <code>1000</code>.\n * @extends {TimestampGenerator}\n * @constructor\n */\nfunction MonotonicTimestampGenerator(warningThreshold, minLogInterval) {\n  if (warningThreshold < 0) {\n    throw new errors.ArgumentError('warningThreshold can not be lower than 0');\n  }\n  this._warningThreshold = warningThreshold || 1000;\n  this._minLogInterval = 1000;\n  if (typeof minLogInterval === 'number') {\n    // A value under 1 will disable logging\n    this._minLogInterval = minLogInterval;\n  }\n  this._micros = -1;\n  this._lastDate = 0;\n  this._lastLogDate = 0;\n}\n\nutil.inherits(MonotonicTimestampGenerator, TimestampGenerator);\n\n/**\n * Returns the current time in milliseconds since UNIX epoch\n * @returns {Number}\n */\nMonotonicTimestampGenerator.prototype.getDate = function () {\n  return Date.now();\n};\n\nMonotonicTimestampGenerator.prototype.next = function (client) {\n  let date = this.getDate();\n  let drifted = 0;\n  if (date > this._lastDate) {\n    this._micros = 0;\n    this._lastDate = date;\n    return this._generateMicroseconds();\n  }\n\n  if (date < this._lastDate) {\n    drifted = this._lastDate - date;\n    date = this._lastDate;\n  }\n  if (++this._micros === 1000) {\n    this._micros = 0;\n    if (date === this._lastDate) {\n      // Move date 1 millisecond into the future\n      date++;\n      drifted++;\n    }\n  }\n  const lastDate = this._lastDate;\n  this._lastDate = date;\n  const result = this._generateMicroseconds();\n  if (drifted >= this._warningThreshold) {\n    // Avoid logging an unbounded amount of times within a clock-skew event or during an interval when more than 1\n    // query is being issued by microsecond\n    const currentLogDate = Date.now();\n    if (this._minLogInterval > 0 && this._lastLogDate + this._minLogInterval <= currentLogDate){\n      const message = util.format(\n        'Timestamp generated using current date was %d milliseconds behind the last generated timestamp (which ' +\n        'millisecond portion was %d), the returned value (%s) is being artificially incremented to guarantee ' +\n        'monotonicity.',\n        drifted, lastDate, result);\n      this._lastLogDate = currentLogDate;\n      client.log('warning', message);\n    }\n  }\n  return result;\n};\n\n/**\n * @private\n * @returns {Number|Long}\n */\nMonotonicTimestampGenerator.prototype._generateMicroseconds = function () {\n  if (this._lastDate < _maxSafeNumberDate) {\n    // We are safe until Jun 06 2255, its faster to perform this operations on Number than on Long\n    // We hope to have native int64 by then :)\n    return this._lastDate * 1000 + this._micros;\n  }\n  return Long\n    .fromNumber(this._lastDate)\n    .multiply(_longOneThousand)\n    .add(Long.fromInt(this._micros));\n};\n\nexports.TimestampGenerator = TimestampGenerator;\nexports.MonotonicTimestampGenerator = MonotonicTimestampGenerator;","'use strict';\n\nconst util = require('util');\nconst errors = require('./errors');\nconst utils = require('./utils');\nconst RequestHandler = require('./request-handler');\n\n/**\n * Encapsulates the logic for dealing with the different prepare request and response flows, including failover when\n * trying to prepare a query.\n */\nclass PrepareHandler {\n  /**\n   * Creates a new instance of PrepareHandler\n   * @param {Client} client\n   * @param {LoadBalancingPolicy} loadBalancing\n   */\n  constructor(client, loadBalancing) {\n    this._client = client;\n    this._loadBalancing = loadBalancing;\n    this.logEmitter = client.options.logEmitter;\n    this.log = utils.log;\n  }\n\n  /**\n   * @param {Client} client\n   * @param {LoadBalancingPolicy} loadBalancing\n   * @param {String} query\n   * @param {String} keyspace\n   * @param {Function} callback\n   * @static\n   */\n  static getPrepared(client, loadBalancing, query, keyspace, callback) {\n    const info = client.metadata.getPreparedInfo(keyspace, query);\n    if (info.queryId) {\n      return callback(null, info.queryId, info.meta);\n    }\n    info.once('prepared', callback);\n    if (info.preparing) {\n      // It's already being prepared\n      return;\n    }\n    const instance = new PrepareHandler(client, loadBalancing);\n    instance._prepare(info, query, keyspace);\n  }\n\n  /**\n   * @param {Client} client\n   * @param {LoadBalancingPolicy} loadBalancing\n   * @param {Array} queries\n   * @param {String} keyspace\n   * @param {Function} callback\n   * @static\n   */\n  static getPreparedMultiple(client, loadBalancing, queries, keyspace, callback) {\n    const result = new Array(queries.length);\n    utils.forEachOf(queries, function eachQuery(item, index, next) {\n      let query;\n      if (item) {\n        query = typeof item === 'string' ? item : item.query;\n      }\n      if (typeof query !== 'string') {\n        return next(new errors.ArgumentError('Query item should be a string'));\n      }\n\n      PrepareHandler.getPrepared(client, loadBalancing, query, keyspace, function getPrepareCb(err, id, meta) {\n        if (err) {\n          return next(err);\n        }\n        result[index] = {\n          query: query,\n          params: utils.adaptNamedParamsPrepared(item.params, meta.columns),\n          queryId: id,\n          meta: meta\n        };\n        next();\n      });\n    }, function eachEnded(err) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, result);\n    });\n  }\n\n  /**\n   * Prepares the query on a single host or on all hosts depending on the options.\n   * Uses the info 'prepared' event to emit the result.\n   * @param {Object} info\n   * @param {String} query\n   * @param {String} keyspace\n   */\n  _prepare(info, query, keyspace) {\n    info.preparing = true;\n    const self = this;\n    this._loadBalancing.newQueryPlan(keyspace, null, function (err, iterator) {\n      if (err) {\n        info.preparing = false;\n        return info.emit('prepared', err);\n      }\n      self._prepareWithQueryPlan(info, iterator, null, query, keyspace);\n    });\n  }\n\n  /**\n   * @param {Object} info\n   * @param {Iterator} iterator\n   * @param {Object|null} triedHosts\n   * @param {String} query\n   * @param {String} keyspace\n   * @private\n   */\n  _prepareWithQueryPlan(info, iterator, triedHosts, query, keyspace) {\n    triedHosts = triedHosts || {};\n    const self = this;\n    RequestHandler.borrowNextConnection(iterator, triedHosts, this._client.profileManager, keyspace,\n      function borrowCallback(err, connection, host) {\n        if (err) {\n          return self._onPrepareError(err, host, triedHosts, info, iterator, query, keyspace);\n        }\n        connection.prepareOnce(query, function prepareOnceCallback(err, response) {\n          if (err) {\n            return self._onPrepareError(err, host, triedHosts, info, iterator, query, keyspace);\n          }\n          if (self._client.options.prepareOnAllHosts) {\n            return self._prepareOnAllHosts(info, response, host, iterator, query, keyspace);\n          }\n          self._onPrepareSuccess(info, response);\n        });\n      });\n  }\n\n  _onPrepareSuccess(info, response) {\n    info.preparing = false;\n    info.queryId = response.id;\n    info.meta = response.meta;\n    this._client.metadata.setPreparedById(info);\n    info.emit('prepared', null, info.queryId, info.meta);\n  }\n\n  _onPrepareError(err, host, triedHosts, info, iterator, query, keyspace) {\n    if (err.isSocketError || err instanceof errors.OperationTimedOutError) {\n      const self = this;\n      triedHosts[host.address] = err;\n      return self._prepareWithQueryPlan(info, iterator, triedHosts, query, keyspace);\n    }\n    info.preparing = false;\n    err.query = query;\n    return info.emit('prepared', err);\n  }\n\n  /**\n   * Prepares all queries on a single host.\n   * @param {Host} host\n   * @param {Array} allPrepared\n   * @param {Function} callback\n   */\n  static prepareAllQueries(host, allPrepared, callback) {\n    const anyKeyspaceQueries = [];\n    const queriesByKeyspace = {};\n    allPrepared.forEach(function (info) {\n      let arr = anyKeyspaceQueries;\n      if (info.keyspace) {\n        arr = queriesByKeyspace[info.keyspace] = (queriesByKeyspace[info.keyspace] || []);\n      }\n      arr.push(info.query);\n    });\n    utils.eachSeries(Object.keys(queriesByKeyspace), function eachKeyspace(keyspace, next) {\n      PrepareHandler._borrowAndPrepare(host, keyspace, queriesByKeyspace[keyspace], next);\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      PrepareHandler._borrowAndPrepare(host, null, anyKeyspaceQueries, callback);\n    });\n  }\n\n  /**\n   * Borrows a connection from the host and prepares the queries provided.\n   * @param {Host} host\n   * @param {String} keyspace\n   * @param {Array} queries\n   * @param {Function} callback\n   * @private\n   */\n  static _borrowAndPrepare(host, keyspace, queries, callback) {\n    if (queries.length === 0) {\n      return callback();\n    }\n\n    host.borrowConnection(keyspace, null, function borrowCallback(err, connection) {\n      if (err) {\n        return callback(err);\n      }\n      utils.each(queries, function prepareEach(query, next) {\n        connection.prepareOnce(query, next);\n      }, callback);\n    });\n  }\n\n  /**\n   * Prepares the provided query on all hosts, except the host provided.\n   * @param {Object} info\n   * @param {Object} response\n   * @param {Host} hostToAvoid\n   * @param {Iterator} iterator\n   * @param {String} query\n   * @param {String} keyspace\n   * @private\n   */\n  _prepareOnAllHosts(info, response, hostToAvoid, iterator, query, keyspace) {\n    const self = this;\n    utils.each(utils.iteratorToArray(iterator), function (host, next) {\n      if (host.address === hostToAvoid.address) {\n        return next();\n      }\n\n      host.borrowConnection(keyspace, null, function borrowCallback(err, connection) {\n        if (err) {\n          // Don't mind about issues with the pool in this case\n          return next();\n        }\n        connection.prepareOnce(query, function (err) {\n          if (err) {\n            // There has been error\n            self.log('verbose', util.format('Unexpected error while preparing query (%s) on %s', query, host.address));\n          }\n          return next();\n        });\n      });\n    }, function eachEnded() {\n      self._onPrepareSuccess(info, response);\n    });\n  }\n}\n\nmodule.exports = PrepareHandler;","'use strict';\n\nconst util = require('util');\nconst utils = require('./utils');\nconst types = require('./types');\nconst errors = require('./errors');\n\n/**\n * Information on the formatting of the returned rows\n */\nconst resultFlag = {\n  globalTablesSpec:   0x0001,\n  hasMorePages:       0x0002,\n  noMetadata:         0x0004\n};\n\n/**\n * Buffer forward reader of CQL binary frames\n * @param {FrameHeader} header\n * @param {Buffer} body\n * @param {Number} [offset]\n */\nfunction FrameReader(header, body, offset) {\n  this.header = header;\n  this.opcode = header.opcode;\n  this.offset = offset || 0;\n  this.buf = body;\n}\n\nFrameReader.prototype.remainingLength = function () {\n  return this.buf.length - this.offset;\n};\n\nFrameReader.prototype.getBuffer = function () {\n  return this.buf;\n};\n\n/**\n * Slices the underlining buffer\n * @param {Number} begin\n * @param {Number} [end]\n * @returns {Buffer}\n */\nFrameReader.prototype.slice = function (begin, end) {\n  if (typeof end === 'undefined') {\n    end = this.buf.length;\n  }\n  return this.buf.slice(begin, end);\n};\n\n/**\n * Modifies the underlying buffer, it concatenates the given buffer with the original (internalBuffer = concat(bytes, internalBuffer)\n */\nFrameReader.prototype.unshift = function (bytes) {\n  if (this.offset > 0) {\n    throw new Error('Can not modify the underlying buffer if already read');\n  }\n  this.buf = Buffer.concat([bytes, this.buf], bytes.length + this.buf.length);\n};\n\n/**\n * Reads any number of bytes and moves the offset.\n * if length not provided or it's larger than the remaining bytes, reads to end.\n * @param length\n * @returns {Buffer}\n */\nFrameReader.prototype.read = function (length) {\n  let end = this.buf.length;\n  if (typeof length !== 'undefined' && this.offset + length < this.buf.length) {\n    end = this.offset + length;\n  }\n  const bytes = this.slice(this.offset, end);\n  this.offset = end;\n  return bytes;\n};\n\n/**\n * Moves the reader cursor to the end\n */\nFrameReader.prototype.toEnd = function () {\n  this.offset = this.buf.length;\n};\n\n/**\n * Reads a BE Int and moves the offset\n * @returns {Number}\n */\nFrameReader.prototype.readInt = function() {\n  const result = this.buf.readInt32BE(this.offset);\n  this.offset += 4;\n  return result;\n};\n\n/** @returns {Number} */\nFrameReader.prototype.readShort = function () {\n  const result = this.buf.readUInt16BE(this.offset);\n  this.offset += 2;\n  return result;\n};\n\nFrameReader.prototype.readByte = function () {\n  const result = this.buf.readUInt8(this.offset);\n  this.offset += 1;\n  return result;\n};\n\nFrameReader.prototype.readString = function () {\n  const length = this.readShort();\n  this.checkOffset(length);\n  const result = this.buf.toString('utf8', this.offset, this.offset+length);\n  this.offset += length;\n  return result;\n};\n\n/**\n * Checks that the new length to read is within the range of the buffer length. Throws a RangeError if not.\n * @param {Number} newLength\n */\nFrameReader.prototype.checkOffset = function (newLength) {\n  if (this.offset + newLength > this.buf.length) {\n    const err = new RangeError('Trying to access beyond buffer length');\n    err.expectedLength = newLength;\n    throw err;\n  }\n};\n\n/**\n * Reads a protocol string list\n * @returns {Array}\n */\nFrameReader.prototype.readStringList = function () {\n  const length = this.readShort();\n  const list = new Array(length);\n  for (let i = 0; i < length; i++) {\n    list[i] = this.readString();\n  }\n  return list;\n};\n\n/**\n * Reads the amount of bytes that the field has and returns them (slicing them).\n * @returns {Buffer}\n */\nFrameReader.prototype.readBytes = function () {\n  const length = this.readInt();\n  if (length < 0) {\n    return null;\n  }\n  this.checkOffset(length);\n  return this.read(length);\n};\n\nFrameReader.prototype.readShortBytes = function () {\n  const length = this.readShort();\n  if (length < 0) {\n    return null;\n  }\n  this.checkOffset(length);\n  return this.read(length);\n};\n\n/**\n * Reads an associative array of strings as keys and bytes as values\n * @returns {Object}\n */\nFrameReader.prototype.readBytesMap = function () {\n  //A [short] n, followed by n pair <k><v> where <k> is a\n  //[string] and <v> is a [bytes].\n  const length = this.readShort();\n  if (length < 0) {\n    return null;\n  }\n  const map = {};\n  for (let i = 0; i < length; i++) {\n    map[this.readString()] = this.readBytes();\n  }\n  return map;\n};\n\n/**\n * Reads a data type definition\n * @returns {{code: Number, info: Object|null}} An array of 2 elements\n */\nFrameReader.prototype.readType = function () {\n  let i;\n  const type = {\n    code: this.readShort(),\n    type: null\n  };\n  switch (type.code) {\n    case types.dataTypes.custom:\n      type.info = this.readString();\n      break;\n    case types.dataTypes.list:\n    case types.dataTypes.set:\n      type.info = this.readType();\n      break;\n    case types.dataTypes.map:\n      type.info = [this.readType(), this.readType()];\n      break;\n    case types.dataTypes.udt:\n      type.info = {\n        keyspace: this.readString(),\n        name: this.readString(),\n        fields: new Array(this.readShort())\n      };\n      for (i = 0; i < type.info.fields.length; i++) {\n        type.info.fields[i] = {\n          name: this.readString(),\n          type: this.readType()\n        };\n      }\n      break;\n    case types.dataTypes.tuple:\n      type.info = new Array(this.readShort());\n      for (i = 0; i < type.info.length; i++) {\n        type.info[i] = this.readType();\n      }\n      break;\n  }\n  return type;\n};\n\n/**\n * Reads an Ip address and port\n * @returns {{address: exports.InetAddress, port: Number}}\n */\nFrameReader.prototype.readInet = function () {\n  const length = this.readByte();\n  const address = this.read(length);\n  return {address: new types.InetAddress(address), port: this.readInt()};\n};\n\n/**\n * Reads the body bytes corresponding to the flags\n * @returns {{traceId: Uuid, warnings: Array, customPayload}}\n * @throws {RangeError}\n */\nFrameReader.prototype.readFlagsInfo = function () {\n  if (this.header.flags === 0) {\n    return utils.emptyObject;\n  }\n  const result = {};\n  if (this.header.flags & types.frameFlags.tracing) {\n    this.checkOffset(16);\n    result.traceId = new types.Uuid(utils.copyBuffer(this.read(16)));\n  }\n  if (this.header.flags & types.frameFlags.warning) {\n    result.warnings = this.readStringList();\n  }\n  if (this.header.flags & types.frameFlags.customPayload) {\n    result.customPayload = this.readBytesMap();\n  }\n  return result;\n};\n\n/**\n * Reads the metadata from a row or a prepared result response\n * @param {Number} kind\n * @returns {Object}\n * @throws {RangeError}\n */\nFrameReader.prototype.readMetadata = function (kind) {\n  let i;\n  //Determines if its a prepared metadata\n  const isPrepared = (kind === types.resultKind.prepared);\n  const meta = {};\n  //as used in Rows and Prepared responses\n  const flags = this.readInt();\n\n  const columnLength = this.readInt();\n  if (types.protocolVersion.supportsPreparedPartitionKey(this.header.version) && isPrepared) {\n    //read the pk columns\n    meta.partitionKeys = new Array(this.readInt());\n    for (i = 0; i < meta.partitionKeys.length; i++) {\n      meta.partitionKeys[i] = this.readShort();\n    }\n  }\n  if (flags & resultFlag.hasMorePages) {\n    meta.pageState = utils.copyBuffer(this.readBytes());\n  }\n  if (flags & resultFlag.globalTablesSpec) {\n    meta.global_tables_spec = true;\n    meta.keyspace = this.readString();\n    meta.table = this.readString();\n  }\n  meta.columns = new Array(columnLength);\n  meta.columnsByName = utils.emptyObject;\n  if (isPrepared) {\n    //for prepared metadata, we will need a index of the columns (param) by name\n    meta.columnsByName = {};\n  }\n  for (i = 0; i < columnLength; i++) {\n    const col = {};\n    if(!meta.global_tables_spec) {\n      col.ksname = this.readString();\n      col.tablename = this.readString();\n    }\n    col.name = this.readString();\n    col.type = this.readType();\n    meta.columns[i] = col;\n    if (isPrepared) {\n      meta.columnsByName[col.name] = i;\n    }\n  }\n\n  return meta;\n};\n\n// templates for derived error messages.\nconst _writeTimeoutQueryMessage = 'Server timeout during write query at consistency %s (%d peer(s) acknowledged the write over %d required)';\nconst _writeTimeoutBatchLogMessage = 'Server timeout during batchlog write at consistency %s (%d peer(s) acknowledged the write over %d required)';\nconst _writeFailureMessage = 'Server failure during write query at consistency %s (%d responses were required but only %d replicas responded, %d failed)';\nconst _unavailableMessage = 'Not enough replicas available for query at consistency %s (%d required but only %d alive)';\nconst _readTimeoutMessage = 'Server timeout during read query at consistency %s (%s)';\nconst _readFailureMessage = 'Server failure during read query at consistency %s (%d responses were required but only %d replicas responded, %d failed)';\n\n/**\n * Reads the error from the frame\n * @throws {RangeError}\n * @returns {ResponseError}\n */\nFrameReader.prototype.readError = function () {\n  const code = this.readInt();\n  const message = this.readString();\n  const err = new errors.ResponseError(code, message);\n  //read extra info\n  switch (code) {\n    case types.responseErrorCodes.unavailableException:\n      err.consistencies = this.readShort();\n      err.required = this.readInt();\n      err.alive = this.readInt();\n      err.message = util.format(_unavailableMessage, types.consistencyToString[err.consistencies], err.required, err.alive);\n      break;\n    case types.responseErrorCodes.readTimeout:\n    case types.responseErrorCodes.readFailure:\n      err.consistencies = this.readShort();\n      err.received = this.readInt();\n      err.blockFor = this.readInt();\n      if (code === types.responseErrorCodes.readFailure) {\n        err.failures = this.readInt();\n      }\n      err.isDataPresent = this.readByte();\n      if (code === types.responseErrorCodes.readTimeout) {\n        let details;\n        if (err.received < err.blockFor) {\n          details = util.format('%d replica(s) responded over %d required', err.received, err.blockFor);\n        } else if (!err.isDataPresent) {\n          details = 'the replica queried for the data didn\\'t respond';\n        } else {\n          details = 'timeout while waiting for repair of inconsistent replica';\n        }\n        err.message = util.format(_readTimeoutMessage, types.consistencyToString[err.consistencies], details);\n      } else {\n        err.message = util.format(_readFailureMessage, types.consistencyToString[err.consistencies],\n          err.blockFor, err.received, err.failures);\n      }\n      break;\n    case types.responseErrorCodes.writeTimeout:\n    case types.responseErrorCodes.writeFailure:\n      err.consistencies = this.readShort();\n      err.received = this.readInt();\n      err.blockFor = this.readInt();\n      if (code === types.responseErrorCodes.writeFailure) {\n        err.failures = this.readInt();\n      }\n      err.writeType = this.readString();\n\n      if (code === types.responseErrorCodes.writeTimeout) {\n        const template = err.writeType === 'BATCH_LOG' ? _writeTimeoutBatchLogMessage : _writeTimeoutQueryMessage;\n        err.message = util.format(template, types.consistencyToString[err.consistencies], err.received, err.blockFor);\n      } else {\n        err.message = util.format(_writeFailureMessage, types.consistencyToString[err.consistencies],\n          err.blockFor, err.received, err.failures);\n      }\n      break;\n    case types.responseErrorCodes.unprepared:\n      err.queryId = utils.copyBuffer(this.readShortBytes());\n      break;\n    case types.responseErrorCodes.functionFailure:\n      err.keyspace = this.readString();\n      err.functionName = this.readString();\n      err.argTypes = this.readStringList();\n      break;\n    case types.responseErrorCodes.alreadyExists: {\n      err.keyspace = this.readString();\n      const table = this.readString();\n      if(table.length > 0) {\n        err.table = table;\n      }\n      break;\n    }\n  }\n  return err;\n};\n\n/**\n * Reads an event from Cassandra and returns the detail\n * @returns {{eventType: String, inet: {address: Buffer, port: Number}}, *}\n */\nFrameReader.prototype.readEvent = function () {\n  const eventType = this.readString();\n  switch (eventType) {\n    case types.protocolEvents.topologyChange:\n      return {\n        added: this.readString() === 'NEW_NODE',\n        inet: this.readInet(),\n        eventType: eventType};\n    case types.protocolEvents.statusChange:\n      return {\n        up: this.readString() === 'UP',\n        inet: this.readInet(),\n        eventType: eventType};\n    case types.protocolEvents.schemaChange:\n      return this.parseSchemaChange();\n  }\n  //Forward compatibility\n  return { eventType: eventType};\n};\n\nFrameReader.prototype.parseSchemaChange = function () {\n  let result;\n  if (!types.protocolVersion.supportsSchemaChangeFullMetadata(this.header.version)) {\n    //v1/v2: 3 strings, the table value can be empty\n    result = {\n      eventType: types.protocolEvents.schemaChange,\n      schemaChangeType: this.readString(),\n      keyspace: this.readString(),\n      table: this.readString()\n    };\n    result.isKeyspace = !result.table;\n    return result;\n  }\n  //v3+: 3 or 4 strings: change_type, target, keyspace and (table, type, functionName or aggregate)\n  result = {\n    eventType: types.protocolEvents.schemaChange,\n    schemaChangeType: this.readString(),\n    target: this.readString(),\n    keyspace: this.readString(),\n    table: null,\n    udt: null,\n    signature: null\n  };\n  result.isKeyspace = result.target === 'KEYSPACE';\n  switch (result.target) {\n    case 'TABLE':\n      result.table = this.readString();\n      break;\n    case 'TYPE':\n      result.udt = this.readString();\n      break;\n    case 'FUNCTION':\n      result.functionName = this.readString();\n      result.signature = this.readStringList();\n      break;\n    case 'AGGREGATE':\n      result.aggregate = this.readString();\n      result.signature = this.readStringList();\n  }\n  return result;\n};\n\nexports.FrameReader = FrameReader;\n","'use strict';\n\nconst errors = require('./errors');\nconst requests = require('./requests');\nconst retry = require('./policies/retry');\nconst types = require('./types');\nconst utils = require('./utils');\n\nconst retryOnCurrentHost = Object.freeze({\n  decision: retry.RetryPolicy.retryDecision.retry,\n  useCurrentHost: true,\n  consistency: undefined\n});\n\nconst rethrowDecision = Object.freeze({ decision: retry.RetryPolicy.retryDecision.rethrow });\n\n/**\n * An internal representation of an error that occurred during the execution of a request.\n */\nconst errorCodes = {\n  none: 0,\n  // Socket error\n  socketError: 1,\n  // Socket error before the request was written to the wire\n  socketErrorBeforeRequestWritten: 2,\n  // OperationTimedOutError\n  clientTimeout: 3,\n  // Response error \"unprepared\"\n  serverErrorUnprepared: 4,\n  // Response error \"overloaded\", \"is_bootstrapping\" and \"truncateError\":\n  serverErrorOverloaded: 5,\n  serverErrorReadTimeout: 6,\n  serverErrorUnavailable: 7,\n  serverErrorWriteTimeout: 8,\n  // Any other server error (different from the ones detailed above)\n  serverErrorOther: 9\n};\n\nconst metricsHandlers = new Map([\n  [ errorCodes.none, (metrics, err, latency) => metrics.onSuccessfulResponse(latency) ],\n  [ errorCodes.socketError, (metrics, err) => metrics.onConnectionError(err) ],\n  [ errorCodes.clientTimeout, (metrics, err) => metrics.onClientTimeoutError(err) ],\n  [ errorCodes.serverErrorOverloaded, (metrics, err) => metrics.onOtherError(err) ],\n  [ errorCodes.serverErrorReadTimeout, (metrics, err) => metrics.onReadTimeoutError(err) ],\n  [ errorCodes.serverErrorUnavailable, (metrics, err) => metrics.onUnavailableError(err) ],\n  [ errorCodes.serverErrorWriteTimeout, (metrics, err) => metrics.onWriteTimeoutError(err) ],\n  [ errorCodes.serverErrorOther, (metrics, err) => metrics.onOtherError(err) ]\n]);\n\nconst metricsRetryHandlers = new Map([\n  [ errorCodes.socketError, (metrics, err) => metrics.onOtherErrorRetry(err) ],\n  [ errorCodes.clientTimeout, (metrics, err) => metrics.onClientTimeoutRetry(err) ],\n  [ errorCodes.serverErrorOverloaded, (metrics, err) => metrics.onOtherErrorRetry(err) ],\n  [ errorCodes.serverErrorReadTimeout, (metrics, err) => metrics.onReadTimeoutRetry(err) ],\n  [ errorCodes.serverErrorUnavailable, (metrics, err) => metrics.onUnavailableRetry(err) ],\n  [ errorCodes.serverErrorWriteTimeout, (metrics, err) => metrics.onWriteTimeoutRetry(err) ],\n  [ errorCodes.serverErrorOther, (metrics, err) => metrics.onOtherErrorRetry(err) ]\n]);\n\nclass RequestExecution {\n  /**\n   * Encapsulates a single flow of execution against a coordinator, handling individual retries and failover.\n   * @param {RequestHandler} parent\n   */\n  constructor(parent) {\n    this._parent = parent;\n    /** @type {OperationState} */\n    this._operation = null;\n    this._host = null;\n    this._cancelled = false;\n    this._startTime = null;\n    this._retryCount = 0;\n    // The streamId information is not included in the request.\n    // A pointer to the parent request can be used, except when changing the consistency level from the retry policy\n    this._request = this._parent.request;\n  }\n\n  /**\n   * Starts the execution by borrowing the next connection available using the query plan.\n   * It invokes the callback when a connection is acquired, if any.\n   * @param {Function} [getHostCallback] Callback to be invoked when a connection to a host was successfully acquired.\n   */\n  start(getHostCallback) {\n    const self = this;\n    getHostCallback = getHostCallback || utils.noop;\n    this._parent.getNextConnection(function nextConnectionCallback(err, connection, host) {\n      if (self._cancelled) {\n        // No need to send the request or invoke any callback\n        return;\n      }\n      if (err) {\n        return self._parent.handleNoHostAvailable(err, self);\n      }\n      self._connection = connection;\n      self._host = host;\n      getHostCallback(host);\n      if (self._retryCount === 0) {\n        self._parent.speculativeExecutions++;\n      }\n      self._sendOnConnection();\n    });\n  }\n\n  _sendOnConnection() {\n    this._startTime = process.hrtime();\n\n    this._operation =\n      this._connection.sendStream(this._request, this._parent.executionOptions, (err, response, length) => {\n        const errorCode = RequestExecution._getErrorCode(err);\n\n        this._trackResponse(process.hrtime(this._startTime), errorCode, err, length);\n\n        if (this._cancelled) {\n          // Avoid handling the response / err\n          return;\n        }\n\n        if (errorCode !== errorCodes.none) {\n          return this._handleError(errorCode, err);\n        }\n\n        if (response.schemaChange) {\n          return this._parent.client.handleSchemaAgreementAndRefresh(\n            this._connection, response.schemaChange, (agreement) => {\n              if (this._cancelled) {\n                // After the schema agreement method was started, this execution was cancelled\n                return;\n              }\n\n              this._parent.setCompleted(null, this._getResultSet(response, agreement));\n            });\n        }\n\n        if (response.keyspaceSet) {\n          this._parent.client.keyspace = response.keyspaceSet;\n        }\n\n        this._parent.setCompleted(null, this._getResultSet(response));\n      });\n  }\n\n  _trackResponse(latency, errorCode, err, length) {\n    // Record metrics\n    RequestExecution._invokeMetricsHandler(errorCode, this._parent.client.metrics, err, latency);\n\n    // Request tracker\n    const tracker = this._parent.client.options.requestTracker;\n\n    if (tracker === null) {\n      return;\n    }\n\n    // Avoid using instanceof as property check is faster\n    const query = this._request.query || this._request.queries;\n    const parameters = this._request.params;\n    const requestLength = this._request.length;\n\n    if (err) {\n      tracker.onError(this._host, query, parameters, this._parent.executionOptions, requestLength, err, latency);\n    } else {\n      tracker.onSuccess(this._host, query, parameters, this._parent.executionOptions, requestLength, length, latency);\n    }\n  }\n\n  _getResultSet(response, agreement) {\n    return new types.ResultSet(response, this._host.address, this._parent.triedHosts, this._parent.speculativeExecutions,\n      this._request.consistency, agreement === undefined || agreement);\n  }\n\n  /**\n   * Gets the method of the {ClientMetrics} instance depending on the error code and invokes it.\n   * @param {Number} errorCode\n   * @param {ClientMetrics} metrics\n   * @param {Error} err\n   * @param {Array} latency\n   * @private\n   */\n  static _invokeMetricsHandler(errorCode, metrics, err, latency) {\n    const handler = metricsHandlers.get(errorCode);\n    if (handler !== undefined) {\n      handler(metrics, err, latency);\n    }\n\n    if (!err || err instanceof errors.ResponseError) {\n      metrics.onResponse(latency);\n    }\n  }\n\n  /**\n   * Gets the method of the {ClientMetrics} instance related to retry depending on the error code and invokes it.\n   * @param {Number} errorCode\n   * @param {ClientMetrics} metrics\n   * @param {Error} err\n   * @private\n   */\n  static _invokeMetricsHandlerForRetry(errorCode, metrics, err) {\n    const handler = metricsRetryHandlers.get(errorCode);\n\n    if (handler !== undefined) {\n      handler(metrics, err);\n    }\n  }\n\n  /**\n   * Allows the handler to cancel the current request.\n   * When the request has been already written, we can unset the callback and forget about it.\n   */\n  cancel() {\n    this._cancelled = true;\n    if (this._operation === null) {\n      return;\n    }\n    this._operation.cancel();\n  }\n\n  /**\n   * Determines if the current execution was cancelled.\n   */\n  wasCancelled() {\n    return this._cancelled;\n  }\n\n  _handleError(errorCode, err) {\n    this._parent.triedHosts[this._host.address] = err;\n    err['coordinator'] = this._host.address;\n\n    if (errorCode === errorCodes.serverErrorUnprepared) {\n      return this._prepareAndRetry(err.queryId);\n    }\n\n    if (errorCode === errorCodes.socketError || errorCode === errorCodes.socketErrorBeforeRequestWritten) {\n      this._host.removeFromPool(this._connection);\n    } else if (errorCode === errorCodes.clientTimeout) {\n      this._parent.log('warning', err.message);\n      this._host.checkHealth(this._connection);\n    }\n\n    const decisionInfo = this._getDecision(errorCode, err);\n\n    if (!decisionInfo || decisionInfo.decision === retry.RetryPolicy.retryDecision.rethrow) {\n      if (this._request instanceof requests.QueryRequest || this._request instanceof requests.ExecuteRequest) {\n        err['query'] = this._request.query;\n      }\n      return this._parent.setCompleted(err);\n    }\n\n    const metrics = this._parent.client.metrics;\n\n    if (decisionInfo.decision === retry.RetryPolicy.retryDecision.ignore) {\n      metrics.onIgnoreError(err);\n\n      // Return an empty ResultSet\n      return this._parent.setCompleted(null, this._getResultSet(utils.emptyObject));\n    }\n\n    RequestExecution._invokeMetricsHandlerForRetry(errorCode, metrics, err);\n\n    return this._retry(decisionInfo.consistency, decisionInfo.useCurrentHost);\n  }\n\n  /**\n   * Gets a decision whether or not to retry based on the error information.\n   * @param {Number} errorCode\n   * @param {Error} err\n   * @returns {{decision, useCurrentHost, consistency}}\n   */\n  _getDecision(errorCode, err) {\n    const operationInfo = {\n      query: this._request && this._request.query,\n      executionOptions: this._parent.executionOptions,\n      nbRetry: this._retryCount\n    };\n\n    const retryPolicy = operationInfo.executionOptions.getRetryPolicy();\n\n    switch (errorCode) {\n      case errorCodes.socketErrorBeforeRequestWritten:\n        // The request was definitely not applied, it's safe to retry.\n        // Retry on the current host as there might be other connections open, in case it fails to obtain a connection\n        // on the current host, the driver will immediately retry on the next host.\n        return retryOnCurrentHost;\n      case errorCodes.socketError:\n      case errorCodes.clientTimeout:\n      case errorCodes.serverErrorOverloaded:\n        if (operationInfo.executionOptions.isIdempotent()) {\n          return retryPolicy.onRequestError(operationInfo, this._request.consistency, err);\n        }\n        return rethrowDecision;\n      case errorCodes.serverErrorUnavailable:\n        return retryPolicy.onUnavailable(operationInfo, err.consistencies, err.required, err.alive);\n      case errorCodes.serverErrorReadTimeout:\n        return retryPolicy.onReadTimeout(\n          operationInfo, err.consistencies, err.received, err.blockFor, err.isDataPresent);\n      case errorCodes.serverErrorWriteTimeout:\n        if (operationInfo.executionOptions.isIdempotent()) {\n          return retryPolicy.onWriteTimeout(\n            operationInfo, err.consistencies, err.received, err.blockFor, err.writeType);\n        }\n        return rethrowDecision;\n      default:\n        return rethrowDecision;\n    }\n  }\n\n  static _getErrorCode(err) {\n    if (!err) {\n      return errorCodes.none;\n    }\n\n    if (err.isSocketError) {\n      if (err.requestNotWritten) {\n        return errorCodes.socketErrorBeforeRequestWritten;\n      }\n      return errorCodes.socketError;\n    }\n\n    if (err instanceof errors.OperationTimedOutError) {\n      return errorCodes.clientTimeout;\n    }\n\n    if (err instanceof errors.ResponseError) {\n      switch (err.code) {\n        case types.responseErrorCodes.overloaded:\n        case types.responseErrorCodes.isBootstrapping:\n        case types.responseErrorCodes.truncateError:\n          return errorCodes.serverErrorOverloaded;\n        case types.responseErrorCodes.unavailableException:\n          return errorCodes.serverErrorUnavailable;\n        case types.responseErrorCodes.readTimeout:\n          return errorCodes.serverErrorReadTimeout;\n        case types.responseErrorCodes.writeTimeout:\n          return errorCodes.serverErrorWriteTimeout;\n        case types.responseErrorCodes.unprepared:\n          return errorCodes.serverErrorUnprepared;\n      }\n    }\n\n    return errorCodes.serverErrorOther;\n  }\n\n  /**\n   * @param {Number|undefined} consistency\n   * @param {Boolean} useCurrentHost\n   * @private\n   */\n  _retry(consistency, useCurrentHost) {\n    if (this._cancelled) {\n      // No point in retrying\n      return;\n    }\n\n    this._parent.log('info', 'Retrying request');\n    this._retryCount++;\n\n    if (typeof consistency === 'number' && this._request.consistency !== consistency) {\n      this._request = this._request.clone();\n      this._request.consistency = consistency;\n    }\n\n    if (useCurrentHost !== false) {\n      // Use existing host (default).\n      const keyspace = this._parent.client.keyspace;\n      // Reusing the existing connection is suitable for the most common scenarios, like server read timeouts that\n      // will be fixed with a new request.\n      // To cover all scenarios (e.g., where a different connection to the same host might mean something different),\n      // we obtain a new connection from the host pool.\n      // When there was a socket error, the connection provided was already removed from the pool earlier.\n      return this._host.borrowConnection(keyspace, this._connection, (err, connection) => {\n        if (err) {\n          // All connections are busy (`BusyConnectionError`) or there isn't a ready connection in the pool (`Error`)\n          // The retry policy declared the intention to retry on the current host but its not available anymore.\n          // Use the next host\n          return this.start();\n        }\n\n        this._connection = connection;\n        this._sendOnConnection();\n      });\n    }\n\n    // Use the next host in the query plan to send the request\n    this.start();\n  }\n\n  /**\n   * Issues a PREPARE request on the current connection.\n   * If there's a socket or timeout issue, it moves to next host and executes the original request.\n   * @param {Buffer} queryId\n   * @private\n   */\n  _prepareAndRetry(queryId) {\n    const connection = this._connection;\n\n    this._parent.log('info',\n      `Query 0x${queryId.toString('hex')} not prepared on` +\n      ` host ${connection.endpointFriendlyName}, preparing and retrying`);\n\n    const info = this._parent.client.metadata.getPreparedById(queryId);\n\n    if (!info) {\n      return this._parent.setCompleted(new errors.DriverInternalError(\n        `Unprepared response invalid, id: 0x${queryId.toString('hex')}`));\n    }\n\n    if (info.keyspace && info.keyspace !== connection.keyspace) {\n      return this._parent.setCompleted(new Error(\n        `Query was prepared on keyspace ${info.keyspace}, can't execute it on ${connection.keyspace} (${info.query})`));\n    }\n\n    const self = this;\n    this._connection.prepareOnce(info.query, function (err) {\n      if (err) {\n        if (!err.isSocketError && err instanceof errors.OperationTimedOutError) {\n          self._parent.log('warning',\n            `Unexpected timeout error when re-preparing query on host ${connection.endpointFriendlyName}`);\n        }\n\n        // There was a failure re-preparing on this connection.\n        // Execute the original request on the next connection and forget about the PREPARE-UNPREPARE flow.\n        return self._retry(undefined, false);\n      }\n      self._retry(undefined, true);\n    });\n  }\n}\n\nmodule.exports = RequestExecution;","'use strict';\nconst util = require('util');\n\nconst errors = require('./errors');\nconst types = require('./types');\nconst utils = require('./utils');\nconst RequestExecution = require('./request-execution');\n\n/**\n * Handles a BATCH, QUERY and EXECUTE request to the server, dealing with host fail-over and retries on error\n */\nclass RequestHandler {\n  /**\n   * Creates a new instance of RequestHandler.\n   * @param {Request} request\n   * @param {ExecutionOptions} execOptions\n   * @param {Client} client Client instance used to retrieve and set the keyspace.\n   */\n  constructor(request, execOptions, client) {\n    this.client = client;\n    this._speculativeExecutionPlan = client.options.policies.speculativeExecution.newPlan(\n      client.keyspace, request.query || request.queries);\n    this.logEmitter = client.options.logEmitter;\n    this.log = utils.log;\n    this.request = request;\n    this.executionOptions = execOptions;\n    this.stackContainer = null;\n    this.triedHosts = {};\n    // start at -1 as first request does not count.\n    this.speculativeExecutions = -1;\n    this._hostIterator = null;\n    this._callback = null;\n    this._newExecutionTimeout = null;\n    this._executions = [];\n  }\n\n  /**\n   * Borrows a connection iterating from the query plan one or more times, until finding an open connection with the\n   * keyspace set.\n   * It invokes the callback with the err, connection and host as parameters.\n   * The error can only be a NoHostAvailableError instance.\n   * @param {Iterator} iterator\n   * @param {Object} triedHosts\n   * @param {ProfileManager} profileManager\n   * @param {String} keyspace\n   * @param {Function} callback\n   */\n  static borrowNextConnection(iterator, triedHosts, profileManager, keyspace, callback) {\n    triedHosts = triedHosts || {};\n    const host = RequestHandler._getNextHost(iterator, profileManager, triedHosts);\n    if (host === null) {\n      return callback(new errors.NoHostAvailableError(triedHosts));\n    }\n\n    host.borrowConnection(keyspace, null, function borrowFromHostCallback(err, connection) {\n      if (err) {\n        triedHosts[host.address] = err;\n        if (connection) {\n          host.removeFromPool(connection);\n        }\n        // Issue on next tick to avoid large numbers of sync recursive calls\n        return process.nextTick(() =>\n          RequestHandler.borrowNextConnection(iterator, triedHosts, profileManager, keyspace, callback));\n      }\n      triedHosts[host.address] = null;\n      callback(null, connection, host);\n    });\n  }\n\n  /**\n   * Gets the next host from the query plan.\n   * @param {Iterator} iterator\n   * @param {ProfileManager} profileManager\n   * @param {Object} triedHosts\n   * @return {Host|null}\n   * @private\n   */\n  static _getNextHost(iterator, profileManager, triedHosts) {\n    let host;\n    // Get a host that is UP in a sync loop\n    while (true) {\n      const item = iterator.next();\n      if (item.done) {\n        return null;\n      }\n      host = item.value;\n      // set the distance relative to the client first\n      const distance = profileManager.getDistance(host);\n      if (distance === types.distance.ignored) {\n        //If its marked as ignore by the load balancing policy, move on.\n        continue;\n      }\n      if (host.isUp()) {\n        break;\n      }\n      triedHosts[host.address] = 'Host considered as DOWN';\n    }\n    return host;\n  }\n\n  /**\n   * Sends a new BATCH, QUERY or EXECUTE request.\n   * @param {Request} request\n   * @param {ExecutionOptions} execOptions\n   * @param {Client} client Client instance used to retrieve and set the keyspace.\n   * @param {Function} callback\n   */\n  static send(request, execOptions, client, callback) {\n    const instance = new RequestHandler(request, execOptions, client);\n    instance.send(callback);\n  }\n\n  /**\n   * Gets a connection from the next host according to the query plan or a NoHostAvailableError.\n   * @param {Function} callback\n   */\n  getNextConnection(callback) {\n    RequestHandler.borrowNextConnection(\n      this._hostIterator, this.triedHosts, this.client.profileManager, this.client.keyspace, callback);\n  }\n\n  /**\n   * Gets an available connection and sends the request\n   * @param {Function} callback\n   */\n  send(callback) {\n    if (this.executionOptions.getCaptureStackTrace()) {\n      Error.captureStackTrace(this.stackContainer = {});\n    }\n\n    const lbp = this.executionOptions.getLoadBalancingPolicy();\n    const fixedHost = this.executionOptions.getFixedHost();\n    const self = this;\n    this._callback = callback;\n\n    if (fixedHost) {\n      // if host is configured bypass load balancing policy and use\n      // a single host plan.\n      self._hostIterator = utils.arrayIterator([fixedHost]);\n      self._startNewExecution();\n    } else {\n      lbp.newQueryPlan(this.client.keyspace, this.executionOptions, function newPlanCb(err, iterator) {\n        if (err) {\n          return self._callback(err);\n        }\n        self._hostIterator = iterator;\n        self._startNewExecution();\n      });\n    }\n  }\n\n  _startNewExecution(isSpecExec) {\n    if (isSpecExec) {\n      this.client.metrics.onSpeculativeExecution();\n    }\n\n    const execution = new RequestExecution(this);\n    this._executions.push(execution);\n    const self = this;\n    execution.start(function hostAcquired(host) {\n      // This function is called when a connection to a host was successfully acquired and\n      // the execution was not yet cancelled\n      if (!self.executionOptions.isIdempotent()) {\n        return;\n      }\n      const delay = self._speculativeExecutionPlan.nextExecution(host);\n      if (typeof delay !== 'number' || delay < 0) {\n        return;\n      }\n      if (delay === 0) {\n        // Multiple parallel executions\n        return process.nextTick(function startNextInParallel() {\n          // Unlike timers process.nextTick() handlers can't be cleared so we must be sure that the\n          // the previous execution wasn't cancelled before issuing the next one.\n          if (execution.wasCancelled()) {\n            return;\n          }\n\n          self._startNewExecution(true);\n        });\n      }\n\n      self._newExecutionTimeout = setTimeout(() => self._startNewExecution(true), delay);\n    });\n  }\n\n  /**\n   * Sets the keyspace in any connection that is already opened.\n   * @param {Client} client\n   * @param {Function} callback\n   */\n  static setKeyspace(client, callback) {\n    let connection;\n    const hosts = client.hosts.values();\n    for (let i = 0; i < hosts.length; i++) {\n      const host = hosts[i];\n      connection = host.getActiveConnection();\n      if (connection) {\n        break;\n      }\n    }\n    if (!connection) {\n      return callback(new errors.DriverInternalError('No active connection found'));\n    }\n    connection.changeKeyspace(client.keyspace, callback);\n  }\n\n  /**\n   * @param {Error} err\n   * @param {ResultSet} [result]\n   */\n  setCompleted(err, result) {\n    if (this._newExecutionTimeout !== null) {\n      clearTimeout(this._newExecutionTimeout);\n    }\n\n    // Mark all executions as cancelled\n    for (let i = 0; i < this._executions.length; i++) {\n      this._executions[i].cancel();\n    }\n\n    if (err) {\n      if (this.executionOptions.getCaptureStackTrace()) {\n        utils.fixStack(this.stackContainer.stack, err);\n      }\n\n      // The error already has the stack information, there is no value in maintaining the call stack\n      // for the callback invocation\n      return process.nextTick(() => this._callback(err));\n    }\n\n    if (result.info.warnings) {\n      // Log the warnings from the response\n      result.info.warnings.forEach(function (message, i, warnings) {\n        this.log('warning', util.format(\n          'Received warning (%d of %d) \"%s\" for \"%s\"',\n          i + 1,\n          warnings.length,\n          message,\n          this.request.query || 'batch'));\n      }, this);\n    }\n\n    // Invoke the callback in the next tick allowing stack unwinding, that way we can continue\n    // processing the read queue before executing user code.\n    // Additionally, we prevent the optimizing compiler to optimize read and write functions together.\n    // FFR: We found corner cases where maintaining the call stack when invoking the user callback impacted the overall\n    // performance of the driver. These corner cases appeared when adding more logic to the completion of the\n    // request/response operation, that by itself had a negligible processing cost, but had a significant\n    // performance penalty when integrated.\n    process.nextTick(() => this._callback(null, result));\n  }\n\n  /**\n   * @param {NoHostAvailableError} err\n   * @param {RequestExecution} sender\n   */\n  handleNoHostAvailable(err, sender) {\n    // Remove the execution\n    const index = this._executions.indexOf(sender);\n    this._executions.splice(index, 1);\n    if (this._executions.length === 0) {\n      // There aren't any other executions, we should report back to the user that there isn't\n      // a host available for executing the request\n      this.setCompleted(err);\n    }\n  }\n}\n\nmodule.exports = RequestHandler;\n","'use strict';\nconst util = require('util');\n\nconst FrameWriter = require('./writers').FrameWriter;\nconst types = require('./types');\nconst utils = require('./utils');\nconst ExecutionOptions = require('./execution-options').ExecutionOptions;\nconst packageInfo = require('../package.json');\n\n/**\n * Options for the execution of the query / prepared statement\n * @private\n */\nconst queryFlag = {\n  values:                 0x01,\n  skipMetadata:           0x02,\n  pageSize:               0x04,\n  withPagingState:        0x08,\n  withSerialConsistency:  0x10,\n  withDefaultTimestamp:   0x20,\n  withNameForValues:      0x40\n};\n\n/**\n * Options for the executing of a batch request from protocol v3 and above\n * @private\n */\nconst batchFlag = {\n  withSerialConsistency:  0x10,\n  withDefaultTimestamp:   0x20,\n  withNameForValues:      0x40\n};\n\nconst batchType = {\n  logged: 0,\n  unlogged: 1,\n  counter: 2\n};\n\n/**\n * Abstract class Request\n */\nclass Request {\n  constructor() {\n    this.length = 0;\n  }\n\n  /**\n   * @abstract\n   * @param {Encoder} encoder\n   * @param {Number} streamId\n   * @throws {TypeError}\n   * @returns {Buffer}\n   */\n  write(encoder, streamId) {\n    throw new Error('Method must be implemented');\n  }\n\n  /**\n   * Creates a new instance using the same constructor as the current instance, copying the properties.\n   * @return {Request}\n   */\n  clone() {\n    const newRequest = new (this.constructor)();\n    const keysArray = Object.keys(this);\n    for (let i = 0; i < keysArray.length; i++) {\n      const key = keysArray[i];\n      newRequest[key] = this[key];\n    }\n    return newRequest;\n  }\n}\n\n/**\n * Writes a execute query (given a prepared queryId)\n * @param {String} query\n * @param {Buffer} queryId\n * @param {Array} params\n * @param options\n */\nclass ExecuteRequest extends Request {\n  /**\n   * @param {String} query\n   * @param queryId\n   * @param params\n   * @param {ExecutionOptions} execOptions\n   * @param meta\n   */\n  constructor(query, queryId, params, execOptions, meta) {\n    super();\n\n    this.query = query;\n    this.queryId = queryId;\n    this.params = params;\n    this.meta = meta;\n    this.options = execOptions || ExecutionOptions.empty();\n    this.consistency = this.options.getConsistency() || types.consistencies.one;\n    // Only QUERY request parameters are encoded as named parameters\n    // EXECUTE request parameters are always encoded as positional parameters\n    this.namedParameters = false;\n  }\n\n  getParamType(index) {\n    const columnInfo = this.meta.columns[index];\n    return columnInfo ? columnInfo.type : null;\n  }\n\n  write(encoder, streamId) {\n    //v1: <queryId>\n    //      <n><value_1>....<value_n><consistency>\n    //v2: <queryId>\n    //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]\n    //v3: <queryId>\n    //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]\n    const frameWriter = new FrameWriter(types.opcodes.execute);\n    let headerFlags = this.options.isQueryTracing() ? types.frameFlags.tracing : 0;\n    if (this.options.getCustomPayload()) {\n      //The body may contain the custom payload\n      headerFlags |= types.frameFlags.customPayload;\n      frameWriter.writeCustomPayload(this.options.getCustomPayload());\n    }\n    frameWriter.writeShortBytes(this.queryId);\n    this.writeQueryParameters(frameWriter, encoder);\n\n    // Record the length of the body of the request before writing it\n    this.length = frameWriter.bodyLength;\n\n    return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);\n  }\n\n  /**\n   * Writes v1 and v2 execute query parameters\n   * @param {FrameWriter} frameWriter\n   * @param {Encoder} encoder\n   */\n  writeQueryParameters(frameWriter, encoder) {\n    //v1: <n><value_1>....<value_n><consistency>\n    //v2: <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]\n    //v3: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]\n    let flags = 0;\n\n    const timestamp = this.options.getOrGenerateTimestamp();\n\n    if (types.protocolVersion.supportsPaging(encoder.protocolVersion)) {\n      flags |= (this.params && this.params.length) ? queryFlag.values : 0;\n      flags |= (this.options.getFetchSize() > 0) ? queryFlag.pageSize : 0;\n      flags |= this.options.getPageState() ? queryFlag.withPagingState : 0;\n      flags |= this.options.getSerialConsistency() ? queryFlag.withSerialConsistency : 0;\n      flags |= timestamp !== null && timestamp !== undefined ? queryFlag.withDefaultTimestamp : 0;\n      flags |= this.namedParameters ? queryFlag.withNameForValues : 0;\n      frameWriter.writeShort(this.consistency);\n      frameWriter.writeByte(flags);\n    }\n\n    if (this.params && this.params.length) {\n      frameWriter.writeShort(this.params.length);\n      for (let i = 0; i < this.params.length; i++) {\n        let paramValue = this.params[i];\n        if (flags & queryFlag.withNameForValues) {\n          //parameter is composed by name / value\n          frameWriter.writeString(paramValue.name);\n          paramValue = paramValue.value;\n        }\n        frameWriter.writeBytes(encoder.encode(paramValue, this.getParamType(i)));\n      }\n    }\n\n    if (!types.protocolVersion.supportsPaging(encoder.protocolVersion)) {\n      if (!this.params || !this.params.length) {\n        //zero parameters\n        frameWriter.writeShort(0);\n      }\n      frameWriter.writeShort(this.consistency);\n      return;\n    }\n    if (flags & queryFlag.pageSize) {\n      frameWriter.writeInt(this.options.getFetchSize());\n    }\n    if (flags & queryFlag.withPagingState) {\n      frameWriter.writeBytes(this.options.getPageState());\n    }\n    if (flags & queryFlag.withSerialConsistency) {\n      frameWriter.writeShort(this.options.getSerialConsistency());\n    }\n    if (flags & queryFlag.withDefaultTimestamp) {\n      frameWriter.writeLong(timestamp);\n    }\n  }\n}\n\nclass QueryRequest extends ExecuteRequest {\n  /**\n   * @param {String} query\n   * @param params\n   * @param {ExecutionOptions} execOptions\n   * @param {Boolean} [namedParameters]\n   */\n  constructor(query, params, execOptions, namedParameters) {\n    super(query, null, params, execOptions, null);\n    this.hints = this.options.getHints() || utils.emptyArray;\n    this.namedParameters = namedParameters;\n  }\n\n  getParamType(index) {\n    return this.hints[index];\n  }\n\n  write(encoder, streamId) {\n    //v1: <query><consistency>\n    //v2: <query>\n    //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]\n    //v3: <query>\n    //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]\n    const frameWriter = new FrameWriter(types.opcodes.query);\n    let headerFlags = this.options.isQueryTracing() ? types.frameFlags.tracing : 0;\n    if (this.options.getCustomPayload()) {\n      //The body may contain the custom payload\n      headerFlags |= types.frameFlags.customPayload;\n      frameWriter.writeCustomPayload(this.options.getCustomPayload());\n    }\n\n    frameWriter.writeLString(this.query);\n\n    if (!types.protocolVersion.supportsPaging(encoder.protocolVersion)) {\n      frameWriter.writeShort(this.consistency);\n    } else {\n      //Use the same fields as the execute writer\n      this.writeQueryParameters(frameWriter, encoder);\n    }\n\n    // Record the length of the body of the request before writing it\n    this.length = frameWriter.bodyLength;\n\n    return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);\n  }\n}\n\nclass PrepareRequest extends Request {\n  constructor(query) {\n    super();\n    this.query = query;\n  }\n\n  write(encoder, streamId) {\n    const frameWriter = new FrameWriter(types.opcodes.prepare);\n    frameWriter.writeLString(this.query);\n    return frameWriter.write(encoder.protocolVersion, streamId);\n  }\n}\n\nclass StartupRequest extends Request {\n\n  /**\n   * Creates a new instance of {@link StartupRequest}.\n   * @param {Object} [options]\n   * @param [options.cqlVersion]\n   * @param [options.noCompact]\n   */\n  constructor(options) {\n    super();\n    this.options = options || {};\n  }\n\n  write(encoder, streamId) {\n    const frameWriter = new FrameWriter(types.opcodes.startup);\n\n    const startupOptions = {\n      CQL_VERSION: this.options.cqlVersion || '3.0.0',\n      DRIVER_NAME: packageInfo.description,\n      DRIVER_VERSION: packageInfo.version\n    };\n\n    if(this.options.noCompact) {\n      startupOptions['NO_COMPACT'] = 'true';\n    }\n\n    frameWriter.writeStringMap(startupOptions);\n    return frameWriter.write(encoder.protocolVersion, streamId);\n  }\n}\n\nclass RegisterRequest extends Request {\n  constructor(events) {\n    super();\n    this.events = events;\n  }\n\n  write(encoder, streamId) {\n    const frameWriter = new FrameWriter(types.opcodes.register);\n    frameWriter.writeStringList(this.events);\n    return frameWriter.write(encoder.protocolVersion, streamId);\n  }\n}\n\n/**\n * Represents an AUTH_RESPONSE request\n * @param {Buffer} token\n */\nclass AuthResponseRequest extends Request {\n  constructor(token) {\n    super();\n    this.token = token;\n  }\n\n  write(encoder, streamId) {\n    const frameWriter = new FrameWriter(types.opcodes.authResponse);\n    frameWriter.writeBytes(this.token);\n    return frameWriter.write(encoder.protocolVersion, streamId);\n  }\n}\n\n/**\n * Represents a protocol v1 CREDENTIALS request message\n */\nclass CredentialsRequest extends Request {\n  constructor(username, password) {\n    super();\n    this.username = username;\n    this.password = password;\n  }\n\n  write(encoder, streamId) {\n    const frameWriter = new FrameWriter(types.opcodes.credentials);\n    frameWriter.writeStringMap({ username:this.username, password:this.password });\n    return frameWriter.write(encoder.protocolVersion, streamId);\n  }\n}\n\nclass BatchRequest extends Request {\n  /**\n   * Creates a new instance of BatchRequest.\n   * @param {Array.<{query, params, [info]}>} queries Array of objects with the properties query and params\n   * @param {ExecutionOptions} execOptions\n   */\n  constructor(queries, execOptions) {\n    super();\n    this.queries = queries;\n    this.options = execOptions;\n    this.hints = execOptions.getHints() || utils.emptyArray;\n    this.type = batchType.logged;\n\n    if (execOptions.isBatchCounter()) {\n      this.type = batchType.counter;\n    } else if (!execOptions.isBatchLogged()) {\n      this.type = batchType.unlogged;\n    }\n  }\n\n  /**\n   * Writes a batch request\n   */\n  write(encoder, streamId) {\n    //v2: <type><n><query_1>...<query_n><consistency>\n    //v3: <type><n><query_1>...<query_n><consistency><flags>[<serial_consistency>][<timestamp>]\n    if (!this.queries || !(this.queries.length > 0)) {\n      throw new TypeError(util.format('Invalid queries provided %s', this.queries));\n    }\n    const frameWriter = new FrameWriter(types.opcodes.batch);\n    let headerFlags = this.options.isQueryTracing() ? types.frameFlags.tracing : 0;\n    if (this.options.getCustomPayload()) {\n      //The body may contain the custom payload\n      headerFlags |= types.frameFlags.customPayload;\n      frameWriter.writeCustomPayload(this.options.getCustomPayload());\n    }\n    frameWriter.writeByte(this.type);\n    frameWriter.writeShort(this.queries.length);\n    const self = this;\n    this.queries.forEach(function eachQuery(item, i) {\n      const hints = self.hints[i];\n      const params = item.params || utils.emptyArray;\n      let getParamType;\n      if (item.queryId) {\n        // Contains prepared queries\n        frameWriter.writeByte(1);\n        frameWriter.writeShortBytes(item.queryId);\n        getParamType = i => item.meta.columns[i].type;\n      }\n      else {\n        // Contains string queries\n        frameWriter.writeByte(0);\n        frameWriter.writeLString(item.query);\n        getParamType = hints ? (i => hints[i]) : (() => null);\n      }\n\n      frameWriter.writeShort(params.length);\n      params.forEach((param, index) => frameWriter.writeBytes(encoder.encode(param, getParamType(index))));\n    }, this);\n\n    frameWriter.writeShort(this.options.getConsistency());\n\n    if (types.protocolVersion.supportsTimestamp(encoder.protocolVersion)) {\n      // Batch flags\n      let flags = this.options.getSerialConsistency() ? batchFlag.withSerialConsistency : 0;\n      const timestamp = this.options.getOrGenerateTimestamp();\n      flags |= timestamp !== null && timestamp !== undefined ? batchFlag.withDefaultTimestamp : 0;\n      frameWriter.writeByte(flags);\n\n      if (flags & batchFlag.withSerialConsistency) {\n        frameWriter.writeShort(this.options.getSerialConsistency());\n      }\n\n      if (flags & batchFlag.withDefaultTimestamp) {\n        frameWriter.writeLong(timestamp);\n      }\n    }\n\n    // Set the length of the body of the request before writing it\n    this.length = frameWriter.bodyLength;\n\n    return frameWriter.write(encoder.protocolVersion, streamId, headerFlags);\n  }\n\n  clone() {\n    return new BatchRequest(this.queries, this.options);\n  }\n}\n\nclass OptionsRequest extends Request {\n\n  write(encoder, streamId) {\n    const frameWriter = new FrameWriter(types.opcodes.options);\n    return frameWriter.write(encoder.protocolVersion, streamId, 0);\n  }\n\n  clone() {\n    // since options has no unique state, simply return self.\n    return this;\n  }\n}\n\nconst options = new OptionsRequest();\n\nexports.AuthResponseRequest = AuthResponseRequest;\nexports.BatchRequest = BatchRequest;\nexports.CredentialsRequest = CredentialsRequest;\nexports.ExecuteRequest = ExecuteRequest;\nexports.PrepareRequest = PrepareRequest;\nexports.QueryRequest = QueryRequest;\nexports.Request = Request;\nexports.RegisterRequest = RegisterRequest;\nexports.StartupRequest = StartupRequest;\nexports.options = options;\n","\"use strict\";\n\nconst types = require('./types');\n\n/**\n * Group size\n * @type {number}\n */\nconst groupSize = 128;\n\n/**\n * Number used to right shift ids to allocate them into groups\n * @const\n * @type {number}\n */\nconst shiftToGroup = 7;\n\n/**\n * Amount of groups that can be released per time\n * If it grows larger than 4 groups (128 * 4), groups can be released\n * @const\n * @type {number}\n */\nconst releasableSize = 4;\n\n/**\n * 32K possible stream ids depending for protocol v3 and above\n * @const\n * @type {number}\n */\nconst maxGroupsFor2Bytes = 256;\n\n/**\n * Delay used to check if groups can be released\n * @const\n * @type {number}\n */\n// eslint-disable-next-line prefer-const\nlet releaseDelay = 5000;\n\n/**\n * Represents a queue of ids from 0 to maximum stream id supported by the protocol version.\n * Clients can dequeue a stream id using {@link StreamIdStack#shift()} and enqueue (release) using\n * {@link StreamIdStack#push()}\n */\nclass StreamIdStack {\n  /**\n   * Creates a new instance of StreamIdStack.\n   * @param {Number} version Protocol version\n   * @constructor\n   */\n  constructor(version) {\n    //Ecmascript Number is 64-bit double, it can be optimized by the engine into a 32-bit int, but nothing below that.\n    //We try to allocate as few as possible in arrays of 128\n    this.currentGroup = generateGroup(0);\n    this.groupIndex = 0;\n    this.groups = [this.currentGroup];\n    this.releaseTimeout = null;\n    this.setVersion(version);\n    /**\n     * Returns the amount of ids currently in use\n     * @member {number}\n     */\n    this.inUse = 0;\n  }\n\n  /**\n   * Sets the protocol version\n   * @param {Number} version\n   */\n  setVersion(version) {\n    //128 or 32K stream ids depending on the protocol version\n    this.maxGroups = types.protocolVersion.uses2BytesStreamIds(version) ? maxGroupsFor2Bytes : 1;\n  }\n\n  /**\n   * Dequeues an id.\n   * Similar to {@link Array#pop()}.\n   * @returns {Number} Returns an id or null\n   */\n  pop() {\n    let id = this.currentGroup.pop();\n    if (typeof id !== 'undefined') {\n      this.inUse++;\n      return id;\n    }\n    //try to use the following groups\n    while (this.groupIndex < this.groups.length - 1) {\n      //move to the following group\n      this.currentGroup = this.groups[++this.groupIndex];\n      //try dequeue\n      id = this.currentGroup.pop();\n      if (typeof id !== 'undefined') {\n        this.inUse++;\n        return id;\n      }\n    }\n    return this._tryCreateGroup();\n  }\n\n  /**\n   * Enqueue an id for future use.\n   * Similar to {@link Array#push()}.\n   * @param {Number} id\n   */\n  push(id) {\n    this.inUse--;\n    const groupIndex = id >> shiftToGroup;\n    const group = this.groups[groupIndex];\n    group.push(id);\n    if (groupIndex < this.groupIndex) {\n      //Set the lower group to be used to dequeue from\n      this.groupIndex = groupIndex;\n      this.currentGroup = group;\n    }\n    this._tryIssueRelease();\n  }\n\n  /**\n   * Clears all timers\n   */\n  clear() {\n    if (this.releaseTimeout) {\n      clearTimeout(this.releaseTimeout);\n      this.releaseTimeout = null;\n    }\n  }\n\n  /**\n   * Tries to create an additional group and returns a new id\n   * @returns {Number} Returns a new id or null if it's not possible to create a new group\n   * @private\n   */\n  _tryCreateGroup() {\n    if (this.groups.length === this.maxGroups) {\n      //we can have an additional group\n      return null;\n    }\n    //Add a new group at the last position\n    this.groupIndex = this.groups.length;\n    //Using 128 * groupIndex as initial value\n    this.currentGroup = generateGroup(this.groupIndex << shiftToGroup);\n    this.groups.push(this.currentGroup);\n    this.inUse++;\n    return this.currentGroup.pop();\n  }\n\n  _tryIssueRelease() {\n    if (this.releaseTimeout || this.groups.length <= releasableSize) {\n      //Nothing to release or a release delay has been issued\n      return;\n    }\n    const self = this;\n    this.releaseTimeout = setTimeout(() => self._releaseGroups(), releaseDelay);\n  }\n\n  _releaseGroups() {\n    let counter = 0;\n    let index = this.groups.length - 1;\n    //only release up to n groups (n = releasable size)\n    //shrink back up to n groups not all the way up to 1\n    while (counter++ < releasableSize && this.groups.length > releasableSize && index > this.groupIndex) {\n      if (this.groups[index].length !== groupSize) {\n        //the group is being used\n        break;\n      }\n      this.groups.pop();\n      index--;\n    }\n    this.releaseTimeout = null;\n    //Issue next release if applies\n    this._tryIssueRelease();\n  }\n}\n\nfunction generateGroup(initialValue) {\n  const arr = new Array(groupSize);\n  const upperBound = initialValue + groupSize - 1;\n  for (let i = 0; i < groupSize; i++) {\n    arr[i] = upperBound - i;\n  }\n  return arr;\n}\n\nmodule.exports = StreamIdStack;","'use strict';\nconst util = require('util');\nconst stream = require('stream');\nconst Transform = stream.Transform;\nconst Writable = stream.Writable;\n\nconst types = require('./types');\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst FrameHeader = types.FrameHeader;\nconst FrameReader = require('./readers').FrameReader;\n\n/**\n * Transforms chunks, emits data objects {header, chunk}\n * @param options Stream options\n * @extends Transform\n */\nfunction Protocol (options) {\n  Transform.call(this, options);\n  this.header = null;\n  this.bodyLength = 0;\n  this.clearHeaderChunks();\n  this.version = 0;\n  this.headerSize = 0;\n}\n\nutil.inherits(Protocol, Transform);\n\nProtocol.prototype._transform = function (chunk, encoding, callback) {\n  let error = null;\n  try {\n    this.readItems(chunk);\n  }\n  catch (err) {\n    error = err;\n  }\n  callback(error);\n};\n\n/**\n * Parses the chunk into frames (header and body).\n * Emits (push) complete frames or frames with incomplete bodies. Following chunks containing the rest of the body will\n * be emitted using the same frame.\n * It buffers incomplete headers.\n * @param {Buffer} chunk\n */\nProtocol.prototype.readItems = function (chunk) {\n  if (!chunk || chunk.length === 0) {\n    return;\n  }\n  if (this.version === 0) {\n    //The server replies the first message with the max protocol version supported\n    this.version = FrameHeader.getProtocolVersion(chunk);\n    this.headerSize = FrameHeader.size(this.version);\n  }\n  let offset = 0;\n  let currentHeader = this.header;\n  this.header = null;\n  if (this.headerChunks.byteLength !== 0) {\n    //incomplete header was buffered try to read the header from the buffered chunks\n    this.headerChunks.parts.push(chunk);\n    if (this.headerChunks.byteLength + chunk.length < this.headerSize) {\n      this.headerChunks.byteLength += chunk.length;\n      return;\n    }\n    currentHeader = FrameHeader.fromBuffer(Buffer.concat(this.headerChunks.parts, this.headerSize));\n    offset = this.headerSize - this.headerChunks.byteLength;\n    this.clearHeaderChunks();\n  }\n  const items = [];\n  while (true) {\n    if (!currentHeader) {\n      if (this.headerSize > chunk.length - offset) {\n        if (chunk.length - offset <= 0) {\n          break;\n        }\n        //the header is incomplete, buffer it until the next chunk\n        const headerPart = chunk.slice(offset, chunk.length);\n        this.headerChunks.parts.push(headerPart);\n        this.headerChunks.byteLength = headerPart.length;\n        break;\n      }\n      //read header\n      currentHeader = FrameHeader.fromBuffer(chunk, offset);\n      offset += this.headerSize;\n    }\n    //parse body\n    const remaining = chunk.length - offset;\n    if (currentHeader.bodyLength <= remaining + this.bodyLength) {\n      items.push({ header: currentHeader, chunk: chunk, offset: offset, frameEnded: true });\n      offset += currentHeader.bodyLength - this.bodyLength;\n      //reset the body length\n      this.bodyLength = 0;\n    }\n    else if (remaining >= 0) {\n      //the body is not fully contained in this chunk\n      //will continue later\n      this.header = currentHeader;\n      this.bodyLength += remaining;\n      if (remaining > 0) {\n        //emit if there is at least a byte to emit\n        items.push({ header: currentHeader, chunk: chunk, offset: offset, frameEnded: false });\n      }\n      break;\n    }\n    currentHeader = null;\n  }\n  for (let i = 0; i < items.length; i++) {\n    this.push(items[i]);\n  }\n};\n\nProtocol.prototype.clearHeaderChunks = function () {\n  this.headerChunks = { byteLength: 0, parts: [] };\n};\n\n/**\n * A stream that gets reads header + body chunks and transforms them into header + (row | error)\n * @param {Object} streamOptions Node.js Stream options\n * @param {Encoder} encoder Encoder instance for the parser to use\n * @extends Transform\n */\nfunction Parser (streamOptions, encoder) {\n  Transform.call(this, streamOptions);\n  //frames that are streaming, indexed by id\n  this.frames = {};\n  this.encoder = encoder;\n}\n\nutil.inherits(Parser, Transform);\n\nParser.prototype._transform = function (item, encoding, callback) {\n  const frameInfo = this.frameState(item);\n\n  let error = null;\n  try {\n    this.parseBody(frameInfo, item);\n  }\n  catch (err) {\n    error = err;\n  }\n  callback(error);\n\n  if (item.frameEnded) {\n    if (frameInfo.cellBuffer) {\n      //Frame was being streamed but an error force it to buffer the result\n      this.push({\n        header: frameInfo.header,\n        error: new errors.DriverInternalError('There was an problem while parsing streaming frame, opcode ' +\n          frameInfo.header.opcode)\n      });\n    }\n    //all the parsing finished and it was streamed down\n    //emit an item that signals it\n    this.push({ header: frameInfo.header, frameEnded: true});\n  }\n};\n\n/**\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n */\nParser.prototype.parseBody = function (frameInfo, item) {\n  frameInfo.isStreaming = frameInfo.byRow && item.header.opcode === types.opcodes.result;\n  if (!this.handleFrameBuffers(frameInfo, item)) {\n    // Frame isn't complete and we are not streaming the frame\n    return;\n  }\n  const reader = new FrameReader(item.header, item.chunk, item.offset);\n  // Check that flags have not been parsed yet for this frame\n  if (frameInfo.flagsInfo === undefined) {\n    const originalOffset = reader.offset;\n    try {\n      frameInfo.flagsInfo = reader.readFlagsInfo();\n    }\n    catch (e) {\n      return this.handleParsingError(e, frameInfo, reader, originalOffset);\n    }\n  }\n\n  //All the body for most operations is already buffered at this stage\n  //Except for RESULT\n  switch (item.header.opcode) {\n    case types.opcodes.result:\n      return this.parseResult(frameInfo, reader);\n    case types.opcodes.ready:\n    case types.opcodes.authSuccess:\n      return this.push({ header: frameInfo.header, ready: true });\n    case types.opcodes.authChallenge:\n      return this.push({ header: frameInfo.header, authChallenge: true, token: reader.readBytes()});\n    case types.opcodes.authenticate:\n      return this.push({ header: frameInfo.header, mustAuthenticate: true, authenticatorName: reader.readString()});\n    case types.opcodes.error:\n      return this.push({ header: frameInfo.header, error: reader.readError()});\n    case types.opcodes.supported:\n      return this.push({ header: frameInfo.header });\n    case types.opcodes.event:\n      return this.push({ header: frameInfo.header, event: reader.readEvent()});\n    default:\n      return this.push({ header: frameInfo.header, error: new Error('Received invalid opcode: ' + item.header.opcode) });\n  }\n};\n\n/**\n * Buffers if needed and returns true if it has all the necessary data to continue parsing the frame.\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n * @returns {Boolean}\n */\nParser.prototype.handleFrameBuffers = function (frameInfo, item) {\n  if (!frameInfo.isStreaming) {\n    // Handle buffering for complete frame bodies\n    const currentLength = (frameInfo.bufferLength || 0) + item.chunk.length - item.offset;\n    if (currentLength < item.header.bodyLength) {\n      //buffer until the frame is completed\n      this.addFrameBuffer(frameInfo, item);\n      return false;\n    }\n    //We have received the full frame body\n    if (frameInfo.buffers) {\n      item.chunk = this.getFrameBuffer(frameInfo, item);\n      item.offset = 0;\n    }\n    return true;\n  }\n  if (frameInfo.cellBuffer) {\n    // Handle buffering for frame cells (row cells or metadata cells)\n    if (item.offset !== 0) {\n      throw new errors.DriverInternalError('Following chunks can not have an offset greater than zero');\n    }\n    frameInfo.cellBuffer.parts.push(item.chunk);\n    if (!frameInfo.cellBuffer.expectedLength) {\n      //Its a buffer outside a row cell (metadata or other)\n      if (frameInfo.cellBuffer.parts.length !== 2) {\n        throw new errors.DriverInternalError('Buffer for streaming frame can not contain more than 1 item');\n      }\n      item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);\n      frameInfo.cellBuffer = null;\n      return true;\n    }\n    if (frameInfo.cellBuffer.expectedLength > frameInfo.cellBuffer.byteLength + item.chunk.length) {\n      //We still haven't got the cell data\n      frameInfo.cellBuffer.byteLength += item.chunk.length;\n      return false;\n    }\n    item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);\n    frameInfo.cellBuffer = null;\n  }\n  return true;\n};\n\n/**\n * Adds this chunk to the frame buffers.\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n */\nParser.prototype.addFrameBuffer = function (frameInfo, item) {\n  if (!frameInfo.buffers) {\n    frameInfo.buffers = [ item.chunk.slice(item.offset) ];\n    frameInfo.bufferLength = item.chunk.length - item.offset;\n    return;\n  }\n  if (item.offset > 0) {\n    throw new errors.DriverInternalError('Following chunks can not have an offset greater than zero');\n  }\n  frameInfo.buffers.push(item.chunk);\n  frameInfo.bufferLength += item.chunk.length;\n};\n\n/**\n * Adds the last chunk and concatenates the frame buffers\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n */\nParser.prototype.getFrameBuffer = function (frameInfo, item) {\n  frameInfo.buffers.push(item.chunk);\n  const result = Buffer.concat(frameInfo.buffers, frameInfo.bodyLength);\n  frameInfo.buffers = null;\n  return result;\n};\n\n/**\n * Tries to read the result in the body of a message\n * @param frameInfo Frame information, header / metadata\n * @param {FrameReader} reader\n */\nParser.prototype.parseResult = function (frameInfo, reader) {\n  let result;\n  // As we might be streaming and the frame buffer might not be complete,\n  // read the metadata and different types of result values in a try-catch.\n  // Store the reader position\n  const originalOffset = reader.offset;\n  try {\n    if (!frameInfo.meta) {\n      frameInfo.kind = reader.readInt();\n      // Spec 4.2.5\n      switch (frameInfo.kind) {\n        case types.resultKind.voidResult:\n          result = { header: frameInfo.header, flags: frameInfo.flagsInfo };\n          break;\n        case types.resultKind.rows:\n          // Parse the rows metadata, the rest of the response is going to be parsed afterwards\n          frameInfo.meta = reader.readMetadata(frameInfo.kind);\n          break;\n        case types.resultKind.setKeyspace:\n          result = { header: frameInfo.header, keyspaceSet: reader.readString(), flags: frameInfo.flagsInfo };\n          break;\n        case types.resultKind.prepared:\n        {\n          const preparedId = utils.copyBuffer(reader.readShortBytes());\n          frameInfo.meta = reader.readMetadata(frameInfo.kind);\n          result = { header: frameInfo.header, id: preparedId, meta: frameInfo.meta, flags: frameInfo.flagsInfo };\n          break;\n        }\n        case types.resultKind.schemaChange:\n          result = { header: frameInfo.header, schemaChange: reader.parseSchemaChange(), flags: frameInfo.flagsInfo };\n          break;\n        default:\n          throw errors.DriverInternalError('Unexpected result kind: ' + frameInfo.kind);\n      }\n    }\n  }\n  catch (e) {\n    return this.handleParsingError(e, frameInfo, reader, originalOffset);\n  }\n  if (result) {\n    if (frameInfo.emitted) {\n      // It may contain additional metadata and info that it's not being parsed\n      return;\n    }\n    frameInfo.emitted = true;\n    return this.push(result);\n  }\n  // Its a `Rows` result\n  if (reader.remainingLength() > 0) {\n    this.parseRows(frameInfo, reader);\n  }\n};\n\n/**\n * @param frameInfo\n * @param {FrameReader} reader\n */\nParser.prototype.parseRows = function (frameInfo, reader) {\n  if (frameInfo.parsingError) {\n    //No more processing on this frame\n    return;\n  }\n  if (frameInfo.rowLength === undefined) {\n    try {\n      frameInfo.rowLength = reader.readInt();\n    }\n    catch (e) {\n      return this.handleParsingError(e, frameInfo, reader);\n    }\n  }\n  if (frameInfo.rowLength === 0) {\n    return this.push({\n      header: frameInfo.header,\n      result: { rows: utils.emptyArray, meta: frameInfo.meta, flags: frameInfo.flagsInfo }\n    });\n  }\n  const meta = frameInfo.meta;\n  frameInfo.rowIndex = frameInfo.rowIndex || 0;\n  for (let i = frameInfo.rowIndex; i < frameInfo.rowLength; i++) {\n    const rowOffset = reader.offset;\n    const row = new types.Row(meta.columns);\n    let cellBuffer;\n    for (let j = 0; j < meta.columns.length; j++ ) {\n      const c = meta.columns[j];\n      try {\n        cellBuffer = reader.readBytes();\n      }\n      catch (e) {\n        return this.handleParsingError(e, frameInfo, reader, rowOffset, i);\n      }\n      try {\n        row[c.name] = this.encoder.decode(cellBuffer, c.type);\n      }\n      catch (e) {\n        //Something went wrong while decoding, we are not going to be able to recover\n        return this.handleParsingError(e, frameInfo, null);\n      }\n    }\n    this.push({\n      header: frameInfo.header,\n      row: row,\n      meta: frameInfo.meta,\n      byRow: frameInfo.byRow,\n      length: frameInfo.rowLength,\n      flags: frameInfo.flagsInfo\n    });\n  }\n};\n\n/**\n * Sets parser options (ie: how to yield the results as they are parsed)\n * @param {Number} id Id of the stream\n * @param options\n */\nParser.prototype.setOptions = function (id, options) {\n  if (this.frames[id.toString()]) {\n    throw new types.DriverError('There was already state for this frame');\n  }\n  this.frames[id.toString()] = options;\n};\n\n/**\n * Gets the frame info from the internal state.\n * In case it is not there, it creates it.\n * In case the frame ended\n */\nParser.prototype.frameState = function (item) {\n  let frameInfo = this.frames[item.header.streamId];\n  if (!frameInfo) {\n    frameInfo = {};\n    if (!item.frameEnded) {\n      //store it in the frames\n      this.frames[item.header.streamId] = frameInfo;\n    }\n  }\n  else if (item.frameEnded) {\n    //if it was already stored, remove it\n    delete this.frames[item.header.streamId];\n  }\n  frameInfo.header = item.header;\n  return frameInfo;\n};\n\n/**\n * Handles parsing error: pushing an error if its unexpected or buffer the cell if its streaming\n * @param {Error} e\n * @param frameInfo\n * @param {FrameReader} reader\n * @param {Number} [originalOffset]\n * @param {Number} [rowIndex]\n */\nParser.prototype.handleParsingError = function (e, frameInfo, reader, originalOffset, rowIndex) {\n  if (reader && frameInfo.isStreaming && (e instanceof RangeError)) {\n    //A controlled error, buffer from offset and move on\n    return this.bufferResultCell(frameInfo, reader, originalOffset, rowIndex, e.expectedLength);\n  }\n  frameInfo.parsingError = true;\n  frameInfo.cellBuffer = null;\n  this.push({ header: frameInfo.header, error: e });\n};\n\n/**\n * When streaming, it buffers data since originalOffset.\n * @param frameInfo\n * @param {FrameReader} reader\n * @param {Number} [originalOffset]\n * @param {Number} [rowIndex]\n * @param {Number} [expectedLength]\n */\nParser.prototype.bufferResultCell = function (frameInfo, reader, originalOffset, rowIndex, expectedLength) {\n  if (!originalOffset && originalOffset !== 0) {\n    originalOffset = reader.offset;\n  }\n  frameInfo.rowIndex = rowIndex;\n  const buffer = reader.slice(originalOffset);\n  frameInfo.cellBuffer = {\n    parts: [ buffer ],\n    byteLength: buffer.length,\n    expectedLength: expectedLength\n  };\n};\n\n/**\n * Represents a writable streams that emits results\n */\nfunction ResultEmitter(options) {\n  Writable.call(this, options);\n  /**\n   * Stores the rows for frames that needs to be yielded as one result with many rows\n   */\n  this.rowBuffer = {};\n}\n\nutil.inherits(ResultEmitter, Writable);\n\nResultEmitter.prototype._write = function (item, encoding, callback) {\n  let error = null;\n  try {\n    this.each(item);\n  }\n  catch (err) {\n    error = err;\n  }\n  callback(error);\n};\n\n\n/**\n * Analyzes the item and emit the corresponding event\n */\nResultEmitter.prototype.each = function (item) {\n  if (item.error || item.result) {\n    //Its either an error or an empty array rows\n    //no transformation needs to be made\n    return this.emit('result', item.header, item.error, item.result);\n  }\n  if (item.frameEnded) {\n    return this.emit('frameEnded', item.header);\n  }\n  if (item.byRow) {\n    //it should be yielded by row\n    return this.emit('row', item.header, item.row, item.meta, item.length, item.flags);\n  }\n  if (item.row) {\n    //it should be yielded as a result\n    //it needs to be buffered to an array of rows\n    return this.bufferAndEmit(item);\n  }\n  if (item.event) {\n    //its an event from Cassandra\n    return this.emit('nodeEvent', item.header, item.event);\n  }\n  //its a raw response (object with flags)\n  return this.emit('result', item.header, null, item);\n};\n\n/**\n * Buffers the rows until the result set is completed and emits the result event.\n */\nResultEmitter.prototype.bufferAndEmit = function (item) {\n  let rows = this.rowBuffer[item.header.streamId];\n  if (!rows) {\n    rows = this.rowBuffer[item.header.streamId] = [];\n  }\n  rows.push(item.row);\n  if (rows.length === item.length) {\n    this.emit('result', item.header, null, { rows: rows, meta: item.meta, flags: item.flags});\n    delete this.rowBuffer[item.header.streamId];\n  }\n};\n\nexports.Protocol = Protocol;\nexports.Parser = Parser;\nexports.ResultEmitter = ResultEmitter;\n","'use strict';\n\nconst types = require('./types');\nconst util = require('util');\n\nconst _Murmur3TokenType = types.dataTypes.getByName('bigint');\nconst _RandomTokenType = types.dataTypes.getByName('varint');\nconst _OrderedTokenType = types.dataTypes.getByName('blob');\n\n/**\n * Represents a token on the Cassandra ring.\n */\nclass Token {\n  constructor(value) {\n    this._value = value;\n  }\n\n  /**\n   * @returns {{code: number, info: *|Object}} The type info for the\n   *                                           type of the value of the token.\n   */\n  getType() {\n    throw new Error('You must implement a getType function for this Token instance');\n  }\n\n  /**\n   * @returns {*} The raw value of the token.\n   */\n  getValue() {\n    return this._value;\n  }\n\n  toString() {\n    return this._value.toString();\n  }\n\n  /**\n   * Returns 0 if the values are equal, 1 if greater than other, -1\n   * otherwise.\n   *\n   * @param {Token} other \n   * @returns {Number}\n   */\n  compare(other) {\n    return this._value.compare(other._value);\n  }\n\n  equals(other) {\n    return this.compare(other) === 0;\n  }\n\n  inspect() {\n    return this.constructor.name + ' { ' + this.toString() + ' }';\n  }\n}\n\n/**\n * Represents a token from a Cassandra ring where the partitioner\n * is Murmur3Partitioner.\n * \n * The raw token type is a varint (represented by MutableLong).\n */\nclass Murmur3Token extends Token {\n  constructor(value) {\n    super(value);\n  }\n\n  getType() {\n    return _Murmur3TokenType;\n  }\n}\n\n/**\n * Represents a token from a Cassandra ring where the partitioner\n * is RandomPartitioner.\n * \n * The raw token type is a bigint (represented by Number).\n */\nclass RandomToken extends Token {\n  constructor(value) {\n    super(value);\n  }\n\n  getType() {\n    return _RandomTokenType;\n  }\n}\n\n/**\n * Represents a token from a Cassandra ring where the partitioner\n * is ByteOrderedPartitioner.\n * \n * The raw token type is a blob (represented by Buffer or Array).\n */\nclass ByteOrderedToken extends Token {\n  constructor(value) {\n    super(value);\n  }\n\n  getType() {\n    return _OrderedTokenType;\n  }\n\n  toString() {\n    return this._value.toString('hex').toUpperCase();\n  }\n}\n\n/** \n * Represents a range of tokens on a Cassandra ring.\n *\n * A range is start-exclusive and end-inclusive.  It is empty when\n * start and end are the same token, except if that is the minimum\n * token, in which case the range covers the whole ring (this is\n * consistent with the behavior of CQL range queries).\n *\n * Note that CQL does not handle wrapping.  To query all partitions\n * in a range, see {@link unwrap}.\n */\nclass TokenRange {\n  constructor(start, end, tokenizer) {\n    this.start = start;\n    this.end = end;\n    Object.defineProperty(this, '_tokenizer', { value: tokenizer, enumerable: false});\n  }\n\n  /**\n   * Splits this range into a number of smaller ranges of equal \"size\"\n   * (referring to the number of tokens, not the actual amount of data).\n   *\n   * Splitting an empty range is not permitted.  But not that, in edge\n   * cases, splitting a range might produce one or more empty ranges.\n   *\n   * @param {Number} numberOfSplits Number of splits to make.\n   * @returns {TokenRange[]} Split ranges.\n   * @throws {Error} If splitting an empty range.\n   */\n  splitEvenly(numberOfSplits) {\n    if (numberOfSplits < 1) {\n      throw new Error(util.format(\"numberOfSplits (%d) must be greater than 0.\", numberOfSplits));\n    }\n    if (this.isEmpty()) {\n      throw new Error(\"Can't split empty range \" + this.toString());\n    }\n\n    const tokenRanges = [];\n    const splitPoints = this._tokenizer.split(this.start, this.end, numberOfSplits);\n    let splitStart = this.start;\n    let splitEnd;\n    for (let splitIndex = 0; splitIndex < splitPoints.length; splitIndex++) {\n      splitEnd = splitPoints[splitIndex];\n      tokenRanges.push(new TokenRange(splitStart, splitEnd, this._tokenizer));\n      splitStart = splitEnd;\n    }\n    tokenRanges.push(new TokenRange(splitStart, this.end, this._tokenizer));\n    return tokenRanges;\n  }\n\n  /**\n   * A range is empty when start and end are the same token, except if\n   * that is the minimum token, in which case the range covers the\n   * whole ring.  This is consistent with the behavior of CQL range\n   * queries.\n   *\n   * @returns {boolean} Whether this range is empty.\n   */\n  isEmpty() {\n    return this.start.equals(this.end) && !this.start.equals(this._tokenizer.minToken());\n  }\n\n  /**\n   * A range wraps around the end of the ring when the start token\n   * is greater than the end token and the end token is not the \n   * minimum token.\n   *\n   * @returns {boolean} Whether this range wraps around.\n   */\n  isWrappedAround() {\n    return this.start.compare(this.end) > 0 && !this.end.equals(this._tokenizer.minToken());\n  }\n\n  /**\n   * Splits this range into a list of two non-wrapping ranges.\n   *\n   * This will return the range itself if it is non-wrapped, or two\n   * ranges otherwise.\n   *\n   * This is useful for CQL range queries, which do not handle\n   * wrapping.\n   *\n   * @returns {TokenRange[]} The list of non-wrapping ranges.\n   */\n  unwrap() {\n    if (this.isWrappedAround()) {\n      return [\n        new TokenRange(this.start, this._tokenizer.minToken(), this._tokenizer),\n        new TokenRange(this._tokenizer.minToken(), this.end, this._tokenizer)\n      ];\n    }\n    return [this];\n  }\n\n  /**\n   * Whether this range contains a given Token.\n   * \n   * @param {*} token Token to check for.\n   * @returns {boolean} Whether or not the Token is in this range.\n   */\n  contains(token) {\n    if (this.isEmpty()) {\n      return false;\n    }\n    const minToken = this._tokenizer.minToken();\n    if (this.end.equals(minToken)) {\n      if (this.start.equals(minToken)) {\n        return true; // ]minToken, minToken] === full ring\n      } else if (token.equals(minToken)) {\n        return true;\n      }\n      return token.compare(this.start) > 0;\n    }\n\n    const isAfterStart = token.compare(this.start) > 0;\n    const isBeforeEnd = token.compare(this.end) <= 0;\n    // if wrapped around ring, token is in ring if its after start or before end.\n    // otherwise, token is in ring if its after start and before end.\n    return this.isWrappedAround() \n      ? isAfterStart || isBeforeEnd\n      : isAfterStart && isBeforeEnd;\n  }\n\n  /**\n   * Determines if the input range is equivalent to this one.\n   * \n   * @param {TokenRange} other Range to compare with.\n   * @returns {boolean} Whether or not the ranges are equal.\n   */\n  equals(other) {\n    if (other === this) {\n      return true;\n    } else if (other instanceof TokenRange) {\n      return this.compare(other) === 0;\n    }\n    return false;\n  }\n\n  /**\n   * Returns 0 if the values are equal, otherwise compares against\n   * start, if start is equal, compares against end.\n   *  \n   * @param {TokenRange} other Range to compare with.\n   * @returns {Number} \n   */\n  compare(other) {\n    const compareStart = this.start.compare(other.start);\n    return compareStart !== 0 ? compareStart : this.end.compare(other.end);\n  }\n\n  toString() {\n    return util.format(']%s, %s]', \n      this.start.toString(),\n      this.end.toString()\n    );\n  }\n}\n\nexports.Token = Token;\nexports.TokenRange = TokenRange;\nexports.ByteOrderedToken = ByteOrderedToken;\nexports.Murmur3Token = Murmur3Token;\nexports.RandomToken = RandomToken;","'use strict';\n\nconst util = require('util');\nconst types = require('./types');\nconst token = require('./token');\nconst utils = require('./utils');\nconst MutableLong = require('./types/mutable-long');\nconst Integer = types.Integer;\n\n// Murmur3 constants\n//-0x783C846EEEBDAC2B\nconst mconst1 = new MutableLong(0x53d5, 0x1142, 0x7b91, 0x87c3);\n//0x4cf5ad432745937f\nconst mconst2 = new MutableLong(0x937f, 0x2745, 0xad43, 0x4cf5);\nconst mlongFive = MutableLong.fromNumber(5);\n//0xff51afd7ed558ccd\nconst mconst3 = new MutableLong(0x8ccd, 0xed55, 0xafd7, 0xff51);\n//0xc4ceb9fe1a85ec53\nconst mconst4 = new MutableLong(0xec53, 0x1a85, 0xb9fe, 0xc4ce);\nconst mconst5 = MutableLong.fromNumber(0x52dce729);\nconst mconst6 = MutableLong.fromNumber(0x38495ab5);\n\n/**\n * Represents a set of methods that are able to generate and parse tokens for the C* partitioner.\n * @abstract\n */\nclass Tokenizer {\n  constructor() {\n\n  }\n\n  /**\n   * Creates a token based on the Buffer value provided\n   * @abstract\n   * @param {Buffer|Array} value\n   * @returns {Token} Computed token\n   */\n  hash(value) {\n    throw new Error('You must implement a hash function for the tokenizer');\n  }\n\n  /**\n   * Parses a token string and returns a representation of the token\n   * @abstract\n   * @param {String} value\n   */\n  parse(value) {\n    throw new Error('You must implement a parse function for the tokenizer');\n  }\n\n  minToken() {\n    throw new Error('You must implement a minToken function for the tokenizer');\n  }\n\n  /**\n   * Splits the range specified by start and end into numberOfSplits equal parts.\n   * @param {Token} start Starting token\n   * @param {Token} end  End token\n   * @param {Number} numberOfSplits Number of splits to make.\n   */\n  split(start, end, numberOfSplits) {\n    throw new Error('You must implement a split function for the tokenizer');\n  }\n\n  /**\n   * Common implementation for splitting token ranges when start is in\n   * a shared Integer format.\n   *\n   * @param {Integer} start Starting token\n   * @param {Integer} range How large the range of the split is\n   * @param {Integer} ringEnd The end point of the ring so we know where to wrap\n   * @param {Integer} ringLength The total size of the ring\n   * @param {Number} numberOfSplits The number of splits to make\n   * @returns {Array<Integer>} The evenly-split points on the range\n   */\n  splitBase(start, range, ringEnd, ringLength, numberOfSplits) {\n    const numberOfSplitsInt = Integer.fromInt(numberOfSplits);\n    const divider = range.divide(numberOfSplitsInt);\n    let remainder = range.modulo(numberOfSplitsInt);\n\n    const results = [];\n    let current = start;\n    const dividerPlusOne = divider.add(Integer.ONE);\n\n    for(let i = 1; i < numberOfSplits; i++) {\n      if (remainder.greaterThan(Integer.ZERO)) {\n        current = current.add(dividerPlusOne);\n      } else {\n        current = current.add(divider);\n      }\n      if (ringLength && current.greaterThan(ringEnd)) {\n        current = current.subtract(ringLength);\n      }\n      results.push(current);\n      remainder = remainder.subtract(Integer.ONE);\n    }\n    return results;\n  }\n\n  /**\n   * Return internal string based representation of a Token.\n   * @param {Token} token \n   */\n  stringify(token) {\n    return token.getValue().toString();\n  }\n}\n\n/**\n * Uniformly distributes data across the cluster based on Cassandra flavored Murmur3 hashed values.\n */\nclass Murmur3Tokenizer extends Tokenizer {\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * @param {Buffer} value\n   * @return {Murmur3Token}\n   */\n  hash(value) {\n    // This is an adapted version of the MurmurHash.hash3_x64_128 from Cassandra used\n    // for M3P. Compared to that methods, there's a few inlining of arguments and we\n    // only return the first 64-bits of the result since that's all M3 partitioner uses.\n\n    const data = value;\n    let offset = 0;\n    const length = data.length;\n\n    const nblocks = length >> 4; // Process as 128-bit blocks.\n\n    const h1 = new MutableLong();\n    const h2 = new MutableLong();\n    let k1 = new MutableLong();\n    let k2 = new MutableLong();\n\n    for (let i = 0; i < nblocks; i++) {\n      k1 = this.getBlock(data, offset, i * 2);\n      k2 = this.getBlock(data, offset, i * 2 + 1);\n\n      k1.multiply(mconst1);\n      this.rotl64(k1, 31);\n      k1.multiply(mconst2);\n\n      h1.xor(k1);\n      this.rotl64(h1, 27);\n      h1.add(h2);\n      h1.multiply(mlongFive).add(mconst5);\n\n      k2.multiply(mconst2);\n      this.rotl64(k2, 33);\n      k2.multiply(mconst1);\n      h2.xor(k2);\n      this.rotl64(h2, 31);\n      h2.add(h1);\n      h2.multiply(mlongFive).add(mconst6);\n    }\n    //----------\n    // tail\n\n    // Advance offset to the unprocessed tail of the data.\n    offset += nblocks * 16;\n\n    k1 = new MutableLong();\n    k2 = new MutableLong();\n\n    /* eslint-disable no-fallthrough */\n    switch(length & 15) {\n      case 15:\n        k2.xor(fromSignedByte(data[offset+14]).shiftLeft(48));\n      case 14:\n        k2.xor(fromSignedByte(data[offset+13]).shiftLeft(40));\n      case 13:\n        k2.xor(fromSignedByte(data[offset+12]).shiftLeft(32));\n      case 12:\n        k2.xor(fromSignedByte(data[offset+11]).shiftLeft(24));\n      case 11:\n        k2.xor(fromSignedByte(data[offset+10]).shiftLeft(16));\n      case 10:\n        k2.xor(fromSignedByte(data[offset+9]).shiftLeft(8));\n      case 9:\n        k2.xor(fromSignedByte(data[offset+8]));\n        k2.multiply(mconst2);\n        this.rotl64(k2, 33);\n        k2.multiply(mconst1);\n        h2.xor(k2);\n      case 8:\n        k1.xor(fromSignedByte(data[offset+7]).shiftLeft(56));\n      case 7:\n        k1.xor(fromSignedByte(data[offset+6]).shiftLeft(48));\n      case 6:\n        k1.xor(fromSignedByte(data[offset+5]).shiftLeft(40));\n      case 5:\n        k1.xor(fromSignedByte(data[offset+4]).shiftLeft(32));\n      case 4:\n        k1.xor(fromSignedByte(data[offset+3]).shiftLeft(24));\n      case 3:\n        k1.xor(fromSignedByte(data[offset+2]).shiftLeft(16));\n      case 2:\n        k1.xor(fromSignedByte(data[offset+1]).shiftLeft(8));\n      case 1:\n        k1.xor(fromSignedByte(data[offset]));\n        k1.multiply(mconst1);\n        this.rotl64(k1,31);\n        k1.multiply(mconst2);\n        h1.xor(k1);\n    }\n    /* eslint-enable no-fallthrough */\n\n    h1.xor(MutableLong.fromNumber(length));\n    h2.xor(MutableLong.fromNumber(length));\n\n    h1.add(h2);\n    h2.add(h1);\n\n\n    this.fmix(h1);\n    this.fmix(h2);\n\n    h1.add(h2);\n\n    return new token.Murmur3Token(h1);\n  }\n\n  /**\n   *\n   * @param {Array<Number>} key\n   * @param {Number} offset\n   * @param {Number} index\n   * @return {MutableLong}\n   */\n  getBlock(key, offset, index) {\n    const i8 = index << 3;\n    const blockOffset = offset + i8;\n    return new MutableLong(\n      (key[blockOffset]) | (key[blockOffset + 1] << 8),\n      (key[blockOffset + 2]) | (key[blockOffset + 3] << 8),\n      (key[blockOffset + 4]) | (key[blockOffset + 5] << 8),\n      (key[blockOffset + 6]) | (key[blockOffset + 7] << 8)\n    );\n  }\n\n  /**\n   * @param {MutableLong} v\n   * @param {Number} n\n   */\n  rotl64(v, n) {\n    const left = v.clone().shiftLeft(n);\n    v.shiftRightUnsigned(64 - n).or(left);\n  }\n\n  /** @param {MutableLong} k */\n  fmix(k) {\n    k.xor(new MutableLong(k.getUint16(2) >>> 1 | ((k.getUint16(3) << 15) & 0xffff), k.getUint16(3) >>> 1, 0, 0));\n    k.multiply(mconst3);\n    const other = new MutableLong(\n      (k.getUint16(2) >>> 1) | ((k.getUint16(3) << 15) & 0xffff),\n      k.getUint16(3) >>> 1,\n      0,\n      0\n    );\n    k.xor(other);\n    k.multiply(mconst4);\n    k.xor(new MutableLong(k.getUint16(2) >>> 1 | (k.getUint16(3) << 15 & 0xffff), k.getUint16(3) >>> 1, 0, 0));\n  }\n\n  /**\n   * Parses a int64 decimal string representation into a MutableLong.\n   * @param {String} value\n   * @returns {Murmur3Token}\n   */\n  parse(value) {\n    return new token.Murmur3Token(MutableLong.fromString(value));\n  }\n\n  minToken() {\n    if (!this._minToken) {\n      // minimum long value.\n      this._minToken = this.parse('-9223372036854775808');\n    }\n    return this._minToken;\n  }\n\n  maxToken() {\n    if (!this._maxToken) {\n      this._maxToken = this.parse('9223372036854775807');\n    }\n    return this._maxToken;\n  }\n\n  maxValue() {\n    if (!this._maxValue) {\n      this._maxValue = Integer.fromString('9223372036854775807');\n    }\n    return this._maxValue;\n  }\n\n  minValue() {\n    if (!this._minValue) {\n      this._minValue = Integer.fromString('-9223372036854775808');\n    }\n    return this._minValue;\n  }\n\n  ringLength() {\n    if (!this._ringLength) {\n      this._ringLength = this.maxValue().subtract(this.minValue());\n    }\n    return this._ringLength;\n  }\n\n  split(start, end, numberOfSplits) {\n    // ]min, min] means the whole ring.\n    if (start.equals(end) && start.equals(this.minToken())) {\n      end = this.maxToken();\n    }\n\n    const startVal = Integer.fromString(start.getValue().toString());\n    const endVal = Integer.fromString(end.getValue().toString());\n\n    let range = endVal.subtract(startVal);\n    if (range.isNegative()) {\n      range = range.add(this.ringLength());\n    }\n\n    const values = this.splitBase(startVal, range, this.maxValue(), this.ringLength(), numberOfSplits);\n    return values.map(v => this.parse(v.toString()));\n  }\n\n  stringify(token) {\n    // Get the underlying MutableLong\n    const value = token.getValue();\n    // We need a way to uniquely represent a token, it doesn't have to be the decimal string representation\n    // Using the uint16 avoids divisions and other expensive operations on the longs\n    return value.getUint16(0) + ',' + value.getUint16(1) + ',' + value.getUint16(2) + ',' + value.getUint16(3);\n  }\n}\n\n/**\n * Uniformly distributes data across the cluster based on MD5 hash values.\n */\nclass RandomTokenizer extends Tokenizer {\n  constructor() {\n    super();\n    // eslint-disable-next-line\n    this._crypto = require('crypto');\n  }\n\n  /**\n   * @param {Buffer|Array} value\n   * @returns {RandomToken}\n   */\n  hash(value) {\n    if (util.isArray(value)) {\n      value = utils.allocBufferFromArray(value);\n    }\n    const hashedValue = this._crypto.createHash('md5').update(value).digest();\n    return new token.RandomToken(Integer.fromBuffer(hashedValue).abs());\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parse(value) {\n    return new token.RandomToken(Integer.fromString(value));\n  }\n\n  minToken() {\n    if (!this._minToken) {\n      this._minToken = this.parse('-1');\n    }\n    return this._minToken;\n  }\n\n  maxValue() {\n    if (!this._maxValue) {\n      this._maxValue = Integer.fromNumber(Math.pow(2, 127));\n    }\n    return this._maxValue;\n  }\n\n  maxToken() {\n    if (!this._maxToken) {\n      this._maxToken = new token.RandomToken(this.maxValue());\n    }\n    return this._maxToken;\n  }\n\n  ringLength() {\n    if (!this._ringLength) {\n      this._ringLength = this.maxValue().add(Integer.ONE);\n    }\n    return this._ringLength;\n  }\n\n  split(start, end, numberOfSplits) {\n    // ]min, min] means the whole ring.\n    if (start.equals(end) && start.equals(this.minToken())) {\n      end = this.maxToken();\n    }\n\n    const startVal = start.getValue();\n    const endVal = end.getValue();\n\n    let range = endVal.subtract(startVal);\n    if (range.lessThan(Integer.ZERO)) {\n      range = range.add(this.ringLength());\n    }\n\n    const values = this.splitBase(startVal, range, this.maxValue(), this.ringLength(), numberOfSplits);\n    return values.map(v => new token.RandomToken(v));\n  }\n}\n\nclass ByteOrderedTokenizer extends Tokenizer {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @param {Buffer} value\n   * @returns {ByteOrderedToken}\n   */\n  hash(value) {\n    // strip any trailing zeros as tokens with trailing zeros are equivalent\n    // to those who don't have them.\n    if (util.isArray(value)) {\n      value = utils.allocBufferFromArray(value);\n    }\n    let zeroIndex = value.length;\n    for(let i = value.length - 1; i > 0; i--) {\n      if(value[i] === 0) {\n        zeroIndex = i;\n      } else {\n        break;\n      }\n    }\n    return new token.ByteOrderedToken(value.slice(0, zeroIndex));\n  }\n\n  stringify(token) {\n    return token.getValue().toString('hex');\n  }\n\n  parse(value) {\n    return this.hash(utils.allocBufferFromString(value, 'hex'));\n  }\n\n  minToken() {\n    if (!this._minToken) {\n      this._minToken = this.hash([]);\n    }\n    return this._minToken;\n  }\n\n  _toNumber(buffer, significantBytes) {\n    // Convert a token's byte array to a number in order to perform computations.\n    // This depends on the number of significant bytes that is used to normalize all tokens\n    // to the same size.  For example if the token is 0x01 but significant bytes is 2, the\n    // result is 0x0100.\n    let target = buffer;\n    if(buffer.length !== significantBytes) {\n      target = Buffer.alloc(significantBytes);\n      buffer.copy(target);\n    }\n\n    // similar to Integer.fromBuffer except we force the sign to 0.\n    const bits = new Array(Math.ceil(target.length / 4));\n    for (let i = 0; i < bits.length; i++) {\n      let offset = target.length - ((i + 1) * 4);\n      let value;\n      if (offset < 0) {\n        //The buffer length is not multiple of 4\n        offset = offset + 4;\n        value = 0;\n        for (let j = 0; j < offset; j++) {\n          const byte = target[j];\n          value = value | (byte << (offset - j - 1) * 8);\n        }\n      }\n      else {\n        value = target.readInt32BE(offset);\n      }\n      bits[i] = value;\n    }\n    return new Integer(bits, 0);\n  }\n\n  _toBuffer(number, significantBytes) {\n    // Convert numeric representation back to a buffer.\n    const buffer = Integer.toBuffer(number);\n    if (buffer.length === significantBytes) {\n      return buffer;\n    }\n\n    // if first byte is a sign byte, skip it.\n    let start, length;\n    if (buffer[0] === 0) {\n      start = 1;\n      length = buffer.length - 1;\n    } else {\n      start = 0;\n      length = buffer.length;\n    }\n\n    const target = Buffer.alloc(significantBytes);\n    buffer.copy(target, significantBytes - length, start, length + start);\n    return target;\n  }\n\n  split(start, end, numberOfSplits) {\n    const tokenOrder = start.compare(end);\n\n    if (tokenOrder === 0 && start.equals(this.minToken())) {\n      throw new Error(\"Cannot split whole ring with ordered partitioner\");\n    }\n\n    let startVal, endVal, range, ringLength, ringEnd;\n    const intNumberOfSplits = Integer.fromNumber(numberOfSplits);\n    // Since tokens are compared lexicographically, convert to numbers using the\n    // largest length (i.e. given 0x0A and 0x0BCD, switch to 0x0A00 and 0x0BCD)\n    let significantBytes = Math.max(start.getValue().length, end.getValue().length);\n    if (tokenOrder < 0) {\n      let addedBytes = 0;\n      while (true) {\n        startVal = this._toNumber(start.getValue(), significantBytes);\n        endVal = this._toNumber(end.getValue(), significantBytes);\n        range = endVal.subtract(startVal);\n        if (addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {\n          break;\n        }\n        significantBytes += 1;\n        addedBytes += 1;\n      }\n    } else {\n      let addedBytes = 0;\n      while (true) {\n        startVal = this._toNumber(start.getValue(), significantBytes);\n        endVal = this._toNumber(end.getValue(), significantBytes);\n        ringLength = Integer.fromNumber(Math.pow(2, significantBytes * 8));\n        ringEnd = ringLength.subtract(Integer.ONE);\n        range = endVal.subtract(startVal).add(ringLength);\n        if (addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {\n          break;\n        }\n        significantBytes += 1;\n        addedBytes += 1;\n      }\n    }\n\n    const values = this.splitBase(startVal, range, ringEnd, ringLength, numberOfSplits);\n    return values.map(v => new token.ByteOrderedToken(this._toBuffer(v, significantBytes)));\n  }\n}\n\n/**\n * @param {Number} value\n * @return {MutableLong}\n */\nfunction fromSignedByte(value) {\n  if (value < 128) {\n    return new MutableLong(value, 0, 0, 0);\n  }\n  return new MutableLong((value - 256) & 0xffff, 0xffff, 0xffff, 0xffff);\n}\n\nexports.Murmur3Tokenizer = Murmur3Tokenizer;\nexports.RandomTokenizer = RandomTokenizer;\nexports.ByteOrderedTokenizer = ByteOrderedTokenizer;\n","'use strict';\n\n/**\n * Tracker module.\n * @module tracker\n */\n\nexports.RequestLogger = require('./request-logger');\nexports.RequestTracker = require('./request-tracker');","'use strict';\n\nconst events = require('events');\nconst RequestTracker = require('./request-tracker');\nconst errors = require('../errors');\nconst format = require('util').format;\n\nconst nanosToMillis = 1000000;\nconst defaultMessageMaxQueryLength = 500;\nconst defaultMaxParameterValueLength = 50;\nconst defaultMaxErrorStackTraceLength = 200;\n\n/**\n * A request tracker that logs the requests executed through the session, according to a set of\n * configurable options.\n * @implements {module:tracker~RequestTracker}\n * @alias module:tracker~RequestLogger\n * @example <caption>Logging slow queries</caption>\n * const requestLogger = new RequestLogger({ slowThreshold: 1000 });\n * requestLogger.emitter.on('show', message => console.log(message));\n * // Add the requestLogger to the client options\n * const client = new Client({ contactPoints, requestTracker: requestLogger });\n */\nclass RequestLogger extends RequestTracker {\n\n  /**\n   * Creates a new instance of {@link RequestLogger}.\n   * @param {Object} options\n   * @param {Number} [options.slowThreshold] The threshold in milliseconds beyond which queries are considered 'slow'\n   * and logged as such by the driver.\n   * @param {Number} [options.requestSizeThreshold] The threshold in bytes beyond which requests are considered 'large'\n   * and logged as such by the driver.\n   * @param {Boolean} [options.logNormalRequests] Determines whether it should emit 'normal' events for every\n   * EXECUTE, QUERY and BATCH request executed successfully, useful only for debugging. This option can be modified\n   * after the client is connected using the property {@link RequestLogger#logNormalRequests}.\n   * @param {Boolean} [options.logErroredRequests] Determines whether it should emit 'failure' events for every\n   * EXECUTE, QUERY and BATCH request execution that resulted in an error. This option can be modified\n   * after the client is connected using the property {@link RequestLogger#logErroredRequests}.\n   * @param {Number} [options.messageMaxQueryLength] The maximum amount of characters that are logged from the query\n   * portion of the message. Defaults to 500.\n   * @param {Number} [options.messageMaxParameterValueLength] The maximum amount of characters of each query parameter\n   * value that will be included in the message. Defaults to 50.\n   * @param {Number} [options.messageMaxErrorStackTraceLength] The maximum amount of characters of the stack trace\n   * that will be included in the message. Defaults to 200.\n   */\n  constructor(options) {\n    super();\n    if (!options) {\n      throw new errors.ArgumentError('RequestLogger options parameter is required');\n    }\n\n    this._options = options;\n\n    /**\n     * Determines whether it should emit 'normal' events for every EXECUTE, QUERY and BATCH request executed\n     * successfully, useful only for debugging\n     * @type {Boolean}\n     */\n    this.logNormalRequests = this._options.logNormalRequests;\n\n    /**\n     * Determines whether it should emit 'failure' events for every EXECUTE, QUERY and BATCH request execution that\n     * resulted in an error\n     * @type {Boolean}\n     */\n    this.logErroredRequests = this._options.logErroredRequests;\n\n    /**\n     * The object instance that emits <code>'slow'</code>, <code>'large'</code>, <code>'normal'</code> and\n     * <code>'failure'</code> events.\n     * @type {EventEmitter}\n     */\n    this.emitter = new events.EventEmitter();\n  }\n\n  /**\n   * Logs message if request execution was deemed too slow, large or if normal requests are logged.\n   * @override\n   */\n  onSuccess(host, query, parameters, execOptions, requestLength, responseLength, latency) {\n    if (this._options.slowThreshold > 0 && toMillis(latency) > this._options.slowThreshold) {\n      this._logSlow(host, query, parameters, execOptions, requestLength, responseLength, latency);\n    }\n    else if (this._options.requestSizeThreshold > 0 && requestLength > this._options.requestSizeThreshold) {\n      this._logLargeRequest(host, query, parameters, execOptions, requestLength, responseLength, latency);\n    }\n    else if (this.logNormalRequests) {\n      this._logNormalRequest(host, query, parameters, execOptions, requestLength, responseLength, latency);\n    }\n  }\n\n  /**\n   * Logs message if request execution was too large and/or encountered an error.\n   * @override\n   */\n  onError(host, query, parameters, execOptions, requestLength, err, latency) {\n    if (this._options.requestSizeThreshold > 0 && requestLength > this._options.requestSizeThreshold) {\n      this._logLargeErrorRequest(host, query, parameters, execOptions, requestLength, err, latency);\n    }\n    else if (this.logErroredRequests) {\n      this._logErrorRequest(host, query, parameters, execOptions, requestLength, err, latency);\n    }\n  }\n\n  _logSlow(host, query, parameters, execOptions, requestLength, responseLength, latency) {\n    const message = format('[%s] Slow request, took %d ms (%s): %s', host.address, Math.floor(toMillis(latency)),\n      getPayloadSizes(requestLength, responseLength), getStatementInfo(query, parameters, execOptions, this._options));\n    this.emitter.emit('slow', message);\n  }\n\n  _logLargeRequest(host, query, parameters, execOptions, requestLength, responseLength, latency) {\n    const message = format('[%s] Request exceeded length, %s (took %d ms): %s', host.address,\n      getPayloadSizes(requestLength, responseLength), ~~toMillis(latency),\n      getStatementInfo(query, parameters, execOptions, this._options));\n    this.emitter.emit('large', message);\n  }\n\n  _logNormalRequest(host, query, parameters, execOptions, requestLength, responseLength, latency) {\n    const message = format('[%s] Request completed normally, took %d ms (%s): %s', host.address, ~~toMillis(latency),\n      getPayloadSizes(requestLength, responseLength), getStatementInfo(query, parameters, execOptions, this._options));\n    this.emitter.emit('normal', message);\n  }\n\n  _logLargeErrorRequest(host, query, parameters, execOptions, requestLength, err, latency) {\n    const maxStackTraceLength = this._options.messageMaxErrorStackTraceLength || defaultMaxErrorStackTraceLength;\n    const message = format('[%s] Request exceeded length and execution failed, %s (took %d ms): %s; error: %s',\n      host.address, getPayloadSizes(requestLength), ~~toMillis(latency),\n      getStatementInfo(query, parameters, execOptions, this._options), err.stack.substr(0, maxStackTraceLength));\n\n    // Use 'large' event and not 'failure' as this log is caused by exceeded length\n    this.emitter.emit('large', message);\n  }\n\n  _logErrorRequest(host, query, parameters, execOptions, requestLength, err, latency) {\n    const maxStackTraceLength = this._options.messageMaxErrorStackTraceLength || defaultMaxErrorStackTraceLength;\n    const message = format('[%s] Request execution failed, took %d ms (%s): %s; error: %s', host.address,\n      ~~toMillis(latency), getPayloadSizes(requestLength),\n      getStatementInfo(query, parameters, execOptions, this._options), err.stack.substr(0, maxStackTraceLength));\n\n    // Avoid using 'error' as its a special event\n    this.emitter.emit('failure', message);\n  }\n}\n\nfunction toMillis(latency) {\n  return latency[0] * 1000 + latency[1] / nanosToMillis;\n}\n\nfunction getStatementInfo(query, parameters, execOptions, options) {\n  const maxQueryLength = options.messageMaxQueryLength || defaultMessageMaxQueryLength;\n  const maxParameterLength = options.messageMaxParameterValueLength || defaultMaxParameterValueLength;\n\n  if (Array.isArray(query)) {\n    return getBatchStatementInfo(query, execOptions, maxQueryLength, maxParameterLength);\n  }\n\n  // String concatenation is usually faster than Array#join() in V8\n  let message = query.substr(0, maxQueryLength);\n  const remaining = maxQueryLength - message.length - 1;\n  message += getParametersInfo(parameters, remaining, maxParameterLength);\n\n  if (!execOptions.isPrepared()) {\n    // This part of the message is not accounted for in \"maxQueryLength\"\n    message += ' (not prepared)';\n  }\n\n  return message;\n}\n\nfunction getBatchStatementInfo(queries, execOptions, maxQueryLength, maxParameterLength) {\n  // This part of the message is not accounted for in \"maxQueryLength\"\n  let message = (execOptions.isBatchLogged() ? 'LOGGED ' : '') + 'BATCH w/ ' + queries.length +\n    (!execOptions.isPrepared() ? ' not prepared' : '') + ' queries (';\n  let remaining = maxQueryLength;\n  let i;\n\n  for (i = 0; i < queries.length && remaining > 0; i++) {\n    let q = queries[i];\n    const params = q.params;\n    if (typeof q !== 'string') {\n      q = q.query;\n    }\n\n    if (i > 0) {\n      message += ',';\n      remaining--;\n    }\n\n    const queryLength = Math.min(remaining, q.length);\n    message += q.substr(0, queryLength);\n    remaining -= queryLength;\n\n    if (remaining <= 0) {\n      break;\n    }\n\n    const parameters = getParametersInfo(params, remaining, maxParameterLength);\n    remaining -= parameters.length;\n    message += parameters;\n  }\n\n  message += i < queries.length ? ',...)' : ')';\n  return message;\n}\n\nfunction getParametersInfo(params, remaining, maxParameterLength) {\n  if (remaining <= 3) {\n    // We need at least 3 chars to describe the parameters\n    // its OK to add more chars in an effort to be descriptive\n    return ' [...]';\n  }\n\n  if (!params) {\n    return ' []';\n  }\n\n  let paramStringifier = (index, length) => formatParam(params[index], length);\n  if (!Array.isArray(params)) {\n    const obj = params;\n    params = Object.keys(params);\n    paramStringifier = (index, length) => {\n      const key = params[index];\n      let result = key.substr(0, length);\n      const rem = length - result.length - 1;\n      if (rem <= 0) {\n        return result;\n      }\n      result += \":\" + formatParam(obj[key], rem);\n      return result;\n    };\n  }\n\n  let message = ' [';\n  let i;\n  for (i = 0; remaining > 0 && i < params.length; i++) {\n    if (i > 0) {\n      message += ',';\n      remaining--;\n    }\n\n    const paramString = paramStringifier(i, Math.min(maxParameterLength, remaining));\n    remaining -= paramString.length;\n    message += paramString;\n  }\n\n  if (i < params.length) {\n    message += '...';\n  }\n\n  message += ']';\n  return message;\n}\n\nfunction formatParam(value, maxLength) {\n  if (value === undefined) {\n    return 'undefined';\n  }\n\n  if (value === null) {\n    return 'null';\n  }\n\n  return value.toString().substr(0, maxLength);\n}\n\nfunction getPayloadSizes(requestLength, responseLength) {\n  let message = 'request size ' + formatSize(requestLength);\n  if (responseLength !== undefined) {\n    message += ' / response size ' + formatSize(responseLength);\n  }\n  return message;\n}\n\nfunction formatSize(length) {\n  return length > 1000 ? Math.round(length / 1024) + ' KB' : length + ' bytes';\n}\n\nmodule.exports = RequestLogger;","'use strict';\n\n/**\n * Tracks request execution for a {@link Client}.\n * <p>\n *   A {@link RequestTracker} can be configured in the client options. The <code>Client</code> will execute\n *   {@link RequestTracker#onSuccess} or {@link RequestTracker#onError} for every query or batch\n *   executed (QUERY, EXECUTE and BATCH requests).\n * </p>\n * @interface\n * @alias module:tracker~RequestTracker\n */\nclass RequestTracker {\n\n  /**\n   * Invoked each time a query or batch request succeeds.\n   * @param {Host} host The node that acted as coordinator of the request.\n   * @param {String|Array} query In the case of prepared or unprepared query executions, the provided\n   * query string. For batch requests, an Array containing the queries and parameters provided.\n   * @param {Array|Object|null} parameters In the case of prepared or unprepared query executions, the provided\n   * parameters.\n   * @param {ExecutionOptions} executionOptions The information related to the execution of the request.\n   * @param {Number} requestLength Length of the body of the request.\n   * @param {Number} responseLength Length of the body of the response.\n   * @param {Array<Number>} latency An array containing [seconds, nanoseconds] tuple, where nanoseconds is the\n   * remaining part of the real time that can't be represented in second precision (see <code>process.hrtime()</code>).\n   */\n  onSuccess(host, query, parameters, executionOptions, requestLength, responseLength, latency) {\n\n  }\n\n  /**\n   * Invoked each time a query or batch request fails.\n   * @param {Host} host The node that acted as coordinator of the request.\n   * @param {String|Array} query In the case of prepared or unprepared query executions, the provided\n   * query string. For batch requests, an Array containing the queries and parameters provided.\n   * @param {Array|Object|null} parameters In the case of prepared or unprepared query executions, the provided\n   * parameters.\n   * @param {ExecutionOptions} executionOptions The information related to the execution of the request.\n   * @param {Number} requestLength Length of the body of the request. When the failure occurred before the request was\n   * written to the wire, the length will be <code>0</code>.\n   * @param {Error} err The error that caused that caused the request to fail.\n   * @param {Array<Number>} latency An array containing [seconds, nanoseconds] tuple, where nanoseconds is the\n   * remaining part of the real time that can't be represented in second precision (see <code>process.hrtime()</code>).\n   */\n  onError(host, query, parameters, executionOptions, requestLength, err, latency) {\n\n  }\n\n  /**\n   * Invoked when the Client is being shutdown.\n   */\n  shutdown() {\n\n  }\n}\n\nmodule.exports = RequestTracker;","'use strict';\nconst Integer = require('./integer');\nconst utils = require('../utils');\n\n/** @module types */\n/**\n * Constructs an immutable arbitrary-precision signed decimal number.\n * A <code>BigDecimal</code> consists of an [arbitrary precision integer]{@link module:types~Integer}\n * <i>unscaled value</i> and a 32-bit integer <i>scale</i>.  If zero\n * or positive, the scale is the number of digits to the right of the\n * decimal point.  If negative, the unscaled value of the number is\n * multiplied by ten to the power of the negation of the scale.  The\n * value of the number represented by the <code>BigDecimal</code> is\n * therefore <tt>(unscaledValue &times; 10<sup>-scale</sup>)</tt>.\n * @class\n * @classdesc The <code>BigDecimal</code> class provides operations for\n * arithmetic, scale manipulation, rounding, comparison and\n * format conversion.  The {@link #toString} method provides a\n * canonical representation of a <code>BigDecimal</code>.\n * @param {Integer|Number} unscaledValue The integer part of the decimal.\n * @param {Number} scale The scale of the decimal.\n * @constructor\n */\nfunction BigDecimal(unscaledValue, scale) {\n  if (typeof unscaledValue === 'number') {\n    unscaledValue = Integer.fromNumber(unscaledValue);\n  }\n  /**\n   * @type {Integer}\n   * @private\n   */\n  this._intVal = unscaledValue;\n  /**\n   * @type {Number}\n   * @private\n   */\n  this._scale = scale;\n}\n\n/**\n * Returns the BigDecimal representation of a buffer composed of the scale (int32BE) and the unsigned value (varint BE)\n * @param {Buffer} buf\n * @returns {BigDecimal}\n */\nBigDecimal.fromBuffer = function (buf) {\n  const scale = buf.readInt32BE(0);\n  const unscaledValue = Integer.fromBuffer(buf.slice(4));\n  return new BigDecimal(unscaledValue, scale);\n};\n\n/**\n * Returns a buffer representation composed of the scale as a BE int 32 and the unsigned value as a BE varint\n * @param {BigDecimal} value\n * @returns {Buffer}\n */\nBigDecimal.toBuffer = function (value) {\n  const unscaledValueBuffer = Integer.toBuffer(value._intVal);\n  const scaleBuffer = utils.allocBufferUnsafe(4);\n  scaleBuffer.writeInt32BE(value._scale, 0);\n  return Buffer.concat([scaleBuffer, unscaledValueBuffer], scaleBuffer.length + unscaledValueBuffer.length);\n};\n\n/**\n * Returns a BigDecimal representation of the string\n * @param {String} value\n * @returns {BigDecimal}\n */\nBigDecimal.fromString = function (value) {\n  if (!value) {\n    throw new TypeError('Invalid null or undefined value');\n  }\n  value = value.trim();\n  const scaleIndex = value.indexOf('.');\n  let scale = 0;\n  if (scaleIndex >= 0) {\n    scale = value.length - 1 - scaleIndex;\n    value = value.substr(0, scaleIndex) + value.substr(scaleIndex + 1);\n  }\n  return new BigDecimal(Integer.fromString(value), scale);\n};\n\n/**\n * Returns a BigDecimal representation of the Number\n * @param {Number} value\n * @returns {BigDecimal}\n */\nBigDecimal.fromNumber = function (value) {\n  if (isNaN(value)) {\n    return new BigDecimal(Integer.ZERO, 0);\n  }\n  let textValue = value.toString();\n  if (textValue.indexOf('e') >= 0) {\n    //get until scale 20\n    textValue = value.toFixed(20);\n  }\n  return BigDecimal.fromString(textValue);\n};\n\n/**\n * Returns true if the value of the BigDecimal instance and other are the same\n * @param {BigDecimal} other\n * @returns {Boolean}\n */\nBigDecimal.prototype.equals = function (other) {\n  return ((other instanceof BigDecimal) && this.compare(other) === 0);\n};\n\nBigDecimal.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * @param {BigDecimal} other\n * @returns {boolean}\n */\nBigDecimal.prototype.notEquals = function (other) {\n  return !this.equals(other);\n};\n\n/**\n * Compares this BigDecimal with the given one.\n * @param {BigDecimal} other Integer to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nBigDecimal.prototype.compare = function (other) {\n  const diff = this.subtract(other);\n  if (diff.isNegative()) {\n    return -1;\n  }\n  if (diff.isZero()) {\n    return 0;\n  }\n  return +1;\n};\n\n/**\n * Returns the difference of this and the given BigDecimal.\n * @param {BigDecimal} other The BigDecimal to subtract from this.\n * @return {!BigDecimal} The BigDecimal result.\n */\nBigDecimal.prototype.subtract = function (other) {\n  const first = this;\n  if (first._scale === other._scale) {\n    return new BigDecimal(first._intVal.subtract(other._intVal), first._scale);\n  }\n  let diffScale;\n  let unscaledValue;\n  if (first._scale < other._scale) {\n    //The scale of this is lower\n    diffScale = other._scale - first._scale;\n    //multiple this unScaledValue to compare in the same scale\n    unscaledValue = first._intVal\n      .multiply(Integer.fromNumber(Math.pow(10, diffScale)))\n      .subtract(other._intVal);\n    return new BigDecimal(unscaledValue, other._scale);\n  }\n  //The scale of this is higher\n  diffScale = first._scale - other._scale;\n  //multiple this unScaledValue to compare in the same scale\n  unscaledValue = first._intVal\n    .subtract(\n      other._intVal.multiply(Integer.fromNumber(Math.pow(10, diffScale))));\n  return new BigDecimal(unscaledValue, first._scale);\n};\n\n/**\n * Returns the sum of this and the given <code>BigDecimal</code>.\n * @param {BigDecimal} other The BigDecimal to sum to this.\n * @return {!BigDecimal} The BigDecimal result.\n */\nBigDecimal.prototype.add = function (other) {\n  const first = this;\n  if (first._scale === other._scale) {\n    return new BigDecimal(first._intVal.add(other._intVal), first._scale);\n  }\n  let diffScale;\n  let unscaledValue;\n  if (first._scale < other._scale) {\n    //The scale of this is lower\n    diffScale = other._scale - first._scale;\n    //multiple this unScaledValue to compare in the same scale\n    unscaledValue = first._intVal\n      .multiply(Integer.fromNumber(Math.pow(10, diffScale)))\n      .add(other._intVal);\n    return new BigDecimal(unscaledValue, other._scale);\n  }\n  //The scale of this is higher\n  diffScale = first._scale - other._scale;\n  //multiple this unScaledValue to compare in the same scale\n  unscaledValue = first._intVal\n    .add(\n      other._intVal.multiply(Integer.fromNumber(Math.pow(10, diffScale))));\n  return new BigDecimal(unscaledValue, first._scale);\n};\n\n/**\n * Returns true if the current instance is greater than the other\n * @param {BigDecimal} other\n * @returns {boolean}\n */\nBigDecimal.prototype.greaterThan = function (other) {\n  return this.compare(other) === 1;\n};\n\n/** @return {boolean} Whether this value is negative. */\nBigDecimal.prototype.isNegative = function () {\n  return this._intVal.isNegative();\n};\n\n/** @return {boolean} Whether this value is zero. */\nBigDecimal.prototype.isZero = function () {\n  return this._intVal.isZero();\n};\n\n/**\n * Returns the string representation of this <code>BigDecimal</code>\n * @returns {string}\n */\nBigDecimal.prototype.toString = function () {\n  let intString = this._intVal.toString();\n  if (this._scale === 0) {\n    return intString;\n  }\n  let signSymbol = '';\n  if (intString.charAt(0) === '-') {\n    signSymbol = '-';\n    intString = intString.substr(1);\n  }\n  let separatorIndex = intString.length - this._scale;\n  if (separatorIndex <= 0) {\n    //add zeros at the beginning, plus an additional zero\n    intString = utils.stringRepeat('0', (-separatorIndex) + 1) + intString;\n    separatorIndex = intString.length - this._scale;\n  }\n  return signSymbol + intString.substr(0, separatorIndex) + '.' + intString.substr(separatorIndex);\n};\n\n/**\n * Returns a Number representation of this <code>BigDecimal</code>.\n * @returns {Number}\n */\nBigDecimal.prototype.toNumber = function () {\n  return parseFloat(this.toString());\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nBigDecimal.prototype.toJSON = function () {\n  return this.toString();\n};\n\n\nmodule.exports = BigDecimal;","'use strict';\nconst Long = require('long');\nconst util = require('util');\nconst utils = require('../utils');\n\n/** @module types */\n\n// Reuse the same buffers that should perform slightly better than built-in buffer pool\nconst reusableBuffers = {\n  months: utils.allocBuffer(9),\n  days: utils.allocBuffer(9),\n  nanoseconds: utils.allocBuffer(9)\n};\n\nconst maxInt32 = 0x7FFFFFFF;\nconst longOneThousand = Long.fromInt(1000);\nconst nanosPerMicro = longOneThousand;\nconst nanosPerMilli = longOneThousand.multiply(nanosPerMicro);\nconst nanosPerSecond = longOneThousand.multiply(nanosPerMilli);\nconst nanosPerMinute = Long.fromInt(60).multiply(nanosPerSecond);\nconst nanosPerHour = Long.fromInt(60).multiply(nanosPerMinute);\nconst daysPerWeek = 7;\nconst monthsPerYear = 12;\nconst standardRegex = /(\\d+)(y|mo|w|d|h|s|ms|us|µs|ns|m)/gi;\nconst iso8601Regex = /P((\\d+)Y)?((\\d+)M)?((\\d+)D)?(T((\\d+)H)?((\\d+)M)?((\\d+)S)?)?/;\nconst iso8601WeekRegex = /P(\\d+)W/;\nconst iso8601AlternateRegex = /P(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n\n/**\n * Creates a new instance of {@link Duration}.\n * @classdesc\n * Represents a duration. A duration stores separately months, days, and seconds due to the fact that the number of\n * days in a month varies, and a day can have 23 or 25 hours if a daylight saving is involved.\n * @param {Number} months The number of months.\n * @param {Number} days The number of days.\n * @param {Number|Long} nanoseconds The number of nanoseconds.\n * @constructor\n */\nfunction Duration(months, days, nanoseconds) {\n  /**\n   * Gets the number of months.\n   * @type {Number}\n   */\n  this.months = months;\n  /**\n   * Gets the number of days.\n   * @type {Number}\n   */\n  this.days = days;\n  /**\n   * Gets the number of nanoseconds represented as a <code>int64</code>.\n   * @type {Long}\n   */\n  this.nanoseconds = typeof nanoseconds === 'number' ? Long.fromNumber(nanoseconds) : nanoseconds;\n}\n\nDuration.prototype.equals = function (other) {\n  if (!(other instanceof Duration)) {\n    return false;\n  }\n  return this.months === other.months &&\n    this.days === other.days &&\n    this.nanoseconds.equals(other.nanoseconds);\n};\n\n/**\n * Serializes the duration and returns the representation of the value in bytes.\n * @returns {Buffer}\n */\nDuration.prototype.toBuffer = function () {\n  const lengthMonths = VIntCoding.writeVInt(Long.fromNumber(this.months), reusableBuffers.months);\n  const lengthDays = VIntCoding.writeVInt(Long.fromNumber(this.days), reusableBuffers.days);\n  const lengthNanoseconds = VIntCoding.writeVInt(this.nanoseconds, reusableBuffers.nanoseconds);\n  const buffer = utils.allocBufferUnsafe(lengthMonths + lengthDays + lengthNanoseconds);\n  reusableBuffers.months.copy(buffer, 0, 0, lengthMonths);\n  let offset = lengthMonths;\n  reusableBuffers.days.copy(buffer, offset, 0, lengthDays);\n  offset += lengthDays;\n  reusableBuffers.nanoseconds.copy(buffer, offset, 0, lengthNanoseconds);\n  return buffer;\n};\n\n/**\n * Returns the string representation of the value.\n * @return {string}\n */\nDuration.prototype.toString = function () {\n  let value = '';\n  function append(dividend, divisor, unit) {\n    if (dividend === 0 || dividend < divisor) {\n      return dividend;\n    }\n    // string concatenation is supposed to be fasted than join()\n    value += (dividend / divisor).toFixed(0) + unit;\n    return dividend % divisor;\n  }\n  function append64(dividend, divisor, unit) {\n    if (dividend.equals(Long.ZERO) || dividend.lessThan(divisor)) {\n      return dividend;\n    }\n    // string concatenation is supposed to be fasted than join()\n    value += dividend.divide(divisor).toString() + unit;\n    return dividend.modulo(divisor);\n  }\n  if (this.months < 0 || this.days < 0 || this.nanoseconds.isNegative()) {\n    value = '-';\n  }\n  let remainder = append(Math.abs(this.months), monthsPerYear, \"y\");\n  append(remainder, 1, \"mo\");\n  append(Math.abs(this.days), 1, \"d\");\n\n  if (!this.nanoseconds.equals(Long.ZERO)) {\n    const nanos = this.nanoseconds.isNegative() ? this.nanoseconds.negate() : this.nanoseconds;\n    remainder = append64(nanos, nanosPerHour, \"h\");\n    remainder = append64(remainder, nanosPerMinute, \"m\");\n    remainder = append64(remainder, nanosPerSecond, \"s\");\n    remainder = append64(remainder, nanosPerMilli, \"ms\");\n    remainder = append64(remainder, nanosPerMicro, \"us\");\n    append64(remainder, Long.ONE, \"ns\");\n  }\n  return value;\n};\n\n/**\n * Creates a new {@link Duration} instance from the binary representation of the value.\n * @param {Buffer} buffer\n * @returns {Duration}\n */\nDuration.fromBuffer = function (buffer) {\n  const offset = { value: 0 };\n  const months = VIntCoding.readVInt(buffer, offset).toNumber();\n  const days = VIntCoding.readVInt(buffer, offset).toNumber();\n  const nanoseconds = VIntCoding.readVInt(buffer, offset);\n  return new Duration(months, days, nanoseconds);\n};\n\n/**\n * Creates a new {@link Duration} instance from the string representation of the value.\n * <p>\n *   Accepted formats:\n * </p>\n * <ul>\n * <li>multiple digits followed by a time unit like: 12h30m where the time unit can be:\n *   <ul>\n *     <li>{@code y}: years</li>\n *     <li>{@code m}: months</li>\n *     <li>{@code w}: weeks</li>\n *     <li>{@code d}: days</li>\n *     <li>{@code h}: hours</li>\n *     <li>{@code m}: minutes</li>\n *     <li>{@code s}: seconds</li>\n *     <li>{@code ms}: milliseconds</li>\n *     <li>{@code us} or {@code µs}: microseconds</li>\n *     <li>{@code ns}: nanoseconds</li>\n *   </ul>\n * </li>\n * <li>ISO 8601 format:  <code>P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W</code></li>\n * <li>ISO 8601 alternative format: <code>P[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]</code></li>\n * </ul>\n * @param {String} input\n * @returns {Duration}\n */\nDuration.fromString = function (input) {\n  const isNegative = input.charAt(0) === '-';\n  const source = isNegative ? input.substr(1) : input;\n  if (source.charAt(0) === 'P') {\n    if (source.charAt(source.length - 1) === 'W') {\n      return parseIso8601WeekFormat(isNegative, source);\n    }\n    if (source.indexOf('-') > 0) {\n      return parseIso8601AlternativeFormat(isNegative, source);\n    }\n    return parseIso8601Format(isNegative, source);\n  }\n  return parseStandardFormat(isNegative, source);\n};\n\n/**\n * @param {Boolean} isNegative\n * @param {String} source\n * @returns {Duration}\n * @private\n */\nfunction parseStandardFormat(isNegative, source) {\n  const builder = new Builder(isNegative);\n  standardRegex.lastIndex = 0;\n  let matches;\n  while ((matches = standardRegex.exec(source)) && matches.length <= 3) {\n    builder.add(matches[1], matches[2]);\n  }\n  return builder.build();\n}\n\n/**\n * @param {Boolean} isNegative\n * @param {String} source\n * @returns {Duration}\n * @private\n */\nfunction parseIso8601Format(isNegative, source) {\n  const matches = iso8601Regex.exec(source);\n  if (!matches || matches[0] !== source) {\n    throw new TypeError(util.format(\"Unable to convert '%s' to a duration\", source));\n  }\n  const builder = new Builder(isNegative);\n  if (matches[1]) {\n    builder.addYears(matches[2]);\n  }\n  if (matches[3]) {\n    builder.addMonths(matches[4]);\n  }\n  if (matches[5]) {\n    builder.addDays(matches[6]);\n  }\n  if (matches[7]) {\n    if (matches[8]) {\n      builder.addHours(matches[9]);\n    }\n    if (matches[10]) {\n      builder.addMinutes(matches[11]);\n    }\n    if (matches[12]) {\n      builder.addSeconds(matches[13]);\n    }\n  }\n  return builder.build();\n}\n\n/**\n * @param {Boolean} isNegative\n * @param {String} source\n * @returns {Duration}\n * @private\n */\nfunction parseIso8601WeekFormat(isNegative, source) {\n  const matches = iso8601WeekRegex.exec(source);\n  if (!matches || matches[0] !== source) {\n    throw new TypeError(util.format(\"Unable to convert '%s' to a duration\", source));\n  }\n  return new Builder(isNegative)\n    .addWeeks(matches[1])\n    .build();\n}\n\n/**\n * @param {Boolean} isNegative\n * @param {String} source\n * @returns {Duration}\n * @private\n */\nfunction parseIso8601AlternativeFormat(isNegative, source) {\n  const matches = iso8601AlternateRegex.exec(source);\n  if (!matches || matches[0] !== source) {\n    throw new TypeError(util.format(\"Unable to convert '%s' to a duration\", source));\n  }\n  return new Builder(isNegative).addYears(matches[1])\n    .addMonths(matches[2])\n    .addDays(matches[3])\n    .addHours(matches[4])\n    .addMinutes(matches[5])\n    .addSeconds(matches[6])\n    .build();\n}\n\n/**\n * @param {Boolean} isNegative\n * @private\n * @constructor\n */\nfunction Builder(isNegative) {\n  this._isNegative = isNegative;\n  this._unitIndex = 0;\n  this._months = 0;\n  this._days = 0;\n  this._nanoseconds = Long.ZERO;\n  this._addMethods = {\n    'y': this.addYears,\n    'mo': this.addMonths,\n    'w': this.addWeeks,\n    'd': this.addDays,\n    'h': this.addHours,\n    'm': this.addMinutes,\n    's': this.addSeconds,\n    'ms': this.addMillis,\n    // µs\n    '\\u00B5s': this.addMicros,\n    'us': this.addMicros,\n    'ns': this.addNanos\n  };\n  this._unitByIndex = [\n    null, 'years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds', 'milliseconds', 'microseconds',\n    'nanoseconds'\n  ];\n}\n\nBuilder.prototype._validateOrder = function (unitIndex) {\n  if (unitIndex === this._unitIndex) {\n    throw new TypeError(util.format(\"Invalid duration. The %s are specified multiple times\", this._getUnitName(unitIndex)));\n  }\n\n  if (unitIndex <= this._unitIndex) {\n    throw new TypeError(util.format(\"Invalid duration. The %s should be after %s\",\n      this._getUnitName(this._unitIndex),\n      this._getUnitName(unitIndex)));\n  }\n  this._unitIndex = unitIndex;\n};\n\n/**\n * @param {Number} units\n * @param {Number} monthsPerUnit\n */\nBuilder.prototype._validateMonths = function(units, monthsPerUnit) {\n  this._validate32(units, (maxInt32 - this._months) / monthsPerUnit, \"months\");\n};\n\n/**\n * @param {Number} units\n * @param {Number} daysPerUnit\n */\nBuilder.prototype._validateDays = function(units, daysPerUnit) {\n  this._validate32(units, (maxInt32 - this._days) / daysPerUnit, \"days\");\n};\n\n/**\n * @param {Long} units\n * @param {Long} nanosPerUnit\n */\nBuilder.prototype._validateNanos = function(units, nanosPerUnit) {\n  this._validate64(units, Long.MAX_VALUE.subtract(this._nanoseconds).divide(nanosPerUnit), \"nanoseconds\");\n};\n\n/**\n * @param {Number} units\n * @param {Number} limit\n * @param {String} unitName\n */\nBuilder.prototype._validate32 = function(units, limit, unitName) {\n  if (units > limit) {\n    throw new TypeError(util.format('Invalid duration. The total number of %s must be less or equal to %s',\n      unitName,\n      maxInt32));\n  }\n};\n\n/**\n * @param {Long} units\n * @param {Long} limit\n * @param {String} unitName\n */\nBuilder.prototype._validate64 = function(units, limit, unitName) {\n  if (units.greaterThan(limit)) {\n    throw new TypeError(util.format('Invalid duration. The total number of %s must be less or equal to %s',\n      unitName,\n      Long.MAX_VALUE.toString()));\n  }\n};\n\nBuilder.prototype._getUnitName = function(unitIndex) {\n  const name = this._unitByIndex[+unitIndex];\n  if (!name) {\n    throw new Error('unknown unit index: ' + unitIndex);\n  }\n  return name;\n};\n\nBuilder.prototype.add = function (textValue, symbol) {\n  const addMethod = this._addMethods[symbol.toLowerCase()];\n  if (!addMethod) {\n    throw new TypeError(util.format(\"Unknown duration symbol '%s'\", symbol));\n  }\n  return addMethod.call(this, textValue);\n};\n\n/**\n * @param {String|Number} years\n * @return {Builder}\n */\nBuilder.prototype.addYears = function (years) {\n  const value = +years;\n  this._validateOrder(1);\n  this._validateMonths(value, monthsPerYear);\n  this._months += value * monthsPerYear;\n  return this;\n};\n\n/**\n * @param {String|Number} months\n * @return {Builder}\n */\nBuilder.prototype.addMonths = function(months) {\n  const value = +months;\n  this._validateOrder(2);\n  this._validateMonths(value, 1);\n  this._months += value;\n  return this;\n};\n\n/**\n * @param {String|Number} weeks\n * @return {Builder}\n */\nBuilder.prototype.addWeeks = function(weeks) {\n  const value = +weeks;\n  this._validateOrder(3);\n  this._validateDays(value, daysPerWeek);\n  this._days += value * daysPerWeek;\n  return this;\n};\n\n/**\n * @param {String|Number} days\n * @return {Builder}\n */\nBuilder.prototype.addDays = function(days) {\n  const value = +days;\n  this._validateOrder(4);\n  this._validateDays(value, 1);\n  this._days += value;\n  return this;\n};\n\n/**\n * @param {String|Long} hours\n * @return {Builder}\n */\nBuilder.prototype.addHours = function(hours) {\n  const value = typeof hours === 'string' ? Long.fromString(hours) : hours;\n  this._validateOrder(5);\n  this._validateNanos(value, nanosPerHour);\n  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerHour));\n  return this;\n};\n\n/**\n * @param {String|Long} minutes\n * @return {Builder}\n */\nBuilder.prototype.addMinutes = function(minutes) {\n  const value = typeof minutes === 'string' ? Long.fromString(minutes) : minutes;\n  this._validateOrder(6);\n  this._validateNanos(value, nanosPerMinute);\n  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMinute));\n  return this;\n};\n\n/**\n * @param {String|Long} seconds\n * @return {Builder}\n */\nBuilder.prototype.addSeconds = function(seconds) {\n  const value = typeof seconds === 'string' ? Long.fromString(seconds) : seconds;\n  this._validateOrder(7);\n  this._validateNanos(value, nanosPerSecond);\n  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerSecond));\n  return this;\n};\n\n/**\n * @param {String|Long} millis\n * @return {Builder}\n */\nBuilder.prototype.addMillis = function(millis) {\n  const value = typeof millis === 'string' ? Long.fromString(millis) : millis;\n  this._validateOrder(8);\n  this._validateNanos(value, nanosPerMilli);\n  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMilli));\n  return this;\n};\n\n/**\n * @param {String|Long} micros\n * @return {Builder}\n */\nBuilder.prototype.addMicros = function(micros) {\n  const value = typeof micros === 'string' ? Long.fromString(micros) : micros;\n  this._validateOrder(9);\n  this._validateNanos(value, nanosPerMicro);\n  this._nanoseconds = this._nanoseconds.add(value.multiply(nanosPerMicro));\n  return this;\n};\n\n/**\n * @param {String|Long} nanos\n * @return {Builder}\n */\nBuilder.prototype.addNanos = function(nanos) {\n  const value = typeof nanos === 'string' ? Long.fromString(nanos) : nanos;\n  this._validateOrder(10);\n  this._validateNanos(value, Long.ONE);\n  this._nanoseconds = this._nanoseconds.add(value);\n  return this;\n};\n\n/** @return {Duration} */\nBuilder.prototype.build = function () {\n  return (this._isNegative ?\n    new Duration(-this._months, -this._days, this._nanoseconds.negate()) :\n    new Duration(this._months, this._days, this._nanoseconds));\n};\n\n/**\n * Contains the methods for reading and writing vints into binary format.\n * Exposes only 2 internal methods, the rest are hidden.\n * @private\n */\nconst VIntCoding = (function () {\n  /** @param {Long} n */\n  function encodeZigZag64(n) {\n    //     (n << 1) ^ (n >> 63);\n    return n.toUnsigned().shiftLeft(1).xor(n.shiftRight(63));\n  }\n\n  /** @param {Long} n */\n  function decodeZigZag64(n) {\n    //     (n >>> 1) ^ -(n & 1);\n    return n.shiftRightUnsigned(1).xor(n.and(Long.ONE).negate());\n  }\n\n  /**\n   * @param {Long} value\n   * @param {Buffer} buffer\n   * @returns {Number}\n   */\n  function writeVInt(value, buffer) {\n    return writeUnsignedVInt(encodeZigZag64(value), buffer);\n  }\n\n  /**\n   * @param {Long} value\n   * @param {Buffer} buffer\n   * @returns {number}\n   */\n  function writeUnsignedVInt(value, buffer) {\n    const size = computeUnsignedVIntSize(value);\n    if (size === 1) {\n      buffer[0] = value.getLowBits();\n      return 1;\n    }\n    encodeVInt(value, size, buffer);\n    return size;\n  }\n\n  /**\n   * @param {Long} value\n   * @returns {number}\n   */\n  function computeUnsignedVIntSize(value) {\n    const magnitude = numberOfLeadingZeros(value.or(Long.ONE));\n    return (639 - magnitude * 9) >> 6;\n  }\n\n  /**\n   * @param {Long} value\n   * @param {Number} size\n   * @param {Buffer} buffer\n   */\n  function encodeVInt(value, size, buffer) {\n    const extraBytes = size - 1;\n    let intValue = value.getLowBits();\n    let i;\n    let intBytes = 4;\n    for (i = extraBytes; i >= 0 && (intBytes--) > 0; i--) {\n      buffer[i] = 0xFF & intValue;\n      intValue >>= 8;\n    }\n    intValue = value.getHighBits();\n    for (; i >= 0; i--) {\n      buffer[i] = 0xFF & intValue;\n      intValue >>= 8;\n    }\n    buffer[0] |= encodeExtraBytesToRead(extraBytes);\n  }\n  /**\n   * Returns the number of zero bits preceding the highest-order one-bit in the binary representation of the value.\n   * @param {Long} value\n   * @returns {Number}\n   */\n  function numberOfLeadingZeros(value) {\n    if (value.equals(Long.ZERO)) {\n      return 64;\n    }\n    let n = 1;\n    let x = value.getHighBits();\n    if (x === 0) {\n      n += 32;\n      x = value.getLowBits();\n    }\n    if (x >>> 16 === 0) {\n      n += 16;\n      x <<= 16;\n    }\n    if (x >>> 24 === 0) {\n      n += 8;\n      x <<= 8;\n    }\n    if (x >>> 28 === 0) {\n      n += 4;\n      x <<= 4;\n    }\n    if (x >>> 30 === 0) {\n      n += 2;\n      x <<= 2;\n    }\n    n -= x >>> 31;\n    return n;\n  }\n\n\n  function encodeExtraBytesToRead(extraBytesToRead) {\n    return ~(0xff >> extraBytesToRead);\n  }\n\n  /**\n   * @param {Buffer} buffer\n   * @param {{value: number}} offset\n   * @returns {Long}\n   */\n  function readVInt(buffer, offset) {\n    return decodeZigZag64(readUnsignedVInt(buffer, offset));\n  }\n\n  /**\n   * @param {Buffer} input\n   * @param {{ value: number}} offset\n   * @returns {Long}\n   */\n  function readUnsignedVInt(input, offset) {\n    const firstByte = input[offset.value++];\n    if ((firstByte & 0x80) === 0) {\n      return Long.fromInt(firstByte);\n    }\n    const sByteInt = fromSignedByteToInt(firstByte);\n    const size = numberOfExtraBytesToRead(sByteInt);\n    let result = Long.fromInt(sByteInt & firstByteValueMask(size));\n    for (let ii = 0; ii < size; ii++) {\n      const b = Long.fromInt(input[offset.value++]);\n      //       (result << 8) | b\n      result = result.shiftLeft(8).or(b);\n    }\n    return result;\n  }\n\n  function fromSignedByteToInt(value) {\n    if (value > 0x7f) {\n      return value - 0x0100;\n    }\n    return value;\n  }\n\n  function numberOfLeadingZerosInt32(i) {\n    if (i === 0) {\n      return 32;\n    }\n    let n = 1;\n    if (i >>> 16 === 0) {\n      n += 16;\n      i <<= 16;\n    }\n    if (i >>> 24 === 0) {\n      n += 8;\n      i <<= 8;\n    }\n    if (i >>> 28 === 0) {\n      n += 4;\n      i <<= 4;\n    }\n    if (i >>> 30 === 0) {\n      n += 2;\n      i <<= 2;\n    }\n    n -= i >>> 31;\n    return n;\n  }\n\n  /**\n   * @param {Number} firstByte\n   * @returns {Number}\n   */\n  function numberOfExtraBytesToRead(firstByte) {\n    // Instead of counting 1s of the byte, we negate and count 0 of the byte\n    return numberOfLeadingZerosInt32(~firstByte) - 24;\n  }\n\n  /**\n   * @param {Number} extraBytesToRead\n   * @returns {Number}\n   */\n  function firstByteValueMask(extraBytesToRead) {\n    return 0xff >> extraBytesToRead;\n  }\n\n  return {\n    readVInt: readVInt,\n    writeVInt: writeVInt\n  };\n})();\n\nmodule.exports = Duration;\n","'use strict';\nconst util = require('util');\n\nconst errors = require('../errors');\nconst TimeUuid = require('./time-uuid');\nconst Uuid = require('./uuid');\nconst protocolVersion = require('./protocol-version');\nconst utils = require('../utils');\n\n/** @module types */\n/**\n * Long constructor, wrapper of the internal library used: {@link https://github.com/dcodeIO/long.js Long.js}.\n * @constructor\n */\nconst Long = require('long');\n\n\n/**\n * Consistency levels\n * @type {Object}\n * @property {Number} any Writing: A write must be written to at least one node. If all replica nodes for the given row key are down, the write can still succeed after a hinted handoff has been written. If all replica nodes are down at write time, an ANY write is not readable until the replica nodes for that row have recovered.\n * @property {Number} one Returns a response from the closest replica, as determined by the snitch.\n * @property {Number} two Returns the most recent data from two of the closest replicas.\n * @property {Number} three Returns the most recent data from three of the closest replicas.\n * @property {Number} quorum Reading: Returns the record with the most recent timestamp after a quorum of replicas has responded regardless of data center. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes.\n * @property {Number} all Reading: Returns the record with the most recent timestamp after all replicas have responded. The read operation will fail if a replica does not respond. Writing: A write must be written to the commit log and memory table on all replica nodes in the cluster for that row.\n * @property {Number} localQuorum Reading: Returns the record with the most recent timestamp once a quorum of replicas in the current data center as the coordinator node has reported. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes in the same data center as the coordinator node. Avoids latency of inter-data center communication.\n * @property {Number} eachQuorum Reading: Returns the record once a quorum of replicas in each data center of the cluster has responded. Writing: Strong consistency. A write must be written to the commit log and memtable on a quorum of replica nodes in all data centers.\n * @property {Number} serial Achieves linearizable consistency for lightweight transactions by preventing unconditional updates.\n * @property {Number} localSerial Same as serial but confined to the data center. A write must be written conditionally to the commit log and memtable on a quorum of replica nodes in the same data center.\n * @property {Number} localOne Similar to One but only within the DC the coordinator is in.\n */\nconst consistencies = {\n  any:          0x00,\n  one:          0x01,\n  two:          0x02,\n  three:        0x03,\n  quorum:       0x04,\n  all:          0x05,\n  localQuorum:  0x06,\n  eachQuorum:   0x07,\n  serial:       0x08,\n  localSerial:  0x09,\n  localOne:     0x0a\n};\n\n/**\n * Mapping of consistency level codes to their string representation.\n * @type {Object}\n */\nconst consistencyToString = {};\nconsistencyToString[consistencies.any] = 'ANY';\nconsistencyToString[consistencies.one] = 'ONE';\nconsistencyToString[consistencies.two] = 'TWO';\nconsistencyToString[consistencies.three] = 'THREE';\nconsistencyToString[consistencies.quorum] = 'QUORUM';\nconsistencyToString[consistencies.all] = 'ALL';\nconsistencyToString[consistencies.localQuorum] = 'LOCAL_QUORUM';\nconsistencyToString[consistencies.eachQuorum] = 'EACH_QUORUM';\nconsistencyToString[consistencies.serial] = 'SERIAL';\nconsistencyToString[consistencies.localSerial] = 'LOCAL_SERIAL';\nconsistencyToString[consistencies.localOne] = 'LOCAL_ONE';\n\n/**\n * CQL data types\n * @type {Object}\n * @property {Number} custom A custom type.\n * @property {Number} ascii ASCII character string.\n * @property {Number} bigint 64-bit signed long.\n * @property {Number} blob Arbitrary bytes (no validation).\n * @property {Number} boolean true or false.\n * @property {Number} counter Counter column (64-bit signed value).\n * @property {Number} decimal Variable-precision decimal.\n * @property {Number} double 64-bit IEEE-754 floating point.\n * @property {Number} float 32-bit IEEE-754 floating point.\n * @property {Number} int 32-bit signed integer.\n * @property {Number} text UTF8 encoded string.\n * @property {Number} timestamp A timestamp.\n * @property {Number} uuid Type 1 or type 4 UUID.\n * @property {Number} varchar UTF8 encoded string.\n * @property {Number} varint Arbitrary-precision integer.\n * @property {Number} timeuuid  Type 1 UUID.\n * @property {Number} inet An IP address. It can be either 4 bytes long (IPv4) or 16 bytes long (IPv6).\n * @property {Number} date A date without a time-zone in the ISO-8601 calendar system.\n * @property {Number} time A value representing the time portion of the day.\n * @property {Number} smallint 16-bit two's complement integer.\n * @property {Number} tinyint 8-bit two's complement integer.\n * @property {Number} list A collection of elements.\n * @property {Number} map Key/value pairs.\n * @property {Number} set A collection that contains no duplicate elements.\n * @property {Number} udt User-defined type.\n * @property {Number} tuple A sequence of values.\n */\nconst dataTypes = {\n  custom:     0x0000,\n  ascii:      0x0001,\n  bigint:     0x0002,\n  blob:       0x0003,\n  boolean:    0x0004,\n  counter:    0x0005,\n  decimal:    0x0006,\n  double:     0x0007,\n  float:      0x0008,\n  int:        0x0009,\n  text:       0x000a,\n  timestamp:  0x000b,\n  uuid:       0x000c,\n  varchar:    0x000d,\n  varint:     0x000e,\n  timeuuid:   0x000f,\n  inet:       0x0010,\n  date:       0x0011,\n  time:       0x0012,\n  smallint:   0x0013,\n  tinyint:    0x0014,\n  list:       0x0020,\n  map:        0x0021,\n  set:        0x0022,\n  udt:        0x0030,\n  tuple:      0x0031,\n  /**\n   * Returns the typeInfo of a given type name\n   * @param name\n   * @returns {{code: number, info: *|Object}}\n   */\n  getByName:  function(name) {\n    name = name.toLowerCase();\n    if (name.indexOf('<') > 0) {\n      const listMatches = /^(list|set)<(.+)>$/.exec(name);\n      if (listMatches) {\n        return { code: this[listMatches[1]], info: this.getByName(listMatches[2])};\n      }\n      const mapMatches = /^(map)< *(.+) *, *(.+)>$/.exec(name);\n      if (mapMatches) {\n        return { code: this[mapMatches[1]], info: [this.getByName(mapMatches[2]), this.getByName(mapMatches[3])]};\n      }\n      const udtMatches = /^(udt)<(.+)>$/.exec(name);\n      if (udtMatches) {\n        //udt name as raw string\n        return { code: this[udtMatches[1]], info: udtMatches[2]};\n      }\n      const tupleMatches = /^(tuple)<(.+)>$/.exec(name);\n      if (tupleMatches) {\n        //tuple info as an array of types\n        return { code: this[tupleMatches[1]], info: tupleMatches[2].split(',').map(function (x) {\n          return this.getByName(x.trim());\n        }, this)};\n      }\n    }\n    const typeInfo = { code: this[name], info: null};\n    if (typeof typeInfo.code !== 'number') {\n      throw new TypeError('Data type with name ' + name + ' not valid');\n    }\n    return typeInfo;\n  }\n};\n\n/**\n * Map of Data types by code\n * @internal\n * @private\n */\nconst _dataTypesByCode = (function () {\n  const result = {};\n  for (const key in dataTypes) {\n    if (!dataTypes.hasOwnProperty(key)) {\n      continue;\n    }\n    const val = dataTypes[key];\n    if (typeof val !== 'number') {\n      continue;\n    }\n    result[val] = key;\n  }\n  return result;\n})();\n\n/**\n * Represents the distance of Cassandra node as assigned by a LoadBalancingPolicy relatively to the driver instance.\n * @type {Object}\n * @property {Number} local A local node.\n * @property {Number} remote A remote node.\n * @property {Number} ignored A node that is meant to be ignored.\n */\nconst distance = {\n  local:    0,\n  remote:   1,\n  ignored:  2\n};\n\n/**\n * An integer byte that distinguish the actual message from and to Cassandra\n * @internal\n * @ignore\n */\nconst opcodes = {\n  error:          0x00,\n  startup:        0x01,\n  ready:          0x02,\n  authenticate:   0x03,\n  credentials:    0x04,\n  options:        0x05,\n  supported:      0x06,\n  query:          0x07,\n  result:         0x08,\n  prepare:        0x09,\n  execute:        0x0a,\n  register:       0x0b,\n  event:          0x0c,\n  batch:          0x0d,\n  authChallenge:  0x0e,\n  authResponse:   0x0f,\n  authSuccess:    0x10,\n\n  /**\n   * Determines if the code is a valid opcode\n   */\n  isInRange: function (code) {\n    return code > this.error && code > this.event;\n  }\n};\n\n/**\n * Event types from Cassandra\n * @type {{topologyChange: string, statusChange: string, schemaChange: string}}\n * @internal\n * @ignore\n */\nconst protocolEvents = {\n  topologyChange: 'TOPOLOGY_CHANGE',\n  statusChange: 'STATUS_CHANGE',\n  schemaChange: 'SCHEMA_CHANGE'\n};\n\n/**\n * Server error codes returned by Cassandra\n * @type {Object}\n * @property {Number} serverError Something unexpected happened.\n * @property {Number} protocolError Some client message triggered a protocol violation.\n * @property {Number} badCredentials Authentication was required and failed.\n * @property {Number} unavailableException Raised when coordinator knows there is not enough replicas alive to perform a query with the requested consistency level.\n * @property {Number} overloaded The request cannot be processed because the coordinator is overloaded.\n * @property {Number} isBootstrapping The request was a read request but the coordinator node is bootstrapping.\n * @property {Number} truncateError Error encountered during a truncate request.\n * @property {Number} writeTimeout Timeout encountered on write query on coordinator waiting for response(s) from replicas.\n * @property {Number} readTimeout Timeout encountered on read query on coordinator waitign for response(s) from replicas.\n * @property {Number} readFailure A non-timeout error encountered during a read request.\n * @property {Number} functionFailure A (user defined) function encountered during execution.\n * @property {Number} writeFailure A non-timeout error encountered during a write request.\n * @property {Number} syntaxError The submitted query has a syntax error.\n * @property {Number} unauthorized The logged user doesn't have the right to perform the query.\n * @property {Number} invalid The query is syntactically correct but invalid.\n * @property {Number} configError The query is invalid because of some configuration issue.\n * @property {Number} alreadyExists The query attempted to create a schema element (i.e. keyspace, table) that already exists.\n * @property {Number} unprepared Can be thrown while a prepared statement tries to be executed if the provided statement is not known by the coordinator.\n */\nconst responseErrorCodes = {\n  serverError:            0x0000,\n  protocolError:          0x000A,\n  badCredentials:         0x0100,\n  unavailableException:   0x1000,\n  overloaded:             0x1001,\n  isBootstrapping:        0x1002,\n  truncateError:          0x1003,\n  writeTimeout:           0x1100,\n  readTimeout:            0x1200,\n  readFailure:            0x1300,\n  functionFailure:        0x1400,\n  writeFailure:           0x1500,\n  syntaxError:            0x2000,\n  unauthorized:           0x2100,\n  invalid:                0x2200,\n  configError:            0x2300,\n  alreadyExists:          0x2400,\n  unprepared:             0x2500\n};\n\n/**\n * Type of result included in a response\n * @internal\n * @ignore\n */\nconst resultKind = {\n  voidResult:      0x0001,\n  rows:            0x0002,\n  setKeyspace:     0x0003,\n  prepared:        0x0004,\n  schemaChange:    0x0005\n};\n\n/**\n * Message frame flags\n * @internal\n * @ignore\n */\nconst frameFlags = {\n  compression:    0x01,\n  tracing:        0x02,\n  customPayload:  0x04,\n  warning:        0x08\n};\n\n/**\n * Unset representation.\n * <p>\n *   Use this field if you want to set a parameter to <code>unset</code>. Valid for Cassandra 2.2 and above.\n * </p>\n */\nconst unset = Object.freeze({'unset': true});\n\n/**\n * A long representing the value 1000\n * @const\n * @private\n */\nconst _longOneThousand = Long.fromInt(1000);\n\n/**\n * Counter used to generate up to 1000 different timestamp values with the same Date\n * @private\n */\nlet _timestampTicks = 0;\n\n/**\n * <p><strong>Backward compatibility only, use [TimeUuid]{@link module:types~TimeUuid} instead</strong>.</p>\n * Generates and returns a RFC4122 v1 (timestamp based) UUID in a string representation.\n * @param {{msecs, node, clockseq, nsecs}} [options]\n * @param {Buffer} [buffer]\n * @param {Number} [offset]\n * @deprecated Use [TimeUuid]{@link module:types~TimeUuid} instead\n */\nfunction timeuuid(options, buffer, offset) {\n  let date;\n  let ticks;\n  let nodeId;\n  let clockId;\n  if (options) {\n    if (typeof options.msecs === 'number') {\n      date = new Date(options.msecs);\n    }\n    if (options.msecs instanceof Date) {\n      date = options.msecs;\n    }\n    if (util.isArray(options.node)) {\n      nodeId = utils.allocBufferFromArray(options.node);\n    }\n    if (typeof options.clockseq === 'number') {\n      clockId = utils.allocBufferUnsafe(2);\n      clockId.writeUInt16BE(options.clockseq, 0);\n    }\n    if (typeof options.nsecs === 'number') {\n      ticks = options.nsecs;\n    }\n  }\n  const uuid = new TimeUuid(date, ticks, nodeId, clockId);\n  if (buffer instanceof Buffer) {\n    //copy the values into the buffer\n    uuid.getBuffer().copy(buffer, offset || 0);\n    return buffer;\n  }\n  return uuid.toString();\n}\n\n/**\n * <p><strong>Backward compatibility only, use [Uuid]{@link module:types~Uuid} class instead</strong>.</p>\n * Generate and return a RFC4122 v4 UUID in a string representation.\n * @deprecated Use [Uuid]{@link module:types~Uuid} class instead\n */\nfunction uuid(options, buffer, offset) {\n  let uuid;\n  if (options) {\n    if (util.isArray(options.random)) {\n      uuid = new Uuid(utils.allocBufferFromArray(options.random));\n    }\n  }\n  if (!uuid) {\n    uuid = Uuid.random();\n  }\n  if (buffer instanceof Buffer) {\n    //copy the values into the buffer\n    uuid.getBuffer().copy(buffer, offset || 0);\n    return buffer;\n  }\n  return uuid.toString();\n}\n\n/**\n * Gets the data type name for a given type definition\n * @internal\n * @ignore\n * @throws {ArgumentError}\n */\nfunction getDataTypeNameByCode(item) {\n  if (!item || typeof item.code !== 'number') {\n    throw new errors.ArgumentError('Invalid signature type definition');\n  }\n  const typeName = _dataTypesByCode[item.code];\n  if (!typeName) {\n    throw new errors.ArgumentError(util.format('Type with code %d not found', item.code));\n  }\n  if (!item.info) {\n    return typeName;\n  }\n  if (util.isArray(item.info)) {\n    return (typeName +\n      '<' +\n      item.info.map(function (t) {\n        return getDataTypeNameByCode(t);\n      }).join(', ') +\n      '>');\n  }\n  if (typeof item.info.code === 'number') {\n    return typeName + '<' + getDataTypeNameByCode(item.info) + '>';\n  }\n  return typeName;\n}\n\n//classes\n\n/**\n * Represents a frame header that could be used to read from a Buffer or to write to a Buffer\n * @ignore\n * @param {Number} version Protocol version\n * @param {Number} flags\n * @param {Number} streamId\n * @param {Number} opcode\n * @param {Number} bodyLength\n * @constructor\n */\nfunction FrameHeader(version, flags, streamId, opcode, bodyLength) {\n  this.version = version;\n  this.flags = flags;\n  this.streamId = streamId;\n  this.opcode = opcode;\n  this.bodyLength = bodyLength;\n}\n\n/**\n * The length of the header of the frame based on the protocol version\n * @returns {Number}\n */\nFrameHeader.size = function (version) {\n  if (protocolVersion.uses2BytesStreamIds(version)) {\n    return 9;\n  }\n  return 8;\n};\n\n/**\n * Gets the protocol version based on the first byte of the header\n * @param {Buffer} buffer\n * @returns {Number}\n */\nFrameHeader.getProtocolVersion = function (buffer) {\n  return buffer[0] & 0x7F;\n};\n\n/**\n * @param {Buffer} buf\n * @param {Number} [offset]\n * @returns {FrameHeader}\n */\nFrameHeader.fromBuffer = function (buf, offset) {\n  let streamId = 0;\n  if (!offset) {\n    offset = 0;\n  }\n  const version = buf[offset++] & 0x7F;\n  const flags = buf.readUInt8(offset++);\n  if (!protocolVersion.uses2BytesStreamIds(version)) {\n    streamId = buf.readInt8(offset++);\n  }\n  else {\n    streamId = buf.readInt16BE(offset);\n    offset += 2;\n  }\n  return new FrameHeader(version, flags, streamId, buf.readUInt8(offset++), buf.readUInt32BE(offset));\n};\n\n/** @returns {Buffer} */\nFrameHeader.prototype.toBuffer = function () {\n  const buf = utils.allocBufferUnsafe(FrameHeader.size(this.version));\n  buf.writeUInt8(this.version, 0);\n  buf.writeUInt8(this.flags, 1);\n  let offset = 3;\n  if (!protocolVersion.uses2BytesStreamIds(this.version)) {\n    buf.writeInt8(this.streamId, 2);\n  }\n  else {\n    buf.writeInt16BE(this.streamId, 2);\n    offset = 4;\n  }\n  buf.writeUInt8(this.opcode, offset++);\n  buf.writeUInt32BE(this.bodyLength, offset);\n  return buf;\n};\n/**\n * Returns a long representation.\n * Used internally for deserialization\n */\nLong.fromBuffer = function (value) {\n  if (!(value instanceof Buffer)) {\n    throw new TypeError('Expected Buffer, obtained ' + util.inspect(value));\n  }\n  return new Long(value.readInt32BE(4), value.readInt32BE(0));\n};\n\n/**\n * Returns a big-endian buffer representation of the Long instance\n * @param {Long} value\n */\nLong.toBuffer = function (value) {\n  if (!(value instanceof Long)) {\n    throw new TypeError('Expected Long, obtained ' + util.inspect(value));\n  }\n  const buffer = utils.allocBufferUnsafe(8);\n  buffer.writeUInt32BE(value.getHighBitsUnsigned(), 0);\n  buffer.writeUInt32BE(value.getLowBitsUnsigned(), 4);\n  return buffer;\n};\n\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nLong.prototype.inspect = function () {\n  return 'Long: ' + this.toString();\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance\n */\nLong.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * Generates a value representing the timestamp for the query in microseconds based on the date and the microseconds provided\n * @param {Date} [date] The date to generate the value, if not provided it will use the current date.\n * @param {Number} [microseconds] A number from 0 to 999 used to build the microseconds part of the date.\n * @returns {Long}\n */\nfunction generateTimestamp(date, microseconds) {\n  if (!date) {\n    date = new Date();\n  }\n  let longMicro = Long.ZERO;\n  if (typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000) {\n    longMicro = Long.fromInt(microseconds);\n  }\n  else {\n    if (_timestampTicks > 999) {\n      _timestampTicks = 0;\n    }\n    longMicro = Long.fromInt(_timestampTicks);\n    _timestampTicks++;\n  }\n  return Long\n    .fromNumber(date.getTime())\n    .multiply(_longOneThousand)\n    .add(longMicro);\n}\n\n//error classes\n\n/** @private */\nfunction QueryParserError(e) {\n  QueryParserError.super_.call(this, e.message, this.constructor);\n  this.internalError = e;\n}\nutil.inherits(QueryParserError, errors.DriverError);\n\n/** @private */\nfunction TimeoutError (message) {\n  TimeoutError.super_.call(this, message, this.constructor);\n  this.info = 'Represents an error that happens when the maximum amount of time for an operation passed.';\n}\nutil.inherits(TimeoutError, errors.DriverError);\n\nexports.opcodes = opcodes;\nexports.consistencies = consistencies;\nexports.consistencyToString = consistencyToString;\nexports.dataTypes = dataTypes;\nexports.getDataTypeNameByCode = getDataTypeNameByCode;\nexports.distance = distance;\nexports.frameFlags = frameFlags;\nexports.protocolEvents = protocolEvents;\nexports.protocolVersion = protocolVersion;\nexports.responseErrorCodes = responseErrorCodes;\nexports.resultKind = resultKind;\nexports.timeuuid = timeuuid;\nexports.uuid = uuid;\nexports.BigDecimal = require('./big-decimal');\nexports.Duration = require('./duration');\nexports.FrameHeader = FrameHeader;\nexports.InetAddress = require('./inet-address');\nexports.Integer = require('./integer');\nexports.LocalDate = require('./local-date');\nexports.LocalTime = require('./local-time');\nexports.Long = Long;\nexports.ResultSet = require('./result-set');\nexports.ResultStream = require('./result-stream');\nexports.Row = require('./row');\n//export DriverError for backward-compatibility\nexports.DriverError = errors.DriverError;\nexports.TimeoutError = TimeoutError;\nexports.TimeUuid = TimeUuid;\nexports.Tuple = require('./tuple');\nexports.Uuid = Uuid;\nexports.unset = unset;\nexports.generateTimestamp = generateTimestamp;\n","\"use strict\";\n\nconst utils = require('../utils');\n\n/** @module types */\n/**\n * Creates a new instance of InetAddress\n * @class\n * @classdesc Represents an v4 or v6 Internet Protocol (IP) address.\n * @param {Buffer} buffer\n * @constructor\n */\nfunction InetAddress(buffer) {\n  if (!(buffer instanceof Buffer) || (buffer.length !== 4 && buffer.length !== 16)) {\n    throw new TypeError('The ip address must contain 4 or 16 bytes');\n  }\n\n  /**\n   * Immutable buffer that represents the IP address \n   * @type Array\n   */\n  this.buffer = buffer;\n\n  /**\n   * Returns the length of the underlying buffer\n   * @type Number\n   */\n  this.length = buffer.length;\n\n  /**\n   * Returns the Ip version (4 or 6)\n   * @type Number\n   */\n  this.version = buffer.length === 4 ? 4 : 6;\n}\n\n/**\n * Parses the string representation and returns an Ip address\n * @param {String} value\n */\nInetAddress.fromString = function (value) {\n  if (!value) {\n    return new InetAddress(utils.allocBufferFromArray([0, 0, 0, 0]));\n  }\n  const ipv4Pattern = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n  const ipv6Pattern = /^[\\da-f:.]+$/i;\n  let parts;\n  if (ipv4Pattern.test(value)) {\n    parts = value.split('.');\n    return new InetAddress(utils.allocBufferFromArray(parts));\n  }\n  if (!ipv6Pattern.test(value)) {\n    throw new TypeError('Value could not be parsed as InetAddress: ' + value);\n  }\n  parts = value.split(':');\n  if (parts.length < 3) {\n    throw new TypeError('Value could not be parsed as InetAddress: ' + value);\n  }\n  const buffer = utils.allocBufferUnsafe(16);\n  let filling = 8 - parts.length + 1;\n  let applied = false;\n  let offset = 0;\n  const embeddedIp4 = ipv4Pattern.test(parts[parts.length - 1]);\n  if (embeddedIp4) {\n    // Its IPv6 address with an embedded IPv4 address:\n    // subtract 1 from the potential empty filling as ip4 contains 4 bytes instead of 2 of a ipv6 section\n    filling -= 1;\n  }\n  function writeItem(uIntValue) {\n    buffer.writeUInt8(+uIntValue, offset++);\n  }\n  for (let i = 0; i < parts.length; i++) {\n    const item = parts[i];\n    if (item) {\n      if (embeddedIp4 && i === parts.length - 1) {\n        item.split('.').forEach(writeItem);\n        break;\n      }\n      buffer.writeUInt16BE(parseInt(item, 16), offset);\n      offset = offset + 2;\n      continue;\n    }\n    //its an empty string\n    if (applied) {\n      //there could be 2 occurrences of empty string\n      filling = 1;\n    }\n    applied = true;\n    for (let j = 0; j < filling; j++) {\n      buffer[offset++] = 0;\n      buffer[offset++] = 0;\n    }\n  }\n  if (embeddedIp4 && !isValidIPv4Mapped(buffer)) {\n    throw new TypeError('Only IPv4-Mapped IPv6 addresses are allowed as IPv6 address with embedded IPv4 address');\n  }\n  return new InetAddress(buffer);\n};\n\n/**\n * Compares 2 addresses and returns true if the underlying bytes are the same\n * @param {InetAddress} other\n * @returns {Boolean}\n */\nInetAddress.prototype.equals = function (other) {\n  if (!(other instanceof InetAddress)) {\n    return false;\n  }\n  return (this.buffer.length === other.buffer.length &&\n    this.buffer.toString('hex') === other.buffer.toString('hex'));\n};\n\n/**\n * Returns the underlying buffer\n * @returns {Buffer}\n */\nInetAddress.prototype.getBuffer = function () {\n  return this.buffer;\n};\n\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nInetAddress.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns the string representation of the IP address.\n * <p>For v4 IP addresses, a string in the form of d.d.d.d is returned.</p>\n * <p>\n *   For v6 IP addresses, a string in the form of x:x:x:x:x:x:x:x is returned, where the 'x's are the hexadecimal\n *   values of the eight 16-bit pieces of the address, according to rfc5952.\n *   In cases where there is more than one field of only zeros, it can be shortened. For example, 2001:0db8:0:0:0:1:0:1\n *   will be expressed as 2001:0db8::1:0:1.\n * </p>\n * @param {String} [encoding]\n * @returns {String}\n */\nInetAddress.prototype.toString = function (encoding) {\n  if (encoding === 'hex') {\n    //backward compatibility: behave in the same way as the buffer\n    return this.buffer.toString('hex');\n  }\n  if (this.buffer.length === 4) {\n    return (\n      this.buffer[0] + '.' +\n      this.buffer[1] + '.' +\n      this.buffer[2] + '.' +\n      this.buffer[3]\n    );\n  }\n  let start = -1;\n  const longest = { length: 0, start: -1};\n  function checkLongest (i) {\n    if (start >= 0) {\n      //close the group\n      const length = i - start;\n      if (length > longest.length) {\n        longest.length = length;\n        longest.start = start;\n        start = -1;\n      }\n    }\n  }\n  //get the longest 16-bit group of zeros\n  for (let i = 0; i < this.buffer.length; i = i + 2) {\n    if (this.buffer[i] === 0 && this.buffer[i + 1] === 0) {\n      //its a group of zeros\n      if (start < 0) {\n        start = i;\n      }\n\n      // at the end of the buffer, make a final call to checkLongest.\n      if(i === this.buffer.length - 2) {\n        checkLongest(i+2);\n      }\n      continue;\n    }\n    //its a group of non-zeros\n    checkLongest(i);\n  }\n\n  let address = '';\n  for (let h = 0; h < this.buffer.length; h = h + 2) {\n    if (h === longest.start) {\n      address += ':';\n      continue;\n    }\n    if (h < (longest.start + longest.length) && h > longest.start) {\n      //its a group of zeros\n      continue;\n    }\n    if (address.length > 0) {\n      address += ':';\n    }\n    address += ((this.buffer[h] << 8) | this.buffer[h+1]).toString(16);\n  }\n  if (address.charAt(address.length-1) === ':') {\n    address += ':';\n  }\n  return address;\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nInetAddress.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * Validates for a IPv4-Mapped IPv6 according to https://tools.ietf.org/html/rfc4291#section-2.5.5\n * @private\n * @param {Buffer} buffer\n */\nfunction isValidIPv4Mapped(buffer) {\n  // check the form\n  // |      80 bits   | 16 |   32 bits\n  // +----------------+----+-------------\n  // |0000........0000|FFFF| IPv4 address\n\n  for (let i = 0; i < buffer.length - 6; i++) {\n    if (buffer[i] !== 0) {\n      return false;\n    }\n  }\n  return !(buffer[10] !== 255 || buffer[11] !== 255);\n}\n\nmodule.exports = InetAddress;","// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @module types */\n\nvar utils = require('../utils');\n\n/**\n * Constructs a two's-complement integer an array containing bits of the\n * integer in 32-bit (signed) pieces, given in little-endian order (i.e.,\n * lowest-order bits in the first piece), and the sign of -1 or 0.\n *\n * See the from* functions below for other convenient ways of constructing\n * Integers.\n *\n * The internal representation of an integer is an array of 32-bit signed\n * pieces, along with a sign (0 or -1) that indicates the contents of all the\n * other 32-bit pieces out to infinity.  We use 32-bit pieces because these are\n * the size of integers on which Javascript performs bit-operations.  For\n * operations like addition and multiplication, we split each number into 16-bit\n * pieces, which can easily be multiplied within Javascript's floating-point\n * representation without overflow or change in sign.\n *\n * @constructor\n * @param {Array.<number>} bits Array containing the bits of the number.\n * @param {number} sign The sign of the number: -1 for negative and 0 positive.\n * @final\n */\nfunction Integer (bits, sign) {\n  /**\n   * @type {!Array.<number>}\n   * @private\n   */\n  this.bits_ = [];\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.sign_ = sign;\n\n  // Copy the 32-bit signed integer values passed in.  We prune out those at the\n  // top that equal the sign since they are redundant.\n  var top = true;\n  for (var i = bits.length - 1; i >= 0; i--) {\n    var val = bits[i] | 0;\n    if (!top || val != sign) {\n      this.bits_[i] = val;\n      top = false;\n    }\n  }\n}\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Integer representations of small integer values.\n * @type {!Object}\n * @private\n */\nInteger.IntCache_ = {};\n\n\n/**\n * Returns an Integer representing the given (32-bit) integer value.\n * @param {number} value A 32-bit integer value.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Integer.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Integer([value | 0], value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Integer.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Returns an Integer representing the given value, provided that it is a finite\n * number.  Otherwise, zero is returned.\n * @param {number} value The value in question.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromNumber = function(value) {\n  if (isNaN(value) || !isFinite(value)) {\n    return Integer.ZERO;\n  } else if (value < 0) {\n    return Integer.fromNumber(-value).negate();\n  } else {\n    var bits = [];\n    var pow = 1;\n    for (var i = 0; value >= pow; i++) {\n      bits[i] = (value / pow) | 0;\n      pow *= Integer.TWO_PWR_32_DBL_;\n    }\n    return new Integer(bits, 0);\n  }\n};\n\n\n/**\n * Returns a Integer representing the value that comes by concatenating the\n * given entries, each is assumed to be 32 signed bits, given in little-endian\n * order (lowest order bits in the lowest index), and sign-extending the highest\n * order 32-bit value.\n * @param {Array.<number>} bits The bits of the number, in 32-bit signed pieces,\n *     in little-endian order.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromBits = function(bits) {\n  var high = bits[bits.length - 1];\n  //noinspection JSBitwiseOperatorUsage\n  return new Integer(bits, high & (1 << 31) ? -1 : 0);\n};\n\n\n/**\n * Returns an Integer representation of the given string, written using the\n * given radix.\n * @param {string} str The textual representation of the Integer.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw TypeError('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Integer.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw TypeError('number format error: interior \"-\" character');\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));\n\n  var result = Integer.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Integer.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Integer.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Integer.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n/**\n * Returns an Integer representation of a given big endian Buffer.\n * The internal representation of bits contains bytes in groups of 4\n * @param {Buffer} buf\n * @returns {Integer}\n */\nInteger.fromBuffer = function (buf) {\n  var bits = new Array(Math.ceil(buf.length / 4));\n  //noinspection JSBitwiseOperatorUsage\n  var sign = buf[0] & (1 << 7) ? -1 : 0;\n  for (var i = 0; i < bits.length; i++) {\n    var offset = buf.length - ((i + 1) * 4);\n    var value;\n    if (offset < 0) {\n      //The buffer length is not multiple of 4\n      offset = offset + 4;\n      value = 0;\n      for (var j = 0; j < offset; j++) {\n        var byte = buf[j];\n        if (sign === -1) {\n          //invert the bits\n          byte = ~byte & 0xff;\n        }\n        value = value | (byte << (offset - j - 1) * 8);\n      }\n      if (sign === -1) {\n        //invert all the bits\n        value = ~value;\n      }\n    }\n    else {\n      value = buf.readInt32BE(offset);\n    }\n    bits[i] = value;\n  }\n  return new Integer(bits, sign);\n};\n\n/**\n * Returns a big endian buffer representation of an Integer.\n * Internally the bits are represented using 4 bytes groups (numbers),\n * in the Buffer representation there might be the case where we need less than the 4 bytes.\n * For example: 0x00000001 -> '01', 0xFFFFFFFF -> 'FF', 0xFFFFFF01 -> 'FF01'\n * @param {Integer} value\n * @returns {Buffer}\n*/\nInteger.toBuffer = function (value) {\n  var sign = value.sign_;\n  var bits = value.bits_;\n  if (bits.length === 0) {\n    //[0] or [0xffffffff]\n    return utils.allocBufferFromArray([value.sign_]);\n  }\n  //the high bits might need to be represented in less than 4 bytes\n  var highBits = bits[bits.length-1];\n  if (sign === -1) {\n    highBits = ~highBits;\n  }\n  var high = [];\n  if (highBits >>> 24 > 0) {\n    high.push((highBits >> 24) & 0xff);\n  }\n  if (highBits >>> 16 > 0) {\n    high.push((highBits >> 16) & 0xff);\n  }\n  if (highBits >>> 8 > 0) {\n    high.push((highBits >> 8) & 0xff);\n  }\n  high.push(highBits & 0xff);\n  if (sign === -1) {\n    //The byte containing the sign bit got removed\n    if (high[0] >> 7 !== 0) {\n      //it is going to be negated\n      high.unshift(0);\n    }\n  }\n  else if (high[0] >> 7 !== 0) {\n    //its positive but it lost the byte containing the sign bit\n    high.unshift(0);\n  }\n  var buf = utils.allocBufferUnsafe(high.length + ((bits.length-1) * 4));\n  for (var j = 0; j < high.length; j++) {\n    var b = high[j];\n    if (sign === -1) {\n      buf[j] = ~b;\n    }\n    else {\n      buf[j] = b;\n    }\n  }\n  for (var i = 0; i < bits.length - 1; i++) {\n    var group = bits[bits.length - 2 - i];\n    var offset = high.length + i * 4;\n    buf.writeInt32BE(group, offset);\n  }\n  return buf;\n};\n\n\n/**\n * A number used repeatedly in calculations.  This must appear before the first\n * call to the from* functions below.\n * @type {number}\n * @private\n */\nInteger.TWO_PWR_32_DBL_ = (1 << 16) * (1 << 16);\n\n\n/** @type {!Integer} */\nInteger.ZERO = Integer.fromInt(0);\n\n\n/** @type {!Integer} */\nInteger.ONE = Integer.fromInt(1);\n\n\n/**\n * @type {!Integer}\n * @private\n */\nInteger.TWO_PWR_24_ = Integer.fromInt(1 << 24);\n\n\n/**\n * Returns the value, assuming it is a 32-bit integer.\n * @return {number} The corresponding int value.\n */\nInteger.prototype.toInt = function() {\n  return this.bits_.length > 0 ? this.bits_[0] : this.sign_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nInteger.prototype.toNumber = function() {\n  if (this.isNegative()) {\n    return -this.negate().toNumber();\n  } else {\n    var val = 0;\n    var pow = 1;\n    for (var i = 0; i < this.bits_.length; i++) {\n      val += this.getBitsUnsigned(i) * pow;\n      pow *= Integer.TWO_PWR_32_DBL_;\n    }\n    return val;\n  }\n};\n\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nInteger.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  } else if (this.isNegative()) {\n    return '-' + this.negate().toString(radix);\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Integer.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.divide(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/**\n * Returns the index-th 32-bit (signed) piece of the Integer according to\n * little-endian order (i.e., index 0 contains the smallest bits).\n * @param {number} index The index in question.\n * @return {number} The requested 32-bits as a signed number.\n */\nInteger.prototype.getBits = function(index) {\n  if (index < 0) {\n    return 0;  // Allowing this simplifies bit shifting operations below...\n  } else if (index < this.bits_.length) {\n    return this.bits_[index];\n  } else {\n    return this.sign_;\n  }\n};\n\n\n/**\n * Returns the index-th 32-bit piece as an unsigned number.\n * @param {number} index The index in question.\n * @return {number} The requested 32-bits as an unsigned number.\n */\nInteger.prototype.getBitsUnsigned = function(index) {\n  var val = this.getBits(index);\n  return val >= 0 ? val : Integer.TWO_PWR_32_DBL_ + val;\n};\n\n\n/** @return {number} The sign bit of this number, -1 or 0. */\nInteger.prototype.getSign = function() {\n  return this.sign_;\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nInteger.prototype.isZero = function() {\n  if (this.sign_ != 0) {\n    return false;\n  }\n  for (var i = 0; i < this.bits_.length; i++) {\n    if (this.bits_[i] != 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nInteger.prototype.isNegative = function() {\n  return this.sign_ == -1;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nInteger.prototype.isOdd = function() {\n  return (this.bits_.length == 0) && (this.sign_ == -1) ||\n    (this.bits_.length > 0) && ((this.bits_[0] & 1) != 0);\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer equals the other.\n */\nInteger.prototype.equals = function(other) {\n  if (this.sign_ != other.sign_) {\n    return false;\n  }\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  for (var i = 0; i < len; i++) {\n    if (this.getBits(i) != other.getBits(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer does not equal the other.\n */\nInteger.prototype.notEquals = function(other) {\n  return !this.equals(other);\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is greater than the other.\n */\nInteger.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is greater than or equal to the other.\n */\nInteger.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is less than the other.\n */\nInteger.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is less than or equal to the other.\n */\nInteger.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * Compares this Integer with the given one.\n * @param {Integer} other Integer to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nInteger.prototype.compare = function(other) {\n  var diff = this.subtract(other);\n  if (diff.isNegative()) {\n    return -1;\n  } else if (diff.isZero()) {\n    return 0;\n  } else {\n    return +1;\n  }\n};\n\n\n/**\n * Returns an integer with only the first numBits bits of this value, sign\n * extended from the final bit.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Integer} The shorted integer value.\n */\nInteger.prototype.shorten = function(numBits) {\n  var arr_index = (numBits - 1) >> 5;\n  var bit_index = (numBits - 1) % 32;\n  var bits = [];\n  for (var i = 0; i < arr_index; i++) {\n    bits[i] = this.getBits(i);\n  }\n  var sigBits = bit_index == 31 ? 0xFFFFFFFF : (1 << (bit_index + 1)) - 1;\n  var val = this.getBits(arr_index) & sigBits;\n  //noinspection JSBitwiseOperatorUsage\n  if (val & (1 << bit_index)) {\n    val |= 0xFFFFFFFF - sigBits;\n    bits[arr_index] = val;\n    return new Integer(bits, -1);\n  } else {\n    bits[arr_index] = val;\n    return new Integer(bits, 0);\n  }\n};\n\n\n/** @return {!Integer} The negation of this value. */\nInteger.prototype.negate = function() {\n  return this.not().add(Integer.ONE);\n};\n\n\n/**\n * Returns the sum of this and the given Integer.\n * @param {Integer} other The Integer to add to this.\n * @return {!Integer} The Integer result.\n */\nInteger.prototype.add = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  var carry = 0;\n\n  for (var i = 0; i <= len; i++) {\n    var a1 = this.getBits(i) >>> 16;\n    var a0 = this.getBits(i) & 0xFFFF;\n\n    var b1 = other.getBits(i) >>> 16;\n    var b0 = other.getBits(i) & 0xFFFF;\n\n    var c0 = carry + a0 + b0;\n    var c1 = (c0 >>> 16) + a1 + b1;\n    carry = c1 >>> 16;\n    c0 &= 0xFFFF;\n    c1 &= 0xFFFF;\n    arr[i] = (c1 << 16) | c0;\n  }\n  return Integer.fromBits(arr);\n};\n\n\n/**\n * Returns the difference of this and the given Integer.\n * @param {Integer} other The Integer to subtract from this.\n * @return {!Integer} The Integer result.\n */\nInteger.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given Integer.\n * @param {Integer} other The Integer to multiply against this.\n * @return {!Integer} The product of this and the other.\n */\nInteger.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Integer.ZERO;\n  } else if (other.isZero()) {\n    return Integer.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both numbers are small, use float multiplication\n  if (this.lessThan(Integer.TWO_PWR_24_) &&\n    other.lessThan(Integer.TWO_PWR_24_)) {\n    return Integer.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Fill in an array of 16-bit products.\n  var len = this.bits_.length + other.bits_.length;\n  var arr = [];\n  for (var i = 0; i < 2 * len; i++) {\n    arr[i] = 0;\n  }\n  for (var i = 0; i < this.bits_.length; i++) {\n    for (var j = 0; j < other.bits_.length; j++) {\n      var a1 = this.getBits(i) >>> 16;\n      var a0 = this.getBits(i) & 0xFFFF;\n\n      var b1 = other.getBits(j) >>> 16;\n      var b0 = other.getBits(j) & 0xFFFF;\n\n      arr[2 * i + 2 * j] += a0 * b0;\n      Integer.carry16_(arr, 2 * i + 2 * j);\n      arr[2 * i + 2 * j + 1] += a1 * b0;\n      Integer.carry16_(arr, 2 * i + 2 * j + 1);\n      arr[2 * i + 2 * j + 1] += a0 * b1;\n      Integer.carry16_(arr, 2 * i + 2 * j + 1);\n      arr[2 * i + 2 * j + 2] += a1 * b1;\n      Integer.carry16_(arr, 2 * i + 2 * j + 2);\n    }\n  }\n\n  // Combine the 16-bit values into 32-bit values.\n  for (var i = 0; i < len; i++) {\n    arr[i] = (arr[2 * i + 1] << 16) | arr[2 * i];\n  }\n  for (var i = len; i < 2 * len; i++) {\n    arr[i] = 0;\n  }\n  return new Integer(arr, 0);\n};\n\n\n/**\n * Carries any overflow from the given index into later entries.\n * @param {Array.<number>} bits Array of 16-bit values in little-endian order.\n * @param {number} index The index in question.\n * @private\n */\nInteger.carry16_ = function(bits, index) {\n  while ((bits[index] & 0xFFFF) != bits[index]) {\n    bits[index + 1] += bits[index] >>> 16;\n    bits[index] &= 0xFFFF;\n  }\n};\n\n\n/**\n * Returns this Integer divided by the given one.\n * @param {Integer} other Th Integer to divide this by.\n * @return {!Integer} This value divided by the given one.\n */\nInteger.prototype.divide = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Integer.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().divide(other.negate());\n    } else {\n      return this.negate().divide(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.divide(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Integer.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Integer.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Integer.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Integer.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Integer modulo the given one.\n * @param {Integer} other The Integer by which to mod.\n * @return {!Integer} This value modulo the given one.\n */\nInteger.prototype.modulo = function(other) {\n  return this.subtract(this.divide(other).multiply(other));\n};\n\n\n/** @return {!Integer} The bitwise-NOT of this value. */\nInteger.prototype.not = function() {\n  var len = this.bits_.length;\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = ~this.bits_[i];\n  }\n  return new Integer(arr, ~this.sign_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Integer and the given one.\n * @param {Integer} other The Integer to AND with this.\n * @return {!Integer} The bitwise-AND of this and the other.\n */\nInteger.prototype.and = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = this.getBits(i) & other.getBits(i);\n  }\n  return new Integer(arr, this.sign_ & other.sign_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Integer and the given one.\n * @param {Integer} other The Integer to OR with this.\n * @return {!Integer} The bitwise-OR of this and the other.\n */\nInteger.prototype.or = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = this.getBits(i) | other.getBits(i);\n  }\n  return new Integer(arr, this.sign_ | other.sign_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Integer and the given one.\n * @param {Integer} other The Integer to XOR with this.\n * @return {!Integer} The bitwise-XOR of this and the other.\n */\nInteger.prototype.xor = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = this.getBits(i) ^ other.getBits(i);\n  }\n  return new Integer(arr, this.sign_ ^ other.sign_);\n};\n\n\n/**\n * Returns this value with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Integer} This shifted to the left by the given amount.\n */\nInteger.prototype.shiftLeft = function(numBits) {\n  var arr_delta = numBits >> 5;\n  var bit_delta = numBits % 32;\n  var len = this.bits_.length + arr_delta + (bit_delta > 0 ? 1 : 0);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    if (bit_delta > 0) {\n      arr[i] = (this.getBits(i - arr_delta) << bit_delta) |\n      (this.getBits(i - arr_delta - 1) >>> (32 - bit_delta));\n    } else {\n      arr[i] = this.getBits(i - arr_delta);\n    }\n  }\n  return new Integer(arr, this.sign_);\n};\n\n\n/**\n * Returns this value with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Integer} This shifted to the right by the given amount.\n */\nInteger.prototype.shiftRight = function(numBits) {\n  var arr_delta = numBits >> 5;\n  var bit_delta = numBits % 32;\n  var len = this.bits_.length - arr_delta;\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    if (bit_delta > 0) {\n      arr[i] = (this.getBits(i + arr_delta) >>> bit_delta) |\n      (this.getBits(i + arr_delta + 1) << (32 - bit_delta));\n    } else {\n      arr[i] = this.getBits(i + arr_delta);\n    }\n  }\n  return new Integer(arr, this.sign_);\n};\n\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nInteger.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns a Integer whose value is the absolute value of this\n * @returns {Integer}\n */\nInteger.prototype.abs = function () {\n  return this.sign_ === 0 ? this : this.negate();\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nInteger.prototype.toJSON = function () {\n  return this.toString();\n};\n\nmodule.exports = Integer;\n","\"use strict\";\nconst util = require('util');\n\nconst utils = require('../utils');\n/** @module types */\n\n/**\n * @private\n * @const\n */\nconst millisecondsPerDay = 86400000;\n/**\n * @private\n */\nconst dateCenter = Math.pow(2,31);\n/**\n *\n * Creates a new instance of LocalDate.\n * @class\n * @classdesc A date without a time-zone in the ISO-8601 calendar system, such as 2010-08-05.\n * <p>\n *   LocalDate is an immutable object that represents a date, often viewed as year-month-day. For example, the value \"1st October 2014\" can be stored in a LocalDate.\n * </p>\n * <p>\n *   This class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n * </p>\n * <p>\n *   Note that this type can represent dates in the range [-5877641-06-23; 5881580-07-17] while the ES5 date type can only represent values in the range of [-271821-04-20; 275760-09-13].\n *   In the event that year, month, day parameters do not fall within the ES5 date range an Error will be thrown.  If you wish to represent a date outside of this range, pass a single\n *   parameter indicating the days since epoch.  For example, -1 represents 1969-12-31.\n * </p>\n * @param {Number} year The year or days since epoch.  If days since epoch, month and day should not be provided.\n * @param {Number} month Between 1 and 12 inclusive.\n * @param {Number} day Between 1 and the number of days in the given month of the given year.\n *\n * @property {Date} date The date representation if falls within a range of an ES5 data type, otherwise an invalid date.\n *\n * @constructor\n */\nfunction LocalDate(year, month, day) {\n  //implementation detail: internally uses a UTC based date\n  if (typeof year === 'number' && typeof month === 'number' && typeof day === 'number') {\n    // Use setUTCFullYear as if there is a 2 digit year, Date.UTC() assumes\n    // that is the 20th century.\n    this.date = new Date();\n    this.date.setUTCHours(0, 0, 0, 0);\n    this.date.setUTCFullYear(year, month-1, day);\n    if(isNaN(this.date.getTime())) {\n      throw new Error(util.format('%d-%d-%d does not form a valid ES5 date!',\n        year, month, day));\n    }\n  }\n  else if (typeof month === 'undefined' && typeof day === 'undefined') {\n    if (typeof year === 'number') {\n      //in days since epoch.\n      if(year < -2147483648 || year > 2147483647) {\n        throw new Error('You must provide a valid value for days since epoch (-2147483648 <= value <= 2147483647).');\n      }\n      this.date = new Date(year * millisecondsPerDay);\n    }\n  }\n\n  if (typeof this.date === 'undefined') {\n    throw new Error('You must provide a valid year, month and day');\n  }\n\n  /** \n   * If date cannot be represented yet given a valid days since epoch, track\n   * it internally.\n   */\n  this._value = isNaN(this.date.getTime()) ? year : null;\n\n  /**\n   * A number representing the year.  May return NaN if cannot be represented as\n   * a Date.\n   * @type Number\n   */\n  this.year = this.date.getUTCFullYear();\n  /**\n   * A number between 1 and 12 inclusive representing the month.  May return\n   * NaN if cannot be represented as a Date.\n   * @type Number\n   */\n  this.month = this.date.getUTCMonth() + 1;\n  /**\n   * A number between 1 and the number of days in the given month of the given year (28, 29, 30, 31).\n   * May return NaN if cannot be represented as a Date.\n   * @type Number\n   */\n  this.day = this.date.getUTCDate();\n}\n\n/**\n * Creates a new instance of LocalDate using the current year, month and day from the system clock in the default time-zone.\n */\nLocalDate.now = function () {\n  return LocalDate.fromDate(new Date());\n};\n\n/**\n * Creates a new instance of LocalDate using the current date from the system clock at UTC.\n */\nLocalDate.utcNow = function () {\n  return new LocalDate(Date.now());\n};\n\n\n/**\n * Creates a new instance of LocalDate using the year, month and day from the provided local date time.\n * @param {Date} date\n */\nLocalDate.fromDate = function (date) {\n  if (isNaN(date.getTime())) {\n    throw new TypeError('Invalid date: ' + date);\n  }\n  return new LocalDate(date.getFullYear(), date.getMonth() + 1, date.getDate());\n};\n\n/**\n * Creates a new instance of LocalDate using the year, month and day provided in the form: yyyy-mm-dd or\n * days since epoch (i.e. -1 for Dec 31, 1969).\n * @param {String} value\n */\nLocalDate.fromString = function (value) {\n  const dashCount = (value.match(/-/g) || []).length;\n  if(dashCount >= 2) {\n    let multiplier = 1;\n    if (value[0] === '-') {\n      value = value.substring(1);\n      multiplier = -1;\n    }\n    const parts = value.split('-');\n    return new LocalDate(multiplier * parseInt(parts[0], 10), parseInt(parts[1], 10), parseInt(parts[2], 10));\n  }\n  if(value.match(/^-?\\d+$/)) {\n    // Parse as days since epoch.\n    return new LocalDate(parseInt(value, 10));\n  }\n  throw new Error(\"Invalid input '\" + value + \"'.\");\n};\n\n/**\n * Creates a new instance of LocalDate using the bytes representation.\n * @param {Buffer} buffer\n */\nLocalDate.fromBuffer = function (buffer) {\n  //move to unix epoch: 0.\n  return new LocalDate((buffer.readUInt32BE(0) - dateCenter));\n};\n\n/**\n * Compares this LocalDate with the given one.\n * @param {LocalDate} other date to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n * if the given one is greater.\n */\nLocalDate.prototype.compare = function (other) {\n  const thisValue = isNaN(this.date.getTime()) ? this._value * millisecondsPerDay : this.date.getTime();\n  const otherValue = isNaN(other.date.getTime()) ? other._value * millisecondsPerDay : other.date.getTime();\n  const diff = thisValue - otherValue;\n  if (diff < 0) {\n    return -1;\n  }\n  if (diff > 0) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * Returns true if the value of the LocalDate instance and other are the same\n * @param {LocalDate} other\n * @returns {Boolean}\n */\nLocalDate.prototype.equals = function (other) {\n  return ((other instanceof LocalDate)) && this.compare(other) === 0;\n};\n\nLocalDate.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Gets the bytes representation of the instance.\n * @returns {Buffer}\n */\nLocalDate.prototype.toBuffer = function () {\n  //days since unix epoch\n  const daysSinceEpoch = isNaN(this.date.getTime()) ? this._value : Math.floor(this.date.getTime() / millisecondsPerDay);\n  const value = daysSinceEpoch + dateCenter;\n  const buf = utils.allocBufferUnsafe(4);\n  buf.writeUInt32BE(value, 0);\n  return buf;\n};\n\n/**\n * Gets the string representation of the instance in the form: yyyy-mm-dd if\n * the value can be parsed as a Date, otherwise days since epoch.\n * @returns {String}\n */\nLocalDate.prototype.toString = function () {\n  let result;\n  //if cannot be parsed as date, return days since epoch representation.\n  if (isNaN(this.date.getTime())) {\n    return this._value.toString();\n  }\n  if (this.year < 0) {\n    result = '-' + fillZeros((this.year * -1).toString(), 4);\n  }\n  else {\n    result = fillZeros(this.year.toString(), 4);\n  }\n  result += '-' + fillZeros(this.month.toString(), 2) + '-' + fillZeros(this.day.toString(), 2);\n  return result;\n};\n\n/**\n * Gets the string representation of the instance in the form: yyyy-mm-dd, valid for JSON.\n * @returns {String}\n */\nLocalDate.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * @param {String} value\n * @param {Number} amount\n * @private\n */\nfunction fillZeros(value, amount) {\n  if (value.length >= amount) {\n    return value;\n  }\n  return utils.stringRepeat('0', amount - value.length) + value;\n}\n\nmodule.exports = LocalDate;","\"use strict\";\nconst Long = require('long');\nconst util = require('util');\nconst utils = require('../utils');\n/** @module types */\n\n/**\n * @const\n * @private\n * */\nconst maxNanos = Long.fromString('86399999999999');\n/**\n * Nanoseconds in a second\n * @const\n * @private\n * */\nconst nanoSecInSec = Long.fromNumber(1000000000);\n/**\n * Nanoseconds in a millisecond\n * @const\n * @private\n * */\nconst nanoSecInMillis = Long.fromNumber(1000000);\n/**\n * Milliseconds in day\n * @const\n * @private\n * */\nconst millisInDay = 86400000;\n/**\n *\n * Creates a new instance of LocalTime.\n * @class\n * @classdesc A time without a time-zone in the ISO-8601 calendar system, such as 10:30:05.\n * <p>\n *   LocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second. Time is represented to nanosecond precision. For example, the value \"13:45.30.123456789\" can be stored in a LocalTime.\n * </p>\n * @param {Long} totalNanoseconds Total nanoseconds since midnight.\n * @constructor\n */\nfunction LocalTime(totalNanoseconds) {\n  if (!(totalNanoseconds instanceof Long)) {\n    throw new Error('You must specify a Long value as totalNanoseconds');\n  }\n  if (totalNanoseconds.lessThan(Long.ZERO) || totalNanoseconds.greaterThan(maxNanos)) {\n    throw new Error('Total nanoseconds out of range');\n  }\n  this.value = totalNanoseconds;\n  \n  /**\n   * Gets the hour component of the time represented by the current instance, a number from 0 to 23.\n   * @type Number\n   */\n  this.hour = this._getParts()[0];\n  /**\n   * Gets the minute component of the time represented by the current instance, a number from 0 to 59.\n   * @type Number\n   */\n  this.minute = this._getParts()[1];\n  /**\n   * Gets the second component of the time represented by the current instance, a number from 0 to 59.\n   * @type Number\n   */\n  this.second = this._getParts()[2];\n  /**\n   * Gets the nanoseconds component of the time represented by the current instance, a number from 0 to 999999999.\n   * @type Number\n   */\n  this.nanosecond = this._getParts()[3];\n}\n\n/**\n * Parses an string representation and returns a new LocalDate.\n * @param {String} value\n * @returns {LocalTime}\n */\nLocalTime.fromString = function (value) {\n  if (typeof value !== 'string') {\n    throw new Error('Argument type invalid: ' + util.inspect(value));\n  }\n  const parts = value.split(':');\n  let millis = parseInt(parts[0], 10) * 3600000 + parseInt(parts[1], 10) * 60000;\n  let nanos;\n  if (parts.length === 3) {\n    const secParts = parts[2].split('.');\n    millis += parseInt(secParts[0], 10) * 1000;\n    if (secParts.length === 2) {\n      nanos = secParts[1];\n      //add zeros at the end\n      nanos = nanos + utils.stringRepeat('0', 9 - nanos.length);\n    }\n  }\n  return LocalTime.fromMilliseconds(millis, parseInt(nanos, 10) || 0);\n};\n\n/**\n * Uses the current local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime\n * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.\n * @returns {LocalTime}\n */\nLocalTime.now = function (nanoseconds) {\n  return LocalTime.fromDate(new Date(), nanoseconds);\n};\n\n/**\n * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime\n * @param {Date} date Local date portion to extract the time passed since midnight.\n * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the nanosecond time portion.\n * @returns {LocalTime}\n */\nLocalTime.fromDate = function (date, nanoseconds) {\n  if (!util.isDate(date)) {\n    throw new Error('Not a valid date');\n  }\n  //Use the local representation, only the milliseconds portion\n  const millis = (date.getTime() + date.getTimezoneOffset() * -60000) % millisInDay;\n  return LocalTime.fromMilliseconds(millis, nanoseconds);\n};\n\n/**\n * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime\n * @param {Number} milliseconds A Number from 0 to 86,399,999.\n * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.\n * @returns {LocalTime}\n */\nLocalTime.fromMilliseconds = function (milliseconds, nanoseconds) {\n  if (typeof nanoseconds !== 'number') {\n    nanoseconds = 0;\n  }\n  return new LocalTime(Long\n    .fromNumber(milliseconds)\n    .multiply(nanoSecInMillis)\n    .add(Long.fromNumber(nanoseconds)));\n};\n\n/**\n * Creates a new instance of LocalTime from the bytes representation.\n * @param {Buffer} value\n * @returns {LocalTime}\n */\nLocalTime.fromBuffer = function (value) {\n  if (!(value instanceof Buffer)) {\n    throw new TypeError('Expected Buffer, obtained ' + util.inspect(value));\n  }\n  return new LocalTime(new Long(value.readInt32BE(4), value.readInt32BE(0)));\n};\n\n/**\n * Compares this LocalTime with the given one.\n * @param {LocalTime} other time to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n * if the given one is greater.\n */\nLocalTime.prototype.compare = function (other) {\n  return this.value.compare(other.value);\n};\n\n/**\n * Returns true if the value of the LocalTime instance and other are the same\n * @param {LocalTime} other\n * @returns {Boolean}\n */\nLocalTime.prototype.equals = function (other) {\n  return ((other instanceof LocalTime)) && this.compare(other) === 0;\n};\n\n/**\n * Gets the total amount of nanoseconds since midnight for this instance.\n * @returns {Long}\n */\nLocalTime.prototype.getTotalNanoseconds = function () {\n  return this.value;\n};\n\nLocalTime.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns a big-endian bytes representation of the instance\n * @returns {Buffer}\n */\nLocalTime.prototype.toBuffer = function () {\n  const buffer = utils.allocBufferUnsafe(8);\n  buffer.writeUInt32BE(this.value.getHighBitsUnsigned(), 0);\n  buffer.writeUInt32BE(this.value.getLowBitsUnsigned(), 4);\n  return buffer;\n};\n\n/**\n * Returns the string representation of the instance in the form of hh:MM:ss.ns\n * @returns {String}\n */\nLocalTime.prototype.toString = function () {\n  return formatTime(this._getParts());\n};\n\n/**\n * Gets the string representation of the instance in the form: hh:MM:ss.ns\n * @returns {String}\n */\nLocalTime.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * @returns {Array.<Number>}\n * @ignore\n */\nLocalTime.prototype._getParts = function () {\n  if (!this._partsCache) {\n    //hours, minutes, seconds and nanos\n    const parts = [0, 0, 0, 0];\n    const secs = this.value.div(nanoSecInSec);\n    //faster modulo\n    //total nanos\n    parts[3] = this.value.subtract(secs.multiply(nanoSecInSec)).toNumber();\n    //seconds\n    parts[2] = secs.toNumber();\n    if (parts[2] >= 60) {\n      //minutes\n      parts[1] = Math.floor(parts[2] / 60);\n      parts[2] = parts[2] % 60;\n    }\n    if (parts[1] >= 60) {\n      //hours\n      parts[0] = Math.floor(parts[1] / 60);\n      parts[1] = parts[1] % 60;\n    }\n    this._partsCache = parts;\n  }\n  return this._partsCache;\n};\n\n/**\n * @param {Array.<Number>} values\n * @private\n */\nfunction formatTime(values) {\n  let result;\n  if (values[0] < 10) {\n    result = '0' + values[0] + ':';\n  }\n  else {\n    result = values[0] + ':';\n  }\n  if (values[1] < 10) {\n    result += '0' + values[1] + ':';\n  }\n  else {\n    result += values[1] + ':';\n  }\n  if (values[2] < 10) {\n    result += '0' + values[2];\n  }\n  else {\n    result += values[2];\n  }\n  if (values[3] > 0) {\n    let nanos = values[3].toString();\n    //nine digits\n    if (nanos.length < 9) {\n      nanos = utils.stringRepeat('0', 9 - nanos.length) + nanos;\n    }\n    let lastPosition;\n    for (let i = nanos.length - 1; i > 0; i--) {\n      if (nanos[i] !== '0') {\n        break;\n      }\n      lastPosition = i;\n    }\n    if (lastPosition) {\n      nanos = nanos.substring(0, lastPosition);\n    }\n    result += '.' + nanos;\n  }\n  return result;\n}\n\nmodule.exports = LocalTime;","\"use strict\";\n\nconst Long = require('long');\n\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst one = new MutableLong(1, 0, 0, 0);\n\n/**\n * Constructs a signed int64 representation.\n * @constructor\n * @ignore\n */\nfunction MutableLong(b00, b16, b32, b48) {\n  // Use an array of uint16\n  this._arr = [ b00 & 0xffff, b16 & 0xffff, b32 & 0xffff, b48 & 0xffff ];\n}\n\nMutableLong.fromNumber = function fromNumber(value) {\n  if (isNaN(value) || !isFinite(value)) {\n    return new MutableLong();\n  }\n  if (value < 0) {\n    return MutableLong.fromNumber(-value).negate();\n  }\n  const low32Bits = value % TWO_PWR_32_DBL;\n  const high32Bits = value / TWO_PWR_32_DBL;\n  return MutableLong.fromBits(low32Bits, high32Bits);\n};\n\nMutableLong.fromBits = function fromBits(low32Bits, high32Bits) {\n  return new MutableLong(low32Bits, low32Bits >>> 16, high32Bits, high32Bits >>> 16);\n};\n\n/**\n * Returns a Long representation of the given string, written using the specified radix.\n * @param {String} str\n * @param {Number} [radix]\n * @return {MutableLong}\n */\nMutableLong.fromString = function fromString(str, radix) {\n  if (typeof str !== 'string') {\n    throw new Error('String format is not valid: ' + str);\n  }\n  if (str.length === 0) {\n    throw Error('number format error: empty string');\n  }\n  if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") {\n    return new MutableLong();\n  }\n  radix = radix || 10;\n  if (radix < 2 || radix > 36) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  let p;\n  if ((p = str.indexOf('-')) > 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n  if (p === 0) {\n    return MutableLong.fromString(str.substring(1), radix).negate();\n  }\n\n  // Do several (8) digits each time through the loop\n  const radixToPower = MutableLong.fromNumber(Math.pow(radix, 8));\n\n  const result = new MutableLong();\n  for (let i = 0; i < str.length; i += 8) {\n    const size = Math.min(8, str.length - i);\n    const value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      const power = MutableLong.fromNumber(Math.pow(radix, size));\n      result.multiply(power).add(MutableLong.fromNumber(value));\n      break;\n    }\n    result.multiply(radixToPower);\n    result.add(MutableLong.fromNumber(value));\n  }\n  return result;\n};\n\nMutableLong.prototype.toString = function toString() {\n  return this.toImmutable().toString();\n};\n\n/**\n * Compares this value with the provided value.\n * @param {MutableLong} other\n * @return {number}\n */\nMutableLong.prototype.compare = function (other) {\n  const thisNeg = this.isNegative();\n  const otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n  // At this point the sign bits are the same\n  return this._compareBits(other);\n};\n\nMutableLong.prototype._compareBits = function(other) {\n  for (let i = 3; i >= 0; i--) {\n    if (this._arr[i] > other._arr[i]) {\n      return 1;\n    }\n    if (this._arr[i] < other._arr[i]) {\n      return -1;\n    }\n  }\n  return 0;\n};\n\nMutableLong.prototype.getUint16 = function (index) {\n  return this._arr[index];\n};\n\nMutableLong.prototype.getLowBitsUnsigned = function () {\n  return (this._arr[0] | ((this._arr[1] & 0xffff) << 16)) >>> 0;\n};\n\nMutableLong.prototype.getHighBitsUnsigned = function () {\n  return (this._arr[2] | (this._arr[3] << 16)) >>> 0;\n};\n\nMutableLong.prototype.toNumber = function () {\n  return (this._arr[3] << 16 | this._arr[2]) * TWO_PWR_32_DBL + ((this._arr[1] << 16 | this._arr[0]) >>> 0);\n};\n\n/**\n * Performs the bitwise NOT of this value.\n * @return {MutableLong}\n */\nMutableLong.prototype.not = function () {\n  this._arr[0] = ~this._arr[0] & 0xffff;\n  this._arr[1] = ~this._arr[1] & 0xffff;\n  this._arr[2] = ~this._arr[2] & 0xffff;\n  this._arr[3] = ~this._arr[3] & 0xffff;\n  return this;\n};\n\nMutableLong.prototype.add = function (addend) {\n  let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += this._arr[0] + addend._arr[0];\n  this._arr[0] = c00 & 0xffff;\n\n  c16 += c00 >>> 16;\n  c16 += this._arr[1] + addend._arr[1];\n  this._arr[1] = c16 & 0xffff;\n\n  c32 += c16 >>> 16;\n  c32 += this._arr[2] + addend._arr[2];\n  this._arr[2] = c32 & 0xffff;\n\n  c48 += c32 >>> 16;\n  c48 += this._arr[3] + addend._arr[3];\n  this._arr[3] = c48 & 0xffff;\n  return this;\n};\n\nMutableLong.prototype.shiftLeft = function (numBits) {\n  if (numBits === 0) {\n    return this;\n  }\n  if (numBits >= 64) {\n    return this.toZero();\n  }\n  const remainingBits = numBits % 16;\n  const pos = Math.floor(numBits / 16);\n  if (pos > 0) {\n    this._arr[3] = this._arr[3 - pos];\n    this._arr[2] = pos > 2 ? 0 : this._arr[2 - pos];\n    this._arr[1] = pos > 1 ? 0 : this._arr[0];\n    this._arr[0] = 0;\n  }\n  if (remainingBits > 0) {\n    // shift left within the int16 and the next one\n    this._arr[3] = ((this._arr[3] << remainingBits) | (this._arr[2] >>> (16 - remainingBits))) & 0xffff;\n    this._arr[2] = ((this._arr[2] << remainingBits) | (this._arr[1] >>> (16 - remainingBits))) & 0xffff;\n    this._arr[1] = ((this._arr[1] << remainingBits) | (this._arr[0] >>> (16 - remainingBits))) & 0xffff;\n    this._arr[0] = (this._arr[0] << remainingBits) & 0xffff;\n  }\n  return this;\n};\n\nMutableLong.prototype.shiftRightUnsigned = function (numBits) {\n  if (numBits === 0) {\n    return this;\n  }\n  if (numBits >= 64) {\n    return this.toZero();\n  }\n  const remainingBits = numBits % 16;\n  const pos = Math.floor(numBits / 16);\n  if (pos > 0) {\n    this._arr[0] = this._arr[pos];\n    this._arr[1] = pos > 2 ? 0 : this._arr[1 + pos];\n    this._arr[2] = pos > 1 ? 0 : this._arr[3];\n    this._arr[3] = 0;\n  }\n  if (remainingBits > 0) {\n    this._arr[0] = (this._arr[0] >>> remainingBits) | ((this._arr[1] << (16 - remainingBits)) & 0xffff);\n    this._arr[1] = (this._arr[1] >>> remainingBits) | ((this._arr[2] << (16 - remainingBits)) & 0xffff);\n    this._arr[2] = (this._arr[2] >>> remainingBits) | ((this._arr[3] << (16 - remainingBits)) & 0xffff);\n    this._arr[3] = this._arr[3] >>> remainingBits;\n  }\n  return this;\n};\n\nMutableLong.prototype.or = function (other) {\n  this._arr[0] |= other._arr[0];\n  this._arr[1] |= other._arr[1];\n  this._arr[2] |= other._arr[2];\n  this._arr[3] |= other._arr[3];\n  return this;\n};\n\n/**\n * Returns the bitwise XOR of this Long and the given one.\n * @param {MutableLong} other\n * @returns {MutableLong} this instance.\n */\nMutableLong.prototype.xor = function (other) {\n  this._arr[0] ^= other._arr[0];\n  this._arr[1] ^= other._arr[1];\n  this._arr[2] ^= other._arr[2];\n  this._arr[3] ^= other._arr[3];\n  return this;\n};\n\nMutableLong.prototype.clone = function () {\n  return new MutableLong(this._arr[0], this._arr[1], this._arr[2], this._arr[3]);\n};\n\n/**\n * Performs the product of this and the specified Long.\n * @param {MutableLong} multiplier\n * @returns {MutableLong} this instance.\n */\nMutableLong.prototype.multiply = function multiply(multiplier) {\n  if (this.isZero() || multiplier.isZero()) {\n    return this.toZero();\n  }\n  if (this.isNegative()) {\n    if (multiplier.isNegative()) {\n      return this.negate().multiply(multiplier.clone().negate());\n    }\n    return this.negate().multiply(multiplier).negate();\n  }\n  else if (multiplier.isNegative()) {\n    return this.multiply(multiplier.clone().negate()).negate();\n  }\n  // We can skip products that would overflow.\n  let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += this._arr[0] * multiplier._arr[0];\n  c16 += c00 >>> 16;\n\n  c16 += this._arr[1] * multiplier._arr[0];\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += this._arr[0] * multiplier._arr[1];\n  c32 += c16 >>> 16;\n\n  c32 += this._arr[2] * multiplier._arr[0];\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += this._arr[1] * multiplier._arr[1];\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += this._arr[0] * multiplier._arr[2];\n  c48 += c32 >>> 16;\n  c48 += this._arr[3] * multiplier._arr[0] + this._arr[2] * multiplier._arr[1] +\n    this._arr[1] * multiplier._arr[2] + this._arr[0] * multiplier._arr[3];\n\n  this._arr[0] = c00 & 0xffff;\n  this._arr[1] = c16 & 0xffff;\n  this._arr[2] = c32 & 0xffff;\n  this._arr[3] = c48 & 0xffff;\n  return this;\n};\n\nMutableLong.prototype.toZero = function () {\n  this._arr[3] = this._arr[2] = this._arr[1] =this._arr[0] = 0;\n  return this;\n};\n\nMutableLong.prototype.isZero = function () {\n  return (this._arr[3] === 0 && this._arr[2] === 0 && this._arr[1] === 0 && this._arr[0] === 0);\n};\n\nMutableLong.prototype.isNegative = function () {\n  // most significant bit turned on\n  return (this._arr[3] & 0x8000) > 0;\n};\n\n\n/**\n * Negates this value.\n * @return {MutableLong}\n */\nMutableLong.prototype.negate = function () {\n  return this.not().add(one);\n};\n\nMutableLong.prototype.equals = function (other) {\n  if (!(other instanceof MutableLong)) {\n    return false;\n  }\n  return (\n    this._arr[0] === other._arr[0] && this._arr[1] === other._arr[1] &&\n    this._arr[2] === other._arr[2] && this._arr[3] === other._arr[3]);\n};\n\nMutableLong.prototype.toImmutable = function () {\n  return Long.fromBits(this.getLowBitsUnsigned(), this.getHighBitsUnsigned(), false);\n};\n\nmodule.exports = MutableLong;","'use strict';\n\nconst utils = require('../utils');\nconst VersionNumber = require('./version-number');\nconst v200 = VersionNumber.parse('2.0.0');\nconst v210 = VersionNumber.parse('2.1.0');\nconst v220 = VersionNumber.parse('2.2.0');\nconst v300 = VersionNumber.parse('3.0.0');\n\n/**\n * Contains information for the different protocol versions supported by the driver.\n * @type {Object}\n * @property {Number} v1 Cassandra protocol v1, supported in Apache Cassandra 1.2-->2.2.\n * @property {Number} v2 Cassandra protocol v2, supported in Apache Cassandra 2.0-->2.2.\n * @property {Number} v3 Cassandra protocol v3, supported in Apache Cassandra 2.1-->3.x.\n * @property {Number} v4 Cassandra protocol v4, supported in Apache Cassandra 2.2-->3.x.\n * @property {Number} v5 Cassandra protocol v5, in beta from Apache Cassandra 3.x+. Currently not supported by the\n * driver.\n * @property {Number} maxSupported Returns the higher protocol version that is supported by this driver.\n * @property {Number} minSupported Returns the lower protocol version that is supported by this driver.\n * @property {Function} isSupported A function that returns a boolean determining whether a given protocol version\n * is supported.\n * @alias module:types~protocolVersion\n */\nconst protocolVersion = {\n  // Strict equality operators to compare versions are allowed, other comparison operators are discouraged. Instead,\n  // use a function that checks if a functionality is present on a certain version, for maintainability purposes.\n  v1: 0x01,\n  v2: 0x02,\n  v3: 0x03,\n  v4: 0x04,\n  v5: 0x05,\n  maxSupported: 0x04,\n  minSupported: 0x01,\n  isSupported: function (version) {\n    return (version <= 0x04 && version >= 0x01);\n  },\n  /**\n   * Determines whether the protocol supports partition key indexes in the `prepared` RESULT responses.\n   * @param {Number} version\n   * @returns {Boolean}\n   * @ignore\n   */\n  supportsPreparedPartitionKey: function (version) {\n    return (version >= this.v4);\n  },\n  /**\n   * Determines whether the protocol supports up to 4 strings (ie: change_type, target, keyspace and table) in the\n   * schema change responses.\n   * @param version\n   * @return {boolean}\n   * @ignore\n   */\n  supportsSchemaChangeFullMetadata: function (version) {\n    return (version >= this.v3);\n  },\n  /**\n   * Determines whether the protocol supports paging state and serial consistency parameters in QUERY and EXECUTE\n   * requests.\n   * @param version\n   * @return {boolean}\n   * @ignore\n   */\n  supportsPaging: function (version) {\n    return (version >= this.v2);\n  },\n  /**\n   * Determines whether the protocol supports timestamps parameters in BATCH, QUERY and EXECUTE requests.\n   * @param {Number} version\n   * @return {boolean}\n   * @ignore\n   */\n  supportsTimestamp: function (version) {\n    return (version >= this.v3);\n  },\n  /**\n   * Determines whether the protocol supports named parameters in QUERY and EXECUTE requests.\n   * @param {Number} version\n   * @return {boolean}\n   * @ignore\n   */\n  supportsNamedParameters: function (version) {\n    return (version >= this.v3);\n  },\n  /**\n   * Determines whether the protocol supports unset parameters.\n   * @param {Number} version\n   * @return {boolean}\n   * @ignore\n   */\n  supportsUnset: function (version) {\n    return (version >= this.v4);\n  },\n  /**\n   * Determines whether the protocol supports timestamp and serial consistency parameters in BATCH requests.\n   * @param {Number} version\n   * @return {boolean}\n   * @ignore\n   */\n  uses2BytesStreamIds: function (version) {\n    return (version >= this.v3);\n  },\n  /**\n   * Determines whether the collection length is encoded using 32 bits.\n   * @param {Number} version\n   * @return {boolean}\n   * @ignore\n   */\n  uses4BytesCollectionLength: function (version) {\n    return (version >= this.v3);\n  },\n  /**\n   * Startup responses using protocol v4+ can be a SERVER_ERROR wrapping a ProtocolException, this method returns true\n   * when is possible to receive such error.\n   * @param {Number} version\n   * @return {boolean}\n   * @ignore\n   */\n  canStartupResponseErrorBeWrapped: function (version) {\n    return (version >= this.v4);\n  },\n  /**\n   * Gets the first version number that is supported, lower than the one provided.\n   * Returns zero when there isn't a lower supported version.\n   * @param {Number} version\n   * @return {Number}\n   * @ignore\n   */\n  getLowerSupported: function (version) {\n    if (version >= this.v5) {\n      return this.v4;\n    }\n    if (version <= this.v1) {\n      return 0;\n    }\n    return version - 1;\n  },\n\n  /**\n   * Computes the highest supported protocol version collectively by the given hosts.\n   *\n   * Considers the cassandra_version of the input hosts to determine what protocol versions\n   * are supported and uses the highest common protocol version among them.\n   *\n   * If hosts >= C* 3.0 are detected, any hosts older than C* 2.1 will not be considered\n   * as those cannot be connected to.  In general this will not be a problem as C* does\n   * not support clusters with nodes that have versions that are more than one major\n   * version away from each other.\n   * @param {Connection} connection Connection hosts were discovered from.\n   * @param {Array.<Host>} hosts The hosts to determine highest protocol version from.\n   * @return {Number} Highest supported protocol version among hosts.\n   */\n  getHighestCommon: function(connection, hosts) {\n    const log = connection.log ? connection.log.bind(connection) : utils.noop;\n    let maxVersion = connection.protocolVersion;\n    // whether or not protocol v3 is required (nodes detected that don't support < 3).\n    let v3Requirement = false;\n    // track the common protocol version >= v3 in case we encounter older versions.\n    let maxVersionWith3OrMore = maxVersion;\n    hosts.forEach(h => {\n      if (!h.cassandraVersion || h.cassandraVersion.length === 0) {\n        log('warning', 'Encountered host ' + h.address + ' with no cassandra version,' +\n          ' skipping as part of protocol version evaluation');\n        return;\n      }\n\n      try {\n        const cassandraVersion = VersionNumber.parse(h.cassandraVersion);\n        log('verbose', 'Encountered host ' + h.address + ' with cassandra version ' + cassandraVersion);\n        if (cassandraVersion.compare(v300) >= 0) {\n          // Anything 3.0.0+ has a max protocol version of V4 and requires at least V3.\n          v3Requirement = true;\n          maxVersion = Math.min(this.v4, maxVersion);\n          maxVersionWith3OrMore = maxVersion;\n        } else if (cassandraVersion.compare(v220) >= 0) {\n          // Cassandra 2.2.x has a max protocol version of V4.\n          maxVersion = Math.min(this.v4, maxVersion);\n          maxVersionWith3OrMore = maxVersion;\n        } else if (cassandraVersion.compare(v210) >= 0) {\n          // Cassandra 2.1.x has a max protocol version of V3.\n          maxVersion = Math.min(this.v3, maxVersion);\n          maxVersionWith3OrMore = maxVersion;\n        } else if (cassandraVersion.compare(v200) >= 0) {\n          // Cassandra 2.0.x has a max protocol version of V2.\n          maxVersion = Math.min(this.v2, maxVersion);\n        } else {\n          // Anything else is < 2.x and requires protocol version V1.\n          maxVersion = this.v1;\n        }\n      } catch (e) {\n        log('warning', 'Encountered host ' + h.address + ' with unparseable cassandra version ' + h.cassandraVersion\n          + ' skipping as part of protocol version evaluation');\n      }\n    });\n\n    if (v3Requirement && maxVersion < this.v3) {\n      const addendum = '. This should not be possible as nodes within a cluster can\\'t be separated by more than one major version';\n      if (maxVersionWith3OrMore < this.v3) {\n        log('error', 'Detected hosts that require at least protocol version 0x3, but currently connected to '\n         + connection.address + ':' + connection.port + ' using protocol version 0x' + maxVersionWith3OrMore\n         + '. Will not be able to connect to these hosts' + addendum);\n      } else {\n        log('error', 'Detected hosts with maximum protocol version of 0x' + maxVersion.toString(16)\n          + ' but there are some hosts that require at least version 0x3. Will not be able to connect to these older hosts'\n          + addendum);\n      }\n      maxVersion = maxVersionWith3OrMore;\n    }\n\n    log('verbose', 'Resolved protocol version 0x' + maxVersion.toString(16) + ' as the highest common protocol version among hosts');\n    return maxVersion;\n  }\n};\n\nmodule.exports = protocolVersion;","\"use strict\";\nconst utils = require('../utils');\n\n/** @module types */\n\n/**\n * Creates a new instance of ResultSet.\n * @class\n * @classdesc Represents the result of a query.\n * @param {Object} response\n * @param {String} host\n * @param {Object} triedHosts\n * @param {Number} speculativeExecutions\n * @param {Number} consistency\n * @param {Boolean} isSchemaInAgreement\n * @constructor\n */\nfunction ResultSet(response, host, triedHosts, speculativeExecutions, consistency, isSchemaInAgreement) {\n  // if no execution was made at all, set to 0.\n  if (speculativeExecutions === -1) {\n    speculativeExecutions = 0;\n  }\n  /**\n   * Information on the execution of a successful query:\n   * @member {Object}\n   * @property {Number} achievedConsistency The consistency level that has been actually achieved by the query.\n   * @property {String} queriedHost The Cassandra host that coordinated this query.\n   * @property {Object} triedHosts Gets the associative array of host that were queried before getting a valid response,\n   * being the last host the one that replied correctly.\n   * @property {Object} speculativeExecutions The number of speculative executions (not including the first) executed before\n   * getting a valid response.\n   * @property {Uuid} traceId Identifier of the trace session.\n   * @property {Array.<string>} warnings Warning messages generated by the server when executing the query.\n   * @property {Boolean} isSchemaInAgreement Whether the cluster had reached schema agreement after the execution of\n   * this query.\n   * <p>\n   *   After a successful schema-altering query (ex: creating a table), the driver will check if\n   *   the cluster's nodes agree on the new schema version. If not, it will keep retrying for a given\n   *   delay (see <code>protocolOptions.maxSchemaAgreementWaitSeconds</code>).\n   * </p>\n   * <p>\n   *   Note that the schema agreement check is only performed for schema-altering queries For other\n   *   query types, this method will always return <code>true</code>. If this method returns <code>false</code>,\n   *   clients can call [Metadata.checkSchemaAgreement()]{@link module:metadata~Metadata#checkSchemaAgreement} later to\n   *   perform the check manually.\n   * </p>\n   */\n  this.info = {\n    queriedHost: host,\n    triedHosts: triedHosts,\n    speculativeExecutions: speculativeExecutions,\n    achievedConsistency: consistency,\n    traceId: null,\n    warnings: null,\n    customPayload: null,\n    isSchemaInAgreement\n  };\n\n  if (response.flags) {\n    this.info.traceId = response.flags.traceId;\n    this.info.warnings = response.flags.warnings;\n    this.info.customPayload = response.flags.customPayload;\n  }\n  /**\n   * Gets an array rows returned by the query, in case the result was buffered.\n   * @type {Array.<Row>}\n   */\n  this.rows = response.rows;\n  /**\n   * Gets the row length of the result, regardless if the result has been buffered or not\n   * @type {Number}\n   */\n  this.rowLength = this.rows ? this.rows.length : response.rowLength;\n  /**\n   * Gets the columns returned in this ResultSet.\n   * @type {Array.<{name, type}>}\n   * @default null\n   */\n  this.columns = null;\n  /**\n   * A string token representing the current page state of query. It can be used in the following executions to\n   * continue paging and retrieve the remained of the result for the query.\n   * @type String\n   * @default null\n   */\n  this.pageState = null;\n  /**\n   * Method used to manually fetch the next page of results.\n   * This method is only exposed when using the {@link Client#eachRow} method and there are more rows available in\n   * following pages.\n   * @type Function\n   */\n  this.nextPage = undefined;\n\n  const meta = response.meta;\n\n  if (meta) {\n    this.columns = meta.columns;\n\n    if (meta.pageState) {\n      this.pageState = meta.pageState.toString('hex');\n\n      // Expose rawPageState internally\n      Object.defineProperty(this, 'rawPageState', { value: meta.pageState, enumerable: false });\n    }\n  }\n}\n\n/**\n * Returns the first row or null if the result rows are empty.\n */\nResultSet.prototype.first = function () {\n  if (this.rows && this.rows.length) {\n    return this.rows[0];\n  }\n  return null;\n};\n\nResultSet.prototype.getPageState = function () {\n  // backward-compatibility\n  return this.pageState;\n};\n\nResultSet.prototype.getColumns = function () {\n  // backward-compatibility\n  return this.columns;\n};\n\n/**\n * When this instance is the result of a conditional update query, it returns whether it was successful.\n * Otherwise, it returns <code>true</code>.\n * <p>\n *   For consistency, this method always returns <code>true</code> for non-conditional queries (although there is\n *   no reason to call the method in that case). This is also the case for conditional DDL statements\n *   (CREATE KEYSPACE... IF NOT EXISTS, CREATE TABLE... IF NOT EXISTS), for which the server doesn't return\n *   information whether it was applied or not.\n * </p>\n */\nResultSet.prototype.wasApplied = function () {\n  if (!this.rows || this.rows.length === 0) {\n    return true;\n  }\n  const firstRow = this.rows[0];\n  const applied = firstRow['[applied]'];\n  return typeof applied === 'boolean' ? applied : true;\n};\n\n/**\n * Gets the iterator function.\n * <p>\n *   Retrieves the iterator of the underlying fetched rows and will not cause the driver to fetch the following\n *   result pages. For more information on result paging,\n *   [visit the documentation]{@link http://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.\n * </p>\n * @alias module:types~ResultSet#@@iterator\n * @example <caption>Using for...of statement</caption>\n * const query = 'SELECT name, email, address FROM users WHERE id = ?';\n * const result = await client.execute(query, [ id ], { prepare: true });\n * for (let row of result) {\n *   console.log(row['email']);\n * }\n * @returns {Iterator.<Row>}\n */\nResultSet.prototype[Symbol.iterator] = function getIterator() {\n  if (!this.rows) {\n    return utils.emptyArray[Symbol.iterator]();\n  }\n  return this.rows[Symbol.iterator]();\n};\n\nmodule.exports = ResultSet;","'use strict';\nconst util = require('util');\nconst stream = require('stream');\n\n/** @module types */\n/**\n * Readable stream using to yield data from a result or a field\n * @constructor\n */\nfunction ResultStream(opt) {\n  stream.Readable.call(this, opt);\n  this.buffer = [];\n  this.paused = true;\n}\n\nutil.inherits(ResultStream, stream.Readable);\n\nResultStream.prototype._read = function() {\n  this.paused = false;\n  if (this.buffer.length === 0) {\n    this._readableState.reading = false;\n  }\n  while (!this.paused && this.buffer.length > 0) {\n    this.paused = !this.push(this.buffer.shift());\n  }\n  if ( !this.paused && !this.buffer.length && this._readNext ) {\n    this._readNext();\n    this._readNext = null;\n  }\n};\n\n/**\n * Allows for throttling, helping nodejs keep the internal buffers reasonably sized.\n * @param {function} readNext function that triggers reading the next result chunk\n */\nResultStream.prototype._valve = function( readNext ) {\n  this._readNext = null;\n  if ( !readNext ) {\n    return;\n  }\n  if ( this.paused || this.buffer.length ) {\n    this._readNext = readNext;\n  }\n  else {\n    readNext();\n  }\n};\n\nResultStream.prototype.add = function (chunk) {\n  this.buffer.push(chunk);\n  this.read(0);\n};\n\nmodule.exports = ResultStream;","\"use strict\";\n/** @module types */\n/**\n * Represents a result row\n * @param {Array} columns\n * @constructor\n */\nfunction Row(columns) {\n  if (!columns) {\n    throw new Error('Columns not defined');\n  }\n  //Private non-enumerable properties, with double underscore to avoid interfering with column names\n  Object.defineProperty(this, '__columns', { value: columns, enumerable: false, writable: false});\n}\n\n/**\n * Returns the cell value.\n * @param {String|Number} columnName Name or index of the column\n */\nRow.prototype.get = function (columnName) {\n  if (typeof columnName === 'number') {\n    //its an index\n    return this[this.__columns[columnName].name];\n  }\n  return this[columnName];\n};\n\n/**\n * Returns an array of the values of the row\n * @returns {Array}\n */\nRow.prototype.values = function () {\n  const valuesArray = [];\n  this.forEach(function (val) {\n    valuesArray.push(val);\n  });\n  return valuesArray;\n};\n\n/**\n * Returns an array of the column names of the row\n * @returns {Array}\n */\nRow.prototype.keys = function () {\n  const keysArray = [];\n  this.forEach(function (val, key) {\n    keysArray.push(key);\n  });\n  return keysArray;\n};\n\n/**\n * Executes the callback for each field in the row, containing the value as first parameter followed by the columnName\n * @param {Function} callback\n */\nRow.prototype.forEach = function (callback) {\n  for (const columnName in this) {\n    if (!this.hasOwnProperty(columnName)) {\n      continue;\n    }\n    callback(this[columnName], columnName);\n  }\n};\n\nmodule.exports = Row;","'use strict';\nconst util = require('util');\nconst crypto = require('crypto');\nconst Long = require('long');\n\nconst Uuid = require('./uuid');\nconst utils = require('../utils');\n\n/** @module types */\n/**\n * Oct 15, 1582 in milliseconds since unix epoch\n * @const\n * @private\n */\nconst _unixToGregorian = 12219292800000;\n/**\n * 10,000 ticks in a millisecond\n * @const\n * @private\n */\nconst _ticksInMs = 10000;\n\nconst minNodeId = utils.allocBufferFromString('808080808080', 'hex');\nconst minClockId = utils.allocBufferFromString('8080', 'hex');\nconst maxNodeId = utils.allocBufferFromString('7f7f7f7f7f7f', 'hex');\nconst maxClockId = utils.allocBufferFromString('7f7f', 'hex');\n\n/**\n * Counter used to generate up to 10000 different timeuuid values with the same Date\n * @private\n * @type {number}\n */\nlet _ticks = 0;\n/**\n * Counter used to generate ticks for the current time\n * @private\n * @type {number}\n */\nlet _ticksForCurrentTime = 0;\n/**\n * Remember the last time when a ticks for the current time so that it can be reset\n * @private\n * @type {number}\n */\nlet _lastTimestamp = 0;\n\n/**\n * Creates a new instance of Uuid based on the parameters provided according to rfc4122.\n * If any of the arguments is not provided, it will be randomly generated, except for the date that will use the current\n * date.\n * <p>\n *   Note that when nodeId and/or clockId portions are not provided, the constructor will generate them using\n *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's\n *   recommended that you use the callback-based version of the static methods <code>fromDate()</code> or\n *   <code>now()</code> in that case.\n * </p>\n * @class\n * @classdesc Represents an immutable version 1 universally unique identifier (UUID). A UUID represents a 128-bit value.\n * <p>Usage: <code>TimeUuid.now()</code></p>\n * @extends module:types~Uuid\n * @param {Date} [value] The datetime for the instance, if not provided, it will use the current Date.\n * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,\n * as Ecmascript Dates have only milliseconds precision.\n * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.\n * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.\n * @constructor\n */\nfunction TimeUuid(value, ticks, nodeId, clockId) {\n  let buffer;\n  if (value instanceof Buffer) {\n    if (value.length !== 16) {\n      throw new Error('Buffer for v1 uuid not valid');\n    }\n    buffer = value;\n  }\n  else {\n    buffer = generateBuffer(value, ticks, nodeId, clockId);\n  }\n  Uuid.call(this, buffer);\n}\n\nutil.inherits(TimeUuid, Uuid);\n\n/**\n * Generates a TimeUuid instance based on the Date provided using random node and clock values.\n * @param {Date} date Date to generate the v1 uuid.\n * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,\n * as Ecmascript Dates have only milliseconds precision.\n * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.\n * If not provided, a random nodeId will be generated.\n * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.\n * If not provided a random clockId will be generated.\n * @param {Function} [callback] An optional callback to be invoked with the error as first parameter and the created\n * <code>TimeUuid</code> as second parameter. When a callback is provided, the random portions of the\n * <code>TimeUuid</code> instance are created asynchronously.\n * <p>\n *   When nodeId and/or clockId portions are not provided, this method will generate them using\n *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's\n *   recommended that you use the callback-based version of this method in that case.\n * </p>\n * @example <caption>Generate a TimeUuid from a ECMAScript Date</caption>\n * const timeuuid = TimeUuid.fromDate(new Date());\n * @example <caption>Generate a TimeUuid from a Date with ticks portion</caption>\n * const timeuuid = TimeUuid.fromDate(new Date(), 1203);\n * @example <caption>Generate a TimeUuid from a Date without any random portion</caption>\n * const timeuuid = TimeUuid.fromDate(new Date(), 1203, 'host01', '02');\n * @example <caption>Generate a TimeUuid from a Date with random node and clock identifiers</caption>\n * TimeUuid.fromDate(new Date(), 1203, function (err, timeuuid) {\n *   // do something with the generated timeuuid\n * });\n */\nTimeUuid.fromDate = function (date, ticks, nodeId, clockId, callback) {\n  if (typeof ticks === 'function') {\n    callback = ticks;\n    ticks = nodeId = clockId = null;\n  } else if (typeof nodeId === 'function') {\n    callback = nodeId;\n    nodeId = clockId = null;\n  } else if (typeof clockId === 'function') {\n    callback = clockId;\n    clockId = null;\n  }\n\n  if (!callback) {\n    return new TimeUuid(date, ticks, nodeId, clockId);\n  }\n\n  utils.parallel([\n    next => getOrGenerateRandom(nodeId, 6, (err, buffer) => next(err, nodeId = buffer)),\n    next => getOrGenerateRandom(clockId, 2, (err, buffer) => next(err, clockId = buffer)),\n  ], (err) => {\n    if (err) {\n      return callback(err);\n    }\n\n    let timeUuid;\n    try {\n      timeUuid = new TimeUuid(date, ticks, nodeId, clockId);\n    }\n    catch (e) {\n      return callback(e);\n    }\n\n    callback(null, timeUuid);\n  });\n};\n\n/**\n * Parses a string representation of a TimeUuid\n * @param {String} value\n * @returns {TimeUuid}\n */\nTimeUuid.fromString = function (value) {\n  return new TimeUuid(Uuid.fromString(value).getBuffer());\n};\n\n/**\n * Returns the smaller possible type 1 uuid with the provided Date.\n */\nTimeUuid.min = function (date, ticks) {\n  return new TimeUuid(date, ticks, minNodeId, minClockId);\n};\n\n/**\n * Returns the biggest possible type 1 uuid with the provided Date.\n */\nTimeUuid.max = function (date, ticks) {\n  return new TimeUuid(date, ticks, maxNodeId, maxClockId);\n};\n\n/**\n * Generates a TimeUuid instance based on the current date using random node and clock values.\n * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.\n * If not provided, a random nodeId will be generated.\n * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.\n * If not provided a random clockId will be generated.\n * @param {Function} [callback] An optional callback to be invoked with the error as first parameter and the created\n * <code>TimeUuid</code> as second parameter. When a callback is provided, the random portions of the\n * <code>TimeUuid</code> instance are created asynchronously.\n * <p>\n *   When nodeId and/or clockId portions are not provided, this method will generate them using\n *   <code>crypto.randomBytes()</code>. As it's possible that <code>crypto.randomBytes()</code> might block, it's\n *   recommended that you use the callback-based version of this method in that case.\n * </p>\n * @example <caption>Generate a TimeUuid from a Date without any random portion</caption>\n * const timeuuid = TimeUuid.now('host01', '02');\n * @example <caption>Generate a TimeUuid with random node and clock identifiers</caption>\n * TimeUuid.now(function (err, timeuuid) {\n *   // do something with the generated timeuuid\n * });\n * @example <caption>Generate a TimeUuid based on the current date (might block)</caption>\n * const timeuuid = TimeUuid.now();\n */\nTimeUuid.now = function (nodeId, clockId, callback) {\n  return TimeUuid.fromDate(null, null, nodeId, clockId, callback);\n};\n\n\n/**\n * Gets the Date and 100-nanoseconds units representation of this instance.\n * @returns {{date: Date, ticks: Number}}\n */\nTimeUuid.prototype.getDatePrecision = function () {\n  const timeLow = this.buffer.readUInt32BE(0);\n\n  let timeHigh = 0;\n  timeHigh |= ( this.buffer[4] & 0xff ) << 8;\n  timeHigh |= this.buffer[5] & 0xff;\n  timeHigh |= ( this.buffer[6] & 0x0f ) << 24;\n  timeHigh |= ( this.buffer[7] & 0xff ) << 16;\n\n  const val = Long.fromBits(timeLow, timeHigh);\n  const ticksInMsLong = Long.fromNumber(_ticksInMs);\n  const ticks = val.modulo(ticksInMsLong);\n  const time = val\n    .div(ticksInMsLong)\n    .subtract(Long.fromNumber(_unixToGregorian));\n  return { date: new Date(time.toNumber()), ticks: ticks.toNumber()};\n};\n\n/**\n * Gets the Date representation of this instance.\n * @returns {Date}\n */\nTimeUuid.prototype.getDate = function () {\n  return this.getDatePrecision().date;\n};\n\n/**\n * Returns the node id this instance\n * @returns {Buffer}\n */\nTimeUuid.prototype.getNodeId = function () {\n  return this.buffer.slice(10);\n};\n\n/**\n * Returns the clock id this instance, with the variant applied (first 2 msb being 1 and 0).\n * @returns {Buffer}\n */\nTimeUuid.prototype.getClockId = function () {\n  return this.buffer.slice(8, 10);\n};\n\n/**\n * Returns the node id this instance as an ascii string\n * @returns {String}\n */\nTimeUuid.prototype.getNodeIdString = function () {\n  return this.buffer.slice(10).toString('ascii');\n};\n\nfunction writeTime(buffer, time, ticks) {\n  //value time expressed in ticks precision\n  const val = Long\n    .fromNumber(time + _unixToGregorian)\n    .multiply(Long.fromNumber(10000))\n    .add(Long.fromNumber(ticks));\n  const timeHigh = val.getHighBitsUnsigned();\n  buffer.writeUInt32BE(val.getLowBitsUnsigned(), 0);\n  buffer.writeUInt16BE(timeHigh & 0xffff, 4);\n  buffer.writeUInt16BE(timeHigh >>> 16 & 0xffff, 6);\n}\n\n/**\n * Returns a buffer of length 2 representing the clock identifier\n * @param {String|Buffer} clockId\n * @returns {Buffer}\n * @private\n */\nfunction getClockId(clockId) {\n  let buffer = clockId;\n  if (typeof clockId === 'string') {\n    buffer = utils.allocBufferFromString(clockId, 'ascii');\n  }\n  if (!(buffer instanceof Buffer)) {\n    //Generate\n    buffer = getRandomBytes(2);\n  }\n  else if (buffer.length !== 2) {\n    throw new Error('Clock identifier must have 2 bytes');\n  }\n  return buffer;\n}\n\n/**\n * Returns a buffer of length 6 representing the clock identifier\n * @param {String|Buffer} nodeId\n * @returns {Buffer}\n * @private\n */\nfunction getNodeId(nodeId) {\n  let buffer = nodeId;\n  if (typeof nodeId === 'string') {\n    buffer = utils.allocBufferFromString(nodeId, 'ascii');\n  }\n  if (!(buffer instanceof Buffer)) {\n    //Generate\n    buffer = getRandomBytes(6);\n  }\n  else if (buffer.length !== 6) {\n    throw new Error('Node identifier must have 6 bytes');\n  }\n  return buffer;\n}\n\n/**\n * Returns the ticks portion of a timestamp.  If the ticks are not provided an internal counter is used that gets reset at 10000.\n * @private\n * @param {Number} [ticks] \n * @returns {Number} \n */\nfunction getTicks(ticks) {\n  if (typeof ticks !== 'number'|| ticks >= _ticksInMs) {\n    _ticks++;\n    if (_ticks >= _ticksInMs) {\n      _ticks = 0;\n    }\n    ticks = _ticks;\n  }\n  return ticks;\n}\n\n/**\n * Returns an object with the time representation of the date expressed in milliseconds since unix epoch \n * and a ticks property for the 100-nanoseconds precision.\n * @private\n * @returns {{time: Number, ticks: Number}} \n */\nfunction getTimeWithTicks(date, ticks) {\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    // time with ticks for the current time\n    date = new Date();\n    const time = date.getTime();\n    _ticksForCurrentTime++;\n    if(_ticksForCurrentTime > _ticksInMs || time > _lastTimestamp) {\n      _ticksForCurrentTime = 0;\n      _lastTimestamp = time;\n    }\n    ticks = _ticksForCurrentTime;\n  }\n  return {\n    time: date.getTime(),\n    ticks: getTicks(ticks)\n  };\n}\n\nfunction getRandomBytes(length) {\n  return crypto.randomBytes(length);\n}\n\nfunction getOrGenerateRandom(id, length, callback) {\n  if (id) {\n    return callback(null, id);\n  }\n  crypto.randomBytes(length, callback);\n}\n\n/**\n * Generates a 16-length Buffer instance\n * @private\n * @param {Date} date\n * @param {Number} ticks\n * @param {String|Buffer} nodeId\n * @param {String|Buffer} clockId\n * @returns {Buffer}\n */\nfunction generateBuffer(date, ticks, nodeId, clockId) {\n  const timeWithTicks = getTimeWithTicks(date, ticks);\n  nodeId = getNodeId(nodeId);\n  clockId = getClockId(clockId);\n  const buffer = utils.allocBufferUnsafe(16);\n  //Positions 0-7 Timestamp\n  writeTime(buffer, timeWithTicks.time, timeWithTicks.ticks);\n  //Position 8-9 Clock\n  clockId.copy(buffer, 8, 0);\n  //Positions 10-15 Node\n  nodeId.copy(buffer, 10, 0);\n  //Version Byte: Time based\n  //0001xxxx\n  //turn off first 4 bits\n  buffer[6] = buffer[6] & 0x0f;\n  //turn on fifth bit\n  buffer[6] = buffer[6] | 0x10;\n\n  //IETF Variant Byte: 1.0.x\n  //10xxxxxx\n  //turn off first 2 bits\n  buffer[8] = buffer[8] & 0x3f;\n  //turn on first bit\n  buffer[8] = buffer[8] | 0x80;\n  return buffer;\n}\n\nmodule.exports = TimeUuid;","\"use strict\";\nconst util = require('util');\n/** @module types */\n/**\n * Creates a new sequence of immutable objects with the parameters provided.\n * @class\n * @classdesc A tuple is a sequence of immutable objects.\n * Tuples are sequences, just like [Arrays]{@link Array}. The only difference is that tuples can't be changed.\n * <p>\n *   As tuples can be used as a Map keys, the {@link Tuple#toString toString()} method calls toString of each element,\n *   to try to get a unique string key.\n * </p>\n * @param [arguments] The sequence elements as arguments.\n * @constructor\n */\nfunction Tuple() {\n  let elements = Array.prototype.slice.call(arguments);\n  if (elements.length === 0) {\n    throw new TypeError('Tuple must contain at least one value');\n  }\n  if (elements.length === 1 && util.isArray(elements)) {\n    //The first argument is an array of the elements, use a copy of the array\n    elements = elements[0];\n  }\n \n  /** \n   * Immutable elements of Tuple object.\n   * @type Array\n   */\n  this.elements = elements;\n\n  /**\n   * Returns the number of the elements.\n   * @type Number\n   */\n  this.length = this.elements.length;\n}\n\n/**\n * Creates a new instance of a tuple based on the Array\n * @param {Array} elements\n * @returns {Tuple}\n */\nTuple.fromArray = function (elements) {\n  //Use a copy of an array\n  return new Tuple(elements.slice(0));\n};\n\n/**\n * Returns the value located at the index.\n * @param {Number} index Element index\n */\nTuple.prototype.get = function (index) {\n  return this.elements[index || 0];\n};\n\n/**\n * Returns the string representation of the sequence surrounded by parenthesis, ie: (1, 2).\n * <p>\n *   The returned value attempts to be a unique string representation of its values.\n * </p>\n * @returns {string}\n */\nTuple.prototype.toString = function () {\n  return ('(' +\n    this.elements.reduce(function (prev, x, i) {\n      return prev + (i > 0 ? ',' : '') + x.toString();\n    }, '') +\n    ')');\n};\n\n/**\n * Returns the Array representation of the sequence.\n * @returns {Array}\n */\nTuple.prototype.toJSON = function () {\n  return this.elements;\n};\n\n/**\n * Gets the elements as an array\n * @returns {Array}\n */\nTuple.prototype.values = function () {\n  return this.elements.slice(0);\n};\n\nmodule.exports = Tuple;","'use strict';\n\nconst crypto = require('crypto');\nconst utils = require('../utils');\n\n/** @module types */\n\n/**\n * Creates a new instance of Uuid based on a Buffer\n * @class\n * @classdesc Represents an immutable universally unique identifier (UUID). A UUID represents a 128-bit value.\n * @param {Buffer} buffer The 16-length buffer.\n * @constructor\n */\nfunction Uuid(buffer) {\n  if (!buffer || buffer.length !== 16) {\n    throw new Error('You must provide a buffer containing 16 bytes');\n  }\n  this.buffer = buffer;\n}\n\n/**\n * Parses a string representation of a Uuid\n * @param {String} value\n * @returns {Uuid}\n */\nUuid.fromString = function (value) {\n  //36 chars: 32 + 4 hyphens\n  if (typeof value !== 'string' || value.length !== 36) {\n    throw new Error('Invalid string representation of Uuid, it should be in the 00000000-0000-0000-0000-000000000000');\n  }\n  return new Uuid(utils.allocBufferFromString(value.replace(/-/g, ''), 'hex'));\n};\n\n/**\n * Creates a new random (version 4) Uuid.\n * @param {function} [callback] Optional callback to be invoked with the error as first parameter and the created Uuid as\n * second parameter.\n * @returns {Uuid}\n */\nUuid.random = function (callback) {\n  if (callback) {\n    getRandomBytes(function(err, buffer) {\n      if (err) {\n        return callback(err);\n      }\n      return callback(null, createUuidFromBuffer(buffer));\n    });\n  } else {\n    const buffer = getRandomBytes();\n    return createUuidFromBuffer(buffer);\n  }\n};\n\n/**\n * Gets the bytes representation of a Uuid\n * @returns {Buffer}\n */\nUuid.prototype.getBuffer = function () {\n  return this.buffer;\n};\n/**\n * Compares this object to the specified object.\n * The result is true if and only if the argument is not null, is a UUID object, and contains the same value, bit for bit, as this UUID.\n * @param {Uuid} other The other value to test for equality.\n */\nUuid.prototype.equals = function (other) {\n  return other instanceof Uuid && this.buffer.equals(other.buffer);\n};\n\n/**\n * Returns a string representation of the value of this Uuid instance.\n * 32 hex separated by hyphens, in the form of 00000000-0000-0000-0000-000000000000.\n * @returns {String}\n */\nUuid.prototype.toString = function () {\n  //32 hex representation of the Buffer\n  const hexValue = getHex(this);\n  return (\n    hexValue.substr(0, 8) + '-' +\n    hexValue.substr(8, 4) + '-' +\n    hexValue.substr(12, 4) + '-' +\n    hexValue.substr(16, 4) + '-' +\n    hexValue.substr(20, 12));\n};\n\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nUuid.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nUuid.prototype.toJSON = function () {\n  return this.toString();\n};\n\n\n/**\n * Returns new Uuid\n * @private\n * @returns {Uuid}\n */\nfunction createUuidFromBuffer (buffer) {\n  //clear the version\n  buffer[6] &= 0x0f;\n  //set the version 4\n  buffer[6] |= 0x40;\n  //clear the variant\n  buffer[8] &= 0x3f;\n  //set the IETF variant\n  buffer[8] |= 0x80;\n  return new Uuid(buffer);\n}\n\n/**\n * @private\n * @returns {String} 32 hex representation of the instance, without separators\n */\nfunction getHex (uuid) {\n  return uuid.buffer.toString('hex');\n}\n\n/**\n * Gets a crypto generated 16 bytes\n * @private\n * @returns {Buffer}\n */\nfunction getRandomBytes (cb) {\n  return crypto.randomBytes(16, cb);\n}\n\nmodule.exports = Uuid;\n","'use strict';\n\nconst _versionPattern = /(\\d+)\\.(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+)?)?(?:[-~]([\\w+]*(?:-\\w[.\\w]*)*))?(?:\\+([.\\w]+))?/;\n\n/**\n * Represents a version number in the form of X.Y.Z with optional pre-release and build metadata.\n *\n * Version numbers compare the usual way, the major version number (X) is compared first, then\n * the minor one (Y) and then the patch level one (Z).  If pre-release or other build metadata\n * is present for a version, that version is considered less than an otherwise equivalent version\n * that doesn't have these labels, otherwise they are considered equal.\n *\n * As of initial implementation versions are only compared against those with at most patch versions\n * more refined comparisons are not needed.\n *\n * @property {Number} major The major version, X of X.Y.Z.\n * @property {Number} minor The minor version, Y of X.Y.Z.\n * @property {Number} patch The patch version, Z of X.Y.Z.\n * @property {Number} dsePatch The dsePatch version, A of X.Y.Z.A or undefined if not present.\n * @property {String[]} preReleases Prerelease indicators if present, i.e. SNAPSHOT of X.Y.Z-SNAPSHOT.\n * @property {String} build Build string if present, i.e. build1 of X.Y.Z+build1.\n *\n * @ignore\n */\nclass VersionNumber {\n  constructor(major, minor, patch, dsePatch, preReleases, build) {\n    this.major = major;\n    this.minor = minor;\n    this.patch = patch;\n    this.dsePatch = dsePatch;\n    this.preReleases = preReleases;\n    this.build = build;\n  }\n\n  /**\n   * @return {String} String representation of this version.\n   */\n  toString() {\n    let str = this.major + '.' + this.minor;\n    if (this.patch !== undefined) {\n      str += '.' + this.patch;\n    }\n    if (this.dsePatch !== undefined) {\n      str += '.' + this.dsePatch;\n    }\n    if (this.preReleases !== undefined) {\n      this.preReleases.forEach((preRelease) => {\n        str += '-' + preRelease;\n      });\n    }\n    if (this.build) {\n      str += '+' + this.build;\n    }\n    return str;\n  }\n\n  /**\n   * Compares this version with the provided version. \n   * @param {VersionNumber} other \n   * @return {Number} -1 if less than other, 0 if equal, 1 if greater than.\n   */\n  compare(other) {\n    if (this.major < other.major) {\n      return -1;\n    } else if (this.major > other.major) {\n      return 1;\n    } else if (this.minor < other.minor) {\n      return -1;\n    } else if (this.minor > other.minor) {\n      return 1;\n    }\n\n    // sanitize patch by setting to 0 if undefined.\n    const thisPatch = this.patch || 0;\n    const otherPatch = other.patch || 0;\n    if (thisPatch < otherPatch) {\n      return -1;\n    } else if (thisPatch > otherPatch) {\n      return 1;\n    }\n\n    // if dsePatch is set in one case, but not other, consider the one where it is set as greater.\n    if (this.dsePatch === undefined) {\n      if (other.dsePatch !== undefined) {\n        return -1;\n      }\n    } else if (other.dsePatch === undefined) {\n      return 1;\n    } else {\n      if (this.dsePatch < other.dsePatch) {\n        return -1;\n      } else if (this.dsePatch > other.dsePatch) {\n        return 1;\n      }\n    }\n\n    // If prereleases are present, consider less than those that don't have any.\n    if (this.preReleases === undefined) {\n      if (other.preReleases !== undefined) {\n        return 1;\n      }\n    } else if (other.preReleases === undefined) {\n      return -1;\n    }\n   \n    // Don't consider build.\n    return 0;\n  }\n\n  static parse(version) {\n    if (!version) {\n      return null;\n    }\n\n    const match = version.match(_versionPattern);\n    if (match) {\n      const major = parseInt(match[1], 10);\n      const minor = parseInt(match[2], 10);\n      const patch = match[3] ? parseInt(match[3], 10) : undefined;\n      const dsePatch = match[4] ? parseInt(match[4], 10) : undefined;\n      const preReleases = match[5] ? match[5].split('-') : undefined;\n      const build = match[6];\n      return new VersionNumber(major, minor, patch, dsePatch, preReleases, build);\n    }\n    throw new TypeError('Could not extract version from \\'' + version + '\\'');\n  }\n}\n\nmodule.exports = VersionNumber;","\"use strict\";\nconst util = require('util');\nconst errors = require('./errors');\n\n/**\n * Max int that can be accurately represented with 64-bit Number (2^53)\n * @type {number}\n * @const\n */\nconst maxInt = 9007199254740992;\n\nconst emptyObject = Object.freeze({});\n\nfunction noop() {}\n\n/**\n * Forward-compatible allocation of buffer, filled with zeros.\n * @type {Function}\n */\nconst allocBuffer = Buffer.alloc || allocBufferFillDeprecated;\n\n/**\n * Forward-compatible unsafe allocation of buffer.\n * @type {Function}\n */\nconst allocBufferUnsafe = Buffer.allocUnsafe || allocBufferDeprecated;\n\n/**\n * Forward-compatible allocation of buffer to contain a string.\n * @type {Function}\n */\nconst allocBufferFromString = (Int8Array.from !== Buffer.from && Buffer.from) || allocBufferFromStringDeprecated;\n\n/**\n * Forward-compatible allocation of buffer from an array of bytes\n * @type {Function}\n */\nconst allocBufferFromArray = (Int8Array.from !== Buffer.from && Buffer.from) || allocBufferFromArrayDeprecated;\n\nfunction allocBufferDeprecated(size) {\n  // eslint-disable-next-line\n  return new Buffer(size);\n}\n\nfunction allocBufferFillDeprecated(size) {\n  const b = allocBufferDeprecated(size);\n  b.fill(0);\n  return b;\n}\n\nfunction allocBufferFromStringDeprecated(text, encoding) {\n  if (typeof text !== 'string') {\n    throw new TypeError('Expected string, obtained ' + util.inspect(text));\n  }\n  // eslint-disable-next-line\n  return new Buffer(text, encoding);\n}\n\nfunction allocBufferFromArrayDeprecated(arr) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('Expected Array, obtained ' + util.inspect(arr));\n  }\n  // eslint-disable-next-line\n  return new Buffer(arr);\n}\n\n/**\n * Creates a copy of a buffer\n */\nfunction copyBuffer(buf) {\n  const targetBuffer = allocBufferUnsafe(buf.length);\n  buf.copy(targetBuffer);\n  return targetBuffer;\n}\n\n/**\n * Appends the original stack trace to the error after a tick of the event loop\n */\nfunction fixStack(stackTrace, error) {\n  if (stackTrace) {\n    error.stack += '\\n  (event loop)\\n' + stackTrace.substr(stackTrace.indexOf(\"\\n\") + 1);\n  }\n  return error;\n}\n\n/**\n * Uses the logEmitter to emit log events\n * @param {String} type\n * @param {String} info\n * @param [furtherInfo]\n */\nfunction log(type, info, furtherInfo) {\n  if (!this.logEmitter) {\n    if (!this.options || !this.options.logEmitter) {\n      throw new Error('Log emitter not defined');\n    }\n    this.logEmitter = this.options.logEmitter;\n  }\n  this.logEmitter('log', type, this.constructor.name, info, furtherInfo || '');\n}\n\n/**\n * Gets the sum of the length of the items of an array\n */\nfunction totalLength (arr) {\n  if (arr.length === 1) {\n    return arr[0].length;\n  }\n  let total = 0;\n  arr.forEach(function (item) {\n    let length = item.length;\n    length = length ? length : 0;\n    total += length;\n  });\n  return total;\n}\n\n/**\n * Merge the contents of two or more objects together into the first object. Similar to jQuery.extend / Object.assign.\n * The main difference between this method is that declared properties with an <code>undefined</code> value are not set\n * to the target.\n */\nfunction extend(target) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = source[key];\n      if (value === undefined) {\n        continue;\n      }\n      target[key] = value;\n    }\n  });\n  return target;\n}\n\n/**\n * Returns a new object with the property names set to lowercase.\n */\nfunction toLowerCaseProperties(obj) {\n  const keys = Object.keys(obj);\n  const result = {};\n  for (let i = 0; i < keys.length; i++) {\n    const k = keys[i];\n    result[k.toLowerCase()] = obj[k];\n  }\n  return result;\n}\n\n/**\n * Extends the target by the most inner props of sources\n * @param {Object} target\n * @returns {Object}\n */\nfunction deepExtend(target) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    for (const prop in source) {\n      if (!source.hasOwnProperty(prop)) {\n        continue;\n      }\n      const targetProp = target[prop];\n      const targetType = (typeof targetProp);\n      //target prop is\n      // a native single type\n      // or not existent\n      // or is not an anonymous object (not class instance)\n      if (!targetProp ||\n        targetType === 'number' ||\n        targetType === 'string' ||\n        util.isArray(targetProp) ||\n        util.isDate(targetProp) ||\n        targetProp.constructor.name !== 'Object') {\n        target[prop] = source[prop];\n      }\n      else {\n        //inner extend\n        target[prop] = deepExtend({}, targetProp, source[prop]);\n      }\n    }\n  });\n  return target;\n}\n\nfunction propCompare(propName) {\n  return function (a, b) {\n    if (a[propName] > b[propName]) {\n      return 1;\n    }\n    if (a[propName] < b[propName]) {\n      return -1;\n    }\n    return 0;\n  };\n}\n\nfunction funcCompare(name, argArray) {\n  return (function (a, b) {\n    if (typeof a[name] === 'undefined') {\n      return 0;\n    }\n    const valA = a[name].apply(a, argArray);\n    const valB = b[name].apply(b, argArray);\n    if (valA > valB) {\n      return 1;\n    }\n    if (valA < valB) {\n      return -1;\n    }\n    return 0;\n  });\n}\n/**\n * Uses the iterator protocol to go through the items of the Array\n * @param arr\n * @returns {{next: function}}\n */\nfunction arrayIterator (arr) {\n  let index = 0;\n  return { next : function () {\n    if (index >= arr.length) {\n      return {done: true};\n    }\n    return {value: arr[index++], done: false };\n  }};\n}\n\n/**\n * Convert the iterator values into an array\n * @param iterator\n * @returns {Array}\n */\nfunction iteratorToArray(iterator) {\n  const values = [];\n  let item = iterator.next();\n  while (!item.done) {\n    values.push(item.value);\n    item = iterator.next();\n  }\n  return values;\n}\n\n/**\n * Searches the specified Array for the provided key using the binary\n * search algorithm.  The Array must be sorted.\n * @param {Array} arr\n * @param key\n * @param {function} compareFunc\n * @returns {number} The position of the key in the Array, if it is found.\n * If it is not found, it returns a negative number which is the bitwise complement of the index of the first element that is larger than key.\n */\nfunction binarySearch(arr, key, compareFunc) {\n  let low = 0;\n  let high = arr.length-1;\n\n  while (low <= high) {\n    const mid = (low + high) >>> 1;\n    const midVal = arr[mid];\n    const cmp = compareFunc(midVal, key);\n    if (cmp < 0) {\n      low = mid + 1;\n    }\n    else if (cmp > 0) {\n      high = mid - 1;\n    }\n    else\n    {\n      //The key was found in the Array\n      return mid;\n    }\n  }\n  // key not found\n  return ~low;\n}\n\n/**\n * Inserts the value in the position determined by its natural order determined by the compare func\n * @param {Array} arr\n * @param item\n * @param {function} compareFunc\n */\nfunction insertSorted(arr, item, compareFunc) {\n  if (arr.length === 0) {\n    return arr.push(item);\n  }\n  let position = binarySearch(arr, item, compareFunc);\n  if (position < 0) {\n    position = ~position;\n  }\n  arr.splice(position, 0, item);\n}\n\n/**\n * Validates the provided parameter is of type function.\n * @param {Function} fn The instance to validate.\n * @param {String} [name] Name of the function to use in the error message. Defaults to 'callback'.\n * @returns {Function}\n */\nfunction validateFn(fn, name) {\n  if (typeof fn !== 'function') {\n    throw new errors.ArgumentError(util.format('%s is not a function', name || 'callback'));\n  }\n  return fn;\n}\n\n/**\n * Adapts the parameters based on the prepared metadata.\n * If the params are passed as an associative array (Object),\n * it adapts the object into an array with the same order as columns\n * @param {Array|Object} params\n * @param {Array} columns\n * @returns {Array} Returns an array of parameters.\n * @throws {Error} In case a parameter with a specific name is not defined\n */\nfunction adaptNamedParamsPrepared(params, columns) {\n  if (!params || util.isArray(params) || !columns || columns.length === 0) {\n    // params is an array or there aren't parameters\n    return params;\n  }\n  const paramsArray = new Array(columns.length);\n  params = toLowerCaseProperties(params);\n  const keys = {};\n  for (let i = 0; i < columns.length; i++) {\n    const name = columns[i].name;\n    if (!params.hasOwnProperty(name)) {\n      throw new errors.ArgumentError(util.format('Parameter \"%s\" not defined', name));\n    }\n    paramsArray[i] = params[name];\n    keys[name] = i;\n  }\n  return paramsArray;\n}\n\n/**\n * Adapts the associative-array of parameters and hints for simple statements\n * into Arrays based on the (arbitrary) position of the keys.\n * @param {Array|Object} params\n * @param {ExecutionOptions} execOptions\n * @returns {{ params: Array<{name, value}>, namedParameters: boolean, keyIndexes: object }} Returns an array of\n * parameters and the keys as an associative array.\n */\nfunction adaptNamedParamsWithHints(params, execOptions) {\n  if (!params || util.isArray(params)) {\n    //The parameters is an Array or there isn't parameter\n    return { params: params, namedParameters: false, keyIndexes: null };\n  }\n\n  const keys = Object.keys(params);\n  const paramsArray = new Array(keys.length);\n  const hints = new Array(keys.length);\n  const userHints = execOptions.getHints() || emptyObject;\n  const keyIndexes = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    // As lower cased identifiers\n    paramsArray[i] = { name: key.toLowerCase(), value: params[key]};\n    hints[i] = userHints[key];\n    keyIndexes[key] = i;\n  }\n\n  execOptions.setHints(hints);\n\n  return { params: paramsArray, namedParameters: true, keyIndexes };\n}\n\n/**\n * Returns a string with a value repeated n times\n * @param {String} val\n * @param {Number} times\n * @returns {String}\n */\nfunction stringRepeat(val, times) {\n  if (!times || times < 0) {\n    return null;\n  }\n  if (times === 1) {\n    return val;\n  }\n  return new Array(times + 1).join(val);\n}\n\n/**\n * Returns an array containing the values of the Object, similar to Object.values().\n * If obj is null or undefined, it will return an empty array.\n * @param {Object} obj\n * @returns {Array}\n */\nfunction objectValues(obj) {\n  if (!obj) {\n    return exports.emptyArray;\n  }\n  const keys = Object.keys(obj);\n  const values = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    values[i] = obj[keys[i]];\n  }\n  return values;\n}\n\n/**\n * Wraps the callback-based method. When no originalCallback is not defined, it returns a Promise.\n * @param {ClientOptions} options\n * @param {Function} originalCallback\n * @param {Function} handler\n * @returns {Promise|undefined}\n */\nfunction promiseWrapper(options, originalCallback, handler) {\n  if (typeof originalCallback === 'function') {\n    // Callback-based invocation\n    handler.call(this, originalCallback);\n    return undefined;\n  }\n  const factory = options.promiseFactory || defaultPromiseFactory;\n  const self = this;\n  return factory(function handlerWrapper(callback) {\n    handler.call(self, callback);\n  });\n}\n\n/**\n * @param {Function} handler\n * @returns {Promise}\n */\nfunction defaultPromiseFactory(handler) {\n  return new Promise(function executor(resolve, reject) {\n    handler(function handlerCallback(err, result) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(result);\n    });\n  });\n}\n\n/**\n * Shuffles an Array in-place.\n * @param {Array} arr\n * @private\n */\nfunction shuffleArray(arr) {\n  // Fisher–Yates algorithm\n  for (let i = arr.length - 1; i > 0; i--) {\n    // Math.random() has an extremely short permutation cycle length but we don't care about collisions\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n}\n\n// Classes\n\n/**\n * Represents a unique set of values.\n * @constructor\n */\nfunction HashSet() {\n  this.length = 0;\n  this.items = {};\n}\n\n/**\n * Adds a new item to the set.\n * @param {Object} key\n * @returns {boolean} Returns true if it was added to the set; false if the key is already present.\n */\nHashSet.prototype.add = function (key) {\n  if (this.items[key]) {\n    return false;\n  }\n  this.items[key] = true;\n  this.length++;\n  return true;\n};\n\n/**\n * @returns {boolean} Returns true if the key is present in the set.\n */\nHashSet.prototype.contains = function (key) {\n  return this.items[key] === true;\n};\n\n/**\n * Returns an array containing the set items.\n * @returns {Array}\n */\nHashSet.prototype.toArray = function () {\n  return Object.keys(this.items);\n};\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction each(arr, fn, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter is not an Array');\n  }\n  callback = callback || noop;\n  const length = arr.length;\n  if (length === 0) {\n    return callback();\n  }\n  let completed = 0;\n  for (let i = 0; i < length; i++) {\n    fn(arr[i], next);\n  }\n  function next(err) {\n    if (err) {\n      const cb = callback;\n      callback = noop;\n      cb(err);\n      return;\n    }\n    if (++completed !== length) {\n      return;\n    }\n    callback();\n  }\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction eachSeries(arr, fn, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter is not an Array');\n  }\n  callback = callback || noop;\n  const length = arr.length;\n  if (length === 0) {\n    return callback();\n  }\n  let sync;\n  let index = 1;\n  fn(arr[0], next);\n  if (sync === undefined) {\n    sync = false;\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (index >= length) {\n      return callback();\n    }\n    if (sync === undefined) {\n      sync = true;\n    }\n    if (sync) {\n      return process.nextTick(function () {\n        fn(arr[index++], next);\n      });\n    }\n    fn(arr[index++], next);\n  }\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction forEachOf(arr, fn, callback) {\n  return mapEach(arr, fn, true, callback);\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction map(arr, fn, callback) {\n  return mapEach(arr, fn, false, callback);\n}\n\nfunction mapEach(arr, fn, useIndex, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  const length = arr.length;\n  if (length === 0) {\n    return callback(null, []);\n  }\n  const result = new Array(length);\n  let completed = 0;\n  const invoke = useIndex ? invokeWithIndex : invokeWithoutIndex;\n  for (let i = 0; i < length; i++) {\n    invoke(i);\n  }\n\n  function invokeWithoutIndex(i) {\n    fn(arr[i], function mapItemCallback(err, transformed) {\n      result[i] = transformed;\n      next(err);\n    });\n  }\n\n  function invokeWithIndex(i) {\n    fn(arr[i], i, function mapItemCallback(err, transformed) {\n      result[i] = transformed;\n      next(err);\n    });\n  }\n\n  function next(err) {\n    if (err) {\n      const cb = callback;\n      callback = noop;\n      cb(err);\n      return;\n    }\n    if (++completed !== length) {\n      return;\n    }\n    callback(null, result);\n  }\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction mapSeries(arr, fn, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  const length = arr.length;\n  if (length === 0) {\n    return callback(null, []);\n  }\n  const result = new Array(length);\n  let index = 0;\n  let sync;\n  invoke(0);\n  if (sync === undefined) {\n    sync = false;\n  }\n\n  function invoke(i) {\n    fn(arr[i], function mapItemCallback(err, transformed) {\n      result[i] = transformed;\n      next(err);\n    });\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (++index === length) {\n      return callback(null, result);\n    }\n    if (sync === undefined) {\n      sync = true;\n    }\n    const i = index;\n    if (sync) {\n      return process.nextTick(function () {\n        invoke(i);\n      });\n    }\n    invoke(index);\n  }\n}\n\n/**\n * @param {Array.<Function>} arr\n * @param {Function} [callback]\n */\nfunction parallel(arr, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  const length = arr.length;\n  let completed = 0;\n  for (let i = 0; i < length; i++) {\n    arr[i](next);\n  }\n  function next(err) {\n    if (err) {\n      const cb = callback;\n      callback = noop;\n      return cb(err);\n    }\n    if (++completed !== length) {\n      return;\n    }\n    callback();\n  }\n}\n\n/**\n * Similar to async.series(), but instead accumulating the result in an Array, it callbacks with the result of the last\n * function in the array.\n * @param {Array.<Function>} arr\n * @param {Function} [callback]\n */\nfunction series(arr, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  let index = 0;\n  let sync;\n  next();\n  function next(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    if (index === arr.length) {\n      return callback(null, result);\n    }\n    if (sync) {\n      return process.nextTick(function () {\n        sync = true;\n        arr[index++](next);\n        sync = false;\n      });\n    }\n    sync = true;\n    arr[index++](next);\n    sync = false;\n  }\n}\n\n/**\n * @param {Number} count\n * @param {Function} iteratorFunc\n * @param {Function} [callback]\n */\nfunction times(count, iteratorFunc, callback) {\n  callback = callback || noop;\n  count = +count;\n  if (isNaN(count) || count === 0) {\n    return callback();\n  }\n  let completed = 0;\n  for (let i = 0; i < count; i++) {\n    iteratorFunc(i, next);\n  }\n  function next(err) {\n    if (err) {\n      const cb = callback;\n      callback = noop;\n      return cb(err);\n    }\n    if (++completed !== count) {\n      return;\n    }\n    callback();\n  }\n}\n\n/**\n * @param {Number} count\n * @param {Number} limit\n * @param {Function} iteratorFunc\n * @param {Function} [callback]\n */\nfunction timesLimit(count, limit, iteratorFunc, callback) {\n  let sync = undefined;\n  callback = callback || noop;\n  limit = Math.min(limit, count);\n  let index = limit - 1;\n  let i;\n  let completed = 0;\n  for (i = 0; i < limit; i++) {\n    iteratorFunc(i, next);\n  }\n  i = -1;\n  function next(err) {\n    if (err) {\n      const cb = callback;\n      callback = noop;\n      cb(err);\n      return;\n    }\n    if (++completed === count) {\n      return callback();\n    }\n    index++;\n    if (index >= count) {\n      return;\n    }\n    if (sync === undefined) {\n      sync = (i >= 0);\n    }\n    if (sync) {\n      const captureIndex = index;\n      return process.nextTick(function () {\n        iteratorFunc(captureIndex, next);\n      });\n    }\n    iteratorFunc(index, next);\n  }\n}\n\n/**\n * @param {Number} count\n * @param {Function} iteratorFunction\n * @param {Function} callback\n */\nfunction timesSeries(count, iteratorFunction, callback) {\n  count = +count;\n  if (isNaN(count) || count < 1) {\n    return callback();\n  }\n  let index = 1;\n  let sync;\n  iteratorFunction(0, next);\n  if (sync === undefined) {\n    sync = false;\n  }\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (index === count) {\n      return callback();\n    }\n    if (sync === undefined) {\n      sync = true;\n    }\n    const i = index++;\n    if (sync) {\n      //Prevent \"Maximum call stack size exceeded\"\n      return process.nextTick(function () {\n        iteratorFunction(i, next);\n      });\n    }\n    //do a sync call as the callback is going to call on a future tick\n    iteratorFunction(i, next);\n  }\n}\n\n/**\n * @param {Function} condition\n * @param {Function} fn\n * @param {Function} callback\n */\nfunction whilst(condition, fn, callback) {\n  let sync = 0;\n  next();\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (!condition()) {\n      return callback();\n    }\n    if (sync === 0) {\n      sync = 1;\n      fn(function (err) {\n        if (sync === 1) {\n          //sync function\n          sync = 4;\n        }\n        next(err);\n      });\n      if (sync === 1) {\n        //async function\n        sync = 2;\n      }\n      return;\n    }\n    if (sync === 4) {\n      //Prevent \"Maximum call stack size exceeded\"\n      return process.nextTick(function () {\n        fn(next);\n      });\n    }\n    //do a sync call as the callback is going to call on a future tick\n    fn(next);\n  }\n}\n\nexports.adaptNamedParamsPrepared = adaptNamedParamsPrepared;\nexports.adaptNamedParamsWithHints = adaptNamedParamsWithHints;\nexports.allocBuffer = allocBuffer;\nexports.allocBufferUnsafe = allocBufferUnsafe;\nexports.allocBufferFromArray = allocBufferFromArray;\nexports.allocBufferFromString = allocBufferFromString;\nexports.arrayIterator = arrayIterator;\nexports.binarySearch = binarySearch;\nexports.copyBuffer = copyBuffer;\nexports.deepExtend = deepExtend;\nexports.each = each;\nexports.eachSeries = eachSeries;\n/** @const */\nexports.emptyArray = Object.freeze([]);\n/** @const */\nexports.emptyObject = emptyObject;\nexports.extend = extend;\nexports.fixStack = fixStack;\nexports.forEachOf = forEachOf;\nexports.funcCompare = funcCompare;\nexports.insertSorted = insertSorted;\nexports.iteratorToArray = iteratorToArray;\nexports.log = log;\nexports.map = map;\nexports.mapSeries = mapSeries;\nexports.maxInt = maxInt;\nexports.noop = noop;\nexports.objectValues = objectValues;\nexports.parallel = parallel;\nexports.promiseWrapper = promiseWrapper;\nexports.propCompare = propCompare;\nexports.series = series;\nexports.stringRepeat = stringRepeat;\nexports.shuffleArray = shuffleArray;\nexports.times = times;\nexports.timesLimit = timesLimit;\nexports.timesSeries = timesSeries;\nexports.totalLength = totalLength;\nexports.validateFn = validateFn;\nexports.whilst = whilst;\nexports.HashSet = HashSet;","'use strict';\nconst events = require('events');\n\nconst types = require('./types');\nconst utils = require('./utils.js');\nconst FrameHeader = types.FrameHeader;\n\n/**\n * Contains the logic to write all the different types to the frame.\n */\nclass FrameWriter {\n  /**\n   * Creates a new instance of FrameWriter.\n   * @param {Number} opcode\n   */\n  constructor(opcode) {\n    if (!opcode) {\n      throw new Error('Opcode not provided');\n    }\n    this.buffers = [];\n    this.opcode = opcode;\n    this.bodyLength = 0;\n  }\n\n  add(buf) {\n    this.buffers.push(buf);\n    this.bodyLength += buf.length;\n  }\n\n  writeShort(num) {\n    const buf = utils.allocBufferUnsafe(2);\n    buf.writeUInt16BE(num, 0);\n    this.add(buf);\n  }\n\n  writeInt(num) {\n    const buf = utils.allocBufferUnsafe(4);\n    buf.writeInt32BE(num, 0);\n    this.add(buf);\n  }\n\n  /** @param {Long} num */\n  writeLong(num) {\n    this.add(types.Long.toBuffer(num));\n  }\n\n  /**\n   * Writes bytes according to Cassandra <int byteLength><bytes>\n   * @param {Buffer|null|types.unset} bytes\n   */\n  writeBytes(bytes) {\n    if (bytes === null) {\n      //Only the length buffer containing -1\n      this.writeInt(-1);\n      return;\n    }\n    if (bytes === types.unset) {\n      this.writeInt(-2);\n      return;\n    }\n    //Add the length buffer\n    this.writeInt(bytes.length);\n    //Add the actual buffer\n    this.add(bytes);\n  }\n\n  /**\n   * Writes a buffer according to Cassandra protocol: bytes.length (2) + bytes\n   * @param {Buffer} bytes\n   */\n  writeShortBytes(bytes) {\n    if(bytes === null) {\n      //Only the length buffer containing -1\n      this.writeShort(-1);\n      return;\n    }\n    //Add the length buffer\n    this.writeShort(bytes.length);\n    //Add the actual buffer\n    this.add(bytes);\n  }\n\n  /**\n   * Writes a single byte\n   * @param {Number} num Value of the byte, a number between 0 and 255.\n   */\n  writeByte(num) {\n    this.add(utils.allocBufferFromArray([num]));\n  }\n\n  writeString(str) {\n    if (typeof str === \"undefined\") {\n      throw new Error(\"can not write undefined\");\n    }\n    const len = Buffer.byteLength(str, 'utf8');\n    const buf = utils.allocBufferUnsafe(2 + len);\n    buf.writeUInt16BE(len, 0);\n    buf.write(str, 2, buf.length-2, 'utf8');\n    this.add(buf);\n  }\n\n  writeLString(str) {\n    const len = Buffer.byteLength(str, 'utf8');\n    const buf = utils.allocBufferUnsafe(4 + len);\n    buf.writeInt32BE(len, 0);\n    buf.write(str, 4, buf.length-4, 'utf8');\n    this.add(buf);\n  }\n\n  writeStringList(values) {\n    this.writeShort(values.length);\n    values.forEach(this.writeString, this);\n  }\n\n  writeCustomPayload(payload) {\n    const keys = Object.keys(payload);\n    this.writeShort(keys.length);\n    keys.forEach(function (k) {\n      this.writeString(k);\n      this.writeBytes(payload[k]);\n    }, this);\n  }\n\n  writeStringMap(map) {\n    const keys = [];\n    for (const k in map) {\n      if (map.hasOwnProperty(k)) {\n        keys.push(k);\n      }\n    }\n\n    this.writeShort(keys.length);\n\n    for(let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      this.writeString(key);\n      this.writeString(map[key]);\n    }\n  }\n\n  /**\n   * @param {Number} version\n   * @param {Number} streamId\n   * @param {Number} [flags] Header flags\n   * @returns {Buffer}\n   * @throws {TypeError}\n   */\n  write(version, streamId, flags) {\n    const header = new FrameHeader(version, flags || 0, streamId, this.opcode, this.bodyLength);\n    const headerBuffer = header.toBuffer();\n    this.buffers.unshift(headerBuffer);\n    return Buffer.concat(this.buffers, headerBuffer.length + this.bodyLength);\n  }\n}\n\n/**\n * Represents a queue that process one write at a time (FIFO).\n * @extends {EventEmitter}\n */\nclass WriteQueue extends events.EventEmitter {\n  /**\n   * Creates a new WriteQueue instance.\n   * @param {Socket} netClient\n   * @param {Encoder} encoder\n   * @param {ClientOptions} options\n   */\n  constructor(netClient, encoder, options) {\n    super();\n    this.netClient = netClient;\n    this.encoder = encoder;\n    this.isRunning = false;\n    /** @type {Array<{operation: OperationState, callback: Function}>} */\n    this.queue = [];\n    this.coalescingThreshold = options.socketOptions.coalescingThreshold;\n    this.error = null;\n  }\n\n  /**\n   * Enqueues a new request\n   * @param {OperationState} operation\n   * @param {Function} callback The write callback.\n   */\n  push(operation, callback) {\n    const self = this;\n    if (this.error) {\n      // There was a write error, there is no point in further trying to write to the socket.\n      return process.nextTick(function writePushError() {\n        callback(self.error);\n      });\n    }\n    this.queue.push({ operation: operation, callback: callback});\n    this.run();\n  }\n\n  run() {\n    if (!this.isRunning) {\n      this.isRunning = true;\n      // Use nextTick to allow the queue to build up on the current phase\n      process.nextTick(() => this.process());\n    }\n  }\n\n  process() {\n    if (this.error) {\n      return;\n    }\n\n    const buffers = [];\n    const callbacks = [];\n    let totalLength = 0;\n\n    while (this.queue.length > 0 && totalLength < this.coalescingThreshold) {\n      const writeItem = this.queue.shift();\n      if (!writeItem.operation.canBeWritten()) {\n        // Invoke the write callback with an error that is not going to be yielded to user\n        // as the operation has timed out or was cancelled.\n        writeItem.callback(new Error('The operation was already cancelled or timeout elapsed'));\n        continue;\n      }\n      let data;\n      try {\n        data = writeItem.operation.request.write(this.encoder, writeItem.operation.streamId);\n      }\n      catch (err) {\n        writeItem.callback(err);\n        continue;\n      }\n      totalLength += data.length;\n      buffers.push(data);\n      callbacks.push(writeItem.callback);\n    }\n\n    if (totalLength === 0) {\n      this.isRunning = false;\n      return;\n    }\n\n    // We have to invoke the callbacks to avoid race conditions.\n    // There is a performance benefit from executing all of them in a loop\n    for (let i = 0; i < callbacks.length; i++) {\n      callbacks[i]();\n    }\n    // Concatenate buffers and write it to the socket\n    // Further writes will be throttled until flushed\n    this.netClient.write(Buffer.concat(buffers, totalLength), err => {\n      if (err) {\n        this.setWriteError(err);\n        return;\n      }\n      if (this.queue.length === 0) {\n        // It will start running once we get the next message\n        this.isRunning = false;\n        return;\n      }\n      // Allow IO between writes\n      setImmediate(() => this.process());\n    });\n  }\n\n  /**\n   * Emits the 'error' event and callbacks items that haven't been written and clears them from the queue.\n   * @param err\n   */\n  setWriteError(err) {\n    err.isSocketError = true;\n    this.error = new types.DriverError('Socket was closed');\n    this.error.isSocketError = true;\n    // Use an special flag for items that haven't been written\n    this.error.requestNotWritten = true;\n    this.error.innerError = err;\n    const q = this.queue;\n    // Not more items can be added to the queue.\n    this.queue = utils.emptyArray;\n    for (let i = 0; i < q.length; i++) {\n      const item = q[i];\n      // Use the error marking that it was not written\n      item.callback(this.error);\n    }\n  }\n}\n\nexports.WriteQueue = WriteQueue;\nexports.FrameWriter = FrameWriter;\n","/*!\n * content-disposition\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = contentDisposition\nmodule.exports.parse = parse\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar basename = require('path').basename\nvar Buffer = require('safe-buffer').Buffer\n\n/**\n * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including \"%\")\n * @private\n */\n\nvar ENCODE_URL_ATTR_CHAR_REGEXP = /[\\x00-\\x20\"'()*,/:;<=>?@[\\\\\\]{}\\x7f]/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match percent encoding escape.\n * @private\n */\n\nvar HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/\nvar HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g\n\n/**\n * RegExp to match non-latin1 characters.\n * @private\n */\n\nvar NON_LATIN1_REGEXP = /[^\\x20-\\x7e\\xa0-\\xff]/g\n\n/**\n * RegExp to match quoted-pair in RFC 2616\n *\n * quoted-pair = \"\\\" CHAR\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\n * @private\n */\n\nvar QESC_REGEXP = /\\\\([\\u0000-\\u007f])/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 2616\n * @private\n */\n\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp for various RFC 2616 grammar\n *\n * parameter     = token \"=\" ( token | quoted-string )\n * token         = 1*<any CHAR except CTLs or separators>\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *               | \"{\" | \"}\" | SP | HT\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n * qdtext        = <any TEXT except <\">>\n * quoted-pair   = \"\\\" CHAR\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\n * TEXT          = <any OCTET except CTLs, but including LWS>\n * LWS           = [CRLF] 1*( SP | HT )\n * CRLF          = CR LF\n * CR            = <US-ASCII CR, carriage return (13)>\n * LF            = <US-ASCII LF, linefeed (10)>\n * SP            = <US-ASCII SP, space (32)>\n * HT            = <US-ASCII HT, horizontal-tab (9)>\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n * OCTET         = <any 8-bit sequence of data>\n * @private\n */\n\nvar PARAM_REGEXP = /;[\\x09\\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*=[\\x09\\x20]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*/g // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\x20-\\x7e\\x80-\\xff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/\n\n/**\n * RegExp for various RFC 5987 grammar\n *\n * ext-value     = charset  \"'\" [ language ] \"'\" value-chars\n * charset       = \"UTF-8\" / \"ISO-8859-1\" / mime-charset\n * mime-charset  = 1*mime-charsetc\n * mime-charsetc = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"%\" / \"&\"\n *               / \"+\" / \"-\" / \"^\" / \"_\" / \"`\"\n *               / \"{\" / \"}\" / \"~\"\n * language      = ( 2*3ALPHA [ extlang ] )\n *               / 4ALPHA\n *               / 5*8ALPHA\n * extlang       = *3( \"-\" 3ALPHA )\n * value-chars   = *( pct-encoded / attr-char )\n * pct-encoded   = \"%\" HEXDIG HEXDIG\n * attr-char     = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"&\" / \"+\" / \"-\" / \".\"\n *               / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n * @private\n */\n\nvar EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/\n\n/**\n * RegExp for various RFC 6266 grammar\n *\n * disposition-type = \"inline\" | \"attachment\" | disp-ext-type\n * disp-ext-type    = token\n * disposition-parm = filename-parm | disp-ext-parm\n * filename-parm    = \"filename\" \"=\" value\n *                  | \"filename*\" \"=\" ext-value\n * disp-ext-parm    = token \"=\" value\n *                  | ext-token \"=\" ext-value\n * ext-token        = <the characters in token, followed by \"*\">\n * @private\n */\n\nvar DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*(?:$|;)/ // eslint-disable-line no-control-regex\n\n/**\n * Create an attachment Content-Disposition header.\n *\n * @param {string} [filename]\n * @param {object} [options]\n * @param {string} [options.type=attachment]\n * @param {string|boolean} [options.fallback=true]\n * @return {string}\n * @public\n */\n\nfunction contentDisposition (filename, options) {\n  var opts = options || {}\n\n  // get type\n  var type = opts.type || 'attachment'\n\n  // get parameters\n  var params = createparams(filename, opts.fallback)\n\n  // format into string\n  return format(new ContentDisposition(type, params))\n}\n\n/**\n * Create parameters object from filename and fallback.\n *\n * @param {string} [filename]\n * @param {string|boolean} [fallback=true]\n * @return {object}\n * @private\n */\n\nfunction createparams (filename, fallback) {\n  if (filename === undefined) {\n    return\n  }\n\n  var params = {}\n\n  if (typeof filename !== 'string') {\n    throw new TypeError('filename must be a string')\n  }\n\n  // fallback defaults to true\n  if (fallback === undefined) {\n    fallback = true\n  }\n\n  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {\n    throw new TypeError('fallback must be a string or boolean')\n  }\n\n  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {\n    throw new TypeError('fallback must be ISO-8859-1 string')\n  }\n\n  // restrict to file base name\n  var name = basename(filename)\n\n  // determine if name is suitable for quoted string\n  var isQuotedString = TEXT_REGEXP.test(name)\n\n  // generate fallback name\n  var fallbackName = typeof fallback !== 'string'\n    ? fallback && getlatin1(name)\n    : basename(fallback)\n  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name\n\n  // set extended filename parameter\n  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {\n    params['filename*'] = name\n  }\n\n  // set filename parameter\n  if (isQuotedString || hasFallback) {\n    params.filename = hasFallback\n      ? fallbackName\n      : name\n  }\n\n  return params\n}\n\n/**\n * Format object to Content-Disposition header.\n *\n * @param {object} obj\n * @param {string} obj.type\n * @param {object} [obj.parameters]\n * @return {string}\n * @private\n */\n\nfunction format (obj) {\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  // start with normalized type\n  var string = String(type).toLowerCase()\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      var val = param.substr(-1) === '*'\n        ? ustring(parameters[param])\n        : qstring(parameters[param])\n\n      string += '; ' + param + '=' + val\n    }\n  }\n\n  return string\n}\n\n/**\n * Decode a RFC 6987 field value (gracefully).\n *\n * @param {string} str\n * @return {string}\n * @private\n */\n\nfunction decodefield (str) {\n  var match = EXT_VALUE_REGEXP.exec(str)\n\n  if (!match) {\n    throw new TypeError('invalid extended field value')\n  }\n\n  var charset = match[1].toLowerCase()\n  var encoded = match[2]\n  var value\n\n  // to binary string\n  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)\n\n  switch (charset) {\n    case 'iso-8859-1':\n      value = getlatin1(binary)\n      break\n    case 'utf-8':\n      value = Buffer.from(binary, 'binary').toString('utf8')\n      break\n    default:\n      throw new TypeError('unsupported charset in extended field')\n  }\n\n  return value\n}\n\n/**\n * Get ISO-8859-1 version of string.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction getlatin1 (val) {\n  // simple Unicode -> ISO-8859-1 transformation\n  return String(val).replace(NON_LATIN1_REGEXP, '?')\n}\n\n/**\n * Parse Content-Disposition header string.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string || typeof string !== 'string') {\n    throw new TypeError('argument string is required')\n  }\n\n  var match = DISPOSITION_TYPE_REGEXP.exec(string)\n\n  if (!match) {\n    throw new TypeError('invalid type format')\n  }\n\n  // normalize type\n  var index = match[0].length\n  var type = match[1].toLowerCase()\n\n  var key\n  var names = []\n  var params = {}\n  var value\n\n  // calculate index to start at\n  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'\n    ? index - 1\n    : index\n\n  // match parameters\n  while ((match = PARAM_REGEXP.exec(string))) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (names.indexOf(key) !== -1) {\n      throw new TypeError('invalid duplicate parameter')\n    }\n\n    names.push(key)\n\n    if (key.indexOf('*') + 1 === key.length) {\n      // decode extended value\n      key = key.slice(0, -1)\n      value = decodefield(value)\n\n      // overwrite existing value\n      params[key] = value\n      continue\n    }\n\n    if (typeof params[key] === 'string') {\n      continue\n    }\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(QESC_REGEXP, '$1')\n    }\n\n    params[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return new ContentDisposition(type, params)\n}\n\n/**\n * Percent decode a single character.\n *\n * @param {string} str\n * @param {string} hex\n * @return {string}\n * @private\n */\n\nfunction pdecode (str, hex) {\n  return String.fromCharCode(parseInt(hex, 16))\n}\n\n/**\n * Percent encode a single character.\n *\n * @param {string} char\n * @return {string}\n * @private\n */\n\nfunction pencode (char) {\n  return '%' + String(char)\n    .charCodeAt(0)\n    .toString(16)\n    .toUpperCase()\n}\n\n/**\n * Quote a string for HTTP.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Encode a Unicode string for HTTP (RFC 5987).\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction ustring (val) {\n  var str = String(val)\n\n  // percent encode as UTF-8\n  var encoded = encodeURIComponent(str)\n    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)\n\n  return 'UTF-8\\'\\'' + encoded\n}\n\n/**\n * Class for parsed Content-Disposition header for v8 optimization\n *\n * @public\n * @param {string} type\n * @param {object} parameters\n * @constructor\n */\n\nfunction ContentDisposition (type, parameters) {\n  this.type = type\n  this.parameters = parameters\n}\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","/**\n * Module dependencies.\n */\n\nvar crypto = require('crypto');\n\n/**\n * Sign the given `val` with `secret`.\n *\n * @param {String} val\n * @param {String} secret\n * @return {String}\n * @api private\n */\n\nexports.sign = function(val, secret){\n  if ('string' != typeof val) throw new TypeError(\"Cookie value must be provided as a string.\");\n  if ('string' != typeof secret) throw new TypeError(\"Secret string must be provided.\");\n  return val + '.' + crypto\n    .createHmac('sha256', secret)\n    .update(val)\n    .digest('base64')\n    .replace(/\\=+$/, '');\n};\n\n/**\n * Unsign and decode the given `val` with `secret`,\n * returning `false` if the signature is invalid.\n *\n * @param {String} val\n * @param {String} secret\n * @return {String|Boolean}\n * @api private\n */\n\nexports.unsign = function(val, secret){\n  if ('string' != typeof val) throw new TypeError(\"Signed cookie string must be provided.\");\n  if ('string' != typeof secret) throw new TypeError(\"Secret string must be provided.\");\n  var str = val.slice(0, val.lastIndexOf('.'))\n    , mac = exports.sign(str, secret);\n  \n  return sha1(mac) == sha1(val) ? str : false;\n};\n\n/**\n * Private\n */\n\nfunction sha1(str){\n  return crypto.createHash('sha1').update(str).digest('hex');\n}\n","/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar pairSplitRegExp = /; */;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var pairs = str.split(pairSplitRegExp);\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var eq_idx = pair.indexOf('=');\n\n    // skip things that don't look like key=value\n    if (eq_idx < 0) {\n      continue;\n    }\n\n    var key = pair.substr(0, eq_idx).trim()\n    var val = pair.substr(++eq_idx, pair.length).trim();\n\n    // quoted values\n    if ('\"' == val[0]) {\n      val = val.slice(1, -1);\n    }\n\n    // only assign once\n    if (undefined == obj[key]) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","/*!\n * depd\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar callSiteToString = require('./lib/compat').callSiteToString\nvar eventListenerCount = require('./lib/compat').eventListenerCount\nvar relative = require('path').relative\n\n/**\n * Module exports.\n */\n\nmodule.exports = depd\n\n/**\n * Get the path to base files on.\n */\n\nvar basePath = process.cwd()\n\n/**\n * Determine if namespace is contained in the string.\n */\n\nfunction containsNamespace (str, namespace) {\n  var vals = str.split(/[ ,]+/)\n  var ns = String(namespace).toLowerCase()\n\n  for (var i = 0; i < vals.length; i++) {\n    var val = vals[i]\n\n    // namespace contained\n    if (val && (val === '*' || val.toLowerCase() === ns)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Convert a data descriptor to accessor descriptor.\n */\n\nfunction convertDataDescriptorToAccessor (obj, prop, message) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n  var value = descriptor.value\n\n  descriptor.get = function getter () { return value }\n\n  if (descriptor.writable) {\n    descriptor.set = function setter (val) { return (value = val) }\n  }\n\n  delete descriptor.value\n  delete descriptor.writable\n\n  Object.defineProperty(obj, prop, descriptor)\n\n  return descriptor\n}\n\n/**\n * Create arguments string to keep arity.\n */\n\nfunction createArgumentsString (arity) {\n  var str = ''\n\n  for (var i = 0; i < arity; i++) {\n    str += ', arg' + i\n  }\n\n  return str.substr(2)\n}\n\n/**\n * Create stack string from stack.\n */\n\nfunction createStackString (stack) {\n  var str = this.name + ': ' + this.namespace\n\n  if (this.message) {\n    str += ' deprecated ' + this.message\n  }\n\n  for (var i = 0; i < stack.length; i++) {\n    str += '\\n    at ' + callSiteToString(stack[i])\n  }\n\n  return str\n}\n\n/**\n * Create deprecate for namespace in caller.\n */\n\nfunction depd (namespace) {\n  if (!namespace) {\n    throw new TypeError('argument namespace is required')\n  }\n\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n  var file = site[0]\n\n  function deprecate (message) {\n    // call to self as log\n    log.call(deprecate, message)\n  }\n\n  deprecate._file = file\n  deprecate._ignored = isignored(namespace)\n  deprecate._namespace = namespace\n  deprecate._traced = istraced(namespace)\n  deprecate._warned = Object.create(null)\n\n  deprecate.function = wrapfunction\n  deprecate.property = wrapproperty\n\n  return deprecate\n}\n\n/**\n * Determine if namespace is ignored.\n */\n\nfunction isignored (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.noDeprecation) {\n    // --no-deprecation support\n    return true\n  }\n\n  var str = process.env.NO_DEPRECATION || ''\n\n  // namespace ignored\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Determine if namespace is traced.\n */\n\nfunction istraced (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.traceDeprecation) {\n    // --trace-deprecation support\n    return true\n  }\n\n  var str = process.env.TRACE_DEPRECATION || ''\n\n  // namespace traced\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Display deprecation message.\n */\n\nfunction log (message, site) {\n  var haslisteners = eventListenerCount(process, 'deprecation') !== 0\n\n  // abort early if no destination\n  if (!haslisteners && this._ignored) {\n    return\n  }\n\n  var caller\n  var callFile\n  var callSite\n  var depSite\n  var i = 0\n  var seen = false\n  var stack = getStack()\n  var file = this._file\n\n  if (site) {\n    // provided site\n    depSite = site\n    callSite = callSiteLocation(stack[1])\n    callSite.name = depSite.name\n    file = callSite[0]\n  } else {\n    // get call site\n    i = 2\n    depSite = callSiteLocation(stack[i])\n    callSite = depSite\n  }\n\n  // get caller of deprecated thing in relation to file\n  for (; i < stack.length; i++) {\n    caller = callSiteLocation(stack[i])\n    callFile = caller[0]\n\n    if (callFile === file) {\n      seen = true\n    } else if (callFile === this._file) {\n      file = this._file\n    } else if (seen) {\n      break\n    }\n  }\n\n  var key = caller\n    ? depSite.join(':') + '__' + caller.join(':')\n    : undefined\n\n  if (key !== undefined && key in this._warned) {\n    // already warned\n    return\n  }\n\n  this._warned[key] = true\n\n  // generate automatic message from call site\n  var msg = message\n  if (!msg) {\n    msg = callSite === depSite || !callSite.name\n      ? defaultMessage(depSite)\n      : defaultMessage(callSite)\n  }\n\n  // emit deprecation if listeners exist\n  if (haslisteners) {\n    var err = DeprecationError(this._namespace, msg, stack.slice(i))\n    process.emit('deprecation', err)\n    return\n  }\n\n  // format and write message\n  var format = process.stderr.isTTY\n    ? formatColor\n    : formatPlain\n  var output = format.call(this, msg, caller, stack.slice(i))\n  process.stderr.write(output + '\\n', 'utf8')\n}\n\n/**\n * Get call site location as array.\n */\n\nfunction callSiteLocation (callSite) {\n  var file = callSite.getFileName() || '<anonymous>'\n  var line = callSite.getLineNumber()\n  var colm = callSite.getColumnNumber()\n\n  if (callSite.isEval()) {\n    file = callSite.getEvalOrigin() + ', ' + file\n  }\n\n  var site = [file, line, colm]\n\n  site.callSite = callSite\n  site.name = callSite.getFunctionName()\n\n  return site\n}\n\n/**\n * Generate a default message from the site.\n */\n\nfunction defaultMessage (site) {\n  var callSite = site.callSite\n  var funcName = site.name\n\n  // make useful anonymous name\n  if (!funcName) {\n    funcName = '<anonymous@' + formatLocation(site) + '>'\n  }\n\n  var context = callSite.getThis()\n  var typeName = context && callSite.getTypeName()\n\n  // ignore useless type name\n  if (typeName === 'Object') {\n    typeName = undefined\n  }\n\n  // make useful type name\n  if (typeName === 'Function') {\n    typeName = context.name || typeName\n  }\n\n  return typeName && callSite.getMethodName()\n    ? typeName + '.' + funcName\n    : funcName\n}\n\n/**\n * Format deprecation message without color.\n */\n\nfunction formatPlain (msg, caller, stack) {\n  var timestamp = new Date().toUTCString()\n\n  var formatted = timestamp +\n    ' ' + this._namespace +\n    ' deprecated ' + msg\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    at ' + callSiteToString(stack[i])\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' at ' + formatLocation(caller)\n  }\n\n  return formatted\n}\n\n/**\n * Format deprecation message with color.\n */\n\nfunction formatColor (msg, caller, stack) {\n  var formatted = '\\x1b[36;1m' + this._namespace + '\\x1b[22;39m' + // bold cyan\n    ' \\x1b[33;1mdeprecated\\x1b[22;39m' + // bold yellow\n    ' \\x1b[0m' + msg + '\\x1b[39m' // reset\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    \\x1b[36mat ' + callSiteToString(stack[i]) + '\\x1b[39m' // cyan\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' \\x1b[36m' + formatLocation(caller) + '\\x1b[39m' // cyan\n  }\n\n  return formatted\n}\n\n/**\n * Format call site location.\n */\n\nfunction formatLocation (callSite) {\n  return relative(basePath, callSite[0]) +\n    ':' + callSite[1] +\n    ':' + callSite[2]\n}\n\n/**\n * Get the stack as array of call sites.\n */\n\nfunction getStack () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = Math.max(10, limit)\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice this function off the top\n  var stack = obj.stack.slice(1)\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack\n}\n\n/**\n * Capture call site stack from v8.\n */\n\nfunction prepareObjectStackTrace (obj, stack) {\n  return stack\n}\n\n/**\n * Return a wrapped function in a deprecation message.\n */\n\nfunction wrapfunction (fn, message) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function')\n  }\n\n  var args = createArgumentsString(fn.length)\n  var deprecate = this // eslint-disable-line no-unused-vars\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  site.name = fn.name\n\n   // eslint-disable-next-line no-eval\n  var deprecatedfn = eval('(function (' + args + ') {\\n' +\n    '\"use strict\"\\n' +\n    'log.call(deprecate, message, site)\\n' +\n    'return fn.apply(this, arguments)\\n' +\n    '})')\n\n  return deprecatedfn\n}\n\n/**\n * Wrap property in a deprecation message.\n */\n\nfunction wrapproperty (obj, prop, message) {\n  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    throw new TypeError('argument obj must be object')\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n\n  if (!descriptor) {\n    throw new TypeError('must call property on owner object')\n  }\n\n  if (!descriptor.configurable) {\n    throw new TypeError('property must be configurable')\n  }\n\n  var deprecate = this\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  // set site name\n  site.name = prop\n\n  // convert data descriptor\n  if ('value' in descriptor) {\n    descriptor = convertDataDescriptorToAccessor(obj, prop, message)\n  }\n\n  var get = descriptor.get\n  var set = descriptor.set\n\n  // wrap getter\n  if (typeof get === 'function') {\n    descriptor.get = function getter () {\n      log.call(deprecate, message, site)\n      return get.apply(this, arguments)\n    }\n  }\n\n  // wrap setter\n  if (typeof set === 'function') {\n    descriptor.set = function setter () {\n      log.call(deprecate, message, site)\n      return set.apply(this, arguments)\n    }\n  }\n\n  Object.defineProperty(obj, prop, descriptor)\n}\n\n/**\n * Create DeprecationError for deprecation\n */\n\nfunction DeprecationError (namespace, message, stack) {\n  var error = new Error()\n  var stackString\n\n  Object.defineProperty(error, 'constructor', {\n    value: DeprecationError\n  })\n\n  Object.defineProperty(error, 'message', {\n    configurable: true,\n    enumerable: false,\n    value: message,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'name', {\n    enumerable: false,\n    configurable: true,\n    value: 'DeprecationError',\n    writable: true\n  })\n\n  Object.defineProperty(error, 'namespace', {\n    configurable: true,\n    enumerable: false,\n    value: namespace,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'stack', {\n    configurable: true,\n    enumerable: false,\n    get: function () {\n      if (stackString !== undefined) {\n        return stackString\n      }\n\n      // prepare stack trace\n      return (stackString = createStackString.call(this, stack))\n    },\n    set: function setter (val) {\n      stackString = val\n    }\n  })\n\n  return error\n}\n","/*!\n * depd\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = callSiteToString\n\n/**\n * Format a CallSite file location to a string.\n */\n\nfunction callSiteFileLocation (callSite) {\n  var fileName\n  var fileLocation = ''\n\n  if (callSite.isNative()) {\n    fileLocation = 'native'\n  } else if (callSite.isEval()) {\n    fileName = callSite.getScriptNameOrSourceURL()\n    if (!fileName) {\n      fileLocation = callSite.getEvalOrigin()\n    }\n  } else {\n    fileName = callSite.getFileName()\n  }\n\n  if (fileName) {\n    fileLocation += fileName\n\n    var lineNumber = callSite.getLineNumber()\n    if (lineNumber != null) {\n      fileLocation += ':' + lineNumber\n\n      var columnNumber = callSite.getColumnNumber()\n      if (columnNumber) {\n        fileLocation += ':' + columnNumber\n      }\n    }\n  }\n\n  return fileLocation || 'unknown source'\n}\n\n/**\n * Format a CallSite to a string.\n */\n\nfunction callSiteToString (callSite) {\n  var addSuffix = true\n  var fileLocation = callSiteFileLocation(callSite)\n  var functionName = callSite.getFunctionName()\n  var isConstructor = callSite.isConstructor()\n  var isMethodCall = !(callSite.isToplevel() || isConstructor)\n  var line = ''\n\n  if (isMethodCall) {\n    var methodName = callSite.getMethodName()\n    var typeName = getConstructorName(callSite)\n\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) !== 0) {\n        line += typeName + '.'\n      }\n\n      line += functionName\n\n      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {\n        line += ' [as ' + methodName + ']'\n      }\n    } else {\n      line += typeName + '.' + (methodName || '<anonymous>')\n    }\n  } else if (isConstructor) {\n    line += 'new ' + (functionName || '<anonymous>')\n  } else if (functionName) {\n    line += functionName\n  } else {\n    addSuffix = false\n    line += fileLocation\n  }\n\n  if (addSuffix) {\n    line += ' (' + fileLocation + ')'\n  }\n\n  return line\n}\n\n/**\n * Get constructor name of reviver.\n */\n\nfunction getConstructorName (obj) {\n  var receiver = obj.receiver\n  return (receiver.constructor && receiver.constructor.name) || null\n}\n","/*!\n * depd\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = eventListenerCount\n\n/**\n * Get the count of listeners on an event emitter of a specific type.\n */\n\nfunction eventListenerCount (emitter, type) {\n  return emitter.listeners(type).length\n}\n","/*!\n * depd\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar EventEmitter = require('events').EventEmitter\n\n/**\n * Module exports.\n * @public\n */\n\nlazyProperty(module.exports, 'callSiteToString', function callSiteToString () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  function prepareObjectStackTrace (obj, stack) {\n    return stack\n  }\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = 2\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice the stack\n  var stack = obj.stack.slice()\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack[0].toString ? toString : require('./callsite-tostring')\n})\n\nlazyProperty(module.exports, 'eventListenerCount', function eventListenerCount () {\n  return EventEmitter.listenerCount || require('./event-listener-count')\n})\n\n/**\n * Define a lazy property.\n */\n\nfunction lazyProperty (obj, prop, getter) {\n  function get () {\n    var val = getter()\n\n    Object.defineProperty(obj, prop, {\n      configurable: true,\n      enumerable: true,\n      value: val\n    })\n\n    return val\n  }\n\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: true,\n    get: get\n  })\n}\n\n/**\n * Call toString() on the obj\n */\n\nfunction toString (obj) {\n  return obj.toString()\n}\n","/*!\n * destroy\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar ReadStream = require('fs').ReadStream\nvar Stream = require('stream')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = destroy\n\n/**\n * Destroy a stream.\n *\n * @param {object} stream\n * @public\n */\n\nfunction destroy(stream) {\n  if (stream instanceof ReadStream) {\n    return destroyReadStream(stream)\n  }\n\n  if (!(stream instanceof Stream)) {\n    return stream\n  }\n\n  if (typeof stream.destroy === 'function') {\n    stream.destroy()\n  }\n\n  return stream\n}\n\n/**\n * Destroy a ReadStream.\n *\n * @param {object} stream\n * @private\n */\n\nfunction destroyReadStream(stream) {\n  stream.destroy()\n\n  if (typeof stream.close === 'function') {\n    // node.js core bug work-around\n    stream.on('open', onOpenClose)\n  }\n\n  return stream\n}\n\n/**\n * On open handler to close stream.\n * @private\n */\n\nfunction onOpenClose() {\n  if (typeof this.fd === 'number') {\n    // actually close down the fd\n    this.close()\n  }\n}\n","/*!\n * ee-first\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = first\n\n/**\n * Get the first event in a set of event emitters and event pairs.\n *\n * @param {array} stuff\n * @param {function} done\n * @public\n */\n\nfunction first(stuff, done) {\n  if (!Array.isArray(stuff))\n    throw new TypeError('arg must be an array of [ee, events...] arrays')\n\n  var cleanups = []\n\n  for (var i = 0; i < stuff.length; i++) {\n    var arr = stuff[i]\n\n    if (!Array.isArray(arr) || arr.length < 2)\n      throw new TypeError('each array member must be [ee, events...]')\n\n    var ee = arr[0]\n\n    for (var j = 1; j < arr.length; j++) {\n      var event = arr[j]\n      var fn = listener(event, callback)\n\n      // listen to the event\n      ee.on(event, fn)\n      // push this listener to the list of cleanups\n      cleanups.push({\n        ee: ee,\n        event: event,\n        fn: fn,\n      })\n    }\n  }\n\n  function callback() {\n    cleanup()\n    done.apply(null, arguments)\n  }\n\n  function cleanup() {\n    var x\n    for (var i = 0; i < cleanups.length; i++) {\n      x = cleanups[i]\n      x.ee.removeListener(x.event, x.fn)\n    }\n  }\n\n  function thunk(fn) {\n    done = fn\n  }\n\n  thunk.cancel = cleanup\n\n  return thunk\n}\n\n/**\n * Create the event listener.\n * @private\n */\n\nfunction listener(event, done) {\n  return function onevent(arg1) {\n    var args = new Array(arguments.length)\n    var ee = this\n    var err = event === 'error'\n      ? arg1\n      : null\n\n    // copy args to prevent arguments escaping scope\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    done(err, ee, event, args)\n  }\n}\n","/*!\n * encodeurl\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = encodeUrl\n\n/**\n * RegExp to match non-URL code points, *after* encoding (i.e. not including \"%\")\n * and including invalid escape sequences.\n * @private\n */\n\nvar ENCODE_CHARS_REGEXP = /(?:[^\\x21\\x25\\x26-\\x3B\\x3D\\x3F-\\x5B\\x5D\\x5F\\x61-\\x7A\\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g\n\n/**\n * RegExp to match unmatched surrogate pair.\n * @private\n */\n\nvar UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\\uD800-\\uDBFF])[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]([^\\uDC00-\\uDFFF]|$)/g\n\n/**\n * String to replace unmatched surrogate pair with.\n * @private\n */\n\nvar UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\\uFFFD$2'\n\n/**\n * Encode a URL to a percent-encoded form, excluding already-encoded sequences.\n *\n * This function will take an already-encoded URL and encode all the non-URL\n * code points. This function will not encode the \"%\" character unless it is\n * not part of a valid sequence (`%20` will be left as-is, but `%foo` will\n * be encoded as `%25foo`).\n *\n * This encode is meant to be \"safe\" and does not throw errors. It will try as\n * hard as it can to properly encode the given URL, including replacing any raw,\n * unpaired surrogate pairs with the Unicode replacement character prior to\n * encoding.\n *\n * @param {string} url\n * @return {string}\n * @public\n */\n\nfunction encodeUrl (url) {\n  return String(url)\n    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)\n    .replace(ENCODE_CHARS_REGEXP, encodeURI)\n}\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","/*!\n * etag\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = etag\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar crypto = require('crypto')\nvar Stats = require('fs').Stats\n\n/**\n * Module variables.\n * @private\n */\n\nvar toString = Object.prototype.toString\n\n/**\n * Generate an entity tag.\n *\n * @param {Buffer|string} entity\n * @return {string}\n * @private\n */\n\nfunction entitytag (entity) {\n  if (entity.length === 0) {\n    // fast-path empty\n    return '\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"'\n  }\n\n  // compute hash of entity\n  var hash = crypto\n    .createHash('sha1')\n    .update(entity, 'utf8')\n    .digest('base64')\n    .substring(0, 27)\n\n  // compute length of entity\n  var len = typeof entity === 'string'\n    ? Buffer.byteLength(entity, 'utf8')\n    : entity.length\n\n  return '\"' + len.toString(16) + '-' + hash + '\"'\n}\n\n/**\n * Create a simple ETag.\n *\n * @param {string|Buffer|Stats} entity\n * @param {object} [options]\n * @param {boolean} [options.weak]\n * @return {String}\n * @public\n */\n\nfunction etag (entity, options) {\n  if (entity == null) {\n    throw new TypeError('argument entity is required')\n  }\n\n  // support fs.Stats object\n  var isStats = isstats(entity)\n  var weak = options && typeof options.weak === 'boolean'\n    ? options.weak\n    : isStats\n\n  // validate argument\n  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {\n    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')\n  }\n\n  // generate entity tag\n  var tag = isStats\n    ? stattag(entity)\n    : entitytag(entity)\n\n  return weak\n    ? 'W/' + tag\n    : tag\n}\n\n/**\n * Determine if object is a Stats object.\n *\n * @param {object} obj\n * @return {boolean}\n * @api private\n */\n\nfunction isstats (obj) {\n  // genuine fs.Stats\n  if (typeof Stats === 'function' && obj instanceof Stats) {\n    return true\n  }\n\n  // quack quack\n  return obj && typeof obj === 'object' &&\n    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&\n    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&\n    'ino' in obj && typeof obj.ino === 'number' &&\n    'size' in obj && typeof obj.size === 'number'\n}\n\n/**\n * Generate a tag for a stat.\n *\n * @param {object} stat\n * @return {string}\n * @private\n */\n\nfunction stattag (stat) {\n  var mtime = stat.mtime.getTime().toString(16)\n  var size = stat.size.toString(16)\n\n  return '\"' + size + '-' + mtime + '\"'\n}\n","const auth = require('basic-auth')\nconst assert = require('assert')\nconst timingSafeEqual = require('crypto').timingSafeEqual\n\n// Credits for the actual algorithm go to github/@Bruce17\n// Thanks to github/@hraban for making me implement this\nfunction safeCompare(userInput, secret) {\n    const userInputLength = Buffer.byteLength(userInput)\n    const secretLength = Buffer.byteLength(secret)\n\n    const userInputBuffer = Buffer.alloc(userInputLength, 0, 'utf8')\n    userInputBuffer.write(userInput)\n    const secretBuffer = Buffer.alloc(userInputLength, 0, 'utf8')\n    secretBuffer.write(secret)\n\n    return !!(timingSafeEqual(userInputBuffer, secretBuffer) & userInputLength === secretLength)\n}\n\nfunction ensureFunction(option, defaultValue) {\n    if(option == undefined)\n        return function() { return defaultValue }\n\n    if(typeof option != 'function')\n        return function() { return option }\n\n    return option\n}\n\nfunction buildMiddleware(options) {\n    var challenge = options.challenge != undefined ? !!options.challenge : false\n    var users = options.users || {}\n    var authorizer = options.authorizer || staticUsersAuthorizer\n    var isAsync = options.authorizeAsync != undefined ? !!options.authorizeAsync : false\n    var getResponseBody = ensureFunction(options.unauthorizedResponse, '')\n    var realm = ensureFunction(options.realm)\n\n    assert(typeof users == 'object', 'Expected an object for the basic auth users, found ' + typeof users + ' instead')\n    assert(typeof authorizer == 'function', 'Expected a function for the basic auth authorizer, found ' + typeof authorizer + ' instead')\n\n    function staticUsersAuthorizer(username, password) {\n        for(var i in users)\n            if(safeCompare(username, i) & safeCompare(password, users[i]))\n                return true\n\n        return false\n    }\n\n    return function authMiddleware(req, res, next) {\n        var authentication = auth(req)\n\n        if(!authentication)\n            return unauthorized()\n\n        req.auth = {\n            user: authentication.name,\n            password: authentication.pass\n        }\n\n        if(isAsync)\n            return authorizer(authentication.name, authentication.pass, authorizerCallback)\n        else if(!authorizer(authentication.name, authentication.pass))\n            return unauthorized()\n\n        return next()\n\n        function unauthorized() {\n            if(challenge) {\n                var challengeString = 'Basic'\n                var realmName = realm(req)\n\n                if(realmName)\n                    challengeString += ' realm=\"' + realmName + '\"'\n\n                res.set('WWW-Authenticate', challengeString)\n            }\n\n            //TODO: Allow response body to be JSON (maybe autodetect?)\n            const response = getResponseBody(req)\n\n            if(typeof response == 'string')\n                return res.status(401).send(response)\n\n            return res.status(401).json(response)\n        }\n\n        function authorizerCallback(err, approved) {\n            assert.ifError(err)\n\n            if(approved)\n                return next()\n\n            return unauthorized()\n        }\n    }\n}\n\nbuildMiddleware.safeCompare = safeCompare\nmodule.exports = buildMiddleware\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\nmodule.exports = require('./lib/express');\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/express/lib sync recursive\";","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar finalhandler = require('finalhandler');\nvar Router = require('./router');\nvar methods = require('methods');\nvar middleware = require('./middleware/init');\nvar query = require('./middleware/query');\nvar debug = require('debug')('express:application');\nvar View = require('./view');\nvar http = require('http');\nvar compileETag = require('./utils').compileETag;\nvar compileQueryParser = require('./utils').compileQueryParser;\nvar compileTrust = require('./utils').compileTrust;\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar merge = require('utils-merge');\nvar resolve = require('path').resolve;\nvar setPrototypeOf = require('setprototypeof')\nvar slice = Array.prototype.slice;\n\n/**\n * Application prototype.\n */\n\nvar app = exports = module.exports = {};\n\n/**\n * Variable for trust proxy inheritance back-compat\n * @private\n */\n\nvar trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';\n\n/**\n * Initialize the server.\n *\n *   - setup default configuration\n *   - setup default middleware\n *   - setup route reflection methods\n *\n * @private\n */\n\napp.init = function init() {\n  this.cache = {};\n  this.engines = {};\n  this.settings = {};\n\n  this.defaultConfiguration();\n};\n\n/**\n * Initialize application configuration.\n * @private\n */\n\napp.defaultConfiguration = function defaultConfiguration() {\n  var env = process.env.NODE_ENV || 'development';\n\n  // default settings\n  this.enable('x-powered-by');\n  this.set('etag', 'weak');\n  this.set('env', env);\n  this.set('query parser', 'extended');\n  this.set('subdomain offset', 2);\n  this.set('trust proxy', false);\n\n  // trust proxy inherit back-compat\n  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n    configurable: true,\n    value: true\n  });\n\n  debug('booting in %s mode', env);\n\n  this.on('mount', function onmount(parent) {\n    // inherit trust proxy\n    if (this.settings[trustProxyDefaultSymbol] === true\n      && typeof parent.settings['trust proxy fn'] === 'function') {\n      delete this.settings['trust proxy'];\n      delete this.settings['trust proxy fn'];\n    }\n\n    // inherit protos\n    setPrototypeOf(this.request, parent.request)\n    setPrototypeOf(this.response, parent.response)\n    setPrototypeOf(this.engines, parent.engines)\n    setPrototypeOf(this.settings, parent.settings)\n  });\n\n  // setup locals\n  this.locals = Object.create(null);\n\n  // top-most app is mounted at /\n  this.mountpath = '/';\n\n  // default locals\n  this.locals.settings = this.settings;\n\n  // default configuration\n  this.set('view', View);\n  this.set('views', resolve('views'));\n  this.set('jsonp callback name', 'callback');\n\n  if (env === 'production') {\n    this.enable('view cache');\n  }\n\n  Object.defineProperty(this, 'router', {\n    get: function() {\n      throw new Error('\\'app.router\\' is deprecated!\\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');\n    }\n  });\n};\n\n/**\n * lazily adds the base router if it has not yet been added.\n *\n * We cannot add the base router in the defaultConfiguration because\n * it reads app settings which might be set after that has run.\n *\n * @private\n */\napp.lazyrouter = function lazyrouter() {\n  if (!this._router) {\n    this._router = new Router({\n      caseSensitive: this.enabled('case sensitive routing'),\n      strict: this.enabled('strict routing')\n    });\n\n    this._router.use(query(this.get('query parser fn')));\n    this._router.use(middleware.init(this));\n  }\n};\n\n/**\n * Dispatch a req, res pair into the application. Starts pipeline processing.\n *\n * If no callback is provided, then default error handlers will respond\n * in the event of an error bubbling through the stack.\n *\n * @private\n */\n\napp.handle = function handle(req, res, callback) {\n  var router = this._router;\n\n  // final handler\n  var done = callback || finalhandler(req, res, {\n    env: this.get('env'),\n    onerror: logerror.bind(this)\n  });\n\n  // no routes\n  if (!router) {\n    debug('no routes defined on app');\n    done();\n    return;\n  }\n\n  router.handle(req, res, done);\n};\n\n/**\n * Proxy `Router#use()` to add middleware to the app router.\n * See Router#use() documentation for details.\n *\n * If the _fn_ parameter is an express app, then it will be\n * mounted at the _route_ specified.\n *\n * @public\n */\n\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires a middleware function')\n  }\n\n  // setup router\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n\n/**\n * Proxy to the app `Router#route()`\n * Returns a new `Route` instance for the _path_.\n *\n * Routes are isolated middleware stacks for specific paths.\n * See the Route api docs for details.\n *\n * @public\n */\n\napp.route = function route(path) {\n  this.lazyrouter();\n  return this._router.route(path);\n};\n\n/**\n * Register the given template engine callback `fn`\n * as `ext`.\n *\n * By default will `require()` the engine based on the\n * file extension. For example if you try to render\n * a \"foo.ejs\" file Express will invoke the following internally:\n *\n *     app.engine('ejs', require('ejs').__express);\n *\n * For engines that do not provide `.__express` out of the box,\n * or if you wish to \"map\" a different extension to the template engine\n * you may use this method. For example mapping the EJS template engine to\n * \".html\" files:\n *\n *     app.engine('html', require('ejs').renderFile);\n *\n * In this case EJS provides a `.renderFile()` method with\n * the same signature that Express expects: `(path, options, callback)`,\n * though note that it aliases this method as `ejs.__express` internally\n * so if you're using \".ejs\" extensions you dont need to do anything.\n *\n * Some template engines do not follow this convention, the\n * [Consolidate.js](https://github.com/tj/consolidate.js)\n * library was created to map all of node's popular template\n * engines to follow this convention, thus allowing them to\n * work seamlessly within Express.\n *\n * @param {String} ext\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\napp.engine = function engine(ext, fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('callback function required');\n  }\n\n  // get file extension\n  var extension = ext[0] !== '.'\n    ? '.' + ext\n    : ext;\n\n  // store engine\n  this.engines[extension] = fn;\n\n  return this;\n};\n\n/**\n * Proxy to `Router#param()` with one added api feature. The _name_ parameter\n * can be an array of names.\n *\n * See the Router#param() docs for more details.\n *\n * @param {String|Array} name\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\napp.param = function param(name, fn) {\n  this.lazyrouter();\n\n  if (Array.isArray(name)) {\n    for (var i = 0; i < name.length; i++) {\n      this.param(name[i], fn);\n    }\n\n    return this;\n  }\n\n  this._router.param(name, fn);\n\n  return this;\n};\n\n/**\n * Assign `setting` to `val`, or return `setting`'s value.\n *\n *    app.set('foo', 'bar');\n *    app.set('foo');\n *    // => \"bar\"\n *\n * Mounted servers inherit their parent server's settings.\n *\n * @param {String} setting\n * @param {*} [val]\n * @return {Server} for chaining\n * @public\n */\n\napp.set = function set(setting, val) {\n  if (arguments.length === 1) {\n    // app.get(setting)\n    return this.settings[setting];\n  }\n\n  debug('set \"%s\" to %o', setting, val);\n\n  // set value\n  this.settings[setting] = val;\n\n  // trigger matched settings\n  switch (setting) {\n    case 'etag':\n      this.set('etag fn', compileETag(val));\n      break;\n    case 'query parser':\n      this.set('query parser fn', compileQueryParser(val));\n      break;\n    case 'trust proxy':\n      this.set('trust proxy fn', compileTrust(val));\n\n      // trust proxy inherit back-compat\n      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n        configurable: true,\n        value: false\n      });\n\n      break;\n  }\n\n  return this;\n};\n\n/**\n * Return the app's absolute pathname\n * based on the parent(s) that have\n * mounted it.\n *\n * For example if the application was\n * mounted as \"/admin\", which itself\n * was mounted as \"/blog\" then the\n * return value would be \"/blog/admin\".\n *\n * @return {String}\n * @private\n */\n\napp.path = function path() {\n  return this.parent\n    ? this.parent.path() + this.mountpath\n    : '';\n};\n\n/**\n * Check if `setting` is enabled (truthy).\n *\n *    app.enabled('foo')\n *    // => false\n *\n *    app.enable('foo')\n *    app.enabled('foo')\n *    // => true\n *\n * @param {String} setting\n * @return {Boolean}\n * @public\n */\n\napp.enabled = function enabled(setting) {\n  return Boolean(this.set(setting));\n};\n\n/**\n * Check if `setting` is disabled.\n *\n *    app.disabled('foo')\n *    // => true\n *\n *    app.enable('foo')\n *    app.disabled('foo')\n *    // => false\n *\n * @param {String} setting\n * @return {Boolean}\n * @public\n */\n\napp.disabled = function disabled(setting) {\n  return !this.set(setting);\n};\n\n/**\n * Enable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @public\n */\n\napp.enable = function enable(setting) {\n  return this.set(setting, true);\n};\n\n/**\n * Disable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @public\n */\n\napp.disable = function disable(setting) {\n  return this.set(setting, false);\n};\n\n/**\n * Delegate `.VERB(...)` calls to `router.VERB(...)`.\n */\n\nmethods.forEach(function(method){\n  app[method] = function(path){\n    if (method === 'get' && arguments.length === 1) {\n      // app.get(setting)\n      return this.set(path);\n    }\n\n    this.lazyrouter();\n\n    var route = this._router.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n/**\n * Special-cased \"all\" method, applying the given route `path`,\n * middleware, and callback to _every_ HTTP method.\n *\n * @param {String} path\n * @param {Function} ...\n * @return {app} for chaining\n * @public\n */\n\napp.all = function all(path) {\n  this.lazyrouter();\n\n  var route = this._router.route(path);\n  var args = slice.call(arguments, 1);\n\n  for (var i = 0; i < methods.length; i++) {\n    route[methods[i]].apply(route, args);\n  }\n\n  return this;\n};\n\n// del -> delete alias\n\napp.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');\n\n/**\n * Render the given view `name` name with `options`\n * and a callback accepting an error and the\n * rendered template string.\n *\n * Example:\n *\n *    app.render('email', { name: 'Tobi' }, function(err, html){\n *      // ...\n *    })\n *\n * @param {String} name\n * @param {Object|Function} options or fn\n * @param {Function} callback\n * @public\n */\n\napp.render = function render(name, options, callback) {\n  var cache = this.cache;\n  var done = callback;\n  var engines = this.engines;\n  var opts = options;\n  var renderOptions = {};\n  var view;\n\n  // support callback function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  // merge app.locals\n  merge(renderOptions, this.locals);\n\n  // merge options._locals\n  if (opts._locals) {\n    merge(renderOptions, opts._locals);\n  }\n\n  // merge options\n  merge(renderOptions, opts);\n\n  // set .cache unless explicitly provided\n  if (renderOptions.cache == null) {\n    renderOptions.cache = this.enabled('view cache');\n  }\n\n  // primed cache\n  if (renderOptions.cache) {\n    view = cache[name];\n  }\n\n  // view\n  if (!view) {\n    var View = this.get('view');\n\n    view = new View(name, {\n      defaultEngine: this.get('view engine'),\n      root: this.get('views'),\n      engines: engines\n    });\n\n    if (!view.path) {\n      var dirs = Array.isArray(view.root) && view.root.length > 1\n        ? 'directories \"' + view.root.slice(0, -1).join('\", \"') + '\" or \"' + view.root[view.root.length - 1] + '\"'\n        : 'directory \"' + view.root + '\"'\n      var err = new Error('Failed to lookup view \"' + name + '\" in views ' + dirs);\n      err.view = view;\n      return done(err);\n    }\n\n    // prime the cache\n    if (renderOptions.cache) {\n      cache[name] = view;\n    }\n  }\n\n  // render\n  tryRender(view, renderOptions, done);\n};\n\n/**\n * Listen for connections.\n *\n * A node `http.Server` is returned, with this\n * application (which is a `Function`) as its\n * callback. If you wish to create both an HTTP\n * and HTTPS server you may do so with the \"http\"\n * and \"https\" modules as shown here:\n *\n *    var http = require('http')\n *      , https = require('https')\n *      , express = require('express')\n *      , app = express();\n *\n *    http.createServer(app).listen(80);\n *    https.createServer({ ... }, app).listen(443);\n *\n * @return {http.Server}\n * @public\n */\n\napp.listen = function listen() {\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n\n/**\n * Log error using console.error.\n *\n * @param {Error} err\n * @private\n */\n\nfunction logerror(err) {\n  /* istanbul ignore next */\n  if (this.get('env') !== 'test') console.error(err.stack || err.toString());\n}\n\n/**\n * Try rendering a view.\n * @private\n */\n\nfunction tryRender(view, options, callback) {\n  try {\n    view.render(options, callback);\n  } catch (err) {\n    callback(err);\n  }\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar bodyParser = require('body-parser')\nvar EventEmitter = require('events').EventEmitter;\nvar mixin = require('merge-descriptors');\nvar proto = require('./application');\nvar Route = require('./router/route');\nvar Router = require('./router');\nvar req = require('./request');\nvar res = require('./response');\n\n/**\n * Expose `createApplication()`.\n */\n\nexports = module.exports = createApplication;\n\n/**\n * Create an express application.\n *\n * @return {Function}\n * @api public\n */\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  mixin(app, EventEmitter.prototype, false);\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n\n/**\n * Expose the prototypes.\n */\n\nexports.application = proto;\nexports.request = req;\nexports.response = res;\n\n/**\n * Expose constructors.\n */\n\nexports.Route = Route;\nexports.Router = Router;\n\n/**\n * Expose middleware\n */\n\nexports.json = bodyParser.json\nexports.query = require('./middleware/query');\nexports.raw = bodyParser.raw\nexports.static = require('serve-static');\nexports.text = bodyParser.text\nexports.urlencoded = bodyParser.urlencoded\n\n/**\n * Replace removed middleware with an appropriate error message.\n */\n\nvar removedMiddlewares = [\n  'bodyParser',\n  'compress',\n  'cookieSession',\n  'session',\n  'logger',\n  'cookieParser',\n  'favicon',\n  'responseTime',\n  'errorHandler',\n  'timeout',\n  'methodOverride',\n  'vhost',\n  'csrf',\n  'directory',\n  'limit',\n  'multipart',\n  'staticCache'\n]\n\nremovedMiddlewares.forEach(function (name) {\n  Object.defineProperty(exports, name, {\n    get: function () {\n      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');\n    },\n    configurable: true\n  });\n});\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar setPrototypeOf = require('setprototypeof')\n\n/**\n * Initialization middleware, exposing the\n * request and response to each other, as well\n * as defaulting the X-Powered-By header field.\n *\n * @param {Function} app\n * @return {Function}\n * @api private\n */\n\nexports.init = function(app){\n  return function expressInit(req, res, next){\n    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');\n    req.res = res;\n    res.req = req;\n    req.next = next;\n\n    setPrototypeOf(req, app.request)\n    setPrototypeOf(res, app.response)\n\n    res.locals = res.locals || Object.create(null);\n\n    next();\n  };\n};\n\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar merge = require('utils-merge')\nvar parseUrl = require('parseurl');\nvar qs = require('qs');\n\n/**\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function query(options) {\n  var opts = merge({}, options)\n  var queryparse = qs.parse;\n\n  if (typeof options === 'function') {\n    queryparse = options;\n    opts = undefined;\n  }\n\n  if (opts !== undefined && opts.allowPrototypes === undefined) {\n    // back-compat for qs module\n    opts.allowPrototypes = true;\n  }\n\n  return function query(req, res, next){\n    if (!req.query) {\n      var val = parseUrl(req).query;\n      req.query = queryparse(val, opts);\n    }\n\n    next();\n  };\n};\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar accepts = require('accepts');\nvar deprecate = require('depd')('express');\nvar isIP = require('net').isIP;\nvar typeis = require('type-is');\nvar http = require('http');\nvar fresh = require('fresh');\nvar parseRange = require('range-parser');\nvar parse = require('parseurl');\nvar proxyaddr = require('proxy-addr');\n\n/**\n * Request prototype.\n * @public\n */\n\nvar req = Object.create(http.IncomingMessage.prototype)\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = req\n\n/**\n * Return request header.\n *\n * The `Referrer` header field is special-cased,\n * both `Referrer` and `Referer` are interchangeable.\n *\n * Examples:\n *\n *     req.get('Content-Type');\n *     // => \"text/plain\"\n *\n *     req.get('content-type');\n *     // => \"text/plain\"\n *\n *     req.get('Something');\n *     // => undefined\n *\n * Aliased as `req.header()`.\n *\n * @param {String} name\n * @return {String}\n * @public\n */\n\nreq.get =\nreq.header = function header(name) {\n  if (!name) {\n    throw new TypeError('name argument is required to req.get');\n  }\n\n  if (typeof name !== 'string') {\n    throw new TypeError('name must be a string to req.get');\n  }\n\n  var lc = name.toLowerCase();\n\n  switch (lc) {\n    case 'referer':\n    case 'referrer':\n      return this.headers.referrer\n        || this.headers.referer;\n    default:\n      return this.headers[lc];\n  }\n};\n\n/**\n * To do: update docs.\n *\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single MIME type string\n * such as \"application/json\", an extension name\n * such as \"json\", a comma-delimited list such as \"json, html, text/plain\",\n * an argument list such as `\"json\", \"html\", \"text/plain\"`,\n * or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given, the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     req.accepts('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     req.accepts('html');\n *     // => \"html\"\n *     req.accepts('text/html');\n *     // => \"text/html\"\n *     req.accepts('json, text');\n *     // => \"json\"\n *     req.accepts('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     req.accepts('image/png');\n *     req.accepts('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     req.accepts(['html', 'json']);\n *     req.accepts('html', 'json');\n *     req.accepts('html, json');\n *     // => \"json\"\n *\n * @param {String|Array} type(s)\n * @return {String|Array|Boolean}\n * @public\n */\n\nreq.accepts = function(){\n  var accept = accepts(this);\n  return accept.types.apply(accept, arguments);\n};\n\n/**\n * Check if the given `encoding`s are accepted.\n *\n * @param {String} ...encoding\n * @return {String|Array}\n * @public\n */\n\nreq.acceptsEncodings = function(){\n  var accept = accepts(this);\n  return accept.encodings.apply(accept, arguments);\n};\n\nreq.acceptsEncoding = deprecate.function(req.acceptsEncodings,\n  'req.acceptsEncoding: Use acceptsEncodings instead');\n\n/**\n * Check if the given `charset`s are acceptable,\n * otherwise you should respond with 406 \"Not Acceptable\".\n *\n * @param {String} ...charset\n * @return {String|Array}\n * @public\n */\n\nreq.acceptsCharsets = function(){\n  var accept = accepts(this);\n  return accept.charsets.apply(accept, arguments);\n};\n\nreq.acceptsCharset = deprecate.function(req.acceptsCharsets,\n  'req.acceptsCharset: Use acceptsCharsets instead');\n\n/**\n * Check if the given `lang`s are acceptable,\n * otherwise you should respond with 406 \"Not Acceptable\".\n *\n * @param {String} ...lang\n * @return {String|Array}\n * @public\n */\n\nreq.acceptsLanguages = function(){\n  var accept = accepts(this);\n  return accept.languages.apply(accept, arguments);\n};\n\nreq.acceptsLanguage = deprecate.function(req.acceptsLanguages,\n  'req.acceptsLanguage: Use acceptsLanguages instead');\n\n/**\n * Parse Range header field, capping to the given `size`.\n *\n * Unspecified ranges such as \"0-\" require knowledge of your resource length. In\n * the case of a byte range this is of course the total number of bytes. If the\n * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,\n * and `-2` when syntactically invalid.\n *\n * When ranges are returned, the array has a \"type\" property which is the type of\n * range that is required (most commonly, \"bytes\"). Each array element is an object\n * with a \"start\" and \"end\" property for the portion of the range.\n *\n * The \"combine\" option can be set to `true` and overlapping & adjacent ranges\n * will be combined into a single range.\n *\n * NOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\n * should respond with 4 users when available, not 3.\n *\n * @param {number} size\n * @param {object} [options]\n * @param {boolean} [options.combine=false]\n * @return {number|array}\n * @public\n */\n\nreq.range = function range(size, options) {\n  var range = this.get('Range');\n  if (!range) return;\n  return parseRange(size, range, options);\n};\n\n/**\n * Return the value of param `name` when present or `defaultValue`.\n *\n *  - Checks route placeholders, ex: _/user/:id_\n *  - Checks body params, ex: id=12, {\"id\":12}\n *  - Checks query string params, ex: ?id=12\n *\n * To utilize request bodies, `req.body`\n * should be an object. This can be done by using\n * the `bodyParser()` middleware.\n *\n * @param {String} name\n * @param {Mixed} [defaultValue]\n * @return {String}\n * @public\n */\n\nreq.param = function param(name, defaultValue) {\n  var params = this.params || {};\n  var body = this.body || {};\n  var query = this.query || {};\n\n  var args = arguments.length === 1\n    ? 'name'\n    : 'name, default';\n  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');\n\n  if (null != params[name] && params.hasOwnProperty(name)) return params[name];\n  if (null != body[name]) return body[name];\n  if (null != query[name]) return query[name];\n\n  return defaultValue;\n};\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains the give mime `type`.\n *\n * Examples:\n *\n *      // With Content-Type: text/html; charset=utf-8\n *      req.is('html');\n *      req.is('text/html');\n *      req.is('text/*');\n *      // => true\n *\n *      // When Content-Type is application/json\n *      req.is('json');\n *      req.is('application/json');\n *      req.is('application/*');\n *      // => true\n *\n *      req.is('html');\n *      // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nreq.is = function is(types) {\n  var arr = types;\n\n  // support flattened arguments\n  if (!Array.isArray(types)) {\n    arr = new Array(arguments.length);\n    for (var i = 0; i < arr.length; i++) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  return typeis(this, arr);\n};\n\n/**\n * Return the protocol string \"http\" or \"https\"\n * when requested with TLS. When the \"trust proxy\"\n * setting trusts the socket address, the\n * \"X-Forwarded-Proto\" header field will be trusted\n * and used if present.\n *\n * If you're running behind a reverse proxy that\n * supplies https for you this may be enabled.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'protocol', function protocol(){\n  var proto = this.connection.encrypted\n    ? 'https'\n    : 'http';\n  var trust = this.app.get('trust proxy fn');\n\n  if (!trust(this.connection.remoteAddress, 0)) {\n    return proto;\n  }\n\n  // Note: X-Forwarded-Proto is normally only ever a\n  //       single value, but this is to be safe.\n  var header = this.get('X-Forwarded-Proto') || proto\n  var index = header.indexOf(',')\n\n  return index !== -1\n    ? header.substring(0, index).trim()\n    : header.trim()\n});\n\n/**\n * Short-hand for:\n *\n *    req.protocol === 'https'\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'secure', function secure(){\n  return this.protocol === 'https';\n});\n\n/**\n * Return the remote address from the trusted proxy.\n *\n * The is the remote address on the socket unless\n * \"trust proxy\" is set.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'ip', function ip(){\n  var trust = this.app.get('trust proxy fn');\n  return proxyaddr(this, trust);\n});\n\n/**\n * When \"trust proxy\" is set, trusted proxy addresses + client.\n *\n * For example if the value were \"client, proxy1, proxy2\"\n * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\n * where \"proxy2\" is the furthest down-stream and \"proxy1\" and\n * \"proxy2\" were trusted.\n *\n * @return {Array}\n * @public\n */\n\ndefineGetter(req, 'ips', function ips() {\n  var trust = this.app.get('trust proxy fn');\n  var addrs = proxyaddr.all(this, trust);\n\n  // reverse the order (to farthest -> closest)\n  // and remove socket address\n  addrs.reverse().pop()\n\n  return addrs\n});\n\n/**\n * Return subdomains as an array.\n *\n * Subdomains are the dot-separated parts of the host before the main domain of\n * the app. By default, the domain of the app is assumed to be the last two\n * parts of the host. This can be changed by setting \"subdomain offset\".\n *\n * For example, if the domain is \"tobi.ferrets.example.com\":\n * If \"subdomain offset\" is not set, req.subdomains is `[\"ferrets\", \"tobi\"]`.\n * If \"subdomain offset\" is 3, req.subdomains is `[\"tobi\"]`.\n *\n * @return {Array}\n * @public\n */\n\ndefineGetter(req, 'subdomains', function subdomains() {\n  var hostname = this.hostname;\n\n  if (!hostname) return [];\n\n  var offset = this.app.get('subdomain offset');\n  var subdomains = !isIP(hostname)\n    ? hostname.split('.').reverse()\n    : [hostname];\n\n  return subdomains.slice(offset);\n});\n\n/**\n * Short-hand for `url.parse(req.url).pathname`.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'path', function path() {\n  return parse(this).pathname;\n});\n\n/**\n * Parse the \"Host\" header field to a hostname.\n *\n * When the \"trust proxy\" setting trusts the socket\n * address, the \"X-Forwarded-Host\" header field will\n * be trusted.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'hostname', function hostname(){\n  var trust = this.app.get('trust proxy fn');\n  var host = this.get('X-Forwarded-Host');\n\n  if (!host || !trust(this.connection.remoteAddress, 0)) {\n    host = this.get('Host');\n  } else if (host.indexOf(',') !== -1) {\n    // Note: X-Forwarded-Host is normally only ever a\n    //       single value, but this is to be safe.\n    host = host.substring(0, host.indexOf(',')).trimRight()\n  }\n\n  if (!host) return;\n\n  // IPv6 literal support\n  var offset = host[0] === '['\n    ? host.indexOf(']') + 1\n    : 0;\n  var index = host.indexOf(':', offset);\n\n  return index !== -1\n    ? host.substring(0, index)\n    : host;\n});\n\n// TODO: change req.host to return host in next major\n\ndefineGetter(req, 'host', deprecate.function(function host(){\n  return this.hostname;\n}, 'req.host: Use req.hostname instead'));\n\n/**\n * Check if the request is fresh, aka\n * Last-Modified and/or the ETag\n * still match.\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'fresh', function(){\n  var method = this.method;\n  var res = this.res\n  var status = res.statusCode\n\n  // GET or HEAD for weak freshness validation only\n  if ('GET' !== method && 'HEAD' !== method) return false;\n\n  // 2xx or 304 as per rfc2616 14.26\n  if ((status >= 200 && status < 300) || 304 === status) {\n    return fresh(this.headers, {\n      'etag': res.get('ETag'),\n      'last-modified': res.get('Last-Modified')\n    })\n  }\n\n  return false;\n});\n\n/**\n * Check if the request is stale, aka\n * \"Last-Modified\" and / or the \"ETag\" for the\n * resource has changed.\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'stale', function stale(){\n  return !this.fresh;\n});\n\n/**\n * Check if the request was an _XMLHttpRequest_.\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'xhr', function xhr(){\n  var val = this.get('X-Requested-With') || '';\n  return val.toLowerCase() === 'xmlhttprequest';\n});\n\n/**\n * Helper function for creating a getter on an object.\n *\n * @param {Object} obj\n * @param {String} name\n * @param {Function} getter\n * @private\n */\nfunction defineGetter(obj, name, getter) {\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: true,\n    get: getter\n  });\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Buffer = require('safe-buffer').Buffer\nvar contentDisposition = require('content-disposition');\nvar deprecate = require('depd')('express');\nvar encodeUrl = require('encodeurl');\nvar escapeHtml = require('escape-html');\nvar http = require('http');\nvar isAbsolute = require('./utils').isAbsolute;\nvar onFinished = require('on-finished');\nvar path = require('path');\nvar statuses = require('statuses')\nvar merge = require('utils-merge');\nvar sign = require('cookie-signature').sign;\nvar normalizeType = require('./utils').normalizeType;\nvar normalizeTypes = require('./utils').normalizeTypes;\nvar setCharset = require('./utils').setCharset;\nvar cookie = require('cookie');\nvar send = require('send');\nvar extname = path.extname;\nvar mime = send.mime;\nvar resolve = path.resolve;\nvar vary = require('vary');\n\n/**\n * Response prototype.\n * @public\n */\n\nvar res = Object.create(http.ServerResponse.prototype)\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = res\n\n/**\n * Module variables.\n * @private\n */\n\nvar charsetRegExp = /;\\s*charset\\s*=/;\n\n/**\n * Set status `code`.\n *\n * @param {Number} code\n * @return {ServerResponse}\n * @public\n */\n\nres.status = function status(code) {\n  this.statusCode = code;\n  return this;\n};\n\n/**\n * Set Link header field with the given `links`.\n *\n * Examples:\n *\n *    res.links({\n *      next: 'http://api.example.com/users?page=2',\n *      last: 'http://api.example.com/users?page=5'\n *    });\n *\n * @param {Object} links\n * @return {ServerResponse}\n * @public\n */\n\nres.links = function(links){\n  var link = this.get('Link') || '';\n  if (link) link += ', ';\n  return this.set('Link', link + Object.keys(links).map(function(rel){\n    return '<' + links[rel] + '>; rel=\"' + rel + '\"';\n  }).join(', '));\n};\n\n/**\n * Send a response.\n *\n * Examples:\n *\n *     res.send(Buffer.from('wahoo'));\n *     res.send({ some: 'json' });\n *     res.send('<p>some html</p>');\n *\n * @param {string|number|boolean|object|Buffer} body\n * @public\n */\n\nres.send = function send(body) {\n  var chunk = body;\n  var encoding;\n  var req = this.req;\n  var type;\n\n  // settings\n  var app = this.app;\n\n  // allow status / body\n  if (arguments.length === 2) {\n    // res.send(body, status) backwards compat\n    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {\n      deprecate('res.send(body, status): Use res.status(status).send(body) instead');\n      this.statusCode = arguments[1];\n    } else {\n      deprecate('res.send(status, body): Use res.status(status).send(body) instead');\n      this.statusCode = arguments[0];\n      chunk = arguments[1];\n    }\n  }\n\n  // disambiguate res.send(status) and res.send(status, num)\n  if (typeof chunk === 'number' && arguments.length === 1) {\n    // res.send(status) will set status message as text string\n    if (!this.get('Content-Type')) {\n      this.type('txt');\n    }\n\n    deprecate('res.send(status): Use res.sendStatus(status) instead');\n    this.statusCode = chunk;\n    chunk = statuses[chunk]\n  }\n\n  switch (typeof chunk) {\n    // string defaulting to html\n    case 'string':\n      if (!this.get('Content-Type')) {\n        this.type('html');\n      }\n      break;\n    case 'boolean':\n    case 'number':\n    case 'object':\n      if (chunk === null) {\n        chunk = '';\n      } else if (Buffer.isBuffer(chunk)) {\n        if (!this.get('Content-Type')) {\n          this.type('bin');\n        }\n      } else {\n        return this.json(chunk);\n      }\n      break;\n  }\n\n  // write strings in utf-8\n  if (typeof chunk === 'string') {\n    encoding = 'utf8';\n    type = this.get('Content-Type');\n\n    // reflect this in content-type\n    if (typeof type === 'string') {\n      this.set('Content-Type', setCharset(type, 'utf-8'));\n    }\n  }\n\n  // determine if ETag should be generated\n  var etagFn = app.get('etag fn')\n  var generateETag = !this.get('ETag') && typeof etagFn === 'function'\n\n  // populate Content-Length\n  var len\n  if (chunk !== undefined) {\n    if (Buffer.isBuffer(chunk)) {\n      // get length of Buffer\n      len = chunk.length\n    } else if (!generateETag && chunk.length < 1000) {\n      // just calculate length when no ETag + small chunk\n      len = Buffer.byteLength(chunk, encoding)\n    } else {\n      // convert chunk to Buffer and calculate\n      chunk = Buffer.from(chunk, encoding)\n      encoding = undefined;\n      len = chunk.length\n    }\n\n    this.set('Content-Length', len);\n  }\n\n  // populate ETag\n  var etag;\n  if (generateETag && len !== undefined) {\n    if ((etag = etagFn(chunk, encoding))) {\n      this.set('ETag', etag);\n    }\n  }\n\n  // freshness\n  if (req.fresh) this.statusCode = 304;\n\n  // strip irrelevant headers\n  if (204 === this.statusCode || 304 === this.statusCode) {\n    this.removeHeader('Content-Type');\n    this.removeHeader('Content-Length');\n    this.removeHeader('Transfer-Encoding');\n    chunk = '';\n  }\n\n  if (req.method === 'HEAD') {\n    // skip body for HEAD\n    this.end();\n  } else {\n    // respond\n    this.end(chunk, encoding);\n  }\n\n  return this;\n};\n\n/**\n * Send JSON response.\n *\n * Examples:\n *\n *     res.json(null);\n *     res.json({ user: 'tj' });\n *\n * @param {string|number|boolean|object} obj\n * @public\n */\n\nres.json = function json(obj) {\n  var val = obj;\n\n  // allow status / body\n  if (arguments.length === 2) {\n    // res.json(body, status) backwards compat\n    if (typeof arguments[1] === 'number') {\n      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');\n      this.statusCode = arguments[1];\n    } else {\n      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');\n      this.statusCode = arguments[0];\n      val = arguments[1];\n    }\n  }\n\n  // settings\n  var app = this.app;\n  var escape = app.get('json escape')\n  var replacer = app.get('json replacer');\n  var spaces = app.get('json spaces');\n  var body = stringify(val, replacer, spaces, escape)\n\n  // content-type\n  if (!this.get('Content-Type')) {\n    this.set('Content-Type', 'application/json');\n  }\n\n  return this.send(body);\n};\n\n/**\n * Send JSON response with JSONP callback support.\n *\n * Examples:\n *\n *     res.jsonp(null);\n *     res.jsonp({ user: 'tj' });\n *\n * @param {string|number|boolean|object} obj\n * @public\n */\n\nres.jsonp = function jsonp(obj) {\n  var val = obj;\n\n  // allow status / body\n  if (arguments.length === 2) {\n    // res.json(body, status) backwards compat\n    if (typeof arguments[1] === 'number') {\n      deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');\n      this.statusCode = arguments[1];\n    } else {\n      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');\n      this.statusCode = arguments[0];\n      val = arguments[1];\n    }\n  }\n\n  // settings\n  var app = this.app;\n  var escape = app.get('json escape')\n  var replacer = app.get('json replacer');\n  var spaces = app.get('json spaces');\n  var body = stringify(val, replacer, spaces, escape)\n  var callback = this.req.query[app.get('jsonp callback name')];\n\n  // content-type\n  if (!this.get('Content-Type')) {\n    this.set('X-Content-Type-Options', 'nosniff');\n    this.set('Content-Type', 'application/json');\n  }\n\n  // fixup callback\n  if (Array.isArray(callback)) {\n    callback = callback[0];\n  }\n\n  // jsonp\n  if (typeof callback === 'string' && callback.length !== 0) {\n    this.set('X-Content-Type-Options', 'nosniff');\n    this.set('Content-Type', 'text/javascript');\n\n    // restrict callback charset\n    callback = callback.replace(/[^\\[\\]\\w$.]/g, '');\n\n    // replace chars not allowed in JavaScript that are in JSON\n    body = body\n      .replace(/\\u2028/g, '\\\\u2028')\n      .replace(/\\u2029/g, '\\\\u2029');\n\n    // the /**/ is a specific security mitigation for \"Rosetta Flash JSONP abuse\"\n    // the typeof check is just to reduce client error noise\n    body = '/**/ typeof ' + callback + ' === \\'function\\' && ' + callback + '(' + body + ');';\n  }\n\n  return this.send(body);\n};\n\n/**\n * Send given HTTP status code.\n *\n * Sets the response status to `statusCode` and the body of the\n * response to the standard description from node's http.STATUS_CODES\n * or the statusCode number if no description.\n *\n * Examples:\n *\n *     res.sendStatus(200);\n *\n * @param {number} statusCode\n * @public\n */\n\nres.sendStatus = function sendStatus(statusCode) {\n  var body = statuses[statusCode] || String(statusCode)\n\n  this.statusCode = statusCode;\n  this.type('txt');\n\n  return this.send(body);\n};\n\n/**\n * Transfer the file at the given `path`.\n *\n * Automatically sets the _Content-Type_ response header field.\n * The callback `callback(err)` is invoked when the transfer is complete\n * or when an error occurs. Be sure to check `res.sentHeader`\n * if you wish to attempt responding, as the header and some data\n * may have already been transferred.\n *\n * Options:\n *\n *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n *   - `root`     root directory for relative filenames\n *   - `headers`  object of headers to serve with file\n *   - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n *\n * Other options are passed along to `send`.\n *\n * Examples:\n *\n *  The following example illustrates how `res.sendFile()` may\n *  be used as an alternative for the `static()` middleware for\n *  dynamic situations. The code backing `res.sendFile()` is actually\n *  the same code, so HTTP cache support etc is identical.\n *\n *     app.get('/user/:uid/photos/:file', function(req, res){\n *       var uid = req.params.uid\n *         , file = req.params.file;\n *\n *       req.user.mayViewFilesFrom(uid, function(yes){\n *         if (yes) {\n *           res.sendFile('/uploads/' + uid + '/' + file);\n *         } else {\n *           res.send(403, 'Sorry! you cant see that.');\n *         }\n *       });\n *     });\n *\n * @public\n */\n\nres.sendFile = function sendFile(path, options, callback) {\n  var done = callback;\n  var req = this.req;\n  var res = this;\n  var next = req.next;\n  var opts = options || {};\n\n  if (!path) {\n    throw new TypeError('path argument is required to res.sendFile');\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError('path must be a string to res.sendFile')\n  }\n\n  // support function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  if (!opts.root && !isAbsolute(path)) {\n    throw new TypeError('path must be absolute or specify root to res.sendFile');\n  }\n\n  // create file stream\n  var pathname = encodeURI(path);\n  var file = send(req, pathname, opts);\n\n  // transfer\n  sendfile(res, file, opts, function (err) {\n    if (done) return done(err);\n    if (err && err.code === 'EISDIR') return next();\n\n    // next() all but write errors\n    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {\n      next(err);\n    }\n  });\n};\n\n/**\n * Transfer the file at the given `path`.\n *\n * Automatically sets the _Content-Type_ response header field.\n * The callback `callback(err)` is invoked when the transfer is complete\n * or when an error occurs. Be sure to check `res.sentHeader`\n * if you wish to attempt responding, as the header and some data\n * may have already been transferred.\n *\n * Options:\n *\n *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n *   - `root`     root directory for relative filenames\n *   - `headers`  object of headers to serve with file\n *   - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n *\n * Other options are passed along to `send`.\n *\n * Examples:\n *\n *  The following example illustrates how `res.sendfile()` may\n *  be used as an alternative for the `static()` middleware for\n *  dynamic situations. The code backing `res.sendfile()` is actually\n *  the same code, so HTTP cache support etc is identical.\n *\n *     app.get('/user/:uid/photos/:file', function(req, res){\n *       var uid = req.params.uid\n *         , file = req.params.file;\n *\n *       req.user.mayViewFilesFrom(uid, function(yes){\n *         if (yes) {\n *           res.sendfile('/uploads/' + uid + '/' + file);\n *         } else {\n *           res.send(403, 'Sorry! you cant see that.');\n *         }\n *       });\n *     });\n *\n * @public\n */\n\nres.sendfile = function (path, options, callback) {\n  var done = callback;\n  var req = this.req;\n  var res = this;\n  var next = req.next;\n  var opts = options || {};\n\n  // support function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  // create file stream\n  var file = send(req, path, opts);\n\n  // transfer\n  sendfile(res, file, opts, function (err) {\n    if (done) return done(err);\n    if (err && err.code === 'EISDIR') return next();\n\n    // next() all but write errors\n    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {\n      next(err);\n    }\n  });\n};\n\nres.sendfile = deprecate.function(res.sendfile,\n  'res.sendfile: Use res.sendFile instead');\n\n/**\n * Transfer the file at the given `path` as an attachment.\n *\n * Optionally providing an alternate attachment `filename`,\n * and optional callback `callback(err)`. The callback is invoked\n * when the data transfer is complete, or when an error has\n * ocurred. Be sure to check `res.headersSent` if you plan to respond.\n *\n * Optionally providing an `options` object to use with `res.sendFile()`.\n * This function will set the `Content-Disposition` header, overriding\n * any `Content-Disposition` header passed as header options in order\n * to set the attachment and filename.\n *\n * This method uses `res.sendFile()`.\n *\n * @public\n */\n\nres.download = function download (path, filename, options, callback) {\n  var done = callback;\n  var name = filename;\n  var opts = options || null\n\n  // support function as second or third arg\n  if (typeof filename === 'function') {\n    done = filename;\n    name = null;\n    opts = null\n  } else if (typeof options === 'function') {\n    done = options\n    opts = null\n  }\n\n  // set Content-Disposition when file is sent\n  var headers = {\n    'Content-Disposition': contentDisposition(name || path)\n  };\n\n  // merge user-provided headers\n  if (opts && opts.headers) {\n    var keys = Object.keys(opts.headers)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      if (key.toLowerCase() !== 'content-disposition') {\n        headers[key] = opts.headers[key]\n      }\n    }\n  }\n\n  // merge user-provided options\n  opts = Object.create(opts)\n  opts.headers = headers\n\n  // Resolve the full path for sendFile\n  var fullPath = resolve(path);\n\n  // send file\n  return this.sendFile(fullPath, opts, done)\n};\n\n/**\n * Set _Content-Type_ response header with `type` through `mime.lookup()`\n * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\n *\n * Examples:\n *\n *     res.type('.html');\n *     res.type('html');\n *     res.type('json');\n *     res.type('application/json');\n *     res.type('png');\n *\n * @param {String} type\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.contentType =\nres.type = function contentType(type) {\n  var ct = type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type;\n\n  return this.set('Content-Type', ct);\n};\n\n/**\n * Respond to the Acceptable formats using an `obj`\n * of mime-type callbacks.\n *\n * This method uses `req.accepted`, an array of\n * acceptable types ordered by their quality values.\n * When \"Accept\" is not present the _first_ callback\n * is invoked, otherwise the first match is used. When\n * no match is performed the server responds with\n * 406 \"Not Acceptable\".\n *\n * Content-Type is set for you, however if you choose\n * you may alter this within the callback using `res.type()`\n * or `res.set('Content-Type', ...)`.\n *\n *    res.format({\n *      'text/plain': function(){\n *        res.send('hey');\n *      },\n *\n *      'text/html': function(){\n *        res.send('<p>hey</p>');\n *      },\n *\n *      'appliation/json': function(){\n *        res.send({ message: 'hey' });\n *      }\n *    });\n *\n * In addition to canonicalized MIME types you may\n * also use extnames mapped to these types:\n *\n *    res.format({\n *      text: function(){\n *        res.send('hey');\n *      },\n *\n *      html: function(){\n *        res.send('<p>hey</p>');\n *      },\n *\n *      json: function(){\n *        res.send({ message: 'hey' });\n *      }\n *    });\n *\n * By default Express passes an `Error`\n * with a `.status` of 406 to `next(err)`\n * if a match is not made. If you provide\n * a `.default` callback it will be invoked\n * instead.\n *\n * @param {Object} obj\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.format = function(obj){\n  var req = this.req;\n  var next = req.next;\n\n  var fn = obj.default;\n  if (fn) delete obj.default;\n  var keys = Object.keys(obj);\n\n  var key = keys.length > 0\n    ? req.accepts(keys)\n    : false;\n\n  this.vary(\"Accept\");\n\n  if (key) {\n    this.set('Content-Type', normalizeType(key).value);\n    obj[key](req, this, next);\n  } else if (fn) {\n    fn();\n  } else {\n    var err = new Error('Not Acceptable');\n    err.status = err.statusCode = 406;\n    err.types = normalizeTypes(keys).map(function(o){ return o.value });\n    next(err);\n  }\n\n  return this;\n};\n\n/**\n * Set _Content-Disposition_ header to _attachment_ with optional `filename`.\n *\n * @param {String} filename\n * @return {ServerResponse}\n * @public\n */\n\nres.attachment = function attachment(filename) {\n  if (filename) {\n    this.type(extname(filename));\n  }\n\n  this.set('Content-Disposition', contentDisposition(filename));\n\n  return this;\n};\n\n/**\n * Append additional header `field` with value `val`.\n *\n * Example:\n *\n *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);\n *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');\n *    res.append('Warning', '199 Miscellaneous warning');\n *\n * @param {String} field\n * @param {String|Array} val\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.append = function append(field, val) {\n  var prev = this.get(field);\n  var value = val;\n\n  if (prev) {\n    // concat the new and prev vals\n    value = Array.isArray(prev) ? prev.concat(val)\n      : Array.isArray(val) ? [prev].concat(val)\n      : [prev, val];\n  }\n\n  return this.set(field, value);\n};\n\n/**\n * Set header `field` to `val`, or pass\n * an object of header fields.\n *\n * Examples:\n *\n *    res.set('Foo', ['bar', 'baz']);\n *    res.set('Accept', 'application/json');\n *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n *\n * Aliased as `res.header()`.\n *\n * @param {String|Object} field\n * @param {String|Array} val\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.set =\nres.header = function header(field, val) {\n  if (arguments.length === 2) {\n    var value = Array.isArray(val)\n      ? val.map(String)\n      : String(val);\n\n    // add charset to content-type\n    if (field.toLowerCase() === 'content-type') {\n      if (Array.isArray(value)) {\n        throw new TypeError('Content-Type cannot be set to an Array');\n      }\n      if (!charsetRegExp.test(value)) {\n        var charset = mime.charsets.lookup(value.split(';')[0]);\n        if (charset) value += '; charset=' + charset.toLowerCase();\n      }\n    }\n\n    this.setHeader(field, value);\n  } else {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n  }\n  return this;\n};\n\n/**\n * Get value for header `field`.\n *\n * @param {String} field\n * @return {String}\n * @public\n */\n\nres.get = function(field){\n  return this.getHeader(field);\n};\n\n/**\n * Clear cookie `name`.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.clearCookie = function clearCookie(name, options) {\n  var opts = merge({ expires: new Date(1), path: '/' }, options);\n\n  return this.cookie(name, '', opts);\n};\n\n/**\n * Set cookie `name` to `value`, with the given `options`.\n *\n * Options:\n *\n *    - `maxAge`   max-age in milliseconds, converted to `expires`\n *    - `signed`   sign the cookie\n *    - `path`     defaults to \"/\"\n *\n * Examples:\n *\n *    // \"Remember Me\" for 15 minutes\n *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n *\n *    // same as above\n *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })\n *\n * @param {String} name\n * @param {String|Object} value\n * @param {Object} [options]\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.cookie = function (name, value, options) {\n  var opts = merge({}, options);\n  var secret = this.req.secret;\n  var signed = opts.signed;\n\n  if (signed && !secret) {\n    throw new Error('cookieParser(\"secret\") required for signed cookies');\n  }\n\n  var val = typeof value === 'object'\n    ? 'j:' + JSON.stringify(value)\n    : String(value);\n\n  if (signed) {\n    val = 's:' + sign(val, secret);\n  }\n\n  if ('maxAge' in opts) {\n    opts.expires = new Date(Date.now() + opts.maxAge);\n    opts.maxAge /= 1000;\n  }\n\n  if (opts.path == null) {\n    opts.path = '/';\n  }\n\n  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));\n\n  return this;\n};\n\n/**\n * Set the location header to `url`.\n *\n * The given `url` can also be \"back\", which redirects\n * to the _Referrer_ or _Referer_ headers or \"/\".\n *\n * Examples:\n *\n *    res.location('/foo/bar').;\n *    res.location('http://example.com');\n *    res.location('../login');\n *\n * @param {String} url\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.location = function location(url) {\n  var loc = url;\n\n  // \"back\" is an alias for the referrer\n  if (url === 'back') {\n    loc = this.req.get('Referrer') || '/';\n  }\n\n  // set location\n  return this.set('Location', encodeUrl(loc));\n};\n\n/**\n * Redirect to the given `url` with optional response `status`\n * defaulting to 302.\n *\n * The resulting `url` is determined by `res.location()`, so\n * it will play nicely with mounted apps, relative paths,\n * `\"back\"` etc.\n *\n * Examples:\n *\n *    res.redirect('/foo/bar');\n *    res.redirect('http://example.com');\n *    res.redirect(301, 'http://example.com');\n *    res.redirect('../login'); // /blog/post/1 -> /blog/login\n *\n * @public\n */\n\nres.redirect = function redirect(url) {\n  var address = url;\n  var body;\n  var status = 302;\n\n  // allow status / url\n  if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number') {\n      status = arguments[0];\n      address = arguments[1];\n    } else {\n      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');\n      status = arguments[1];\n    }\n  }\n\n  // Set location header\n  address = this.location(address).get('Location');\n\n  // Support text/{plain,html} by default\n  this.format({\n    text: function(){\n      body = statuses[status] + '. Redirecting to ' + address\n    },\n\n    html: function(){\n      var u = escapeHtml(address);\n      body = '<p>' + statuses[status] + '. Redirecting to <a href=\"' + u + '\">' + u + '</a></p>'\n    },\n\n    default: function(){\n      body = '';\n    }\n  });\n\n  // Respond\n  this.statusCode = status;\n  this.set('Content-Length', Buffer.byteLength(body));\n\n  if (this.req.method === 'HEAD') {\n    this.end();\n  } else {\n    this.end(body);\n  }\n};\n\n/**\n * Add `field` to Vary. If already present in the Vary set, then\n * this call is simply ignored.\n *\n * @param {Array|String} field\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.vary = function(field){\n  // checks for back-compat\n  if (!field || (Array.isArray(field) && !field.length)) {\n    deprecate('res.vary(): Provide a field name');\n    return this;\n  }\n\n  vary(this, field);\n\n  return this;\n};\n\n/**\n * Render `view` with the given `options` and optional callback `fn`.\n * When a callback function is given a response will _not_ be made\n * automatically, otherwise a response of _200_ and _text/html_ is given.\n *\n * Options:\n *\n *  - `cache`     boolean hinting to the engine it should cache\n *  - `filename`  filename of the view being rendered\n *\n * @public\n */\n\nres.render = function render(view, options, callback) {\n  var app = this.req.app;\n  var done = callback;\n  var opts = options || {};\n  var req = this.req;\n  var self = this;\n\n  // support callback function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  // merge res.locals\n  opts._locals = self.locals;\n\n  // default callback to respond\n  done = done || function (err, str) {\n    if (err) return req.next(err);\n    self.send(str);\n  };\n\n  // render\n  app.render(view, opts, done);\n};\n\n// pipe the send file stream\nfunction sendfile(res, file, options, callback) {\n  var done = false;\n  var streaming;\n\n  // request aborted\n  function onaborted() {\n    if (done) return;\n    done = true;\n\n    var err = new Error('Request aborted');\n    err.code = 'ECONNABORTED';\n    callback(err);\n  }\n\n  // directory\n  function ondirectory() {\n    if (done) return;\n    done = true;\n\n    var err = new Error('EISDIR, read');\n    err.code = 'EISDIR';\n    callback(err);\n  }\n\n  // errors\n  function onerror(err) {\n    if (done) return;\n    done = true;\n    callback(err);\n  }\n\n  // ended\n  function onend() {\n    if (done) return;\n    done = true;\n    callback();\n  }\n\n  // file\n  function onfile() {\n    streaming = false;\n  }\n\n  // finished\n  function onfinish(err) {\n    if (err && err.code === 'ECONNRESET') return onaborted();\n    if (err) return onerror(err);\n    if (done) return;\n\n    setImmediate(function () {\n      if (streaming !== false && !done) {\n        onaborted();\n        return;\n      }\n\n      if (done) return;\n      done = true;\n      callback();\n    });\n  }\n\n  // streaming\n  function onstream() {\n    streaming = true;\n  }\n\n  file.on('directory', ondirectory);\n  file.on('end', onend);\n  file.on('error', onerror);\n  file.on('file', onfile);\n  file.on('stream', onstream);\n  onFinished(res, onfinish);\n\n  if (options.headers) {\n    // set headers on successful transfer\n    file.on('headers', function headers(res) {\n      var obj = options.headers;\n      var keys = Object.keys(obj);\n\n      for (var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n        res.setHeader(k, obj[k]);\n      }\n    });\n  }\n\n  // pipe\n  file.pipe(res);\n}\n\n/**\n * Stringify JSON, like JSON.stringify, but v8 optimized, with the\n * ability to escape characters that can trigger HTML sniffing.\n *\n * @param {*} value\n * @param {function} replaces\n * @param {number} spaces\n * @param {boolean} escape\n * @returns {string}\n * @private\n */\n\nfunction stringify (value, replacer, spaces, escape) {\n  // v8 checks arguments.length for optimizing simple call\n  // https://bugs.chromium.org/p/v8/issues/detail?id=4730\n  var json = replacer || spaces\n    ? JSON.stringify(value, replacer, spaces)\n    : JSON.stringify(value);\n\n  if (escape) {\n    json = json.replace(/[<>&]/g, function (c) {\n      switch (c.charCodeAt(0)) {\n        case 0x3c:\n          return '\\\\u003c'\n        case 0x3e:\n          return '\\\\u003e'\n        case 0x26:\n          return '\\\\u0026'\n        /* istanbul ignore next: unreachable default */\n        default:\n          return c\n      }\n    })\n  }\n\n  return json\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Route = require('./route');\nvar Layer = require('./layer');\nvar methods = require('methods');\nvar mixin = require('utils-merge');\nvar debug = require('debug')('express:router');\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar parseUrl = require('parseurl');\nvar setPrototypeOf = require('setprototypeof')\n\n/**\n * Module variables.\n * @private\n */\n\nvar objectRegExp = /^\\[object (\\S+)\\]$/;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {Object} [options]\n * @return {Router} which is an callable function\n * @public\n */\n\nvar proto = module.exports = function(options) {\n  var opts = options || {};\n\n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n\n  // mixin Router class functions\n  setPrototypeOf(router, proto)\n\n  router.params = {};\n  router._params = [];\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.strict = opts.strict;\n  router.stack = [];\n\n  return router;\n};\n\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code,\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  app.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err);\n *      } else if (!user) {\n *        return next(new Error('failed to load user'));\n *      }\n *      req.user = user;\n *      next();\n *    });\n *  });\n *\n * @param {String} name\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\nproto.param = function param(name, fn) {\n  // param logic\n  if (typeof name === 'function') {\n    deprecate('router.param(fn): Refactor to use path params');\n    this._params.push(name);\n    return;\n  }\n\n  // apply param functions\n  var params = this._params;\n  var len = params.length;\n  var ret;\n\n  if (name[0] === ':') {\n    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');\n    name = name.substr(1);\n  }\n\n  for (var i = 0; i < len; ++i) {\n    if (ret = params[i](name, fn)) {\n      fn = ret;\n    }\n  }\n\n  // ensure we end up with a\n  // middleware function\n  if ('function' !== typeof fn) {\n    throw new Error('invalid param() call for ' + name + ', got ' + fn);\n  }\n\n  (this.params[name] = this.params[name] || []).push(fn);\n  return this;\n};\n\n/**\n * Dispatch a req, res into the router.\n * @private\n */\n\nproto.handle = function handle(req, res, out) {\n  var self = this;\n\n  debug('dispatching %s %s', req.method, req.url);\n\n  var idx = 0;\n  var protohost = getProtohost(req.url) || ''\n  var removed = '';\n  var slashAdded = false;\n  var paramcalled = {};\n\n  // store options for OPTIONS request\n  // only used if OPTIONS request\n  var options = [];\n\n  // middleware and routes\n  var stack = self.stack;\n\n  // manage inter-router variables\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup next layer\n  req.next = next;\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    done = wrap(done, function(old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  }\n\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path breaks on a path separator\n      var c = path[layerPath.length]\n      if (c && c !== '/' && c !== '.') return next(layerError)\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.substr(protohost.length + removed.length);\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n\n/**\n * Process any parameters for the layer.\n * @private\n */\n\nproto.process_params = function process_params(layer, called, req, res, done) {\n  var params = this.params;\n\n  // captured parameters from the layer, keys and values\n  var keys = layer.keys;\n\n  // fast track\n  if (!keys || keys.length === 0) {\n    return done();\n  }\n\n  var i = 0;\n  var name;\n  var paramIndex = 0;\n  var key;\n  var paramVal;\n  var paramCallbacks;\n  var paramCalled;\n\n  // process params in order\n  // param callbacks can be async\n  function param(err) {\n    if (err) {\n      return done(err);\n    }\n\n    if (i >= keys.length ) {\n      return done();\n    }\n\n    paramIndex = 0;\n    key = keys[i++];\n    name = key.name;\n    paramVal = req.params[name];\n    paramCallbacks = params[name];\n    paramCalled = called[name];\n\n    if (paramVal === undefined || !paramCallbacks) {\n      return param();\n    }\n\n    // param previously called with same value or error occurred\n    if (paramCalled && (paramCalled.match === paramVal\n      || (paramCalled.error && paramCalled.error !== 'route'))) {\n      // restore value\n      req.params[name] = paramCalled.value;\n\n      // next param\n      return param(paramCalled.error);\n    }\n\n    called[name] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    };\n\n    paramCallback();\n  }\n\n  // single param callbacks\n  function paramCallback(err) {\n    var fn = paramCallbacks[paramIndex++];\n\n    // store updated value\n    paramCalled.value = req.params[key.name];\n\n    if (err) {\n      // store error\n      paramCalled.error = err;\n      param(err);\n      return;\n    }\n\n    if (!fn) return param();\n\n    try {\n      fn(req, res, paramCallback, paramVal, key.name);\n    } catch (e) {\n      paramCallback(e);\n    }\n  }\n\n  param();\n};\n\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\nproto.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate router.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset));\n\n  if (callbacks.length === 0) {\n    throw new TypeError('Router.use() requires a middleware function')\n  }\n\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>')\n\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n\n    layer.route = undefined;\n\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {String} path\n * @return {Route}\n * @public\n */\n\nproto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n\n// create Router#VERB functions\nmethods.concat('all').forEach(function(method){\n  proto[method] = function(path){\n    var route = this.route(path)\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n// append methods to a list of methods\nfunction appendMethods(list, addition) {\n  for (var i = 0; i < addition.length; i++) {\n    var method = addition[i];\n    if (list.indexOf(method) === -1) {\n      list.push(method);\n    }\n  }\n}\n\n// get pathname of request\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname;\n  } catch (err) {\n    return undefined;\n  }\n}\n\n// Get get protocol + host for a URL\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined\n  }\n\n  var searchIndex = url.indexOf('?')\n  var pathLength = searchIndex !== -1\n    ? searchIndex\n    : url.length\n  var fqdnIndex = url.substr(0, pathLength).indexOf('://')\n\n  return fqdnIndex !== -1\n    ? url.substr(0, url.indexOf('/', 3 + fqdnIndex))\n    : undefined\n}\n\n// get type for error message\nfunction gettype(obj) {\n  var type = typeof obj;\n\n  if (type !== 'object') {\n    return type;\n  }\n\n  // inspect [[Class]] for objects\n  return toString.call(obj)\n    .replace(objectRegExp, '$1');\n}\n\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path);\n  } catch (err) {\n    return err;\n  }\n}\n\n// merge params with parent params\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params;\n  }\n\n  // make copy of parent for base\n  var obj = mixin({}, parent);\n\n  // simple non-numeric merging\n  if (!(0 in params) || !(0 in parent)) {\n    return mixin(obj, params);\n  }\n\n  var i = 0;\n  var o = 0;\n\n  // determine numeric gaps\n  while (i in params) {\n    i++;\n  }\n\n  while (o in parent) {\n    o++;\n  }\n\n  // offset numeric indices in params before merge\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i];\n\n    // create holes for the merge when necessary\n    if (i < o) {\n      delete params[i];\n    }\n  }\n\n  return mixin(obj, params);\n}\n\n// restore obj props after function\nfunction restore(fn, obj) {\n  var props = new Array(arguments.length - 2);\n  var vals = new Array(arguments.length - 2);\n\n  for (var i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2];\n    vals[i] = obj[props[i]];\n  }\n\n  return function () {\n    // restore vals\n    for (var i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i];\n    }\n\n    return fn.apply(this, arguments);\n  };\n}\n\n// send an OPTIONS response\nfunction sendOptionsResponse(res, options, next) {\n  try {\n    var body = options.join(',');\n    res.set('Allow', body);\n    res.send(body);\n  } catch (err) {\n    next(err);\n  }\n}\n\n// wrap a function\nfunction wrap(old, fn) {\n  return function proxy() {\n    var args = new Array(arguments.length + 1);\n\n    args[0] = old;\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i];\n    }\n\n    fn.apply(this, args);\n  };\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar pathRegexp = require('path-to-regexp');\nvar debug = require('debug')('express:router:layer');\n\n/**\n * Module variables.\n * @private\n */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Layer;\n\nfunction Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n\n  debug('new %o', path)\n  var opts = options || {};\n\n  this.handle = fn;\n  this.name = fn.name || '<anonymous>';\n  this.params = undefined;\n  this.path = undefined;\n  this.regexp = pathRegexp(path, this.keys = [], opts);\n\n  // set fast path flags\n  this.regexp.fast_star = path === '*'\n  this.regexp.fast_slash = path === '/' && opts.end === false\n}\n\n/**\n * Handle the error for the layer.\n *\n * @param {Error} error\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handle_error = function handle_error(error, req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length !== 4) {\n    // not a standard error handler\n    return next(error);\n  }\n\n  try {\n    fn(error, req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Handle the request for the layer.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nLayer.prototype.match = function match(path) {\n  var match\n\n  if (path != null) {\n    // fast path non-ending match for / (any path matches)\n    if (this.regexp.fast_slash) {\n      this.params = {}\n      this.path = ''\n      return true\n    }\n\n    // fast path for * (everything matched in a param)\n    if (this.regexp.fast_star) {\n      this.params = {'0': decode_param(path)}\n      this.path = path\n      return true\n    }\n\n    // match the path\n    match = this.regexp.exec(path)\n  }\n\n  if (!match) {\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  // store values\n  this.params = {};\n  this.path = match[0]\n\n  var keys = this.keys;\n  var params = this.params;\n\n  for (var i = 1; i < match.length; i++) {\n    var key = keys[i - 1];\n    var prop = key.name;\n    var val = decode_param(match[i])\n\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\n      params[prop] = val;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Decode param value.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction decode_param(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return val;\n  }\n\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    if (err instanceof URIError) {\n      err.message = 'Failed to decode param \\'' + val + '\\'';\n      err.status = err.statusCode = 400;\n    }\n\n    throw err;\n  }\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('express:router:route');\nvar flatten = require('array-flatten');\nvar Layer = require('./layer');\nvar methods = require('methods');\n\n/**\n * Module variables.\n * @private\n */\n\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Route;\n\n/**\n * Initialize `Route` with the given `path`,\n *\n * @param {String} path\n * @public\n */\n\nfunction Route(path) {\n  this.path = path;\n  this.stack = [];\n\n  debug('new %o', path)\n\n  // route handlers for various http methods\n  this.methods = {};\n}\n\n/**\n * Determine if the route handles a given method.\n * @private\n */\n\nRoute.prototype._handles_method = function _handles_method(method) {\n  if (this.methods._all) {\n    return true;\n  }\n\n  var name = method.toLowerCase();\n\n  if (name === 'head' && !this.methods['head']) {\n    name = 'get';\n  }\n\n  return Boolean(this.methods[name]);\n};\n\n/**\n * @return {Array} supported HTTP methods\n * @private\n */\n\nRoute.prototype._options = function _options() {\n  var methods = Object.keys(this.methods);\n\n  // append automatic head\n  if (this.methods.get && !this.methods.head) {\n    methods.push('head');\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    // make upper case\n    methods[i] = methods[i].toUpperCase();\n  }\n\n  return methods;\n};\n\n/**\n * dispatch req, res into this route\n * @private\n */\n\nRoute.prototype.dispatch = function dispatch(req, res, done) {\n  var idx = 0;\n  var stack = this.stack;\n  if (stack.length === 0) {\n    return done();\n  }\n\n  var method = req.method.toLowerCase();\n  if (method === 'head' && !this.methods['head']) {\n    method = 'get';\n  }\n\n  req.route = this;\n\n  next();\n\n  function next(err) {\n    // signal to exit route\n    if (err && err === 'route') {\n      return done();\n    }\n\n    // signal to exit router\n    if (err && err === 'router') {\n      return done(err)\n    }\n\n    var layer = stack[idx++];\n    if (!layer) {\n      return done(err);\n    }\n\n    if (layer.method && layer.method !== method) {\n      return next(err);\n    }\n\n    if (err) {\n      layer.handle_error(err, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n\n/**\n * Add a handler for all HTTP verbs to this route.\n *\n * Behaves just like middleware and can respond or call `next`\n * to continue processing.\n *\n * You can use multiple `.all` call to add multiple handlers.\n *\n *   function check_something(req, res, next){\n *     next();\n *   };\n *\n *   function validate_user(req, res, next){\n *     next();\n *   };\n *\n *   route\n *   .all(validate_user)\n *   .all(check_something)\n *   .get(function(req, res, next){\n *     res.send('hello world');\n *   });\n *\n * @param {function} handler\n * @return {Route} for chaining\n * @api public\n */\n\nRoute.prototype.all = function all() {\n  var handles = flatten(slice.call(arguments));\n\n  for (var i = 0; i < handles.length; i++) {\n    var handle = handles[i];\n\n    if (typeof handle !== 'function') {\n      var type = toString.call(handle);\n      var msg = 'Route.all() requires a callback function but got a ' + type\n      throw new TypeError(msg);\n    }\n\n    var layer = Layer('/', {}, handle);\n    layer.method = undefined;\n\n    this.methods._all = true;\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires a callback function but got a ' + type\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @api private\n */\n\nvar Buffer = require('safe-buffer').Buffer\nvar contentDisposition = require('content-disposition');\nvar contentType = require('content-type');\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar mime = require('send').mime;\nvar etag = require('etag');\nvar proxyaddr = require('proxy-addr');\nvar qs = require('qs');\nvar querystring = require('querystring');\n\n/**\n * Return strong ETag for `body`.\n *\n * @param {String|Buffer} body\n * @param {String} [encoding]\n * @return {String}\n * @api private\n */\n\nexports.etag = createETagGenerator({ weak: false })\n\n/**\n * Return weak ETag for `body`.\n *\n * @param {String|Buffer} body\n * @param {String} [encoding]\n * @return {String}\n * @api private\n */\n\nexports.wetag = createETagGenerator({ weak: true })\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.isAbsolute = function(path){\n  if ('/' === path[0]) return true;\n  if (':' === path[1] && ('\\\\' === path[2] || '/' === path[2])) return true; // Windows device path\n  if ('\\\\\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path\n};\n\n/**\n * Flatten the given `arr`.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.flatten = deprecate.function(flatten,\n  'utils.flatten: use array-flatten npm module instead');\n\n/**\n * Normalize the given `type`, for example \"html\" becomes \"text/html\".\n *\n * @param {String} type\n * @return {Object}\n * @api private\n */\n\nexports.normalizeType = function(type){\n  return ~type.indexOf('/')\n    ? acceptParams(type)\n    : { value: mime.lookup(type), params: {} };\n};\n\n/**\n * Normalize `types`, for example \"html\" becomes \"text/html\".\n *\n * @param {Array} types\n * @return {Array}\n * @api private\n */\n\nexports.normalizeTypes = function(types){\n  var ret = [];\n\n  for (var i = 0; i < types.length; ++i) {\n    ret.push(exports.normalizeType(types[i]));\n  }\n\n  return ret;\n};\n\n/**\n * Generate Content-Disposition header appropriate for the filename.\n * non-ascii filenames are urlencoded and a filename* parameter is added\n *\n * @param {String} filename\n * @return {String}\n * @api private\n */\n\nexports.contentDisposition = deprecate.function(contentDisposition,\n  'utils.contentDisposition: use content-disposition npm module instead');\n\n/**\n * Parse accept params `str` returning an\n * object with `.value`, `.quality` and `.params`.\n * also includes `.originalIndex` for stable sorting\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction acceptParams(str, index) {\n  var parts = str.split(/ *; */);\n  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };\n\n  for (var i = 1; i < parts.length; ++i) {\n    var pms = parts[i].split(/ *= */);\n    if ('q' === pms[0]) {\n      ret.quality = parseFloat(pms[1]);\n    } else {\n      ret.params[pms[0]] = pms[1];\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compile \"etag\" value to function.\n *\n * @param  {Boolean|String|Function} val\n * @return {Function}\n * @api private\n */\n\nexports.compileETag = function(val) {\n  var fn;\n\n  if (typeof val === 'function') {\n    return val;\n  }\n\n  switch (val) {\n    case true:\n      fn = exports.wetag;\n      break;\n    case false:\n      break;\n    case 'strong':\n      fn = exports.etag;\n      break;\n    case 'weak':\n      fn = exports.wetag;\n      break;\n    default:\n      throw new TypeError('unknown value for etag function: ' + val);\n  }\n\n  return fn;\n}\n\n/**\n * Compile \"query parser\" value to function.\n *\n * @param  {String|Function} val\n * @return {Function}\n * @api private\n */\n\nexports.compileQueryParser = function compileQueryParser(val) {\n  var fn;\n\n  if (typeof val === 'function') {\n    return val;\n  }\n\n  switch (val) {\n    case true:\n      fn = querystring.parse;\n      break;\n    case false:\n      fn = newObject;\n      break;\n    case 'extended':\n      fn = parseExtendedQueryString;\n      break;\n    case 'simple':\n      fn = querystring.parse;\n      break;\n    default:\n      throw new TypeError('unknown value for query parser function: ' + val);\n  }\n\n  return fn;\n}\n\n/**\n * Compile \"proxy trust\" value to function.\n *\n * @param  {Boolean|String|Number|Array|Function} val\n * @return {Function}\n * @api private\n */\n\nexports.compileTrust = function(val) {\n  if (typeof val === 'function') return val;\n\n  if (val === true) {\n    // Support plain true/false\n    return function(){ return true };\n  }\n\n  if (typeof val === 'number') {\n    // Support trusting hop count\n    return function(a, i){ return i < val };\n  }\n\n  if (typeof val === 'string') {\n    // Support comma-separated values\n    val = val.split(/ *, */);\n  }\n\n  return proxyaddr.compile(val || []);\n}\n\n/**\n * Set the charset in a given Content-Type string.\n *\n * @param {String} type\n * @param {String} charset\n * @return {String}\n * @api private\n */\n\nexports.setCharset = function setCharset(type, charset) {\n  if (!type || !charset) {\n    return type;\n  }\n\n  // parse type\n  var parsed = contentType.parse(type);\n\n  // set charset\n  parsed.parameters.charset = charset;\n\n  // format type\n  return contentType.format(parsed);\n};\n\n/**\n * Create an ETag generator function, generating ETags with\n * the given options.\n *\n * @param {object} options\n * @return {function}\n * @private\n */\n\nfunction createETagGenerator (options) {\n  return function generateETag (body, encoding) {\n    var buf = !Buffer.isBuffer(body)\n      ? Buffer.from(body, encoding)\n      : body\n\n    return etag(buf, options)\n  }\n}\n\n/**\n * Parse an extended query string with qs.\n *\n * @return {Object}\n * @private\n */\n\nfunction parseExtendedQueryString(str) {\n  return qs.parse(str, {\n    allowPrototypes: true\n  });\n}\n\n/**\n * Return new empty object.\n *\n * @return {Object}\n * @api private\n */\n\nfunction newObject() {\n  return {};\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('express:view');\nvar path = require('path');\nvar fs = require('fs');\n\n/**\n * Module variables.\n * @private\n */\n\nvar dirname = path.dirname;\nvar basename = path.basename;\nvar extname = path.extname;\nvar join = path.join;\nvar resolve = path.resolve;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = View;\n\n/**\n * Initialize a new `View` with the given `name`.\n *\n * Options:\n *\n *   - `defaultEngine` the default template engine name\n *   - `engines` template engine require() cache\n *   - `root` root path for view lookup\n *\n * @param {string} name\n * @param {object} options\n * @public\n */\n\nfunction View(name, options) {\n  var opts = options || {};\n\n  this.defaultEngine = opts.defaultEngine;\n  this.ext = extname(name);\n  this.name = name;\n  this.root = opts.root;\n\n  if (!this.ext && !this.defaultEngine) {\n    throw new Error('No default engine was specified and no extension was provided.');\n  }\n\n  var fileName = name;\n\n  if (!this.ext) {\n    // get extension from default engine name\n    this.ext = this.defaultEngine[0] !== '.'\n      ? '.' + this.defaultEngine\n      : this.defaultEngine;\n\n    fileName += this.ext;\n  }\n\n  if (!opts.engines[this.ext]) {\n    // load engine\n    var mod = this.ext.substr(1)\n    debug('require \"%s\"', mod)\n\n    // default engine export\n    var fn = require(mod).__express\n\n    if (typeof fn !== 'function') {\n      throw new Error('Module \"' + mod + '\" does not provide a view engine.')\n    }\n\n    opts.engines[this.ext] = fn\n  }\n\n  // store loaded engine\n  this.engine = opts.engines[this.ext];\n\n  // lookup path\n  this.path = this.lookup(fileName);\n}\n\n/**\n * Lookup view by the given `name`\n *\n * @param {string} name\n * @private\n */\n\nView.prototype.lookup = function lookup(name) {\n  var path;\n  var roots = [].concat(this.root);\n\n  debug('lookup \"%s\"', name);\n\n  for (var i = 0; i < roots.length && !path; i++) {\n    var root = roots[i];\n\n    // resolve the path\n    var loc = resolve(root, name);\n    var dir = dirname(loc);\n    var file = basename(loc);\n\n    // resolve the file\n    path = this.resolve(dir, file);\n  }\n\n  return path;\n};\n\n/**\n * Render with the given options.\n *\n * @param {object} options\n * @param {function} callback\n * @private\n */\n\nView.prototype.render = function render(options, callback) {\n  debug('render \"%s\"', this.path);\n  this.engine(this.path, options, callback);\n};\n\n/**\n * Resolve the file within the given directory.\n *\n * @param {string} dir\n * @param {string} file\n * @private\n */\n\nView.prototype.resolve = function resolve(dir, file) {\n  var ext = this.ext;\n\n  // <path>.<ext>\n  var path = join(dir, file);\n  var stat = tryStat(path);\n\n  if (stat && stat.isFile()) {\n    return path;\n  }\n\n  // <path>/index.<ext>\n  path = join(dir, basename(file, ext), 'index' + ext);\n  stat = tryStat(path);\n\n  if (stat && stat.isFile()) {\n    return path;\n  }\n};\n\n/**\n * Return a stat, maybe.\n *\n * @param {string} path\n * @return {fs.Stats}\n * @private\n */\n\nfunction tryStat(path) {\n  debug('stat \"%s\"', path);\n\n  try {\n    return fs.statSync(path);\n  } catch (e) {\n    return undefined;\n  }\n}\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","/*!\n * finalhandler\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('finalhandler')\nvar encodeUrl = require('encodeurl')\nvar escapeHtml = require('escape-html')\nvar onFinished = require('on-finished')\nvar parseUrl = require('parseurl')\nvar statuses = require('statuses')\nvar unpipe = require('unpipe')\n\n/**\n * Module variables.\n * @private\n */\n\nvar DOUBLE_SPACE_REGEXP = /\\x20{2}/g\nvar NEWLINE_REGEXP = /\\n/g\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }\nvar isFinished = onFinished.isFinished\n\n/**\n * Create a minimal HTML document.\n *\n * @param {string} message\n * @private\n */\n\nfunction createHtmlDocument (message) {\n  var body = escapeHtml(message)\n    .replace(NEWLINE_REGEXP, '<br>')\n    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;')\n\n  return '<!DOCTYPE html>\\n' +\n    '<html lang=\"en\">\\n' +\n    '<head>\\n' +\n    '<meta charset=\"utf-8\">\\n' +\n    '<title>Error</title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '<pre>' + body + '</pre>\\n' +\n    '</body>\\n' +\n    '</html>\\n'\n}\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = finalhandler\n\n/**\n * Create a function to handle the final response.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {Object} [options]\n * @return {Function}\n * @public\n */\n\nfunction finalhandler (req, res, options) {\n  var opts = options || {}\n\n  // get environment\n  var env = opts.env || process.env.NODE_ENV || 'development'\n\n  // get error callback\n  var onerror = opts.onerror\n\n  return function (err) {\n    var headers\n    var msg\n    var status\n\n    // ignore 404 on in-flight response\n    if (!err && headersSent(res)) {\n      debug('cannot 404 after headers sent')\n      return\n    }\n\n    // unhandled error\n    if (err) {\n      // respect status code from error\n      status = getErrorStatusCode(err)\n\n      if (status === undefined) {\n        // fallback to status code on response\n        status = getResponseStatusCode(res)\n      } else {\n        // respect headers from error\n        headers = getErrorHeaders(err)\n      }\n\n      // get error message\n      msg = getErrorMessage(err, status, env)\n    } else {\n      // not found\n      status = 404\n      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))\n    }\n\n    debug('default %s', status)\n\n    // schedule onerror callback\n    if (err && onerror) {\n      defer(onerror, err, req, res)\n    }\n\n    // cannot actually respond\n    if (headersSent(res)) {\n      debug('cannot %d after headers sent', status)\n      req.socket.destroy()\n      return\n    }\n\n    // send response\n    send(req, res, status, headers, msg)\n  }\n}\n\n/**\n * Get headers from Error object.\n *\n * @param {Error} err\n * @return {object}\n * @private\n */\n\nfunction getErrorHeaders (err) {\n  if (!err.headers || typeof err.headers !== 'object') {\n    return undefined\n  }\n\n  var headers = Object.create(null)\n  var keys = Object.keys(err.headers)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    headers[key] = err.headers[key]\n  }\n\n  return headers\n}\n\n/**\n * Get message from Error object, fallback to status message.\n *\n * @param {Error} err\n * @param {number} status\n * @param {string} env\n * @return {string}\n * @private\n */\n\nfunction getErrorMessage (err, status, env) {\n  var msg\n\n  if (env !== 'production') {\n    // use err.stack, which typically includes err.message\n    msg = err.stack\n\n    // fallback to err.toString() when possible\n    if (!msg && typeof err.toString === 'function') {\n      msg = err.toString()\n    }\n  }\n\n  return msg || statuses[status]\n}\n\n/**\n * Get status code from Error object.\n *\n * @param {Error} err\n * @return {number}\n * @private\n */\n\nfunction getErrorStatusCode (err) {\n  // check err.status\n  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {\n    return err.status\n  }\n\n  // check err.statusCode\n  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {\n    return err.statusCode\n  }\n\n  return undefined\n}\n\n/**\n * Get resource name for the request.\n *\n * This is typically just the original pathname of the request\n * but will fallback to \"resource\" is that cannot be determined.\n *\n * @param {IncomingMessage} req\n * @return {string}\n * @private\n */\n\nfunction getResourceName (req) {\n  try {\n    return parseUrl.original(req).pathname\n  } catch (e) {\n    return 'resource'\n  }\n}\n\n/**\n * Get status code from response.\n *\n * @param {OutgoingMessage} res\n * @return {number}\n * @private\n */\n\nfunction getResponseStatusCode (res) {\n  var status = res.statusCode\n\n  // default status code to 500 if outside valid range\n  if (typeof status !== 'number' || status < 400 || status > 599) {\n    status = 500\n  }\n\n  return status\n}\n\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\nfunction headersSent (res) {\n  return typeof res.headersSent !== 'boolean'\n    ? Boolean(res._header)\n    : res.headersSent\n}\n\n/**\n * Send response.\n *\n * @param {IncomingMessage} req\n * @param {OutgoingMessage} res\n * @param {number} status\n * @param {object} headers\n * @param {string} message\n * @private\n */\n\nfunction send (req, res, status, headers, message) {\n  function write () {\n    // response body\n    var body = createHtmlDocument(message)\n\n    // response status\n    res.statusCode = status\n    res.statusMessage = statuses[status]\n\n    // response headers\n    setHeaders(res, headers)\n\n    // security headers\n    res.setHeader('Content-Security-Policy', \"default-src 'none'\")\n    res.setHeader('X-Content-Type-Options', 'nosniff')\n\n    // standard headers\n    res.setHeader('Content-Type', 'text/html; charset=utf-8')\n    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))\n\n    if (req.method === 'HEAD') {\n      res.end()\n      return\n    }\n\n    res.end(body, 'utf8')\n  }\n\n  if (isFinished(req)) {\n    write()\n    return\n  }\n\n  // unpipe everything from the request\n  unpipe(req)\n\n  // flush the request\n  onFinished(req, write)\n  req.resume()\n}\n\n/**\n * Set response headers from an object.\n *\n * @param {OutgoingMessage} res\n * @param {object} headers\n * @private\n */\n\nfunction setHeaders (res, headers) {\n  if (!headers) {\n    return\n  }\n\n  var keys = Object.keys(headers)\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    res.setHeader(key, headers[key])\n  }\n}\n","/*!\n * forwarded\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = forwarded\n\n/**\n * Get all addresses in the request, using the `X-Forwarded-For` header.\n *\n * @param {object} req\n * @return {array}\n * @public\n */\n\nfunction forwarded (req) {\n  if (!req) {\n    throw new TypeError('argument req is required')\n  }\n\n  // simple header parsing\n  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')\n  var socketAddr = req.connection.remoteAddress\n  var addrs = [socketAddr].concat(proxyAddrs)\n\n  // return all addresses\n  return addrs\n}\n\n/**\n * Parse the X-Forwarded-For header.\n *\n * @param {string} header\n * @private\n */\n\nfunction parse (header) {\n  var end = header.length\n  var list = []\n  var start = header.length\n\n  // gather addresses, backwards\n  for (var i = header.length - 1; i >= 0; i--) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i\n        }\n        break\n      case 0x2c: /* , */\n        if (start !== end) {\n          list.push(header.substring(start, end))\n        }\n        start = end = i\n        break\n      default:\n        start = i\n        break\n    }\n  }\n\n  // final address\n  if (start !== end) {\n    list.push(header.substring(start, end))\n  }\n\n  return list\n}\n","/*!\n * fresh\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to check for no-cache token in Cache-Control.\n * @private\n */\n\nvar CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = fresh\n\n/**\n * Check freshness of the response using request and response headers.\n *\n * @param {Object} reqHeaders\n * @param {Object} resHeaders\n * @return {Boolean}\n * @public\n */\n\nfunction fresh (reqHeaders, resHeaders) {\n  // fields\n  var modifiedSince = reqHeaders['if-modified-since']\n  var noneMatch = reqHeaders['if-none-match']\n\n  // unconditional request\n  if (!modifiedSince && !noneMatch) {\n    return false\n  }\n\n  // Always return stale when Cache-Control: no-cache\n  // to support end-to-end reload requests\n  // https://tools.ietf.org/html/rfc2616#section-14.9.4\n  var cacheControl = reqHeaders['cache-control']\n  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n    return false\n  }\n\n  // if-none-match\n  if (noneMatch && noneMatch !== '*') {\n    var etag = resHeaders['etag']\n\n    if (!etag) {\n      return false\n    }\n\n    var etagStale = true\n    var matches = parseTokenList(noneMatch)\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i]\n      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {\n        etagStale = false\n        break\n      }\n    }\n\n    if (etagStale) {\n      return false\n    }\n  }\n\n  // if-modified-since\n  if (modifiedSince) {\n    var lastModified = resHeaders['last-modified']\n    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))\n\n    if (modifiedStale) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  // istanbul ignore next: guard against date.js Date.parse patching\n  return typeof timestamp === 'number'\n    ? timestamp\n    : NaN\n}\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(str.substring(start, end))\n\n  return list\n}\n","/*!\n * http-errors\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar deprecate = require('depd')('http-errors')\nvar setPrototypeOf = require('setprototypeof')\nvar statuses = require('statuses')\nvar inherits = require('inherits')\nvar toIdentifier = require('toidentifier')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = createError\nmodule.exports.HttpError = createHttpErrorConstructor()\n\n// Populate exports for all constructors\npopulateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)\n\n/**\n * Get the code class of a status code.\n * @private\n */\n\nfunction codeClass (status) {\n  return Number(String(status).charAt(0) + '00')\n}\n\n/**\n * Create a new HTTP Error.\n *\n * @returns {Error}\n * @public\n */\n\nfunction createError () {\n  // so much arity going on ~_~\n  var err\n  var msg\n  var status = 500\n  var props = {}\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i]\n    if (arg instanceof Error) {\n      err = arg\n      status = err.status || err.statusCode || status\n      continue\n    }\n    switch (typeof arg) {\n      case 'string':\n        msg = arg\n        break\n      case 'number':\n        status = arg\n        if (i !== 0) {\n          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)')\n        }\n        break\n      case 'object':\n        props = arg\n        break\n    }\n  }\n\n  if (typeof status === 'number' && (status < 400 || status >= 600)) {\n    deprecate('non-error status code; use only 4xx or 5xx status codes')\n  }\n\n  if (typeof status !== 'number' ||\n    (!statuses[status] && (status < 400 || status >= 600))) {\n    status = 500\n  }\n\n  // constructor\n  var HttpError = createError[status] || createError[codeClass(status)]\n\n  if (!err) {\n    // create error\n    err = HttpError\n      ? new HttpError(msg)\n      : new Error(msg || statuses[status])\n    Error.captureStackTrace(err, createError)\n  }\n\n  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {\n    // add properties to generic error\n    err.expose = status < 500\n    err.status = err.statusCode = status\n  }\n\n  for (var key in props) {\n    if (key !== 'status' && key !== 'statusCode') {\n      err[key] = props[key]\n    }\n  }\n\n  return err\n}\n\n/**\n * Create HTTP error abstract base class.\n * @private\n */\n\nfunction createHttpErrorConstructor () {\n  function HttpError () {\n    throw new TypeError('cannot construct abstract class')\n  }\n\n  inherits(HttpError, Error)\n\n  return HttpError\n}\n\n/**\n * Create a constructor for a client error.\n * @private\n */\n\nfunction createClientErrorConstructor (HttpError, name, code) {\n  var className = name.match(/Error$/) ? name : name + 'Error'\n\n  function ClientError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ClientError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ClientError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ClientError, HttpError)\n  nameFunc(ClientError, className)\n\n  ClientError.prototype.status = code\n  ClientError.prototype.statusCode = code\n  ClientError.prototype.expose = true\n\n  return ClientError\n}\n\n/**\n * Create a constructor for a server error.\n * @private\n */\n\nfunction createServerErrorConstructor (HttpError, name, code) {\n  var className = name.match(/Error$/) ? name : name + 'Error'\n\n  function ServerError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ServerError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ServerError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ServerError, HttpError)\n  nameFunc(ServerError, className)\n\n  ServerError.prototype.status = code\n  ServerError.prototype.statusCode = code\n  ServerError.prototype.expose = false\n\n  return ServerError\n}\n\n/**\n * Set the name of a function, if possible.\n * @private\n */\n\nfunction nameFunc (func, name) {\n  var desc = Object.getOwnPropertyDescriptor(func, 'name')\n\n  if (desc && desc.configurable) {\n    desc.value = name\n    Object.defineProperty(func, 'name', desc)\n  }\n}\n\n/**\n * Populate the exports object with constructors for every error class.\n * @private\n */\n\nfunction populateConstructorExports (exports, codes, HttpError) {\n  codes.forEach(function forEachCode (code) {\n    var CodeError\n    var name = toIdentifier(statuses[code])\n\n    switch (codeClass(code)) {\n      case 400:\n        CodeError = createClientErrorConstructor(HttpError, name, code)\n        break\n      case 500:\n        CodeError = createServerErrorConstructor(HttpError, name, code)\n        break\n    }\n\n    if (CodeError) {\n      // export the constructor\n      exports[code] = CodeError\n      exports[name] = CodeError\n    }\n  })\n\n  // backwards-compatibility\n  exports[\"I'mateapot\"] = deprecate.function(exports.ImATeapot,\n    '\"I\\'mateapot\"; use \"ImATeapot\" instead')\n}\n","try {\n  var util = require('util');\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = Buffer.alloc(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = Buffer.alloc(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = Buffer.alloc(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = Buffer.alloc(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n","\"use strict\";\n\n// Description of supported double byte encodings and aliases.\n// Tables are not require()-d until they are needed to speed up library load.\n// require()-s are direct to support Browserify.\n\nmodule.exports = {\n    \n    // == Japanese/ShiftJIS ====================================================\n    // All japanese encodings are based on JIS X set of standards:\n    // JIS X 0201 - Single-byte encoding of ASCII + ¥ + Kana chars at 0xA1-0xDF.\n    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. \n    //              Has several variations in 1978, 1983, 1990 and 1997.\n    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.\n    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.\n    //              2 planes, first is superset of 0208, second - revised 0212.\n    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)\n\n    // Byte encodings are:\n    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte\n    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.\n    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.\n    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.\n    //               0x00-0x7F       - lower part of 0201\n    //               0x8E, 0xA1-0xDF - upper part of 0201\n    //               (0xA1-0xFE)x2   - 0208 plane (94x94).\n    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).\n    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.\n    //               Used as-is in ISO2022 family.\n    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, \n    //                0201-1976 Roman, 0208-1978, 0208-1983.\n    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.\n    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.\n    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.\n    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.\n    //\n    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.\n    //\n    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html\n\n    'shiftjis': {\n        type: '_dbcs',\n        table: function() { return require('./tables/shiftjis.json') },\n        encodeAdd: {'\\u00a5': 0x5C, '\\u203E': 0x7E},\n        encodeSkipVals: [{from: 0xED40, to: 0xF940}],\n    },\n    'csshiftjis': 'shiftjis',\n    'mskanji': 'shiftjis',\n    'sjis': 'shiftjis',\n    'windows31j': 'shiftjis',\n    'ms31j': 'shiftjis',\n    'xsjis': 'shiftjis',\n    'windows932': 'shiftjis',\n    'ms932': 'shiftjis',\n    '932': 'shiftjis',\n    'cp932': 'shiftjis',\n\n    'eucjp': {\n        type: '_dbcs',\n        table: function() { return require('./tables/eucjp.json') },\n        encodeAdd: {'\\u00a5': 0x5C, '\\u203E': 0x7E},\n    },\n\n    // TODO: KDDI extension to Shift_JIS\n    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.\n    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.\n\n\n    // == Chinese/GBK ==========================================================\n    // http://en.wikipedia.org/wiki/GBK\n    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder\n\n    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936\n    'gb2312': 'cp936',\n    'gb231280': 'cp936',\n    'gb23121980': 'cp936',\n    'csgb2312': 'cp936',\n    'csiso58gb231280': 'cp936',\n    'euccn': 'cp936',\n\n    // Microsoft's CP936 is a subset and approximation of GBK.\n    'windows936': 'cp936',\n    'ms936': 'cp936',\n    '936': 'cp936',\n    'cp936': {\n        type: '_dbcs',\n        table: function() { return require('./tables/cp936.json') },\n    },\n\n    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.\n    'gbk': {\n        type: '_dbcs',\n        table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },\n    },\n    'xgbk': 'gbk',\n    'isoir58': 'gbk',\n\n    // GB18030 is an algorithmic extension of GBK.\n    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder\n    // http://icu-project.org/docs/papers/gb18030.html\n    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml\n    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0\n    'gb18030': {\n        type: '_dbcs',\n        table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },\n        gb18030: function() { return require('./tables/gb18030-ranges.json') },\n        encodeSkipVals: [0x80],\n        encodeAdd: {'€': 0xA2E3},\n    },\n\n    'chinese': 'gb18030',\n\n\n    // == Korean ===============================================================\n    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.\n    'windows949': 'cp949',\n    'ms949': 'cp949',\n    '949': 'cp949',\n    'cp949': {\n        type: '_dbcs',\n        table: function() { return require('./tables/cp949.json') },\n    },\n\n    'cseuckr': 'cp949',\n    'csksc56011987': 'cp949',\n    'euckr': 'cp949',\n    'isoir149': 'cp949',\n    'korean': 'cp949',\n    'ksc56011987': 'cp949',\n    'ksc56011989': 'cp949',\n    'ksc5601': 'cp949',\n\n\n    // == Big5/Taiwan/Hong Kong ================================================\n    // There are lots of tables for Big5 and cp950. Please see the following links for history:\n    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html\n    // Variations, in roughly number of defined chars:\n    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT\n    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/\n    //  * Big5-2003 (Taiwan standard) almost superset of cp950.\n    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.\n    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. \n    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.\n    //    Plus, it has 4 combining sequences.\n    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299\n    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.\n    //    Implementations are not consistent within browsers; sometimes labeled as just big5.\n    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.\n    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31\n    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.\n    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt\n    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt\n    // \n    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder\n    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.\n\n    'windows950': 'cp950',\n    'ms950': 'cp950',\n    '950': 'cp950',\n    'cp950': {\n        type: '_dbcs',\n        table: function() { return require('./tables/cp950.json') },\n    },\n\n    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.\n    'big5': 'big5hkscs',\n    'big5hkscs': {\n        type: '_dbcs',\n        table: function() { return require('./tables/cp950.json').concat(require('./tables/big5-added.json')) },\n        encodeSkipVals: [0xa2cc],\n    },\n\n    'cnbig5': 'big5hkscs',\n    'csbig5': 'big5hkscs',\n    'xxbig5': 'big5hkscs',\n};\n","\"use strict\";\n\n// Update this array if you add/rename/remove files in this directory.\n// We support Browserify by skipping automatic module discovery and requiring modules directly.\nvar modules = [\n    require(\"./internal\"),\n    require(\"./utf16\"),\n    require(\"./utf7\"),\n    require(\"./sbcs-codec\"),\n    require(\"./sbcs-data\"),\n    require(\"./sbcs-data-generated\"),\n    require(\"./dbcs-codec\"),\n    require(\"./dbcs-data\"),\n];\n\n// Put all encoding/alias/codec definitions to single object and export it. \nfor (var i = 0; i < modules.length; i++) {\n    var module = modules[i];\n    for (var enc in module)\n        if (Object.prototype.hasOwnProperty.call(module, enc))\n            exports[enc] = module[enc];\n}\n","\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Export Node.js internal encodings.\n\nmodule.exports = {\n    // Encodings\n    utf8:   { type: \"_internal\", bomAware: true},\n    cesu8:  { type: \"_internal\", bomAware: true},\n    unicode11utf8: \"utf8\",\n\n    ucs2:   { type: \"_internal\", bomAware: true},\n    utf16le: \"ucs2\",\n\n    binary: { type: \"_internal\" },\n    base64: { type: \"_internal\" },\n    hex:    { type: \"_internal\" },\n\n    // Codec.\n    _internal: InternalCodec,\n};\n\n//------------------------------------------------------------------------------\n\nfunction InternalCodec(codecOptions, iconv) {\n    this.enc = codecOptions.encodingName;\n    this.bomAware = codecOptions.bomAware;\n\n    if (this.enc === \"base64\")\n        this.encoder = InternalEncoderBase64;\n    else if (this.enc === \"cesu8\") {\n        this.enc = \"utf8\"; // Use utf8 for decoding.\n        this.encoder = InternalEncoderCesu8;\n\n        // Add decoder for versions of Node not supporting CESU-8\n        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '💩') {\n            this.decoder = InternalDecoderCesu8;\n            this.defaultCharUnicode = iconv.defaultCharUnicode;\n        }\n    }\n}\n\nInternalCodec.prototype.encoder = InternalEncoder;\nInternalCodec.prototype.decoder = InternalDecoder;\n\n//------------------------------------------------------------------------------\n\n// We use node.js internal decoder. Its signature is the same as ours.\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nif (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.\n    StringDecoder.prototype.end = function() {};\n\n\nfunction InternalDecoder(options, codec) {\n    StringDecoder.call(this, codec.enc);\n}\n\nInternalDecoder.prototype = StringDecoder.prototype;\n\n\n//------------------------------------------------------------------------------\n// Encoder is mostly trivial\n\nfunction InternalEncoder(options, codec) {\n    this.enc = codec.enc;\n}\n\nInternalEncoder.prototype.write = function(str) {\n    return Buffer.from(str, this.enc);\n}\n\nInternalEncoder.prototype.end = function() {\n}\n\n\n//------------------------------------------------------------------------------\n// Except base64 encoder, which must keep its state.\n\nfunction InternalEncoderBase64(options, codec) {\n    this.prevStr = '';\n}\n\nInternalEncoderBase64.prototype.write = function(str) {\n    str = this.prevStr + str;\n    var completeQuads = str.length - (str.length % 4);\n    this.prevStr = str.slice(completeQuads);\n    str = str.slice(0, completeQuads);\n\n    return Buffer.from(str, \"base64\");\n}\n\nInternalEncoderBase64.prototype.end = function() {\n    return Buffer.from(this.prevStr, \"base64\");\n}\n\n\n//------------------------------------------------------------------------------\n// CESU-8 encoder is also special.\n\nfunction InternalEncoderCesu8(options, codec) {\n}\n\nInternalEncoderCesu8.prototype.write = function(str) {\n    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;\n    for (var i = 0; i < str.length; i++) {\n        var charCode = str.charCodeAt(i);\n        // Naive implementation, but it works because CESU-8 is especially easy\n        // to convert from UTF-16 (which all JS strings are encoded in).\n        if (charCode < 0x80)\n            buf[bufIdx++] = charCode;\n        else if (charCode < 0x800) {\n            buf[bufIdx++] = 0xC0 + (charCode >>> 6);\n            buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n        }\n        else { // charCode will always be < 0x10000 in javascript.\n            buf[bufIdx++] = 0xE0 + (charCode >>> 12);\n            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);\n            buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n        }\n    }\n    return buf.slice(0, bufIdx);\n}\n\nInternalEncoderCesu8.prototype.end = function() {\n}\n\n//------------------------------------------------------------------------------\n// CESU-8 decoder is not implemented in Node v4.0+\n\nfunction InternalDecoderCesu8(options, codec) {\n    this.acc = 0;\n    this.contBytes = 0;\n    this.accBytes = 0;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n}\n\nInternalDecoderCesu8.prototype.write = function(buf) {\n    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, \n        res = '';\n    for (var i = 0; i < buf.length; i++) {\n        var curByte = buf[i];\n        if ((curByte & 0xC0) !== 0x80) { // Leading byte\n            if (contBytes > 0) { // Previous code is invalid\n                res += this.defaultCharUnicode;\n                contBytes = 0;\n            }\n\n            if (curByte < 0x80) { // Single-byte code\n                res += String.fromCharCode(curByte);\n            } else if (curByte < 0xE0) { // Two-byte code\n                acc = curByte & 0x1F;\n                contBytes = 1; accBytes = 1;\n            } else if (curByte < 0xF0) { // Three-byte code\n                acc = curByte & 0x0F;\n                contBytes = 2; accBytes = 1;\n            } else { // Four or more are not supported for CESU-8.\n                res += this.defaultCharUnicode;\n            }\n        } else { // Continuation byte\n            if (contBytes > 0) { // We're waiting for it.\n                acc = (acc << 6) | (curByte & 0x3f);\n                contBytes--; accBytes++;\n                if (contBytes === 0) {\n                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\n                    if (accBytes === 2 && acc < 0x80 && acc > 0)\n                        res += this.defaultCharUnicode;\n                    else if (accBytes === 3 && acc < 0x800)\n                        res += this.defaultCharUnicode;\n                    else\n                        // Actually add character.\n                        res += String.fromCharCode(acc);\n                }\n            } else { // Unexpected continuation byte\n                res += this.defaultCharUnicode;\n            }\n        }\n    }\n    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;\n    return res;\n}\n\nInternalDecoderCesu8.prototype.end = function() {\n    var res = 0;\n    if (this.contBytes > 0)\n        res += this.defaultCharUnicode;\n    return res;\n}\n","\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nexports._sbcs = SBCSCodec;\nfunction SBCSCodec(codecOptions, iconv) {\n    if (!codecOptions)\n        throw new Error(\"SBCS codec is called without the data.\")\n    \n    // Prepare char buffer for decoding.\n    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))\n        throw new Error(\"Encoding '\"+codecOptions.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n    \n    if (codecOptions.chars.length === 128) {\n        var asciiString = \"\";\n        for (var i = 0; i < 128; i++)\n            asciiString += String.fromCharCode(i);\n        codecOptions.chars = asciiString + codecOptions.chars;\n    }\n\n    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');\n    \n    // Encoding buffer.\n    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n\n    for (var i = 0; i < codecOptions.chars.length; i++)\n        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n    this.encodeBuf = encodeBuf;\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\n\n\nfunction SBCSEncoder(options, codec) {\n    this.encodeBuf = codec.encodeBuf;\n}\n\nSBCSEncoder.prototype.write = function(str) {\n    var buf = Buffer.alloc(str.length);\n    for (var i = 0; i < str.length; i++)\n        buf[i] = this.encodeBuf[str.charCodeAt(i)];\n    \n    return buf;\n}\n\nSBCSEncoder.prototype.end = function() {\n}\n\n\nfunction SBCSDecoder(options, codec) {\n    this.decodeBuf = codec.decodeBuf;\n}\n\nSBCSDecoder.prototype.write = function(buf) {\n    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n    var decodeBuf = this.decodeBuf;\n    var newBuf = Buffer.alloc(buf.length*2);\n    var idx1 = 0, idx2 = 0;\n    for (var i = 0; i < buf.length; i++) {\n        idx1 = buf[i]*2; idx2 = i*2;\n        newBuf[idx2] = decodeBuf[idx1];\n        newBuf[idx2+1] = decodeBuf[idx1+1];\n    }\n    return newBuf.toString('ucs2');\n}\n\nSBCSDecoder.prototype.end = function() {\n}\n","\"use strict\";\n\n// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.\nmodule.exports = {\n  \"437\": \"cp437\",\n  \"737\": \"cp737\",\n  \"775\": \"cp775\",\n  \"850\": \"cp850\",\n  \"852\": \"cp852\",\n  \"855\": \"cp855\",\n  \"856\": \"cp856\",\n  \"857\": \"cp857\",\n  \"858\": \"cp858\",\n  \"860\": \"cp860\",\n  \"861\": \"cp861\",\n  \"862\": \"cp862\",\n  \"863\": \"cp863\",\n  \"864\": \"cp864\",\n  \"865\": \"cp865\",\n  \"866\": \"cp866\",\n  \"869\": \"cp869\",\n  \"874\": \"windows874\",\n  \"922\": \"cp922\",\n  \"1046\": \"cp1046\",\n  \"1124\": \"cp1124\",\n  \"1125\": \"cp1125\",\n  \"1129\": \"cp1129\",\n  \"1133\": \"cp1133\",\n  \"1161\": \"cp1161\",\n  \"1162\": \"cp1162\",\n  \"1163\": \"cp1163\",\n  \"1250\": \"windows1250\",\n  \"1251\": \"windows1251\",\n  \"1252\": \"windows1252\",\n  \"1253\": \"windows1253\",\n  \"1254\": \"windows1254\",\n  \"1255\": \"windows1255\",\n  \"1256\": \"windows1256\",\n  \"1257\": \"windows1257\",\n  \"1258\": \"windows1258\",\n  \"28591\": \"iso88591\",\n  \"28592\": \"iso88592\",\n  \"28593\": \"iso88593\",\n  \"28594\": \"iso88594\",\n  \"28595\": \"iso88595\",\n  \"28596\": \"iso88596\",\n  \"28597\": \"iso88597\",\n  \"28598\": \"iso88598\",\n  \"28599\": \"iso88599\",\n  \"28600\": \"iso885910\",\n  \"28601\": \"iso885911\",\n  \"28603\": \"iso885913\",\n  \"28604\": \"iso885914\",\n  \"28605\": \"iso885915\",\n  \"28606\": \"iso885916\",\n  \"windows874\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����\"\n  },\n  \"win874\": \"windows874\",\n  \"cp874\": \"windows874\",\n  \"windows1250\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙\"\n  },\n  \"win1250\": \"windows1250\",\n  \"cp1250\": \"windows1250\",\n  \"windows1251\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя\"\n  },\n  \"win1251\": \"windows1251\",\n  \"cp1251\": \"windows1251\",\n  \"windows1252\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\"\n  },\n  \"win1252\": \"windows1252\",\n  \"cp1252\": \"windows1252\",\n  \"windows1253\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�\"\n  },\n  \"win1253\": \"windows1253\",\n  \"cp1253\": \"windows1253\",\n  \"windows1254\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ\"\n  },\n  \"win1254\": \"windows1254\",\n  \"cp1254\": \"windows1254\",\n  \"windows1255\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹֺֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�\"\n  },\n  \"win1255\": \"windows1255\",\n  \"cp1255\": \"windows1255\",\n  \"windows1256\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے\"\n  },\n  \"win1256\": \"windows1256\",\n  \"cp1256\": \"windows1256\",\n  \"windows1257\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙\"\n  },\n  \"win1257\": \"windows1257\",\n  \"cp1257\": \"windows1257\",\n  \"windows1258\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ\"\n  },\n  \"win1258\": \"windows1258\",\n  \"cp1258\": \"windows1258\",\n  \"iso88591\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\"\n  },\n  \"cp28591\": \"iso88591\",\n  \"iso88592\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙\"\n  },\n  \"cp28592\": \"iso88592\",\n  \"iso88593\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙\"\n  },\n  \"cp28593\": \"iso88593\",\n  \"iso88594\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙\"\n  },\n  \"cp28594\": \"iso88594\",\n  \"iso88595\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ\"\n  },\n  \"cp28595\": \"iso88595\",\n  \"iso88596\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������\"\n  },\n  \"cp28596\": \"iso88596\",\n  \"iso88597\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�\"\n  },\n  \"cp28597\": \"iso88597\",\n  \"iso88598\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�\"\n  },\n  \"cp28598\": \"iso88598\",\n  \"iso88599\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ\"\n  },\n  \"cp28599\": \"iso88599\",\n  \"iso885910\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ\"\n  },\n  \"cp28600\": \"iso885910\",\n  \"iso885911\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����\"\n  },\n  \"cp28601\": \"iso885911\",\n  \"iso885913\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’\"\n  },\n  \"cp28603\": \"iso885913\",\n  \"iso885914\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ\"\n  },\n  \"cp28604\": \"iso885914\",\n  \"iso885915\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\"\n  },\n  \"cp28605\": \"iso885915\",\n  \"iso885916\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ\"\n  },\n  \"cp28606\": \"iso885916\",\n  \"cp437\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \"\n  },\n  \"ibm437\": \"cp437\",\n  \"csibm437\": \"cp437\",\n  \"cp737\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ \"\n  },\n  \"ibm737\": \"cp737\",\n  \"csibm737\": \"cp737\",\n  \"cp775\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ \"\n  },\n  \"ibm775\": \"cp775\",\n  \"csibm775\": \"cp775\",\n  \"cp850\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ \"\n  },\n  \"ibm850\": \"cp850\",\n  \"csibm850\": \"cp850\",\n  \"cp852\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ \"\n  },\n  \"ibm852\": \"cp852\",\n  \"csibm852\": \"cp852\",\n  \"cp855\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ \"\n  },\n  \"ibm855\": \"cp855\",\n  \"csibm855\": \"cp855\",\n  \"cp856\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ \"\n  },\n  \"ibm856\": \"cp856\",\n  \"csibm856\": \"cp856\",\n  \"cp857\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ \"\n  },\n  \"ibm857\": \"cp857\",\n  \"csibm857\": \"cp857\",\n  \"cp858\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ \"\n  },\n  \"ibm858\": \"cp858\",\n  \"csibm858\": \"cp858\",\n  \"cp860\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \"\n  },\n  \"ibm860\": \"cp860\",\n  \"csibm860\": \"cp860\",\n  \"cp861\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \"\n  },\n  \"ibm861\": \"cp861\",\n  \"csibm861\": \"cp861\",\n  \"cp862\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \"\n  },\n  \"ibm862\": \"cp862\",\n  \"csibm862\": \"cp862\",\n  \"cp863\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \"\n  },\n  \"ibm863\": \"cp863\",\n  \"csibm863\": \"cp863\",\n  \"cp864\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�\"\n  },\n  \"ibm864\": \"cp864\",\n  \"csibm864\": \"cp864\",\n  \"cp865\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \"\n  },\n  \"ibm865\": \"cp865\",\n  \"csibm865\": \"cp865\",\n  \"cp866\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ \"\n  },\n  \"ibm866\": \"cp866\",\n  \"csibm866\": \"cp866\",\n  \"cp869\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ \"\n  },\n  \"ibm869\": \"cp869\",\n  \"csibm869\": \"cp869\",\n  \"cp922\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ\"\n  },\n  \"ibm922\": \"cp922\",\n  \"csibm922\": \"cp922\",\n  \"cp1046\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�\"\n  },\n  \"ibm1046\": \"cp1046\",\n  \"csibm1046\": \"cp1046\",\n  \"cp1124\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ\"\n  },\n  \"ibm1124\": \"cp1124\",\n  \"csibm1124\": \"cp1124\",\n  \"cp1125\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ \"\n  },\n  \"ibm1125\": \"cp1125\",\n  \"csibm1125\": \"cp1125\",\n  \"cp1129\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ\"\n  },\n  \"ibm1129\": \"cp1129\",\n  \"csibm1129\": \"cp1129\",\n  \"cp1133\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�\"\n  },\n  \"ibm1133\": \"cp1133\",\n  \"csibm1133\": \"cp1133\",\n  \"cp1161\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ \"\n  },\n  \"ibm1161\": \"cp1161\",\n  \"csibm1161\": \"cp1161\",\n  \"cp1162\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����\"\n  },\n  \"ibm1162\": \"cp1162\",\n  \"csibm1162\": \"cp1162\",\n  \"cp1163\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ\"\n  },\n  \"ibm1163\": \"cp1163\",\n  \"csibm1163\": \"cp1163\",\n  \"maccroatian\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ\"\n  },\n  \"maccyrillic\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤\"\n  },\n  \"macgreek\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�\"\n  },\n  \"maciceland\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ\"\n  },\n  \"macroman\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ\"\n  },\n  \"macromania\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ\"\n  },\n  \"macthai\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู﻿​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����\"\n  },\n  \"macturkish\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ\"\n  },\n  \"macukraine\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤\"\n  },\n  \"koi8r\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ\"\n  },\n  \"koi8u\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ\"\n  },\n  \"koi8ru\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ\"\n  },\n  \"koi8t\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ\"\n  },\n  \"armscii8\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�\"\n  },\n  \"rk1048\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя\"\n  },\n  \"tcvn\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000ÚỤ\\u0003ỪỬỮ\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010ỨỰỲỶỸÝỴ\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ\"\n  },\n  \"georgianacademy\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ\"\n  },\n  \"georgianps\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ\"\n  },\n  \"pt154\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя\"\n  },\n  \"viscii\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001Ẳ\\u0003\\u0004ẴẪ\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013Ỷ\\u0015\\u0016\\u0017\\u0018Ỹ\\u001a\\u001b\\u001c\\u001dỴ\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ\"\n  },\n  \"iso646cn\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������\"\n  },\n  \"iso646jp\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������\"\n  },\n  \"hproman8\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \" ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�\"\n  },\n  \"macintosh\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ\"\n  },\n  \"ascii\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"��������������������������������������������������������������������������������������������������������������������������������\"\n  },\n  \"tis620\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����\"\n  }\n}","\"use strict\";\n\n// Manually added data to be used by sbcs codec in addition to generated one.\n\nmodule.exports = {\n    // Not supported by iconv, not sure why.\n    \"10029\": \"maccenteuro\",\n    \"maccenteuro\": {\n        \"type\": \"_sbcs\",\n        \"chars\": \"ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ\"\n    },\n\n    \"808\": \"cp808\",\n    \"ibm808\": \"cp808\",\n    \"cp808\": {\n        \"type\": \"_sbcs\",\n        \"chars\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ \"\n    },\n\n    \"mik\": {\n        \"type\": \"_sbcs\",\n        \"chars\": \"АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя└┴┬├─┼╣║╚╔╩╦╠═╬┐░▒▓│┤№§╗╝┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \"\n    },\n\n    // Aliases of generated encodings.\n    \"ascii8bit\": \"ascii\",\n    \"usascii\": \"ascii\",\n    \"ansix34\": \"ascii\",\n    \"ansix341968\": \"ascii\",\n    \"ansix341986\": \"ascii\",\n    \"csascii\": \"ascii\",\n    \"cp367\": \"ascii\",\n    \"ibm367\": \"ascii\",\n    \"isoir6\": \"ascii\",\n    \"iso646us\": \"ascii\",\n    \"iso646irv\": \"ascii\",\n    \"us\": \"ascii\",\n\n    \"latin1\": \"iso88591\",\n    \"latin2\": \"iso88592\",\n    \"latin3\": \"iso88593\",\n    \"latin4\": \"iso88594\",\n    \"latin5\": \"iso88599\",\n    \"latin6\": \"iso885910\",\n    \"latin7\": \"iso885913\",\n    \"latin8\": \"iso885914\",\n    \"latin9\": \"iso885915\",\n    \"latin10\": \"iso885916\",\n\n    \"csisolatin1\": \"iso88591\",\n    \"csisolatin2\": \"iso88592\",\n    \"csisolatin3\": \"iso88593\",\n    \"csisolatin4\": \"iso88594\",\n    \"csisolatincyrillic\": \"iso88595\",\n    \"csisolatinarabic\": \"iso88596\",\n    \"csisolatingreek\" : \"iso88597\",\n    \"csisolatinhebrew\": \"iso88598\",\n    \"csisolatin5\": \"iso88599\",\n    \"csisolatin6\": \"iso885910\",\n\n    \"l1\": \"iso88591\",\n    \"l2\": \"iso88592\",\n    \"l3\": \"iso88593\",\n    \"l4\": \"iso88594\",\n    \"l5\": \"iso88599\",\n    \"l6\": \"iso885910\",\n    \"l7\": \"iso885913\",\n    \"l8\": \"iso885914\",\n    \"l9\": \"iso885915\",\n    \"l10\": \"iso885916\",\n\n    \"isoir14\": \"iso646jp\",\n    \"isoir57\": \"iso646cn\",\n    \"isoir100\": \"iso88591\",\n    \"isoir101\": \"iso88592\",\n    \"isoir109\": \"iso88593\",\n    \"isoir110\": \"iso88594\",\n    \"isoir144\": \"iso88595\",\n    \"isoir127\": \"iso88596\",\n    \"isoir126\": \"iso88597\",\n    \"isoir138\": \"iso88598\",\n    \"isoir148\": \"iso88599\",\n    \"isoir157\": \"iso885910\",\n    \"isoir166\": \"tis620\",\n    \"isoir179\": \"iso885913\",\n    \"isoir199\": \"iso885914\",\n    \"isoir203\": \"iso885915\",\n    \"isoir226\": \"iso885916\",\n\n    \"cp819\": \"iso88591\",\n    \"ibm819\": \"iso88591\",\n\n    \"cyrillic\": \"iso88595\",\n\n    \"arabic\": \"iso88596\",\n    \"arabic8\": \"iso88596\",\n    \"ecma114\": \"iso88596\",\n    \"asmo708\": \"iso88596\",\n\n    \"greek\" : \"iso88597\",\n    \"greek8\" : \"iso88597\",\n    \"ecma118\" : \"iso88597\",\n    \"elot928\" : \"iso88597\",\n\n    \"hebrew\": \"iso88598\",\n    \"hebrew8\": \"iso88598\",\n\n    \"turkish\": \"iso88599\",\n    \"turkish8\": \"iso88599\",\n\n    \"thai\": \"iso885911\",\n    \"thai8\": \"iso885911\",\n\n    \"celtic\": \"iso885914\",\n    \"celtic8\": \"iso885914\",\n    \"isoceltic\": \"iso885914\",\n\n    \"tis6200\": \"tis620\",\n    \"tis62025291\": \"tis620\",\n    \"tis62025330\": \"tis620\",\n\n    \"10000\": \"macroman\",\n    \"10006\": \"macgreek\",\n    \"10007\": \"maccyrillic\",\n    \"10079\": \"maciceland\",\n    \"10081\": \"macturkish\",\n\n    \"cspc8codepage437\": \"cp437\",\n    \"cspc775baltic\": \"cp775\",\n    \"cspc850multilingual\": \"cp850\",\n    \"cspcp852\": \"cp852\",\n    \"cspc862latinhebrew\": \"cp862\",\n    \"cpgr\": \"cp869\",\n\n    \"msee\": \"cp1250\",\n    \"mscyrl\": \"cp1251\",\n    \"msansi\": \"cp1252\",\n    \"msgreek\": \"cp1253\",\n    \"msturk\": \"cp1254\",\n    \"mshebr\": \"cp1255\",\n    \"msarab\": \"cp1256\",\n    \"winbaltrim\": \"cp1257\",\n\n    \"cp20866\": \"koi8r\",\n    \"20866\": \"koi8r\",\n    \"ibm878\": \"koi8r\",\n    \"cskoi8r\": \"koi8r\",\n\n    \"cp21866\": \"koi8u\",\n    \"21866\": \"koi8u\",\n    \"ibm1168\": \"koi8u\",\n\n    \"strk10482002\": \"rk1048\",\n\n    \"tcvn5712\": \"tcvn\",\n    \"tcvn57121\": \"tcvn\",\n\n    \"gb198880\": \"iso646cn\",\n    \"cn\": \"iso646cn\",\n\n    \"csiso14jisc6220ro\": \"iso646jp\",\n    \"jisc62201969ro\": \"iso646jp\",\n    \"jp\": \"iso646jp\",\n\n    \"cshproman8\": \"hproman8\",\n    \"r8\": \"hproman8\",\n    \"roman8\": \"hproman8\",\n    \"xroman8\": \"hproman8\",\n    \"ibm1051\": \"hproman8\",\n\n    \"mac\": \"macintosh\",\n    \"csmacintosh\": \"macintosh\",\n};\n\n","\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js\n\n// == UTF16-BE codec. ==========================================================\n\nexports.utf16be = Utf16BECodec;\nfunction Utf16BECodec() {\n}\n\nUtf16BECodec.prototype.encoder = Utf16BEEncoder;\nUtf16BECodec.prototype.decoder = Utf16BEDecoder;\nUtf16BECodec.prototype.bomAware = true;\n\n\n// -- Encoding\n\nfunction Utf16BEEncoder() {\n}\n\nUtf16BEEncoder.prototype.write = function(str) {\n    var buf = Buffer.from(str, 'ucs2');\n    for (var i = 0; i < buf.length; i += 2) {\n        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;\n    }\n    return buf;\n}\n\nUtf16BEEncoder.prototype.end = function() {\n}\n\n\n// -- Decoding\n\nfunction Utf16BEDecoder() {\n    this.overflowByte = -1;\n}\n\nUtf16BEDecoder.prototype.write = function(buf) {\n    if (buf.length == 0)\n        return '';\n\n    var buf2 = Buffer.alloc(buf.length + 1),\n        i = 0, j = 0;\n\n    if (this.overflowByte !== -1) {\n        buf2[0] = buf[0];\n        buf2[1] = this.overflowByte;\n        i = 1; j = 2;\n    }\n\n    for (; i < buf.length-1; i += 2, j+= 2) {\n        buf2[j] = buf[i+1];\n        buf2[j+1] = buf[i];\n    }\n\n    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;\n\n    return buf2.slice(0, j).toString('ucs2');\n}\n\nUtf16BEDecoder.prototype.end = function() {\n}\n\n\n// == UTF-16 codec =============================================================\n// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.\n// Defaults to UTF-16LE, as it's prevalent and default in Node.\n// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le\n// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});\n\n// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).\n\nexports.utf16 = Utf16Codec;\nfunction Utf16Codec(codecOptions, iconv) {\n    this.iconv = iconv;\n}\n\nUtf16Codec.prototype.encoder = Utf16Encoder;\nUtf16Codec.prototype.decoder = Utf16Decoder;\n\n\n// -- Encoding (pass-through)\n\nfunction Utf16Encoder(options, codec) {\n    options = options || {};\n    if (options.addBOM === undefined)\n        options.addBOM = true;\n    this.encoder = codec.iconv.getEncoder('utf-16le', options);\n}\n\nUtf16Encoder.prototype.write = function(str) {\n    return this.encoder.write(str);\n}\n\nUtf16Encoder.prototype.end = function() {\n    return this.encoder.end();\n}\n\n\n// -- Decoding\n\nfunction Utf16Decoder(options, codec) {\n    this.decoder = null;\n    this.initialBytes = [];\n    this.initialBytesLen = 0;\n\n    this.options = options || {};\n    this.iconv = codec.iconv;\n}\n\nUtf16Decoder.prototype.write = function(buf) {\n    if (!this.decoder) {\n        // Codec is not chosen yet. Accumulate initial bytes.\n        this.initialBytes.push(buf);\n        this.initialBytesLen += buf.length;\n        \n        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)\n            return '';\n\n        // We have enough bytes -> detect endianness.\n        var buf = Buffer.concat(this.initialBytes),\n            encoding = detectEncoding(buf, this.options.defaultEncoding);\n        this.decoder = this.iconv.getDecoder(encoding, this.options);\n        this.initialBytes.length = this.initialBytesLen = 0;\n    }\n\n    return this.decoder.write(buf);\n}\n\nUtf16Decoder.prototype.end = function() {\n    if (!this.decoder) {\n        var buf = Buffer.concat(this.initialBytes),\n            encoding = detectEncoding(buf, this.options.defaultEncoding);\n        this.decoder = this.iconv.getDecoder(encoding, this.options);\n\n        var res = this.decoder.write(buf),\n            trail = this.decoder.end();\n\n        return trail ? (res + trail) : res;\n    }\n    return this.decoder.end();\n}\n\nfunction detectEncoding(buf, defaultEncoding) {\n    var enc = defaultEncoding || 'utf-16le';\n\n    if (buf.length >= 2) {\n        // Check BOM.\n        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM\n            enc = 'utf-16be';\n        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM\n            enc = 'utf-16le';\n        else {\n            // No BOM found. Try to deduce encoding from initial content.\n            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.\n            // So, we count ASCII as if it was LE or BE, and decide from that.\n            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions\n                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.\n\n            for (var i = 0; i < _len; i += 2) {\n                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;\n                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;\n            }\n\n            if (asciiCharsBE > asciiCharsLE)\n                enc = 'utf-16be';\n            else if (asciiCharsBE < asciiCharsLE)\n                enc = 'utf-16le';\n        }\n    }\n\n    return enc;\n}\n\n\n","\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152\n// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3\n\nexports.utf7 = Utf7Codec;\nexports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7\nfunction Utf7Codec(codecOptions, iconv) {\n    this.iconv = iconv;\n};\n\nUtf7Codec.prototype.encoder = Utf7Encoder;\nUtf7Codec.prototype.decoder = Utf7Decoder;\nUtf7Codec.prototype.bomAware = true;\n\n\n// -- Encoding\n\nvar nonDirectChars = /[^A-Za-z0-9'\\(\\),-\\.\\/:\\? \\n\\r\\t]+/g;\n\nfunction Utf7Encoder(options, codec) {\n    this.iconv = codec.iconv;\n}\n\nUtf7Encoder.prototype.write = function(str) {\n    // Naive implementation.\n    // Non-direct chars are encoded as \"+<base64>-\"; single \"+\" char is encoded as \"+-\".\n    return Buffer.from(str.replace(nonDirectChars, function(chunk) {\n        return \"+\" + (chunk === '+' ? '' : \n            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) \n            + \"-\";\n    }.bind(this)));\n}\n\nUtf7Encoder.prototype.end = function() {\n}\n\n\n// -- Decoding\n\nfunction Utf7Decoder(options, codec) {\n    this.iconv = codec.iconv;\n    this.inBase64 = false;\n    this.base64Accum = '';\n}\n\nvar base64Regex = /[A-Za-z0-9\\/+]/;\nvar base64Chars = [];\nfor (var i = 0; i < 256; i++)\n    base64Chars[i] = base64Regex.test(String.fromCharCode(i));\n\nvar plusChar = '+'.charCodeAt(0), \n    minusChar = '-'.charCodeAt(0),\n    andChar = '&'.charCodeAt(0);\n\nUtf7Decoder.prototype.write = function(buf) {\n    var res = \"\", lastI = 0,\n        inBase64 = this.inBase64,\n        base64Accum = this.base64Accum;\n\n    // The decoder is more involved as we must handle chunks in stream.\n\n    for (var i = 0; i < buf.length; i++) {\n        if (!inBase64) { // We're in direct mode.\n            // Write direct chars until '+'\n            if (buf[i] == plusChar) {\n                res += this.iconv.decode(buf.slice(lastI, i), \"ascii\"); // Write direct chars.\n                lastI = i+1;\n                inBase64 = true;\n            }\n        } else { // We decode base64.\n            if (!base64Chars[buf[i]]) { // Base64 ended.\n                if (i == lastI && buf[i] == minusChar) {// \"+-\" -> \"+\"\n                    res += \"+\";\n                } else {\n                    var b64str = base64Accum + buf.slice(lastI, i).toString();\n                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n                }\n\n                if (buf[i] != minusChar) // Minus is absorbed after base64.\n                    i--;\n\n                lastI = i+1;\n                inBase64 = false;\n                base64Accum = '';\n            }\n        }\n    }\n\n    if (!inBase64) {\n        res += this.iconv.decode(buf.slice(lastI), \"ascii\"); // Write direct chars.\n    } else {\n        var b64str = base64Accum + buf.slice(lastI).toString();\n\n        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.\n        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.\n        b64str = b64str.slice(0, canBeDecoded);\n\n        res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n    }\n\n    this.inBase64 = inBase64;\n    this.base64Accum = base64Accum;\n\n    return res;\n}\n\nUtf7Decoder.prototype.end = function() {\n    var res = \"\";\n    if (this.inBase64 && this.base64Accum.length > 0)\n        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), \"utf16-be\");\n\n    this.inBase64 = false;\n    this.base64Accum = '';\n    return res;\n}\n\n\n// UTF-7-IMAP codec.\n// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)\n// Differences:\n//  * Base64 part is started by \"&\" instead of \"+\"\n//  * Direct characters are 0x20-0x7E, except \"&\" (0x26)\n//  * In Base64, \",\" is used instead of \"/\"\n//  * Base64 must not be used to represent direct characters.\n//  * No implicit shift back from Base64 (should always end with '-')\n//  * String must end in non-shifted position.\n//  * \"-&\" while in base64 is not allowed.\n\n\nexports.utf7imap = Utf7IMAPCodec;\nfunction Utf7IMAPCodec(codecOptions, iconv) {\n    this.iconv = iconv;\n};\n\nUtf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;\nUtf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;\nUtf7IMAPCodec.prototype.bomAware = true;\n\n\n// -- Encoding\n\nfunction Utf7IMAPEncoder(options, codec) {\n    this.iconv = codec.iconv;\n    this.inBase64 = false;\n    this.base64Accum = Buffer.alloc(6);\n    this.base64AccumIdx = 0;\n}\n\nUtf7IMAPEncoder.prototype.write = function(str) {\n    var inBase64 = this.inBase64,\n        base64Accum = this.base64Accum,\n        base64AccumIdx = this.base64AccumIdx,\n        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;\n\n    for (var i = 0; i < str.length; i++) {\n        var uChar = str.charCodeAt(i);\n        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.\n            if (inBase64) {\n                if (base64AccumIdx > 0) {\n                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\\//g, ',').replace(/=+$/, ''), bufIdx);\n                    base64AccumIdx = 0;\n                }\n\n                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.\n                inBase64 = false;\n            }\n\n            if (!inBase64) {\n                buf[bufIdx++] = uChar; // Write direct character\n\n                if (uChar === andChar)  // Ampersand -> '&-'\n                    buf[bufIdx++] = minusChar;\n            }\n\n        } else { // Non-direct character\n            if (!inBase64) {\n                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.\n                inBase64 = true;\n            }\n            if (inBase64) {\n                base64Accum[base64AccumIdx++] = uChar >> 8;\n                base64Accum[base64AccumIdx++] = uChar & 0xFF;\n\n                if (base64AccumIdx == base64Accum.length) {\n                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\\//g, ','), bufIdx);\n                    base64AccumIdx = 0;\n                }\n            }\n        }\n    }\n\n    this.inBase64 = inBase64;\n    this.base64AccumIdx = base64AccumIdx;\n\n    return buf.slice(0, bufIdx);\n}\n\nUtf7IMAPEncoder.prototype.end = function() {\n    var buf = Buffer.alloc(10), bufIdx = 0;\n    if (this.inBase64) {\n        if (this.base64AccumIdx > 0) {\n            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\\//g, ',').replace(/=+$/, ''), bufIdx);\n            this.base64AccumIdx = 0;\n        }\n\n        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.\n        this.inBase64 = false;\n    }\n\n    return buf.slice(0, bufIdx);\n}\n\n\n// -- Decoding\n\nfunction Utf7IMAPDecoder(options, codec) {\n    this.iconv = codec.iconv;\n    this.inBase64 = false;\n    this.base64Accum = '';\n}\n\nvar base64IMAPChars = base64Chars.slice();\nbase64IMAPChars[','.charCodeAt(0)] = true;\n\nUtf7IMAPDecoder.prototype.write = function(buf) {\n    var res = \"\", lastI = 0,\n        inBase64 = this.inBase64,\n        base64Accum = this.base64Accum;\n\n    // The decoder is more involved as we must handle chunks in stream.\n    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).\n\n    for (var i = 0; i < buf.length; i++) {\n        if (!inBase64) { // We're in direct mode.\n            // Write direct chars until '&'\n            if (buf[i] == andChar) {\n                res += this.iconv.decode(buf.slice(lastI, i), \"ascii\"); // Write direct chars.\n                lastI = i+1;\n                inBase64 = true;\n            }\n        } else { // We decode base64.\n            if (!base64IMAPChars[buf[i]]) { // Base64 ended.\n                if (i == lastI && buf[i] == minusChar) { // \"&-\" -> \"&\"\n                    res += \"&\";\n                } else {\n                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');\n                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n                }\n\n                if (buf[i] != minusChar) // Minus may be absorbed after base64.\n                    i--;\n\n                lastI = i+1;\n                inBase64 = false;\n                base64Accum = '';\n            }\n        }\n    }\n\n    if (!inBase64) {\n        res += this.iconv.decode(buf.slice(lastI), \"ascii\"); // Write direct chars.\n    } else {\n        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');\n\n        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.\n        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.\n        b64str = b64str.slice(0, canBeDecoded);\n\n        res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n    }\n\n    this.inBase64 = inBase64;\n    this.base64Accum = base64Accum;\n\n    return res;\n}\n\nUtf7IMAPDecoder.prototype.end = function() {\n    var res = \"\";\n    if (this.inBase64 && this.base64Accum.length > 0)\n        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), \"utf16-be\");\n\n    this.inBase64 = false;\n    this.base64Accum = '';\n    return res;\n}\n\n\n","\"use strict\";\n\nvar BOMChar = '\\uFEFF';\n\nexports.PrependBOM = PrependBOMWrapper\nfunction PrependBOMWrapper(encoder, options) {\n    this.encoder = encoder;\n    this.addBOM = true;\n}\n\nPrependBOMWrapper.prototype.write = function(str) {\n    if (this.addBOM) {\n        str = BOMChar + str;\n        this.addBOM = false;\n    }\n\n    return this.encoder.write(str);\n}\n\nPrependBOMWrapper.prototype.end = function() {\n    return this.encoder.end();\n}\n\n\n//------------------------------------------------------------------------------\n\nexports.StripBOM = StripBOMWrapper;\nfunction StripBOMWrapper(decoder, options) {\n    this.decoder = decoder;\n    this.pass = false;\n    this.options = options || {};\n}\n\nStripBOMWrapper.prototype.write = function(buf) {\n    var res = this.decoder.write(buf);\n    if (this.pass || !res)\n        return res;\n\n    if (res[0] === BOMChar) {\n        res = res.slice(1);\n        if (typeof this.options.stripBOM === 'function')\n            this.options.stripBOM();\n    }\n\n    this.pass = true;\n    return res;\n}\n\nStripBOMWrapper.prototype.end = function() {\n    return this.decoder.end();\n}\n\n","\"use strict\";\nvar Buffer = require(\"buffer\").Buffer;\n// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer\n\n// == Extend Node primitives to use iconv-lite =================================\n\nmodule.exports = function (iconv) {\n    var original = undefined; // Place to keep original methods.\n\n    // Node authors rewrote Buffer internals to make it compatible with\n    // Uint8Array and we cannot patch key functions since then.\n    // Note: this does use older Buffer API on a purpose\n    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);\n\n    iconv.extendNodeEncodings = function extendNodeEncodings() {\n        if (original) return;\n        original = {};\n\n        if (!iconv.supportsNodeEncodingsExtension) {\n            console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n            console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n            return;\n        }\n\n        var nodeNativeEncodings = {\n            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, \n            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,\n        };\n\n        Buffer.isNativeEncoding = function(enc) {\n            return enc && nodeNativeEncodings[enc.toLowerCase()];\n        }\n\n        // -- SlowBuffer -----------------------------------------------------------\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        original.SlowBufferToString = SlowBuffer.prototype.toString;\n        SlowBuffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.SlowBufferWrite = SlowBuffer.prototype.write;\n        SlowBuffer.prototype.write = function(string, offset, length, encoding) {\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n        }\n\n        // -- Buffer ---------------------------------------------------------------\n\n        original.BufferIsEncoding = Buffer.isEncoding;\n        Buffer.isEncoding = function(encoding) {\n            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n        }\n\n        original.BufferByteLength = Buffer.byteLength;\n        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferByteLength.call(this, str, encoding);\n\n            // Slow, I know, but we don't have a better way yet.\n            return iconv.encode(str, encoding).length;\n        }\n\n        original.BufferToString = Buffer.prototype.toString;\n        Buffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.BufferWrite = Buffer.prototype.write;\n        Buffer.prototype.write = function(string, offset, length, encoding) {\n            var _offset = offset, _length = length, _encoding = encoding;\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n\n            // TODO: Set _charsWritten.\n        }\n\n\n        // -- Readable -------------------------------------------------------------\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            original.ReadableSetEncoding = Readable.prototype.setEncoding;\n            Readable.prototype.setEncoding = function setEncoding(enc, options) {\n                // Use our own decoder, it has the same interface.\n                // We cannot use original function as it doesn't handle BOM-s.\n                this._readableState.decoder = iconv.getDecoder(enc, options);\n                this._readableState.encoding = enc;\n            }\n\n            Readable.prototype.collect = iconv._collect;\n        }\n    }\n\n    // Remove iconv-lite Node primitive extensions.\n    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n        if (!iconv.supportsNodeEncodingsExtension)\n            return;\n        if (!original)\n            throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\")\n\n        delete Buffer.isNativeEncoding;\n\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        SlowBuffer.prototype.toString = original.SlowBufferToString;\n        SlowBuffer.prototype.write = original.SlowBufferWrite;\n\n        Buffer.isEncoding = original.BufferIsEncoding;\n        Buffer.byteLength = original.BufferByteLength;\n        Buffer.prototype.toString = original.BufferToString;\n        Buffer.prototype.write = original.BufferWrite;\n\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            Readable.prototype.setEncoding = original.ReadableSetEncoding;\n            delete Readable.prototype.collect;\n        }\n\n        original = undefined;\n    }\n}\n","\"use strict\";\n\n// Some environments don't have global Buffer (e.g. React Native).\n// Solution would be installing npm modules \"buffer\" and \"stream\" explicitly.\nvar Buffer = require(\"safer-buffer\").Buffer;\n\nvar bomHandling = require(\"./bom-handling\"),\n    iconv = module.exports;\n\n// All codecs and aliases are kept here, keyed by encoding name/alias.\n// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.\niconv.encodings = null;\n\n// Characters emitted in case of error.\niconv.defaultCharUnicode = '�';\niconv.defaultCharSingleByte = '?';\n\n// Public API.\niconv.encode = function encode(str, encoding, options) {\n    str = \"\" + (str || \"\"); // Ensure string.\n\n    var encoder = iconv.getEncoder(encoding, options);\n\n    var res = encoder.write(str);\n    var trail = encoder.end();\n    \n    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;\n}\n\niconv.decode = function decode(buf, encoding, options) {\n    if (typeof buf === 'string') {\n        if (!iconv.skipDecodeWarning) {\n            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');\n            iconv.skipDecodeWarning = true;\n        }\n\n        buf = Buffer.from(\"\" + (buf || \"\"), \"binary\"); // Ensure buffer.\n    }\n\n    var decoder = iconv.getDecoder(encoding, options);\n\n    var res = decoder.write(buf);\n    var trail = decoder.end();\n\n    return trail ? (res + trail) : res;\n}\n\niconv.encodingExists = function encodingExists(enc) {\n    try {\n        iconv.getCodec(enc);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Legacy aliases to convert functions\niconv.toEncoding = iconv.encode;\niconv.fromEncoding = iconv.decode;\n\n// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.\niconv._codecDataCache = {};\niconv.getCodec = function getCodec(encoding) {\n    if (!iconv.encodings)\n        iconv.encodings = require(\"../encodings\"); // Lazy load all encoding definitions.\n    \n    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.\n    var enc = iconv._canonicalizeEncoding(encoding);\n\n    // Traverse iconv.encodings to find actual codec.\n    var codecOptions = {};\n    while (true) {\n        var codec = iconv._codecDataCache[enc];\n        if (codec)\n            return codec;\n\n        var codecDef = iconv.encodings[enc];\n\n        switch (typeof codecDef) {\n            case \"string\": // Direct alias to other encoding.\n                enc = codecDef;\n                break;\n\n            case \"object\": // Alias with options. Can be layered.\n                for (var key in codecDef)\n                    codecOptions[key] = codecDef[key];\n\n                if (!codecOptions.encodingName)\n                    codecOptions.encodingName = enc;\n                \n                enc = codecDef.type;\n                break;\n\n            case \"function\": // Codec itself.\n                if (!codecOptions.encodingName)\n                    codecOptions.encodingName = enc;\n\n                // The codec function must load all tables and return object with .encoder and .decoder methods.\n                // It'll be called only once (for each different options object).\n                codec = new codecDef(codecOptions, iconv);\n\n                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.\n                return codec;\n\n            default:\n                throw new Error(\"Encoding not recognized: '\" + encoding + \"' (searched as: '\"+enc+\"')\");\n        }\n    }\n}\n\niconv._canonicalizeEncoding = function(encoding) {\n    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.\n    return (''+encoding).toLowerCase().replace(/:\\d{4}$|[^0-9a-z]/g, \"\");\n}\n\niconv.getEncoder = function getEncoder(encoding, options) {\n    var codec = iconv.getCodec(encoding),\n        encoder = new codec.encoder(options, codec);\n\n    if (codec.bomAware && options && options.addBOM)\n        encoder = new bomHandling.PrependBOM(encoder, options);\n\n    return encoder;\n}\n\niconv.getDecoder = function getDecoder(encoding, options) {\n    var codec = iconv.getCodec(encoding),\n        decoder = new codec.decoder(options, codec);\n\n    if (codec.bomAware && !(options && options.stripBOM === false))\n        decoder = new bomHandling.StripBOM(decoder, options);\n\n    return decoder;\n}\n\n\n// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.\nvar nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;\nif (nodeVer) {\n\n    // Load streaming support in Node v0.10+\n    var nodeVerArr = nodeVer.split(\".\").map(Number);\n    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {\n        require(\"./streams\")(iconv);\n    }\n\n    // Load Node primitive extensions.\n    require(\"./extend-node\")(iconv);\n}\n\nif (\"Ā\" != \"\\u0100\") {\n    console.error(\"iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.\");\n}\n","\"use strict\";\n\nvar Buffer = require(\"buffer\").Buffer,\n    Transform = require(\"stream\").Transform;\n\n\n// == Exports ==================================================================\nmodule.exports = function(iconv) {\n    \n    // Additional Public API.\n    iconv.encodeStream = function encodeStream(encoding, options) {\n        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);\n    }\n\n    iconv.decodeStream = function decodeStream(encoding, options) {\n        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);\n    }\n\n    iconv.supportsStreams = true;\n\n\n    // Not published yet.\n    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;\n    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;\n    iconv._collect = IconvLiteDecoderStream.prototype.collect;\n};\n\n\n// == Encoder stream =======================================================\nfunction IconvLiteEncoderStream(conv, options) {\n    this.conv = conv;\n    options = options || {};\n    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.\n    Transform.call(this, options);\n}\n\nIconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {\n    constructor: { value: IconvLiteEncoderStream }\n});\n\nIconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {\n    if (typeof chunk != 'string')\n        return done(new Error(\"Iconv encoding stream needs strings as its input.\"));\n    try {\n        var res = this.conv.write(chunk);\n        if (res && res.length) this.push(res);\n        done();\n    }\n    catch (e) {\n        done(e);\n    }\n}\n\nIconvLiteEncoderStream.prototype._flush = function(done) {\n    try {\n        var res = this.conv.end();\n        if (res && res.length) this.push(res);\n        done();\n    }\n    catch (e) {\n        done(e);\n    }\n}\n\nIconvLiteEncoderStream.prototype.collect = function(cb) {\n    var chunks = [];\n    this.on('error', cb);\n    this.on('data', function(chunk) { chunks.push(chunk); });\n    this.on('end', function() {\n        cb(null, Buffer.concat(chunks));\n    });\n    return this;\n}\n\n\n// == Decoder stream =======================================================\nfunction IconvLiteDecoderStream(conv, options) {\n    this.conv = conv;\n    options = options || {};\n    options.encoding = this.encoding = 'utf8'; // We output strings.\n    Transform.call(this, options);\n}\n\nIconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {\n    constructor: { value: IconvLiteDecoderStream }\n});\n\nIconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {\n    if (!Buffer.isBuffer(chunk))\n        return done(new Error(\"Iconv decoding stream needs buffers as its input.\"));\n    try {\n        var res = this.conv.write(chunk);\n        if (res && res.length) this.push(res, this.encoding);\n        done();\n    }\n    catch (e) {\n        done(e);\n    }\n}\n\nIconvLiteDecoderStream.prototype._flush = function(done) {\n    try {\n        var res = this.conv.end();\n        if (res && res.length) this.push(res, this.encoding);                \n        done();\n    }\n    catch (e) {\n        done(e);\n    }\n}\n\nIconvLiteDecoderStream.prototype.collect = function(cb) {\n    var res = '';\n    this.on('error', cb);\n    this.on('data', function(chunk) { res += chunk; });\n    this.on('end', function() {\n        cb(null, res);\n    });\n    return this;\n}\n\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","(function() {\n  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;\n\n  ipaddr = {};\n\n  root = this;\n\n  if ((typeof module !== \"undefined\" && module !== null) && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root['ipaddr'] = ipaddr;\n  }\n\n  matchCIDR = function(first, second, partSize, cidrBits) {\n    var part, shift;\n    if (first.length !== second.length) {\n      throw new Error(\"ipaddr: cannot match CIDR for objects with different lengths\");\n    }\n    part = 0;\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n      if (shift < 0) {\n        shift = 0;\n      }\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n      cidrBits -= partSize;\n      part += 1;\n    }\n    return true;\n  };\n\n  ipaddr.subnetMatch = function(address, rangeList, defaultName) {\n    var k, len, rangeName, rangeSubnets, subnet;\n    if (defaultName == null) {\n      defaultName = 'unicast';\n    }\n    for (rangeName in rangeList) {\n      rangeSubnets = rangeList[rangeName];\n      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n        rangeSubnets = [rangeSubnets];\n      }\n      for (k = 0, len = rangeSubnets.length; k < len; k++) {\n        subnet = rangeSubnets[k];\n        if (address.kind() === subnet[0].kind()) {\n          if (address.match.apply(address, subnet)) {\n            return rangeName;\n          }\n        }\n      }\n    }\n    return defaultName;\n  };\n\n  ipaddr.IPv4 = (function() {\n    function IPv4(octets) {\n      var k, len, octet;\n      if (octets.length !== 4) {\n        throw new Error(\"ipaddr: ipv4 octet count should be 4\");\n      }\n      for (k = 0, len = octets.length; k < len; k++) {\n        octet = octets[k];\n        if (!((0 <= octet && octet <= 255))) {\n          throw new Error(\"ipaddr: ipv4 octet should fit in 8 bits\");\n        }\n      }\n      this.octets = octets;\n    }\n\n    IPv4.prototype.kind = function() {\n      return 'ipv4';\n    };\n\n    IPv4.prototype.toString = function() {\n      return this.octets.join(\".\");\n    };\n\n    IPv4.prototype.toNormalizedString = function() {\n      return this.toString();\n    };\n\n    IPv4.prototype.toByteArray = function() {\n      return this.octets.slice(0);\n    };\n\n    IPv4.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv4') {\n        throw new Error(\"ipaddr: cannot match ipv4 address with non-ipv4 one\");\n      }\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    };\n\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      \"private\": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]\n    };\n\n    IPv4.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv4.prototype.toIPv4MappedAddress = function() {\n      return ipaddr.IPv6.parse(\"::ffff:\" + (this.toString()));\n    };\n\n    IPv4.prototype.prefixLengthFromSubnetMask = function() {\n      var cidr, i, k, octet, stop, zeros, zerotable;\n      zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      cidr = 0;\n      stop = false;\n      for (i = k = 3; k >= 0; i = k += -1) {\n        octet = this.octets[i];\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 8) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 32 - cidr;\n    };\n\n    return IPv4;\n\n  })();\n\n  ipv4Part = \"(0?\\\\d+|0x[a-f0-9]+)\";\n\n  ipv4Regexes = {\n    fourOctet: new RegExp(\"^\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"$\", 'i'),\n    longValue: new RegExp(\"^\" + ipv4Part + \"$\", 'i')\n  };\n\n  ipaddr.IPv4.parser = function(string) {\n    var match, parseIntAuto, part, shift, value;\n    parseIntAuto = function(string) {\n      if (string[0] === \"0\" && string[1] !== \"x\") {\n        return parseInt(string, 8);\n      } else {\n        return parseInt(string);\n      }\n    };\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return (function() {\n        var k, len, ref, results;\n        ref = match.slice(1, 6);\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(parseIntAuto(part));\n        }\n        return results;\n      })();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n      if (value > 0xffffffff || value < 0) {\n        throw new Error(\"ipaddr: address outside defined range\");\n      }\n      return ((function() {\n        var k, results;\n        results = [];\n        for (shift = k = 0; k <= 24; shift = k += 8) {\n          results.push((value >> shift) & 0xff);\n        }\n        return results;\n      })()).reverse();\n    } else {\n      return null;\n    }\n  };\n\n  ipaddr.IPv6 = (function() {\n    function IPv6(parts, zoneId) {\n      var i, k, l, len, part, ref;\n      if (parts.length === 16) {\n        this.parts = [];\n        for (i = k = 0; k <= 14; i = k += 2) {\n          this.parts.push((parts[i] << 8) | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error(\"ipaddr: ipv6 part count should be 8 or 16\");\n      }\n      ref = this.parts;\n      for (l = 0, len = ref.length; l < len; l++) {\n        part = ref[l];\n        if (!((0 <= part && part <= 0xffff))) {\n          throw new Error(\"ipaddr: ipv6 part should fit in 16 bits\");\n        }\n      }\n      if (zoneId) {\n        this.zoneId = zoneId;\n      }\n    }\n\n    IPv6.prototype.kind = function() {\n      return 'ipv6';\n    };\n\n    IPv6.prototype.toString = function() {\n      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');\n    };\n\n    IPv6.prototype.toRFC5952String = function() {\n      var bestMatchIndex, bestMatchLength, match, regex, string;\n      regex = /((^|:)(0(:|$)){2,})/g;\n      string = this.toNormalizedString();\n      bestMatchIndex = 0;\n      bestMatchLength = -1;\n      while ((match = regex.exec(string))) {\n        if (match[0].length > bestMatchLength) {\n          bestMatchIndex = match.index;\n          bestMatchLength = match[0].length;\n        }\n      }\n      if (bestMatchLength < 0) {\n        return string;\n      }\n      return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);\n    };\n\n    IPv6.prototype.toByteArray = function() {\n      var bytes, k, len, part, ref;\n      bytes = [];\n      ref = this.parts;\n      for (k = 0, len = ref.length; k < len; k++) {\n        part = ref[k];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n      return bytes;\n    };\n\n    IPv6.prototype.toNormalizedString = function() {\n      var addr, part, suffix;\n      addr = ((function() {\n        var k, len, ref, results;\n        ref = this.parts;\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(part.toString(16));\n        }\n        return results;\n      }).call(this)).join(\":\");\n      suffix = '';\n      if (this.zoneId) {\n        suffix = '%' + this.zoneId;\n      }\n      return addr + suffix;\n    };\n\n    IPv6.prototype.toFixedLengthString = function() {\n      var addr, part, suffix;\n      addr = ((function() {\n        var k, len, ref, results;\n        ref = this.parts;\n        results = [];\n        for (k = 0, len = ref.length; k < len; k++) {\n          part = ref[k];\n          results.push(part.toString(16).padStart(4, '0'));\n        }\n        return results;\n      }).call(this)).join(\":\");\n      suffix = '';\n      if (this.zoneId) {\n        suffix = '%' + this.zoneId;\n      }\n      return addr + suffix;\n    };\n\n    IPv6.prototype.match = function(other, cidrRange) {\n      var ref;\n      if (cidrRange === void 0) {\n        ref = other, other = ref[0], cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv6') {\n        throw new Error(\"ipaddr: cannot match ipv6 address with non-ipv6 one\");\n      }\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    };\n\n    IPv6.prototype.SpecialRanges = {\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    };\n\n    IPv6.prototype.range = function() {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    IPv6.prototype.isIPv4MappedAddress = function() {\n      return this.range() === 'ipv4Mapped';\n    };\n\n    IPv6.prototype.toIPv4Address = function() {\n      var high, low, ref;\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error(\"ipaddr: trying to convert a generic ipv6 address to ipv4\");\n      }\n      ref = this.parts.slice(-2), high = ref[0], low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    };\n\n    IPv6.prototype.prefixLengthFromSubnetMask = function() {\n      var cidr, i, k, part, stop, zeros, zerotable;\n      zerotable = {\n        0: 16,\n        32768: 15,\n        49152: 14,\n        57344: 13,\n        61440: 12,\n        63488: 11,\n        64512: 10,\n        65024: 9,\n        65280: 8,\n        65408: 7,\n        65472: 6,\n        65504: 5,\n        65520: 4,\n        65528: 3,\n        65532: 2,\n        65534: 1,\n        65535: 0\n      };\n      cidr = 0;\n      stop = false;\n      for (i = k = 7; k >= 0; i = k += -1) {\n        part = this.parts[i];\n        if (part in zerotable) {\n          zeros = zerotable[part];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 16) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 128 - cidr;\n    };\n\n    return IPv6;\n\n  })();\n\n  ipv6Part = \"(?:[0-9a-f]+::?)+\";\n\n  zoneIndex = \"%[0-9a-z]{1,}\";\n\n  ipv6Regexes = {\n    zoneIndex: new RegExp(zoneIndex, 'i'),\n    \"native\": new RegExp(\"^(::)?(\" + ipv6Part + \")?([0-9a-f]+)?(::)?(\" + zoneIndex + \")?$\", 'i'),\n    transitional: new RegExp((\"^((?:\" + ipv6Part + \")|(?:::)(?:\" + ipv6Part + \")?)\") + (ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part + \"\\\\.\" + ipv4Part) + (\"(\" + zoneIndex + \")?$\"), 'i')\n  };\n\n  expandIPv6 = function(string, parts) {\n    var colonCount, lastColon, part, replacement, replacementCount, zoneId;\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];\n    if (zoneId) {\n      zoneId = zoneId.substring(1);\n      string = string.replace(/%.+$/, '');\n    }\n    colonCount = 0;\n    lastColon = -1;\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    }\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    }\n    if (colonCount > parts) {\n      return null;\n    }\n    replacementCount = parts - colonCount;\n    replacement = ':';\n    while (replacementCount--) {\n      replacement += '0:';\n    }\n    string = string.replace('::', replacement);\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n    parts = (function() {\n      var k, len, ref, results;\n      ref = string.split(\":\");\n      results = [];\n      for (k = 0, len = ref.length; k < len; k++) {\n        part = ref[k];\n        results.push(parseInt(part, 16));\n      }\n      return results;\n    })();\n    return {\n      parts: parts,\n      zoneId: zoneId\n    };\n  };\n\n  ipaddr.IPv6.parser = function(string) {\n    var addr, k, len, match, octet, octets, zoneId;\n    if (ipv6Regexes['native'].test(string)) {\n      return expandIPv6(string, 8);\n    } else if (match = string.match(ipv6Regexes['transitional'])) {\n      zoneId = match[6] || '';\n      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);\n      if (addr.parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n        for (k = 0, len = octets.length; k < len; k++) {\n          octet = octets[k];\n          if (!((0 <= octet && octet <= 255))) {\n            return null;\n          }\n        }\n        addr.parts.push(octets[0] << 8 | octets[1]);\n        addr.parts.push(octets[2] << 8 | octets[3]);\n        return {\n          parts: addr.parts,\n          zoneId: addr.zoneId\n        };\n      }\n    }\n    return null;\n  };\n\n  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {\n    return this.parser(string) !== null;\n  };\n\n  ipaddr.IPv4.isValid = function(string) {\n    var e;\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (error1) {\n      e = error1;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.isValidFourPartDecimal = function(string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  ipaddr.IPv6.isValid = function(string) {\n    var addr, e;\n    if (typeof string === \"string\" && string.indexOf(\":\") === -1) {\n      return false;\n    }\n    try {\n      addr = this.parser(string);\n      new this(addr.parts, addr.zoneId);\n      return true;\n    } catch (error1) {\n      e = error1;\n      return false;\n    }\n  };\n\n  ipaddr.IPv4.parse = function(string) {\n    var parts;\n    parts = this.parser(string);\n    if (parts === null) {\n      throw new Error(\"ipaddr: string is not formatted like ip address\");\n    }\n    return new this(parts);\n  };\n\n  ipaddr.IPv6.parse = function(string) {\n    var addr;\n    addr = this.parser(string);\n    if (addr.parts === null) {\n      throw new Error(\"ipaddr: string is not formatted like ip address\");\n    }\n    return new this(addr.parts, addr.zoneId);\n  };\n\n  ipaddr.IPv4.parseCIDR = function(string) {\n    var maskLength, match, parsed;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 32) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function() {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv4 CIDR range\");\n  };\n\n  ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {\n    var filledOctetCount, j, octets;\n    prefix = parseInt(prefix);\n    if (prefix < 0 || prefix > 32) {\n      throw new Error('ipaddr: invalid IPv4 prefix length');\n    }\n    octets = [0, 0, 0, 0];\n    j = 0;\n    filledOctetCount = Math.floor(prefix / 8);\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n    if (filledOctetCount < 4) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n    }\n    return new this(octets);\n  };\n\n  ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {\n    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n      return new this(octets);\n    } catch (error1) {\n      error = error1;\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  ipaddr.IPv4.networkAddressFromCIDR = function(string) {\n    var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n      return new this(octets);\n    } catch (error1) {\n      error = error1;\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  ipaddr.IPv6.parseCIDR = function(string) {\n    var maskLength, match, parsed;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 128) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function() {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error(\"ipaddr: string is not formatted like an IPv6 CIDR range\");\n  };\n\n  ipaddr.isValid = function(string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  };\n\n  ipaddr.parse = function(string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 format\");\n    }\n  };\n\n  ipaddr.parseCIDR = function(string) {\n    var e;\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (error1) {\n      e = error1;\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (error1) {\n        e = error1;\n        throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 CIDR format\");\n      }\n    }\n  };\n\n  ipaddr.fromByteArray = function(bytes) {\n    var length;\n    length = bytes.length;\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error(\"ipaddr: the binary input is neither an IPv6 nor IPv4 address\");\n    }\n  };\n\n  ipaddr.process = function(string) {\n    var addr;\n    addr = this.parse(string);\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  };\n\n}).call(this);\n","/*\r\n Copyright 2013 Daniel Wirtz <dcode@dcode.io>\r\n Copyright 2009 The Closure Library Authors. All Rights Reserved.\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n */\r\n\r\n/**\r\n * @license Long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/Long.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (typeof define === 'function' && define[\"amd\"])\r\n        define([], factory);\r\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === \"object\" && module && module[\"exports\"])\r\n        module[\"exports\"] = factory();\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"Long\"] = factory();\r\n\r\n})(this, function() {\r\n    \"use strict\";\r\n\r\n    /**\r\n     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n     *  See the from* functions below for more convenient ways of constructing Longs.\r\n     * @exports Long\r\n     * @class A Long class for representing a 64 bit two's-complement integer value.\r\n     * @param {number} low The low (signed) 32 bits of the long\r\n     * @param {number} high The high (signed) 32 bits of the long\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @constructor\r\n     */\r\n    function Long(low, high, unsigned) {\r\n\r\n        /**\r\n         * The low 32 bits as a signed value.\r\n         * @type {number}\r\n         * @expose\r\n         */\r\n        this.low = low|0;\r\n\r\n        /**\r\n         * The high 32 bits as a signed value.\r\n         * @type {number}\r\n         * @expose\r\n         */\r\n        this.high = high|0;\r\n\r\n        /**\r\n         * Whether unsigned or not.\r\n         * @type {boolean}\r\n         * @expose\r\n         */\r\n        this.unsigned = !!unsigned;\r\n    }\r\n\r\n    // The internal representation of a long is the two given signed, 32-bit values.\r\n    // We use 32-bit pieces because these are the size of integers on which\r\n    // Javascript performs bit-operations.  For operations like addition and\r\n    // multiplication, we split each number into 16 bit pieces, which can easily be\r\n    // multiplied within Javascript's floating-point representation without overflow\r\n    // or change in sign.\r\n    //\r\n    // In the algorithms below, we frequently reduce the negative case to the\r\n    // positive case by negating the input(s) and then post-processing the result.\r\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n    // a positive number, it overflows back into a negative).  Not handling this\r\n    // case would often result in infinite recursion.\r\n    //\r\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n    // methods on which they depend.\r\n\r\n    /**\r\n     * An indicator used to reliably determine if an object is a Long or not.\r\n     * @type {boolean}\r\n     * @const\r\n     * @expose\r\n     * @private\r\n     */\r\n    Long.__isLong__;\r\n\r\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\r\n        value: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    /**\r\n     * Tests if the specified object is a Long.\r\n     * @param {*} obj Object\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.isLong = function isLong(obj) {\r\n        return (obj && obj[\"__isLong__\"]) === true;\r\n    };\r\n\r\n    /**\r\n     * A cache of the Long representations of small integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var INT_CACHE = {};\r\n\r\n    /**\r\n     * A cache of the Long representations of small unsigned integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var UINT_CACHE = {};\r\n\r\n    /**\r\n     * Returns a Long representing the given 32 bit integer value.\r\n     * @param {number} value The 32 bit integer in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     * @expose\r\n     */\r\n    Long.fromInt = function fromInt(value, unsigned) {\r\n        var obj, cachedObj;\r\n        if (!unsigned) {\r\n            value = value | 0;\r\n            if (-128 <= value && value < 128) {\r\n                cachedObj = INT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = new Long(value, value < 0 ? -1 : 0, false);\r\n            if (-128 <= value && value < 128)\r\n                INT_CACHE[value] = obj;\r\n            return obj;\r\n        } else {\r\n            value = value >>> 0;\r\n            if (0 <= value && value < 256) {\r\n                cachedObj = UINT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = new Long(value, (value | 0) < 0 ? -1 : 0, true);\r\n            if (0 <= value && value < 256)\r\n                UINT_CACHE[value] = obj;\r\n            return obj;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n     * @param {number} value The number in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     * @expose\r\n     */\r\n    Long.fromNumber = function fromNumber(value, unsigned) {\r\n        unsigned = !!unsigned;\r\n        if (isNaN(value) || !isFinite(value))\r\n            return Long.ZERO;\r\n        if (!unsigned && value <= -TWO_PWR_63_DBL)\r\n            return Long.MIN_VALUE;\r\n        if (!unsigned && value + 1 >= TWO_PWR_63_DBL)\r\n            return Long.MAX_VALUE;\r\n        if (unsigned && value >= TWO_PWR_64_DBL)\r\n            return Long.MAX_UNSIGNED_VALUE;\r\n        if (value < 0)\r\n            return Long.fromNumber(-value, unsigned).negate();\r\n        return new Long((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n     *  assumed to use 32 bits.\r\n     * @param {number} lowBits The low 32 bits\r\n     * @param {number} highBits The high 32 bits\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     * @expose\r\n     */\r\n    Long.fromBits = function fromBits(lowBits, highBits, unsigned) {\r\n        return new Long(lowBits, highBits, unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns a Long representation of the given string, written using the specified radix.\r\n     * @param {string} str The textual representation of the Long\r\n     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n     * @returns {!Long} The corresponding Long value\r\n     * @expose\r\n     */\r\n    Long.fromString = function fromString(str, unsigned, radix) {\r\n        if (str.length === 0)\r\n            throw Error('number format error: empty string');\r\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n            return Long.ZERO;\r\n        if (typeof unsigned === 'number') // For goog.math.long compatibility\r\n            radix = unsigned,\r\n            unsigned = false;\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw Error('radix out of range: ' + radix);\r\n\r\n        var p;\r\n        if ((p = str.indexOf('-')) > 0)\r\n            throw Error('number format error: interior \"-\" character: ' + str);\r\n        else if (p === 0)\r\n            return Long.fromString(str.substring(1), unsigned, radix).negate();\r\n\r\n        // Do several (8) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = Long.fromNumber(Math.pow(radix, 8));\r\n\r\n        var result = Long.ZERO;\r\n        for (var i = 0; i < str.length; i += 8) {\r\n            var size = Math.min(8, str.length - i);\r\n            var value = parseInt(str.substring(i, i + size), radix);\r\n            if (size < 8) {\r\n                var power = Long.fromNumber(Math.pow(radix, size));\r\n                result = result.multiply(power).add(Long.fromNumber(value));\r\n            } else {\r\n                result = result.multiply(radixToPower);\r\n                result = result.add(Long.fromNumber(value));\r\n            }\r\n        }\r\n        result.unsigned = unsigned;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Converts the specified value to a Long.\r\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n     * @returns {!Long}\r\n     * @expose\r\n     */\r\n    Long.fromValue = function fromValue(val) {\r\n        if (val /* is compatible */ instanceof Long)\r\n            return val;\r\n        if (typeof val === 'number')\r\n            return Long.fromNumber(val);\r\n        if (typeof val === 'string')\r\n            return Long.fromString(val);\r\n        // Throws for non-objects, converts non-instanceof Long:\r\n        return new Long(val.low, val.high, val.unsigned);\r\n    };\r\n\r\n    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n    // no runtime penalty for these.\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_16_DBL = 1 << 16;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24_DBL = 1 << 24;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\r\n\r\n    /**\r\n     * Signed zero.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.ZERO = Long.fromInt(0);\r\n\r\n    /**\r\n     * Unsigned zero.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.UZERO = Long.fromInt(0, true);\r\n\r\n    /**\r\n     * Signed one.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.ONE = Long.fromInt(1);\r\n\r\n    /**\r\n     * Unsigned one.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.UONE = Long.fromInt(1, true);\r\n\r\n    /**\r\n     * Signed negative one.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.NEG_ONE = Long.fromInt(-1);\r\n\r\n    /**\r\n     * Maximum signed value.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.MAX_VALUE = Long.fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n    /**\r\n     * Maximum unsigned value.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n    /**\r\n     * Minimum signed value.\r\n     * @type {!Long}\r\n     * @expose\r\n     */\r\n    Long.MIN_VALUE = Long.fromBits(0, 0x80000000|0, false);\r\n\r\n    /**\r\n     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    Long.prototype.toInt = function toInt() {\r\n        return this.unsigned ? this.low >>> 0 : this.low;\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    Long.prototype.toNumber = function toNumber() {\r\n        if (this.unsigned) {\r\n            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n        }\r\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a string written in the specified radix.\r\n     * @param {number=} radix Radix (2-36), defaults to 10\r\n     * @returns {string}\r\n     * @override\r\n     * @throws {RangeError} If `radix` is out of range\r\n     * @expose\r\n     */\r\n    Long.prototype.toString = function toString(radix) {\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix out of range: ' + radix);\r\n        if (this.isZero())\r\n            return '0';\r\n        var rem;\r\n        if (this.isNegative()) { // Unsigned Longs are never negative\r\n            if (this.equals(Long.MIN_VALUE)) {\r\n                // We need to change the Long value before it can be negated, so we remove\r\n                // the bottom-most digit in this base and then recurse to do the rest.\r\n                var radixLong = Long.fromNumber(radix);\r\n                var div = this.divide(radixLong);\r\n                rem = div.multiply(radixLong).subtract(this);\r\n                return div.toString(radix) + rem.toInt().toString(radix);\r\n            } else\r\n                return '-' + this.negate().toString(radix);\r\n        }\r\n\r\n        // Do several (6) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\r\n        rem = this;\r\n        var result = '';\r\n        while (true) {\r\n            var remDiv = rem.divide(radixToPower),\r\n                intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0,\r\n                digits = intval.toString(radix);\r\n            rem = remDiv;\r\n            if (rem.isZero())\r\n                return digits + result;\r\n            else {\r\n                while (digits.length < 6)\r\n                    digits = '0' + digits;\r\n                result = '' + digits + result;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as a signed integer.\r\n     * @returns {number} Signed high bits\r\n     * @expose\r\n     */\r\n    Long.prototype.getHighBits = function getHighBits() {\r\n        return this.high;\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned high bits\r\n     * @expose\r\n     */\r\n    Long.prototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n        return this.high >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as a signed integer.\r\n     * @returns {number} Signed low bits\r\n     * @expose\r\n     */\r\n    Long.prototype.getLowBits = function getLowBits() {\r\n        return this.low;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned low bits\r\n     * @expose\r\n     */\r\n    Long.prototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n        return this.low >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the number of bits needed to represent the absolute value of this Long.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    Long.prototype.getNumBitsAbs = function getNumBitsAbs() {\r\n        if (this.isNegative()) // Unsigned Longs are never negative\r\n            return this.equals(Long.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();\r\n        var val = this.high != 0 ? this.high : this.low;\r\n        for (var bit = 31; bit > 0; bit--)\r\n            if ((val & (1 << bit)) != 0)\r\n                break;\r\n        return this.high != 0 ? bit + 33 : bit + 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals zero.\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.isZero = function isZero() {\r\n        return this.high === 0 && this.low === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is negative.\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.isNegative = function isNegative() {\r\n        return !this.unsigned && this.high < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is positive.\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.isPositive = function isPositive() {\r\n        return this.unsigned || this.high >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is odd.\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.isOdd = function isOdd() {\r\n        return (this.low & 1) === 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is even.\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.isEven = function isEven() {\r\n        return (this.low & 1) === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.equals = function equals(other) {\r\n        if (!Long.isLong(other))\r\n            other = Long.fromValue(other);\r\n        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n            return false;\r\n        return this.high === other.high && this.low === other.low;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.eq = Long.prototype.equals;\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.notEquals = function notEquals(other) {\r\n        return !this.equals(/* validates */ other);\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.neq = Long.prototype.notEquals;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.lessThan = function lessThan(other) {\r\n        return this.compare(/* validates */ other) < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.lt = Long.prototype.lessThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n        return this.compare(/* validates */ other) <= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.lte = Long.prototype.lessThanOrEqual;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.greaterThan = function greaterThan(other) {\r\n        return this.compare(/* validates */ other) > 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.gt = Long.prototype.greaterThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n        return this.compare(/* validates */ other) >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     * @expose\r\n     */\r\n    Long.prototype.gte = Long.prototype.greaterThanOrEqual;\r\n\r\n    /**\r\n     * Compares this Long's value with the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n     *  if the given one is greater\r\n     * @expose\r\n     */\r\n    Long.prototype.compare = function compare(other) {\r\n        if (!Long.isLong(other))\r\n            other = Long.fromValue(other);\r\n        if (this.equals(other))\r\n            return 0;\r\n        var thisNeg = this.isNegative(),\r\n            otherNeg = other.isNegative();\r\n        if (thisNeg && !otherNeg)\r\n            return -1;\r\n        if (!thisNeg && otherNeg)\r\n            return 1;\r\n        // At this point the sign bits are the same\r\n        if (!this.unsigned)\r\n            return this.subtract(other).isNegative() ? -1 : 1;\r\n        // Both are positive if at least one is unsigned\r\n        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n    };\r\n\r\n    /**\r\n     * Negates this Long's value.\r\n     * @returns {!Long} Negated Long\r\n     * @expose\r\n     */\r\n    Long.prototype.negate = function negate() {\r\n        if (!this.unsigned && this.equals(Long.MIN_VALUE))\r\n            return Long.MIN_VALUE;\r\n        return this.not().add(Long.ONE);\r\n    };\r\n\r\n    /**\r\n     * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n     * @function\r\n     * @returns {!Long} Negated Long\r\n     * @expose\r\n     */\r\n    Long.prototype.neg = Long.prototype.negate;\r\n\r\n    /**\r\n     * Returns the sum of this and the specified Long.\r\n     * @param {!Long|number|string} addend Addend\r\n     * @returns {!Long} Sum\r\n     * @expose\r\n     */\r\n    Long.prototype.add = function add(addend) {\r\n        if (!Long.isLong(addend))\r\n            addend = Long.fromValue(addend);\r\n\r\n        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = addend.high >>> 16;\r\n        var b32 = addend.high & 0xFFFF;\r\n        var b16 = addend.low >>> 16;\r\n        var b00 = addend.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 + b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 + b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 + b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 + b48;\r\n        c48 &= 0xFFFF;\r\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long.\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     * @expose\r\n     */\r\n    Long.prototype.subtract = function subtract(subtrahend) {\r\n        if (!Long.isLong(subtrahend))\r\n            subtrahend = Long.fromValue(subtrahend);\r\n        return this.add(subtrahend.negate());\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n     * @function\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     * @expose\r\n     */\r\n    Long.prototype.sub = Long.prototype.subtract;\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long.\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     * @expose\r\n     */\r\n    Long.prototype.multiply = function multiply(multiplier) {\r\n        if (this.isZero())\r\n            return Long.ZERO;\r\n        if (!Long.isLong(multiplier))\r\n            multiplier = Long.fromValue(multiplier);\r\n        if (multiplier.isZero())\r\n            return Long.ZERO;\r\n        if (this.equals(Long.MIN_VALUE))\r\n            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\r\n        if (multiplier.equals(Long.MIN_VALUE))\r\n            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\r\n\r\n        if (this.isNegative()) {\r\n            if (multiplier.isNegative())\r\n                return this.negate().multiply(multiplier.negate());\r\n            else\r\n                return this.negate().multiply(multiplier).negate();\r\n        } else if (multiplier.isNegative())\r\n            return this.multiply(multiplier.negate()).negate();\r\n\r\n        // If both longs are small, use float multiplication\r\n        if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24))\r\n            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n        // We can skip products that would overflow.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = multiplier.high >>> 16;\r\n        var b32 = multiplier.high & 0xFFFF;\r\n        var b16 = multiplier.low >>> 16;\r\n        var b00 = multiplier.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 * b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 * b00;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c16 += a00 * b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 * b00;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a16 * b16;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a00 * b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n        c48 &= 0xFFFF;\r\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n     * @function\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     * @expose\r\n     */\r\n    Long.prototype.mul = Long.prototype.multiply;\r\n\r\n    /**\r\n     * Returns this Long divided by the specified.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     * @expose\r\n     */\r\n    Long.prototype.divide = function divide(divisor) {\r\n        if (!Long.isLong(divisor))\r\n            divisor = Long.fromValue(divisor);\r\n        if (divisor.isZero())\r\n            throw(new Error('division by zero'));\r\n        if (this.isZero())\r\n            return this.unsigned ? Long.UZERO : Long.ZERO;\r\n        var approx, rem, res;\r\n        if (this.equals(Long.MIN_VALUE)) {\r\n            if (divisor.equals(Long.ONE) || divisor.equals(Long.NEG_ONE))\r\n                return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.equals(Long.MIN_VALUE))\r\n                return Long.ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shiftRight(1);\r\n                approx = halfThis.divide(divisor).shiftLeft(1);\r\n                if (approx.equals(Long.ZERO)) {\r\n                    return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\r\n                } else {\r\n                    rem = this.subtract(divisor.multiply(approx));\r\n                    res = approx.add(rem.divide(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.equals(Long.MIN_VALUE))\r\n            return this.unsigned ? Long.UZERO : Long.ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.negate().divide(divisor.negate());\r\n            return this.negate().divide(divisor).negate();\r\n        } else if (divisor.isNegative())\r\n            return this.divide(divisor.negate()).negate();\r\n\r\n        // Repeat the following until the remainder is less than other:  find a\r\n        // floating-point that approximates remainder / other *from below*, add this\r\n        // into the result, and subtract it from the remainder.  It is critical that\r\n        // the approximate value is less than or equal to the real value so that the\r\n        // remainder never becomes negative.\r\n        res = Long.ZERO;\r\n        rem = this;\r\n        while (rem.greaterThanOrEqual(divisor)) {\r\n            // Approximate the result of division. This may be a little greater or\r\n            // smaller than the actual value.\r\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n            // We will tweak the approximate result by changing it in the 48-th digit or\r\n            // the smallest non-fractional digit, whichever is larger.\r\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n                delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48),\r\n\r\n            // Decrease the approximation until it is smaller than the remainder.  Note\r\n            // that if it is too large, the product overflows and is negative.\r\n                approxRes = Long.fromNumber(approx),\r\n                approxRem = approxRes.multiply(divisor);\r\n            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\r\n                approx -= delta;\r\n                approxRes = Long.fromNumber(approx, this.unsigned);\r\n                approxRem = approxRes.multiply(divisor);\r\n            }\r\n\r\n            // We know the answer can't be zero... and actually, zero would cause\r\n            // infinite recursion since we would make no progress.\r\n            if (approxRes.isZero())\r\n                approxRes = Long.ONE;\r\n\r\n            res = res.add(approxRes);\r\n            rem = rem.subtract(approxRem);\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /**\r\n     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     * @expose\r\n     */\r\n    Long.prototype.div = Long.prototype.divide;\r\n\r\n    /**\r\n     * Returns this Long modulo the specified.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     * @expose\r\n     */\r\n    Long.prototype.modulo = function modulo(divisor) {\r\n        if (!Long.isLong(divisor))\r\n            divisor = Long.fromValue(divisor);\r\n        return this.subtract(this.divide(divisor).multiply(divisor));\r\n    };\r\n\r\n    /**\r\n     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     * @expose\r\n     */\r\n    Long.prototype.mod = Long.prototype.modulo;\r\n\r\n    /**\r\n     * Returns the bitwise NOT of this Long.\r\n     * @returns {!Long}\r\n     * @expose\r\n     */\r\n    Long.prototype.not = function not() {\r\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise AND of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     * @expose\r\n     */\r\n    Long.prototype.and = function and(other) {\r\n        if (!Long.isLong(other))\r\n            other = Long.fromValue(other);\r\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise OR of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     * @expose\r\n     */\r\n    Long.prototype.or = function or(other) {\r\n        if (!Long.isLong(other))\r\n            other = Long.fromValue(other);\r\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise XOR of this Long and the given one.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     * @expose\r\n     */\r\n    Long.prototype.xor = function xor(other) {\r\n        if (!Long.isLong(other))\r\n            other = Long.fromValue(other);\r\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     * @expose\r\n     */\r\n    Long.prototype.shiftLeft = function shiftLeft(numBits) {\r\n        if (Long.isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n        else\r\n            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     * @expose\r\n     */\r\n    Long.prototype.shl = Long.prototype.shiftLeft;\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     * @expose\r\n     */\r\n    Long.prototype.shiftRight = function shiftRight(numBits) {\r\n        if (Long.isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n        else\r\n            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     * @expose\r\n     */\r\n    Long.prototype.shr = Long.prototype.shiftRight;\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     * @expose\r\n     */\r\n    Long.prototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n        if (Long.isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits &= 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else {\r\n            var high = this.high;\r\n            if (numBits < 32) {\r\n                var low = this.low;\r\n                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n            } else if (numBits === 32)\r\n                return Long.fromBits(high, 0, this.unsigned);\r\n            else\r\n                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     * @expose\r\n     */\r\n    Long.prototype.shru = Long.prototype.shiftRightUnsigned;\r\n\r\n    /**\r\n     * Converts this Long to signed.\r\n     * @returns {!Long} Signed long\r\n     * @expose\r\n     */\r\n    Long.prototype.toSigned = function toSigned() {\r\n        if (!this.unsigned)\r\n            return this;\r\n        return new Long(this.low, this.high, false);\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to unsigned.\r\n     * @returns {!Long} Unsigned long\r\n     * @expose\r\n     */\r\n    Long.prototype.toUnsigned = function toUnsigned() {\r\n        if (this.unsigned)\r\n            return this;\r\n        return new Long(this.low, this.high, true);\r\n    };\r\n\r\n    return Long;\r\n});\r\n","/*!\n * media-typer\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 2616 sec 3.7\n *\n * parameter     = token \"=\" ( token | quoted-string )\n * token         = 1*<any CHAR except CTLs or separators>\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *               | \"{\" | \"}\" | SP | HT\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n * qdtext        = <any TEXT except <\">>\n * quoted-pair   = \"\\\" CHAR\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\n * TEXT          = <any OCTET except CTLs, but including LWS>\n * LWS           = [CRLF] 1*( SP | HT )\n * CRLF          = CR LF\n * CR            = <US-ASCII CR, carriage return (13)>\n * LF            = <US-ASCII LF, linefeed (10)>\n * SP            = <US-ASCII SP, space (32)>\n * SHT           = <US-ASCII HT, horizontal-tab (9)>\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n * OCTET         = <any 8-bit sequence of data>\n */\nvar paramRegExp = /; *([!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) *= *(\"(?:[ !\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u0020-\\u007e])*\"|[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) */g;\nvar textRegExp = /^[\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar tokenRegExp = /^[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 2616\n *\n * quoted-pair = \"\\\" CHAR\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\n */\nvar qescRegExp = /\\\\([\\u0000-\\u007f])/g;\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 2616\n */\nvar quoteRegExp = /([\\\\\"])/g;\n\n/**\n * RegExp to match type in RFC 6838\n *\n * type-name = restricted-name\n * subtype-name = restricted-name\n * restricted-name = restricted-name-first *126restricted-name-chars\n * restricted-name-first  = ALPHA / DIGIT\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\n * restricted-name-chars =/ \".\" ; Characters before first dot always\n *                              ; specify a facet name\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\n *                              ; specify a structured syntax suffix\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\n * DIGIT =  %x30-39             ; 0-9\n */\nvar subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/\nvar typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/\nvar typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;\n\n/**\n * Module exports.\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @api public\n */\n\nfunction format(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var subtype = obj.subtype\n  var suffix = obj.suffix\n  var type = obj.type\n\n  if (!type || !typeNameRegExp.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  if (!subtype || !subtypeNameRegExp.test(subtype)) {\n    throw new TypeError('invalid subtype')\n  }\n\n  // format as type/subtype\n  var string = type + '/' + subtype\n\n  // append +suffix\n  if (suffix) {\n    if (!typeNameRegExp.test(suffix)) {\n      throw new TypeError('invalid suffix')\n    }\n\n    string += '+' + suffix\n  }\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!tokenRegExp.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @api public\n */\n\nfunction parse(string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  if (typeof string === 'object') {\n    string = getcontenttype(string)\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = string.indexOf(';')\n  var type = index !== -1\n    ? string.substr(0, index)\n    : string\n\n  var key\n  var match\n  var obj = splitType(type)\n  var params = {}\n  var value\n\n  paramRegExp.lastIndex = index\n\n  while (match = paramRegExp.exec(string)) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(qescRegExp, '$1')\n    }\n\n    params[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  obj.parameters = params\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @api private\n */\n\nfunction getcontenttype(obj) {\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    return obj.getHeader('content-type')\n  }\n\n  if (typeof obj.headers === 'object') {\n    // req-like\n    return obj.headers && obj.headers['content-type']\n  }\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @api private\n */\n\nfunction qstring(val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (tokenRegExp.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !textRegExp.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(quoteRegExp, '\\\\$1') + '\"'\n}\n\n/**\n * Simply \"type/subtype+siffx\" into parts.\n *\n * @param {string} string\n * @return {Object}\n * @api private\n */\n\nfunction splitType(string) {\n  var match = typeRegExp.exec(string.toLowerCase())\n\n  if (!match) {\n    throw new TypeError('invalid media type')\n  }\n\n  var type = match[1]\n  var subtype = match[2]\n  var suffix\n\n  // suffix after last +\n  var index = subtype.lastIndexOf('+')\n  if (index !== -1) {\n    suffix = subtype.substr(index + 1)\n    subtype = subtype.substr(0, index)\n  }\n\n  var obj = {\n    type: type,\n    subtype: subtype,\n    suffix: suffix\n  }\n\n  return obj\n}\n","/*!\n * merge-descriptors\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = merge\n\n/**\n * Module variables.\n * @private\n */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * Merge the property descriptors of `src` into `dest`\n *\n * @param {object} dest Object to add descriptors to\n * @param {object} src Object to clone descriptors from\n * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties\n * @returns {object} Reference to dest\n * @public\n */\n\nfunction merge(dest, src, redefine) {\n  if (!dest) {\n    throw new TypeError('argument dest is required')\n  }\n\n  if (!src) {\n    throw new TypeError('argument src is required')\n  }\n\n  if (redefine === undefined) {\n    // Default to true\n    redefine = true\n  }\n\n  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {\n    if (!redefine && hasOwnProperty.call(dest, name)) {\n      // Skip desriptor\n      return\n    }\n\n    // Copy descriptor\n    var descriptor = Object.getOwnPropertyDescriptor(src, name)\n    Object.defineProperty(dest, name, descriptor)\n  })\n\n  return dest\n}\n","/*!\n * methods\n * Copyright(c) 2013-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar http = require('http');\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getCurrentNodeMethods() || getBasicNodeMethods();\n\n/**\n * Get the current Node.js methods.\n * @private\n */\n\nfunction getCurrentNodeMethods() {\n  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {\n    return method.toLowerCase();\n  });\n}\n\n/**\n * Get the \"basic\" Node.js methods, a snapshot from Node.js 0.10.\n * @private\n */\n\nfunction getBasicNodeMethods() {\n  return [\n    'get',\n    'post',\n    'put',\n    'head',\n    'delete',\n    'options',\n    'trace',\n    'copy',\n    'lock',\n    'mkcol',\n    'move',\n    'purge',\n    'propfind',\n    'proppatch',\n    'unlock',\n    'report',\n    'mkactivity',\n    'checkout',\n    'merge',\n    'm-search',\n    'notify',\n    'subscribe',\n    'unsubscribe',\n    'patch',\n    'search',\n    'connect'\n  ];\n}\n","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","var path = require('path');\nvar fs = require('fs');\n\nfunction Mime() {\n  // Map of extension -> mime type\n  this.types = Object.create(null);\n\n  // Map of mime type -> extension\n  this.extensions = Object.create(null);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * @param map (Object) type definitions\n */\nMime.prototype.define = function (map) {\n  for (var type in map) {\n    var exts = map[type];\n    for (var i = 0; i < exts.length; i++) {\n      if (process.env.DEBUG_MIME && this.types[exts[i]]) {\n        console.warn((this._loading || \"define()\").replace(/.*\\//, ''), 'changes \"' + exts[i] + '\" extension type from ' +\n          this.types[exts[i]] + ' to ' + type);\n      }\n\n      this.types[exts[i]] = type;\n    }\n\n    // Default extension is the first one we encounter\n    if (!this.extensions[type]) {\n      this.extensions[type] = exts[0];\n    }\n  }\n};\n\n/**\n * Load an Apache2-style \".types\" file\n *\n * This may be called multiple times (it's expected).  Where files declare\n * overlapping types/extensions, the last file wins.\n *\n * @param file (String) path of file to load.\n */\nMime.prototype.load = function(file) {\n  this._loading = file;\n  // Read file and split into lines\n  var map = {},\n      content = fs.readFileSync(file, 'ascii'),\n      lines = content.split(/[\\r\\n]+/);\n\n  lines.forEach(function(line) {\n    // Clean up whitespace/comments, and split into fields\n    var fields = line.replace(/\\s*#.*|^\\s*|\\s*$/g, '').split(/\\s+/);\n    map[fields.shift()] = fields;\n  });\n\n  this.define(map);\n\n  this._loading = null;\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.lookup = function(path, fallback) {\n  var ext = path.replace(/^.*[\\.\\/\\\\]/, '').toLowerCase();\n\n  return this.types[ext] || fallback || this.default_type;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.extension = function(mimeType) {\n  var type = mimeType.match(/^\\s*([^;\\s]*)(?:;|\\s|$)/)[1].toLowerCase();\n  return this.extensions[type];\n};\n\n// Default instance\nvar mime = new Mime();\n\n// Define built-in types\nmime.define(require('./types.json'));\n\n// Default type\nmime.default_type = mime.lookup('bin');\n\n//\n// Additional API specific to the default instance\n//\n\nmime.Mime = Mime;\n\n/**\n * Lookup a charset based on mime type.\n */\nmime.charsets = {\n  lookup: function(mimeType, fallback) {\n    // Assume text types are utf8\n    return (/^text\\/|^application\\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;\n  }\n};\n\nmodule.exports = mime;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/*!\n * negotiator\n * Copyright(c) 2012 Federico Romero\n * Copyright(c) 2012-2014 Isaac Z. Schlueter\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Cached loaded submodules.\n * @private\n */\n\nvar modules = Object.create(null);\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Negotiator;\nmodule.exports.Negotiator = Negotiator;\n\n/**\n * Create a Negotiator instance from a request.\n * @param {object} request\n * @public\n */\n\nfunction Negotiator(request) {\n  if (!(this instanceof Negotiator)) {\n    return new Negotiator(request);\n  }\n\n  this.request = request;\n}\n\nNegotiator.prototype.charset = function charset(available) {\n  var set = this.charsets(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.charsets = function charsets(available) {\n  var preferredCharsets = loadModule('charset').preferredCharsets;\n  return preferredCharsets(this.request.headers['accept-charset'], available);\n};\n\nNegotiator.prototype.encoding = function encoding(available) {\n  var set = this.encodings(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.encodings = function encodings(available) {\n  var preferredEncodings = loadModule('encoding').preferredEncodings;\n  return preferredEncodings(this.request.headers['accept-encoding'], available);\n};\n\nNegotiator.prototype.language = function language(available) {\n  var set = this.languages(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.languages = function languages(available) {\n  var preferredLanguages = loadModule('language').preferredLanguages;\n  return preferredLanguages(this.request.headers['accept-language'], available);\n};\n\nNegotiator.prototype.mediaType = function mediaType(available) {\n  var set = this.mediaTypes(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.mediaTypes = function mediaTypes(available) {\n  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;\n  return preferredMediaTypes(this.request.headers.accept, available);\n};\n\n// Backwards compatibility\nNegotiator.prototype.preferredCharset = Negotiator.prototype.charset;\nNegotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;\nNegotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;\nNegotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;\nNegotiator.prototype.preferredLanguage = Negotiator.prototype.language;\nNegotiator.prototype.preferredLanguages = Negotiator.prototype.languages;\nNegotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;\nNegotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;\n\n/**\n * Load the given module.\n * @private\n */\n\nfunction loadModule(moduleName) {\n  var module = modules[moduleName];\n\n  if (module !== undefined) {\n    return module;\n  }\n\n  // This uses a switch for static require analysis\n  switch (moduleName) {\n    case 'charset':\n      module = require('./lib/charset');\n      break;\n    case 'encoding':\n      module = require('./lib/encoding');\n      break;\n    case 'language':\n      module = require('./lib/language');\n      break;\n    case 'mediaType':\n      module = require('./lib/mediaType');\n      break;\n    default:\n      throw new Error('Cannot find module \\'' + moduleName + '\\'');\n  }\n\n  // Store to prevent invoking require()\n  modules[moduleName] = module;\n\n  return module;\n}\n","/**\n * negotiator\n * Copyright(c) 2012 Isaac Z. Schlueter\n * Copyright(c) 2014 Federico Romero\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = preferredCharsets;\nmodule.exports.preferredCharsets = preferredCharsets;\n\n/**\n * Module variables.\n * @private\n */\n\nvar simpleCharsetRegExp = /^\\s*([^\\s;]+)\\s*(?:;(.*))?$/;\n\n/**\n * Parse the Accept-Charset header.\n * @private\n */\n\nfunction parseAcceptCharset(accept) {\n  var accepts = accept.split(',');\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var charset = parseCharset(accepts[i].trim(), i);\n\n    if (charset) {\n      accepts[j++] = charset;\n    }\n  }\n\n  // trim accepts\n  accepts.length = j;\n\n  return accepts;\n}\n\n/**\n * Parse a charset from the Accept-Charset header.\n * @private\n */\n\nfunction parseCharset(str, i) {\n  var match = simpleCharsetRegExp.exec(str);\n  if (!match) return null;\n\n  var charset = match[1];\n  var q = 1;\n  if (match[2]) {\n    var params = match[2].split(';')\n    for (var j = 0; j < params.length; j++) {\n      var p = params[j].trim().split('=');\n      if (p[0] === 'q') {\n        q = parseFloat(p[1]);\n        break;\n      }\n    }\n  }\n\n  return {\n    charset: charset,\n    q: q,\n    i: i\n  };\n}\n\n/**\n * Get the priority of a charset.\n * @private\n */\n\nfunction getCharsetPriority(charset, accepted, index) {\n  var priority = {o: -1, q: 0, s: 0};\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(charset, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}\n\n/**\n * Get the specificity of the charset.\n * @private\n */\n\nfunction specify(charset, spec, index) {\n  var s = 0;\n  if(spec.charset.toLowerCase() === charset.toLowerCase()){\n    s |= 1;\n  } else if (spec.charset !== '*' ) {\n    return null\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s\n  }\n}\n\n/**\n * Get the preferred charsets from an Accept-Charset header.\n * @public\n */\n\nfunction preferredCharsets(accept, provided) {\n  // RFC 2616 sec 14.2: no header = *\n  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');\n\n  if (!provided) {\n    // sorted list of all charsets\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullCharset);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getCharsetPriority(type, accepts, index);\n  });\n\n  // sorted list of accepted charsets\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}\n\n/**\n * Compare two specs.\n * @private\n */\n\nfunction compareSpecs(a, b) {\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\n}\n\n/**\n * Get full charset string.\n * @private\n */\n\nfunction getFullCharset(spec) {\n  return spec.charset;\n}\n\n/**\n * Check if a spec has any quality.\n * @private\n */\n\nfunction isQuality(spec) {\n  return spec.q > 0;\n}\n","/**\n * negotiator\n * Copyright(c) 2012 Isaac Z. Schlueter\n * Copyright(c) 2014 Federico Romero\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = preferredEncodings;\nmodule.exports.preferredEncodings = preferredEncodings;\n\n/**\n * Module variables.\n * @private\n */\n\nvar simpleEncodingRegExp = /^\\s*([^\\s;]+)\\s*(?:;(.*))?$/;\n\n/**\n * Parse the Accept-Encoding header.\n * @private\n */\n\nfunction parseAcceptEncoding(accept) {\n  var accepts = accept.split(',');\n  var hasIdentity = false;\n  var minQuality = 1;\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var encoding = parseEncoding(accepts[i].trim(), i);\n\n    if (encoding) {\n      accepts[j++] = encoding;\n      hasIdentity = hasIdentity || specify('identity', encoding);\n      minQuality = Math.min(minQuality, encoding.q || 1);\n    }\n  }\n\n  if (!hasIdentity) {\n    /*\n     * If identity doesn't explicitly appear in the accept-encoding header,\n     * it's added to the list of acceptable encoding with the lowest q\n     */\n    accepts[j++] = {\n      encoding: 'identity',\n      q: minQuality,\n      i: i\n    };\n  }\n\n  // trim accepts\n  accepts.length = j;\n\n  return accepts;\n}\n\n/**\n * Parse an encoding from the Accept-Encoding header.\n * @private\n */\n\nfunction parseEncoding(str, i) {\n  var match = simpleEncodingRegExp.exec(str);\n  if (!match) return null;\n\n  var encoding = match[1];\n  var q = 1;\n  if (match[2]) {\n    var params = match[2].split(';');\n    for (var j = 0; j < params.length; j++) {\n      var p = params[j].trim().split('=');\n      if (p[0] === 'q') {\n        q = parseFloat(p[1]);\n        break;\n      }\n    }\n  }\n\n  return {\n    encoding: encoding,\n    q: q,\n    i: i\n  };\n}\n\n/**\n * Get the priority of an encoding.\n * @private\n */\n\nfunction getEncodingPriority(encoding, accepted, index) {\n  var priority = {o: -1, q: 0, s: 0};\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(encoding, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}\n\n/**\n * Get the specificity of the encoding.\n * @private\n */\n\nfunction specify(encoding, spec, index) {\n  var s = 0;\n  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){\n    s |= 1;\n  } else if (spec.encoding !== '*' ) {\n    return null\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s\n  }\n};\n\n/**\n * Get the preferred encodings from an Accept-Encoding header.\n * @public\n */\n\nfunction preferredEncodings(accept, provided) {\n  var accepts = parseAcceptEncoding(accept || '');\n\n  if (!provided) {\n    // sorted list of all encodings\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullEncoding);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getEncodingPriority(type, accepts, index);\n  });\n\n  // sorted list of accepted encodings\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}\n\n/**\n * Compare two specs.\n * @private\n */\n\nfunction compareSpecs(a, b) {\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\n}\n\n/**\n * Get full encoding string.\n * @private\n */\n\nfunction getFullEncoding(spec) {\n  return spec.encoding;\n}\n\n/**\n * Check if a spec has any quality.\n * @private\n */\n\nfunction isQuality(spec) {\n  return spec.q > 0;\n}\n","/**\n * negotiator\n * Copyright(c) 2012 Isaac Z. Schlueter\n * Copyright(c) 2014 Federico Romero\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = preferredLanguages;\nmodule.exports.preferredLanguages = preferredLanguages;\n\n/**\n * Module variables.\n * @private\n */\n\nvar simpleLanguageRegExp = /^\\s*([^\\s\\-;]+)(?:-([^\\s;]+))?\\s*(?:;(.*))?$/;\n\n/**\n * Parse the Accept-Language header.\n * @private\n */\n\nfunction parseAcceptLanguage(accept) {\n  var accepts = accept.split(',');\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var language = parseLanguage(accepts[i].trim(), i);\n\n    if (language) {\n      accepts[j++] = language;\n    }\n  }\n\n  // trim accepts\n  accepts.length = j;\n\n  return accepts;\n}\n\n/**\n * Parse a language from the Accept-Language header.\n * @private\n */\n\nfunction parseLanguage(str, i) {\n  var match = simpleLanguageRegExp.exec(str);\n  if (!match) return null;\n\n  var prefix = match[1],\n    suffix = match[2],\n    full = prefix;\n\n  if (suffix) full += \"-\" + suffix;\n\n  var q = 1;\n  if (match[3]) {\n    var params = match[3].split(';')\n    for (var j = 0; j < params.length; j++) {\n      var p = params[j].split('=');\n      if (p[0] === 'q') q = parseFloat(p[1]);\n    }\n  }\n\n  return {\n    prefix: prefix,\n    suffix: suffix,\n    q: q,\n    i: i,\n    full: full\n  };\n}\n\n/**\n * Get the priority of a language.\n * @private\n */\n\nfunction getLanguagePriority(language, accepted, index) {\n  var priority = {o: -1, q: 0, s: 0};\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(language, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}\n\n/**\n * Get the specificity of the language.\n * @private\n */\n\nfunction specify(language, spec, index) {\n  var p = parseLanguage(language)\n  if (!p) return null;\n  var s = 0;\n  if(spec.full.toLowerCase() === p.full.toLowerCase()){\n    s |= 4;\n  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {\n    s |= 2;\n  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {\n    s |= 1;\n  } else if (spec.full !== '*' ) {\n    return null\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s\n  }\n};\n\n/**\n * Get the preferred languages from an Accept-Language header.\n * @public\n */\n\nfunction preferredLanguages(accept, provided) {\n  // RFC 2616 sec 14.4: no header = *\n  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');\n\n  if (!provided) {\n    // sorted list of all languages\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullLanguage);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getLanguagePriority(type, accepts, index);\n  });\n\n  // sorted list of accepted languages\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}\n\n/**\n * Compare two specs.\n * @private\n */\n\nfunction compareSpecs(a, b) {\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\n}\n\n/**\n * Get full language string.\n * @private\n */\n\nfunction getFullLanguage(spec) {\n  return spec.full;\n}\n\n/**\n * Check if a spec has any quality.\n * @private\n */\n\nfunction isQuality(spec) {\n  return spec.q > 0;\n}\n","/**\n * negotiator\n * Copyright(c) 2012 Isaac Z. Schlueter\n * Copyright(c) 2014 Federico Romero\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = preferredMediaTypes;\nmodule.exports.preferredMediaTypes = preferredMediaTypes;\n\n/**\n * Module variables.\n * @private\n */\n\nvar simpleMediaTypeRegExp = /^\\s*([^\\s\\/;]+)\\/([^;\\s]+)\\s*(?:;(.*))?$/;\n\n/**\n * Parse the Accept header.\n * @private\n */\n\nfunction parseAccept(accept) {\n  var accepts = splitMediaTypes(accept);\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var mediaType = parseMediaType(accepts[i].trim(), i);\n\n    if (mediaType) {\n      accepts[j++] = mediaType;\n    }\n  }\n\n  // trim accepts\n  accepts.length = j;\n\n  return accepts;\n}\n\n/**\n * Parse a media type from the Accept header.\n * @private\n */\n\nfunction parseMediaType(str, i) {\n  var match = simpleMediaTypeRegExp.exec(str);\n  if (!match) return null;\n\n  var params = Object.create(null);\n  var q = 1;\n  var subtype = match[2];\n  var type = match[1];\n\n  if (match[3]) {\n    var kvps = splitParameters(match[3]).map(splitKeyValuePair);\n\n    for (var j = 0; j < kvps.length; j++) {\n      var pair = kvps[j];\n      var key = pair[0].toLowerCase();\n      var val = pair[1];\n\n      // get the value, unwrapping quotes\n      var value = val && val[0] === '\"' && val[val.length - 1] === '\"'\n        ? val.substr(1, val.length - 2)\n        : val;\n\n      if (key === 'q') {\n        q = parseFloat(value);\n        break;\n      }\n\n      // store parameter\n      params[key] = value;\n    }\n  }\n\n  return {\n    type: type,\n    subtype: subtype,\n    params: params,\n    q: q,\n    i: i\n  };\n}\n\n/**\n * Get the priority of a media type.\n * @private\n */\n\nfunction getMediaTypePriority(type, accepted, index) {\n  var priority = {o: -1, q: 0, s: 0};\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(type, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}\n\n/**\n * Get the specificity of the media type.\n * @private\n */\n\nfunction specify(type, spec, index) {\n  var p = parseMediaType(type);\n  var s = 0;\n\n  if (!p) {\n    return null;\n  }\n\n  if(spec.type.toLowerCase() == p.type.toLowerCase()) {\n    s |= 4\n  } else if(spec.type != '*') {\n    return null;\n  }\n\n  if(spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {\n    s |= 2\n  } else if(spec.subtype != '*') {\n    return null;\n  }\n\n  var keys = Object.keys(spec.params);\n  if (keys.length > 0) {\n    if (keys.every(function (k) {\n      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();\n    })) {\n      s |= 1\n    } else {\n      return null\n    }\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s,\n  }\n}\n\n/**\n * Get the preferred media types from an Accept header.\n * @public\n */\n\nfunction preferredMediaTypes(accept, provided) {\n  // RFC 2616 sec 14.2: no header = */*\n  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');\n\n  if (!provided) {\n    // sorted list of all types\n    return accepts\n      .filter(isQuality)\n      .sort(compareSpecs)\n      .map(getFullType);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getMediaTypePriority(type, accepts, index);\n  });\n\n  // sorted list of accepted types\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}\n\n/**\n * Compare two specs.\n * @private\n */\n\nfunction compareSpecs(a, b) {\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\n}\n\n/**\n * Get full type string.\n * @private\n */\n\nfunction getFullType(spec) {\n  return spec.type + '/' + spec.subtype;\n}\n\n/**\n * Check if a spec has any quality.\n * @private\n */\n\nfunction isQuality(spec) {\n  return spec.q > 0;\n}\n\n/**\n * Count the number of quotes in a string.\n * @private\n */\n\nfunction quoteCount(string) {\n  var count = 0;\n  var index = 0;\n\n  while ((index = string.indexOf('\"', index)) !== -1) {\n    count++;\n    index++;\n  }\n\n  return count;\n}\n\n/**\n * Split a key value pair.\n * @private\n */\n\nfunction splitKeyValuePair(str) {\n  var index = str.indexOf('=');\n  var key;\n  var val;\n\n  if (index === -1) {\n    key = str;\n  } else {\n    key = str.substr(0, index);\n    val = str.substr(index + 1);\n  }\n\n  return [key, val];\n}\n\n/**\n * Split an Accept header into media types.\n * @private\n */\n\nfunction splitMediaTypes(accept) {\n  var accepts = accept.split(',');\n\n  for (var i = 1, j = 0; i < accepts.length; i++) {\n    if (quoteCount(accepts[j]) % 2 == 0) {\n      accepts[++j] = accepts[i];\n    } else {\n      accepts[j] += ',' + accepts[i];\n    }\n  }\n\n  // trim accepts\n  accepts.length = j + 1;\n\n  return accepts;\n}\n\n/**\n * Split a string of parameters.\n * @private\n */\n\nfunction splitParameters(str) {\n  var parameters = str.split(';');\n\n  for (var i = 1, j = 0; i < parameters.length; i++) {\n    if (quoteCount(parameters[j]) % 2 == 0) {\n      parameters[++j] = parameters[i];\n    } else {\n      parameters[j] += ';' + parameters[i];\n    }\n  }\n\n  // trim parameters\n  parameters.length = j + 1;\n\n  for (var i = 0; i < parameters.length; i++) {\n    parameters[i] = parameters[i].trim();\n  }\n\n  return parameters;\n}\n","/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished\nmodule.exports.isFinished = isFinished\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar first = require('ee-first')\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg)\n    return msg\n  }\n\n  // attach the listener to the message\n  attachListener(msg, listener)\n\n  return msg\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || (socket && !socket.writable))\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\n  }\n\n  // don't know\n  return undefined\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg\n  var eeSocket\n  var finished = false\n\n  function onFinish(error) {\n    eeMsg.cancel()\n    eeSocket.cancel()\n\n    finished = true\n    callback(error)\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket)\n\n    if (finished) return\n    if (eeMsg !== eeSocket) return\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket)\n    return\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket)\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket)\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n\n  attached.queue.push(listener)\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null\n    if (!listener.queue) return\n\n    var queue = listener.queue\n    listener.queue = null\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg)\n    }\n  }\n\n  listener.queue = []\n\n  return listener\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket\n\n  if (typeof assignSocket !== 'function') return\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket)\n    callback(socket)\n  }\n}\n","/*!\n * parseurl\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar url = require('url')\nvar parse = url.parse\nvar Url = url.Url\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = parseurl\nmodule.exports.original = originalurl\n\n/**\n * Parse the `req` url with memoization.\n *\n * @param {ServerRequest} req\n * @return {Object}\n * @public\n */\n\nfunction parseurl (req) {\n  var url = req.url\n\n  if (url === undefined) {\n    // URL is undefined\n    return undefined\n  }\n\n  var parsed = req._parsedUrl\n\n  if (fresh(url, parsed)) {\n    // Return cached URL parse\n    return parsed\n  }\n\n  // Parse the URL\n  parsed = fastparse(url)\n  parsed._raw = url\n\n  return (req._parsedUrl = parsed)\n};\n\n/**\n * Parse the `req` original url with fallback and memoization.\n *\n * @param {ServerRequest} req\n * @return {Object}\n * @public\n */\n\nfunction originalurl (req) {\n  var url = req.originalUrl\n\n  if (typeof url !== 'string') {\n    // Fallback\n    return parseurl(req)\n  }\n\n  var parsed = req._parsedOriginalUrl\n\n  if (fresh(url, parsed)) {\n    // Return cached URL parse\n    return parsed\n  }\n\n  // Parse the URL\n  parsed = fastparse(url)\n  parsed._raw = url\n\n  return (req._parsedOriginalUrl = parsed)\n};\n\n/**\n * Parse the `str` url with fast-path short-cut.\n *\n * @param {string} str\n * @return {Object}\n * @private\n */\n\nfunction fastparse (str) {\n  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {\n    return parse(str)\n  }\n\n  var pathname = str\n  var query = null\n  var search = null\n\n  // This takes the regexp from https://github.com/joyent/node/pull/7878\n  // Which is /^(\\/[^?#\\s]*)(\\?[^#\\s]*)?$/\n  // And unrolls it into a for loop\n  for (var i = 1; i < str.length; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x3f: /* ?  */\n        if (search === null) {\n          pathname = str.substring(0, i)\n          query = str.substring(i + 1)\n          search = str.substring(i)\n        }\n        break\n      case 0x09: /* \\t */\n      case 0x0a: /* \\n */\n      case 0x0c: /* \\f */\n      case 0x0d: /* \\r */\n      case 0x20: /*    */\n      case 0x23: /* #  */\n      case 0xa0:\n      case 0xfeff:\n        return parse(str)\n    }\n  }\n\n  var url = Url !== undefined\n    ? new Url()\n    : {}\n\n  url.path = str\n  url.href = str\n  url.pathname = pathname\n\n  if (search !== null) {\n    url.query = query\n    url.search = search\n  }\n\n  return url\n}\n\n/**\n * Determine if parsed is still fresh for url.\n *\n * @param {string} url\n * @param {object} parsedUrl\n * @return {boolean}\n * @private\n */\n\nfunction fresh (url, parsedUrl) {\n  return typeof parsedUrl === 'object' &&\n    parsedUrl !== null &&\n    (Url === undefined || parsedUrl instanceof Url) &&\n    parsedUrl._raw === url\n}\n","/**\n * Expose `pathtoRegexp`.\n */\n\nmodule.exports = pathtoRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathtoRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      keys.push({\n        name: name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\n    .replace(/\\/\\(/g, '/(?:')\n    .replace(/([\\/\\.])/g, '\\\\$1')\n    .replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n      slash = slash || '';\n      format = format || '';\n      capture = capture || '([^\\\\/' + format + ']+?)';\n      optional = optional || '';\n\n      keys.push({\n        name: key,\n        optional: !!optional,\n        offset: offset + extraOffset\n      });\n\n      var result = ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + format + (optional ? slash : '') + capture\n        + (star ? '((?:[\\\\/' + format + '].+?)?)' : '')\n        + ')'\n        + optional;\n\n      extraOffset += result.length - match.length;\n\n      return result;\n    })\n    .replace(/\\*/g, function (star, index) {\n      var len = keys.length\n\n      while (len-- > keysOffset && keys[len].offset > index) {\n        keys[len].offset += 3; // Replacement length minus asterisk length.\n      }\n\n      return '(.*)';\n    });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    var escapeCount = 0;\n    var index = m.index;\n\n    while (path.charAt(--index) === '\\\\') {\n      escapeCount++;\n    }\n\n    // It's possible to escape the bracket.\n    if (escapeCount % 2 === 1) {\n      continue;\n    }\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++, // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  }\n\n  // If the path is non-ending, match until the end or a slash.\n  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));\n\n  return new RegExp(path, flags);\n};\n","/**\n * Prometheus client\n * @module Prometheus client\n */\n\n'use strict';\n\nexports.register = require('./lib/registry').globalRegistry;\nexports.Registry = require('./lib/registry');\nexports.contentType = require('./lib/registry').globalRegistry.contentType;\nexports.validateMetricName = require('./lib/validation').validateMetricName;\n\nexports.Counter = require('./lib/counter');\nexports.Gauge = require('./lib/gauge');\nexports.Histogram = require('./lib/histogram');\nexports.Summary = require('./lib/summary');\nexports.Pushgateway = require('./lib/pushgateway');\n\nexports.linearBuckets = require('./lib/bucketGenerators').linearBuckets;\nexports.exponentialBuckets = require('./lib/bucketGenerators').exponentialBuckets;\n\nexports.collectDefaultMetrics = require('./lib/defaultMetrics');\n\nexports.aggregators = require('./lib/metricAggregators').aggregators;\nexports.AggregatorRegistry = require('./lib/cluster');\n","'use strict';\n\nexports.linearBuckets = (start, width, count) => {\n\tif (count < 1) {\n\t\tthrow new Error('Linear buckets needs a positive count');\n\t}\n\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start;\n\t\tstart += width;\n\t}\n\treturn buckets;\n};\n\nexports.exponentialBuckets = (start, factor, count) => {\n\tif (start <= 0) {\n\t\tthrow new Error('Exponential buckets needs a positive start');\n\t}\n\tif (count < 1) {\n\t\tthrow new Error('Exponential buckets needs a positive count');\n\t}\n\tif (factor <= 1) {\n\t\tthrow new Error('Exponential buckets needs a factor greater than 1');\n\t}\n\tconst buckets = new Array(count);\n\tfor (let i = 0; i < count; i++) {\n\t\tbuckets[i] = start;\n\t\tstart *= factor;\n\t}\n\treturn buckets;\n};\n","'use strict';\n\n/**\n * Extends the Registry class with a `clusterMetrics` method that returns\n * aggregated metrics for all workers.\n *\n * In cluster workers, listens for and responds to requests for metrics by the\n * cluster master.\n */\n\nconst cluster = require('cluster');\nconst Registry = require('./registry');\nconst { Grouper } = require('./util');\nconst { aggregators } = require('./metricAggregators');\n\nconst GET_METRICS_REQ = 'prom-client:getMetricsReq';\nconst GET_METRICS_RES = 'prom-client:getMetricsRes';\n\nlet registries = [Registry.globalRegistry];\nlet requestCtr = 0; // Concurrency control\nlet listenersAdded = false;\nconst requests = new Map(); // Pending requests for workers' local metrics.\n\nclass AggregatorRegistry extends Registry {\n\tconstructor() {\n\t\tsuper();\n\t\taddListeners();\n\t}\n\n\t/**\n\t * Gets aggregated metrics for all workers. The optional callback and\n\t * returned Promise resolve with the same value; either may be used.\n\t * @param {Function?} callback (err, metrics) => any\n\t * @return {Promise<string>} Promise that resolves with the aggregated\n\t *   metrics.\n\t */\n\tclusterMetrics(callback) {\n\t\tconst requestId = requestCtr++;\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfunction done(err, result) {\n\t\t\t\t// Don't resolve/reject the promise if a callback is provided\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback(err, result);\n\t\t\t\t} else {\n\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\telse resolve(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst request = {\n\t\t\t\tresponses: [],\n\t\t\t\tpending: 0,\n\t\t\t\tdone,\n\t\t\t\terrorTimeout: setTimeout(() => {\n\t\t\t\t\trequest.failed = true;\n\t\t\t\t\tconst err = new Error('Operation timed out.');\n\t\t\t\t\trequest.done(err);\n\t\t\t\t}, 5000),\n\t\t\t\tfailed: false\n\t\t\t};\n\t\t\trequests.set(requestId, request);\n\n\t\t\tconst message = {\n\t\t\t\ttype: GET_METRICS_REQ,\n\t\t\t\trequestId\n\t\t\t};\n\n\t\t\tfor (const id in cluster.workers) {\n\t\t\t\t// If the worker exits abruptly, it may still be in the workers\n\t\t\t\t// list but not able to communicate.\n\t\t\t\tif (cluster.workers[id].isConnected()) {\n\t\t\t\t\tcluster.workers[id].send(message);\n\t\t\t\t\trequest.pending++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (request.pending === 0) {\n\t\t\t\t// No workers were up\n\t\t\t\tclearTimeout(request.errorTimeout);\n\t\t\t\tprocess.nextTick(() => done(null, ''));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new Registry instance from an array of metrics that were\n\t * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using\n\t * the method specified by their `aggregator` property, or by summation if\n\t * `aggregator` is undefined.\n\t * @param {Array} metricsArr Array of metrics, each of which created by\n\t *   `registry.getMetricsAsJSON()`.\n\t * @return {Registry} aggregated registry.\n\t */\n\tstatic aggregate(metricsArr) {\n\t\tconst aggregatedRegistry = new Registry();\n\t\tconst metricsByName = new Grouper();\n\n\t\t// Gather by name\n\t\tmetricsArr.forEach(metrics => {\n\t\t\tmetrics.forEach(metric => {\n\t\t\t\tmetricsByName.add(metric.name, metric);\n\t\t\t});\n\t\t});\n\n\t\t// Aggregate gathered metrics.\n\t\tmetricsByName.forEach(metrics => {\n\t\t\tconst aggregatorName = metrics[0].aggregator;\n\t\t\tconst aggregatorFn = aggregators[aggregatorName];\n\t\t\tif (typeof aggregatorFn !== 'function') {\n\t\t\t\tthrow new Error(`'${aggregatorName}' is not a defined aggregator.`);\n\t\t\t}\n\t\t\tconst aggregatedMetric = aggregatorFn(metrics);\n\t\t\t// NB: The 'omit' aggregator returns undefined.\n\t\t\tif (aggregatedMetric) {\n\t\t\t\tconst aggregatedMetricWrapper = Object.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tget: () => aggregatedMetric\n\t\t\t\t\t},\n\t\t\t\t\taggregatedMetric\n\t\t\t\t);\n\t\t\t\taggregatedRegistry.registerMetric(aggregatedMetricWrapper);\n\t\t\t}\n\t\t});\n\n\t\treturn aggregatedRegistry;\n\t}\n\n\t/**\n\t * Sets the registry or registries to be aggregated. Call from workers to\n\t * use a registry/registries other than the default global registry.\n\t * @param {Array<Registry>|Registry} regs Registry or registries to be\n\t *   aggregated.\n\t * @return {void}\n\t */\n\tstatic setRegistries(regs) {\n\t\tif (!Array.isArray(regs)) regs = [regs];\n\t\tregs.forEach(reg => {\n\t\t\tif (!(reg instanceof Registry)) {\n\t\t\t\tthrow new TypeError(`Expected Registry, got ${typeof reg}`);\n\t\t\t}\n\t\t});\n\t\tregistries = regs;\n\t}\n}\n\n/**\n * Adds event listeners for cluster aggregation. Idempotent (safe to call more\n * than once).\n * @return {void}\n */\nfunction addListeners() {\n\tif (listenersAdded) return;\n\tlistenersAdded = true;\n\n\tif (cluster.isMaster) {\n\t\t// Listen for worker responses to requests for local metrics\n\t\tcluster.on('message', (worker, message) => {\n\t\t\tif (message.type === GET_METRICS_RES) {\n\t\t\t\tconst request = requests.get(message.requestId);\n\t\t\t\tmessage.metrics.forEach(registry => request.responses.push(registry));\n\t\t\t\trequest.pending--;\n\n\t\t\t\tif (request.pending === 0) {\n\t\t\t\t\t// finalize\n\t\t\t\t\trequests.delete(message.requestId);\n\t\t\t\t\tclearTimeout(request.errorTimeout);\n\n\t\t\t\t\tif (request.failed) return; // Callback already run with Error.\n\n\t\t\t\t\tconst registry = AggregatorRegistry.aggregate(request.responses);\n\t\t\t\t\tconst promString = registry.metrics();\n\t\t\t\t\trequest.done(null, promString);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nif (cluster.isWorker) {\n\t// Respond to master's requests for worker's local metrics.\n\tprocess.on('message', message => {\n\t\tif (message.type === GET_METRICS_REQ) {\n\t\t\tprocess.send({\n\t\t\t\ttype: GET_METRICS_RES,\n\t\t\t\trequestId: message.requestId,\n\t\t\t\tmetrics: registries.map(r => r.getMetricsAsJSON())\n\t\t\t});\n\t\t}\n\t});\n}\n\nmodule.exports = AggregatorRegistry;\n","/**\n * Counter metric\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'counter';\nconst {\n\tisDate,\n\tgetPropertiesFromObj,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tgetLabels,\n\tremoveLabels\n} = require('./util');\n\nconst {\n\tvalidateLabel,\n\tvalidateMetricName,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Counter {\n\t/**\n\t * Counter\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help description for the metric\n\t * @param {Array.<string>} labels - Labels\n\t */\n\tconstructor(name, help, labels) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\n\t\tif (!config.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!config.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(config.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\n\t\tif (!validateLabelName(config.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tthis.name = config.name;\n\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tthis.reset();\n\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Increment counter\n\t * @param {object} labels - What label you want to be incremented\n\t * @param {Number} value - Value to increment, if omitted increment with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the counter to\n\t * @returns {void}\n\t */\n\tinc(labels, value, timestamp) {\n\t\tif (!isObject(labels)) {\n\t\t\treturn inc.call(this, null)(labels, value);\n\t\t}\n\n\t\tconst hash = hashObject(labels);\n\t\treturn inc.call(this, labels, hash)(value, timestamp);\n\t}\n\n\t/**\n\t * Reset counter\n\t * @returns {void}\n\t */\n\treset() {\n\t\treturn reset.call(this);\n\t}\n\n\tget() {\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype,\n\t\t\tvalues: getPropertiesFromObj(this.hashMap),\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments) || {};\n\t\tconst hash = hashObject(labels);\n\t\tvalidateLabel(this.labelNames, labels);\n\t\treturn {\n\t\t\tinc: inc.call(this, labels, hash)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments) || {};\n\t\treturn removeLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nconst reset = function() {\n\tthis.hashMap = {};\n\n\tif (this.labelNames.length === 0) {\n\t\tthis.hashMap = setValue({}, 0);\n\t}\n};\n\nconst inc = function(labels, hash) {\n\treturn (value, timestamp) => {\n\t\tif (value && !Number.isFinite(value)) {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (timestamp && !isDate(timestamp) && !Number.isFinite(timestamp)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Timestamp is not a valid date or number: ${util.format(timestamp)}`\n\t\t\t);\n\t\t}\n\t\tif (value < 0) {\n\t\t\tthrow new Error('It is not possible to decrease a counter');\n\t\t}\n\n\t\tlabels = labels || {};\n\t\tvalidateLabel(this.labelNames, labels);\n\n\t\tconst incValue = value === null || value === undefined ? 1 : value;\n\n\t\tthis.hashMap = setValue(this.hashMap, incValue, timestamp, labels, hash);\n\t};\n};\n\nfunction setValue(hashMap, value, timestamp, labels, hash) {\n\thash = hash || '';\n\ttimestamp = isDate(timestamp)\n\t\t? timestamp.valueOf()\n\t\t: Number.isFinite(timestamp)\n\t\t? timestamp\n\t\t: undefined;\n\tif (hashMap[hash]) {\n\t\thashMap[hash].value += value;\n\t\thashMap[hash].timestamp = timestamp;\n\t} else {\n\t\thashMap[hash] = { value, labels: labels || {}, timestamp };\n\t}\n\treturn hashMap;\n}\n\nmodule.exports = Counter;\n","'use strict';\n\nconst processCpuTotal = require('./metrics/processCpuTotal');\nconst processStartTime = require('./metrics/processStartTime');\nconst osMemoryHeap = require('./metrics/osMemoryHeap');\nconst processOpenFileDescriptors = require('./metrics/processOpenFileDescriptors');\nconst processMaxFileDescriptors = require('./metrics/processMaxFileDescriptors');\nconst eventLoopLag = require('./metrics/eventLoopLag');\nconst processHandles = require('./metrics/processHandles');\nconst processRequests = require('./metrics/processRequests');\nconst heapSizeAndUsed = require('./metrics/heapSizeAndUsed');\nconst heapSpacesSizeAndUsed = require('./metrics/heapSpacesSizeAndUsed');\nconst version = require('./metrics/version');\nconst { globalRegistry } = require('./registry');\nconst { printDeprecationCollectDefaultMetricsNumber } = require('./util');\n\nconst metrics = {\n\tprocessCpuTotal,\n\tprocessStartTime,\n\tosMemoryHeap,\n\tprocessOpenFileDescriptors,\n\tprocessMaxFileDescriptors,\n\teventLoopLag,\n\tprocessHandles,\n\tprocessRequests,\n\theapSizeAndUsed,\n\theapSpacesSizeAndUsed,\n\tversion\n};\nconst metricsList = Object.keys(metrics);\n\nlet existingInterval = null;\n// This is used to ensure the program throws on duplicate metrics during first run\n// We might want to consider not supporting running the default metrics function more than once\nlet init = true;\n\nmodule.exports = function startDefaultMetrics(config) {\n\tlet normalizedConfig = config;\n\tif (typeof config === 'number') {\n\t\tprintDeprecationCollectDefaultMetricsNumber(config);\n\n\t\tnormalizedConfig = { timeout: config };\n\t}\n\n\tnormalizedConfig = Object.assign(\n\t\t{\n\t\t\ttimestamps: true,\n\t\t\ttimeout: 10000\n\t\t},\n\t\tnormalizedConfig\n\t);\n\n\tif (existingInterval !== null) {\n\t\tclearInterval(existingInterval);\n\t}\n\n\tconst initialisedMetrics = metricsList.map(metric => {\n\t\tconst defaultMetric = metrics[metric];\n\t\tif (!init) {\n\t\t\tdefaultMetric.metricNames.map(\n\t\t\t\tglobalRegistry.removeSingleMetric,\n\t\t\t\tglobalRegistry\n\t\t\t);\n\t\t}\n\n\t\treturn defaultMetric(normalizedConfig.register, normalizedConfig);\n\t});\n\n\tfunction updateAllMetrics() {\n\t\tinitialisedMetrics.forEach(metric => metric.call());\n\t}\n\n\tupdateAllMetrics();\n\n\texistingInterval = setInterval(\n\t\tupdateAllMetrics,\n\t\tnormalizedConfig.timeout\n\t).unref();\n\n\tinit = false;\n\n\treturn existingInterval;\n};\n\nmodule.exports.metricsList = metricsList;\n","/**\n * Gauge metric\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'gauge';\n\nconst {\n\tisDate,\n\tsetValue,\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateMetricName,\n\tvalidateLabel,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Gauge {\n\t/**\n\t * Gauge\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {Array.<string>} labels - Array with strings, all label keywords supported\n\t */\n\tconstructor(name, help, labels) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tprintDeprecationObjectConstructor();\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\n\t\tif (!config.help) {\n\t\t\tthrow new Error('Missing mandatory help parameter');\n\t\t}\n\t\tif (!config.name) {\n\t\t\tthrow new Error('Missing mandatory name parameter');\n\t\t}\n\t\tif (!validateMetricName(config.name)) {\n\t\t\tthrow new Error('Invalid metric name');\n\t\t}\n\t\tif (!validateLabelName(config.labelNames)) {\n\t\t\tthrow new Error('Invalid label name');\n\t\t}\n\n\t\tthis.name = config.name;\n\t\tthis.labelNames = config.labelNames || [];\n\t\tthis.reset();\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Set a gauge to a value\n\t * @param {object} labels - Object with labels and their values\n\t * @param {Number} value - Value to set the gauge to, must be positive\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tset(labels, value, timestamp) {\n\t\tif (!isObject(labels)) {\n\t\t\treturn set.call(this, null)(labels, value);\n\t\t}\n\t\treturn set.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Reset gauge\n\t * @returns {void}\n\t */\n\treset() {\n\t\treturn reset.call(this);\n\t}\n\n\t/**\n\t * Increment a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to increment - if omitted, increment with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tinc(labels, value, timestamp) {\n\t\tinc.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Decrement a gauge value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to decrement - if omitted, decrement with 1\n\t * @param {(Number|Date)} timestamp - Timestamp to set the gauge to\n\t * @returns {void}\n\t */\n\tdec(labels, value, timestamp) {\n\t\tdec.call(this, labels)(value, timestamp);\n\t}\n\n\t/**\n\t * Set the gauge to current unix epoch\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {void}\n\t */\n\tsetToCurrentTime(labels) {\n\t\treturn setToCurrentTime.call(this, labels)();\n\t}\n\n\t/**\n\t * Start a timer\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Invoke this function to set the duration in seconds since you started the timer.\n\t * @example\n\t * var done = gauge.startTimer();\n\t * makeXHRRequest(function(err, response) {\n\t *\tdone(); //Duration of the request will be saved\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tget() {\n\t\treturn {\n\t\t\thelp: this.help,\n\t\t\tname: this.name,\n\t\t\ttype,\n\t\t\tvalues: getPropertiesFromObj(this.hashMap),\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\t_getValue(labels) {\n\t\tconst hash = hashObject(labels || {});\n\t\treturn this.hashMap[hash] ? this.hashMap[hash].value : 0;\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tinc: inc.call(this, labels),\n\t\t\tdec: dec.call(this, labels),\n\t\t\tset: set.call(this, labels),\n\t\t\tsetToCurrentTime: setToCurrentTime.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction setToCurrentTime(labels) {\n\treturn () => {\n\t\tconst now = Date.now() / 1000;\n\t\tif (labels === undefined) {\n\t\t\tthis.set(now);\n\t\t} else {\n\t\t\tthis.set(labels, now);\n\t\t}\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.set(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\n\nfunction dec(labels) {\n\treturn (value, timestamp) => {\n\t\tconst data = convertLabelsAndValues(labels, value);\n\t\tthis.set(\n\t\t\tdata.labels,\n\t\t\tthis._getValue(data.labels) - (data.value || 1),\n\t\t\ttimestamp\n\t\t);\n\t};\n}\n\nfunction inc(labels) {\n\treturn (value, timestamp) => {\n\t\tconst data = convertLabelsAndValues(labels, value);\n\t\tthis.set(\n\t\t\tdata.labels,\n\t\t\tthis._getValue(data.labels) + (data.value || 1),\n\t\t\ttimestamp\n\t\t);\n\t};\n}\n\nfunction set(labels) {\n\treturn (value, timestamp) => {\n\t\tif (typeof value !== 'number') {\n\t\t\tthrow new TypeError(`Value is not a valid number: ${util.format(value)}`);\n\t\t}\n\t\tif (timestamp && !isDate(timestamp) && !Number.isFinite(timestamp)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Timestamp is not a valid date or number: ${util.format(timestamp)}`\n\t\t\t);\n\t\t}\n\n\t\tlabels = labels || {};\n\n\t\tvalidateLabel(this.labelNames, labels);\n\t\tthis.hashMap = setValue(this.hashMap, value, labels, timestamp);\n\t};\n}\n\nfunction reset() {\n\tthis.hashMap = {};\n\n\tif (this.labelNames.length === 0) {\n\t\tthis.hashMap = setValue({}, 0, {});\n\t}\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (!isObject(labels)) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nmodule.exports = Gauge;\n","/**\n * Histogram\n */\n'use strict';\n\nconst util = require('util');\nconst globalRegistry = require('./registry').globalRegistry;\nconst type = 'histogram';\nconst {\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateMetricName,\n\tvalidateLabel,\n\tvalidateLabelName\n} = require('./validation');\n\nclass Histogram {\n\t/**\n\t * Histogram\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {object|Array.<string>} labelsOrConf - Either array of label names or config object as a key-value object\n\t * @param {object} conf - Configuration object\n\t */\n\tconstructor(name, help, labelsOrConf, conf) {\n\t\tlet config;\n\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tbuckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tlet obj;\n\t\t\tlet labels = [];\n\n\t\t\tif (Array.isArray(labelsOrConf)) {\n\t\t\t\tobj = conf || {};\n\t\t\t\tlabels = labelsOrConf;\n\t\t\t} else {\n\t\t\t\tobj = labelsOrConf || {};\n\t\t\t}\n\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\tlabelNames: labels,\n\t\t\t\thelp,\n\t\t\t\tbuckets: configureUpperbounds(obj.buckets),\n\t\t\t\tregisters: [globalRegistry]\n\t\t\t};\n\t\t}\n\t\tvalidateInput(config.name, config.help, config.labelNames);\n\n\t\tthis.name = config.name;\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tthis.upperBounds = config.buckets;\n\t\tthis.bucketValues = this.upperBounds.reduce((acc, upperBound) => {\n\t\t\tacc[upperBound] = 0;\n\t\t\treturn acc;\n\t\t}, {});\n\n\t\tObject.freeze(this.bucketValues);\n\t\tObject.freeze(this.upperBounds);\n\t\tthis.sum = 0;\n\t\tthis.count = 0;\n\n\t\tthis.hashMap = {};\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: createBaseValues(\n\t\t\t\t\t{},\n\t\t\t\t\tObject.assign({}, this.bucketValues)\n\t\t\t\t)\n\t\t\t};\n\t\t}\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Observe a value in histogram\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe in the histogram\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tget() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tconst values = data\n\t\t\t.map(extractBucketValuesForExport(this))\n\t\t\t.reduce(addSumAndCountForExport(this), []);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\treset() {\n\t\tthis.sum = 0;\n\t\tthis.count = 0;\n\t\tthis.hashMap = {};\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = histogram.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.observe(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\nfunction validateInput(name, help, labels) {\n\tif (!help) {\n\t\tthrow new Error('Missing mandatory help parameter');\n\t}\n\tif (!name) {\n\t\tthrow new Error('Missing mandatory name parameter');\n\t}\n\n\tif (!validateMetricName(name)) {\n\t\tthrow new Error('Invalid metric name');\n\t}\n\n\tif (!validateLabelName(labels)) {\n\t\tthrow new Error('Invalid label name');\n\t}\n\n\tlabels.forEach(label => {\n\t\tif (label === 'le') {\n\t\t\tthrow new Error('le is a reserved label keyword');\n\t\t}\n\t});\n}\n\nfunction configureUpperbounds(configuredBuckets) {\n\tconst defaultBuckets = [\n\t\t0.005,\n\t\t0.01,\n\t\t0.025,\n\t\t0.05,\n\t\t0.1,\n\t\t0.25,\n\t\t0.5,\n\t\t1,\n\t\t2.5,\n\t\t5,\n\t\t10\n\t];\n\treturn [].concat(configuredBuckets || defaultBuckets).sort(sortAscending);\n}\n\nfunction sortAscending(x, y) {\n\treturn x - y;\n}\n\nfunction setValuePair(labels, value, metricName) {\n\treturn {\n\t\tlabels,\n\t\tvalue,\n\t\tmetricName\n\t};\n}\n\nfunction findBound(upperBounds, value) {\n\tfor (let i = 0; i < upperBounds.length; i++) {\n\t\tconst bound = upperBounds[i];\n\t\tif (value <= bound) {\n\t\t\treturn bound;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, labelValuePair.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels);\n\t\tlet valueFromMap = this.hashMap[hash];\n\t\tif (!valueFromMap) {\n\t\t\tvalueFromMap = createBaseValues(\n\t\t\t\tlabelValuePair.labels,\n\t\t\t\tObject.assign({}, this.bucketValues)\n\t\t\t);\n\t\t}\n\n\t\tconst b = findBound(this.upperBounds, labelValuePair.value);\n\n\t\tvalueFromMap.sum += labelValuePair.value;\n\t\tvalueFromMap.count += 1;\n\n\t\tif (valueFromMap.bucketValues.hasOwnProperty(b)) {\n\t\t\tvalueFromMap.bucketValues[b] += 1;\n\t\t}\n\n\t\tthis.hashMap[hash] = valueFromMap;\n\t};\n}\n\nfunction createBaseValues(labels, bucketValues) {\n\treturn {\n\t\tlabels,\n\t\tbucketValues,\n\t\tsum: 0,\n\t\tcount: 0\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (!isObject(labels)) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nfunction extractBucketValuesForExport(histogram) {\n\treturn bucketData => {\n\t\tconst buckets = [];\n\t\tconst bucketLabelNames = Object.keys(bucketData.labels);\n\t\tlet acc = 0;\n\t\tfor (const upperBound of histogram.upperBounds) {\n\t\t\tacc += bucketData.bucketValues[upperBound];\n\t\t\tconst lbls = { le: upperBound };\n\t\t\tfor (const labelName of bucketLabelNames) {\n\t\t\t\tlbls[labelName] = bucketData.labels[labelName];\n\t\t\t}\n\t\t\tbuckets.push(setValuePair(lbls, acc, `${histogram.name}_bucket`));\n\t\t}\n\t\treturn { buckets, data: bucketData };\n\t};\n}\n\nfunction addSumAndCountForExport(histogram) {\n\treturn (acc, d) => {\n\t\tacc.push(...d.buckets);\n\n\t\tconst infLabel = { le: '+Inf' };\n\t\tfor (const label of Object.keys(d.data.labels)) {\n\t\t\tinfLabel[label] = d.data.labels[label];\n\t\t}\n\t\tacc.push(\n\t\t\tsetValuePair(infLabel, d.data.count, `${histogram.name}_bucket`),\n\t\t\tsetValuePair(d.data.labels, d.data.sum, `${histogram.name}_sum`),\n\t\t\tsetValuePair(d.data.labels, d.data.count, `${histogram.name}_count`)\n\t\t);\n\t\treturn acc;\n\t};\n}\n\nmodule.exports = Histogram;\n","'use strict';\n\nconst { Grouper, hashObject } = require('./util');\n\n/**\n * Returns a new function that applies the `aggregatorFn` to the values.\n * @param {Function} aggregatorFn function to apply to values.\n * @return {Function} aggregator function\n */\nfunction AggregatorFactory(aggregatorFn) {\n\treturn metrics => {\n\t\tif (metrics.length === 0) return;\n\t\tconst result = {\n\t\t\thelp: metrics[0].help,\n\t\t\tname: metrics[0].name,\n\t\t\ttype: metrics[0].type,\n\t\t\tvalues: [],\n\t\t\taggregator: metrics[0].aggregator\n\t\t};\n\t\t// Gather metrics by metricName and labels.\n\t\tconst byLabels = new Grouper();\n\t\tmetrics.forEach(metric => {\n\t\t\tmetric.values.forEach(value => {\n\t\t\t\tconst key = hashObject(value.labels);\n\t\t\t\tbyLabels.add(`${value.metricName}_${key}`, value);\n\t\t\t});\n\t\t});\n\t\t// Apply aggregator function to gathered metrics.\n\t\tbyLabels.forEach(values => {\n\t\t\tif (values.length === 0) return;\n\t\t\tconst valObj = {\n\t\t\t\tvalue: aggregatorFn(values),\n\t\t\t\tlabels: values[0].labels\n\t\t\t};\n\t\t\tif (values[0].metricName) {\n\t\t\t\tvalObj.metricName = values[0].metricName;\n\t\t\t}\n\t\t\t// NB: Timestamps are omitted.\n\t\t\tresult.values.push(valObj);\n\t\t});\n\t\treturn result;\n\t};\n}\n// Export for users to define their own aggregation methods.\nexports.AggregatorFactory = AggregatorFactory;\n\n/**\n * Functions that can be used to aggregate metrics from multiple registries.\n */\nexports.aggregators = {\n\t/**\n\t * @return The sum of values.\n\t */\n\tsum: AggregatorFactory(v => v.reduce((p, c) => p + c.value, 0)),\n\t/**\n\t * @return The first value.\n\t */\n\tfirst: AggregatorFactory(v => v[0].value),\n\t/**\n\t * @return {undefined} Undefined; omits the metric.\n\t */\n\tomit: () => {},\n\t/**\n\t * @return The arithmetic mean of the values.\n\t */\n\taverage: AggregatorFactory(\n\t\tv => v.reduce((p, c) => p + c.value, 0) / v.length\n\t),\n\t/**\n\t * @return The minimum of the values.\n\t */\n\tmin: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.min(p, c.value), Infinity)\n\t),\n\t/**\n\t * @return The maximum of the values.\n\t */\n\tmax: AggregatorFactory(v =>\n\t\tv.reduce((p, c) => Math.max(p, c.value), -Infinity)\n\t)\n};\n","'use strict';\n\nconst Gauge = require('../gauge');\n\nconst NODEJS_EVENTLOOP_LAG = 'nodejs_eventloop_lag_seconds';\n\nfunction reportEventloopLag(start, gauge) {\n\tconst delta = process.hrtime(start);\n\tconst nanosec = delta[0] * 1e9 + delta[1];\n\tconst seconds = nanosec / 1e9;\n\n\tgauge.set(seconds, Date.now());\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_EVENTLOOP_LAG,\n\t\thelp: 'Lag of event loop in seconds.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'average'\n\t});\n\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\tsetImmediate(reportEventloopLag, start, gauge);\n\t};\n};\n\nmodule.exports.metricNames = [NODEJS_EVENTLOOP_LAG];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst NODEJS_HEAP_SIZE_TOTAL = 'nodejs_heap_size_total_bytes';\nconst NODEJS_HEAP_SIZE_USED = 'nodejs_heap_size_used_bytes';\nconst NODEJS_EXTERNAL_MEMORY = 'nodejs_external_memory_bytes';\n\nmodule.exports = (registry, config = {}) => {\n\tif (typeof process.memoryUsage !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst heapSizeTotal = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_TOTAL,\n\t\thelp: 'Process heap size from node.js in bytes.',\n\t\tregisters\n\t});\n\tconst heapSizeUsed = new Gauge({\n\t\tname: namePrefix + NODEJS_HEAP_SIZE_USED,\n\t\thelp: 'Process heap size used from node.js in bytes.',\n\t\tregisters\n\t});\n\tlet externalMemUsed;\n\n\tconst usage = safeMemoryUsage();\n\tif (usage && usage.external) {\n\t\texternalMemUsed = new Gauge({\n\t\t\tname: namePrefix + NODEJS_EXTERNAL_MEMORY,\n\t\t\thelp: 'Nodejs external memory size in bytes.',\n\t\t\tregisters\n\t\t});\n\t}\n\n\treturn () => {\n\t\t// process.memoryUsage() can throw EMFILE errors, see #67\n\t\tconst memUsage = safeMemoryUsage();\n\t\tif (memUsage) {\n\t\t\tif (config.timestamps) {\n\t\t\t\tconst now = Date.now();\n\t\t\t\theapSizeTotal.set(memUsage.heapTotal, now);\n\t\t\t\theapSizeUsed.set(memUsage.heapUsed, now);\n\t\t\t\tif (memUsage.external && externalMemUsed) {\n\t\t\t\t\texternalMemUsed.set(memUsage.external, now);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\theapSizeTotal.set(memUsage.heapTotal);\n\t\t\t\theapSizeUsed.set(memUsage.heapUsed);\n\t\t\t\tif (memUsage.external && externalMemUsed) {\n\t\t\t\t\texternalMemUsed.set(memUsage.external);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttotal: heapSizeTotal,\n\t\t\tused: heapSizeUsed,\n\t\t\texternal: externalMemUsed\n\t\t};\n\t};\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_HEAP_SIZE_TOTAL,\n\tNODEJS_HEAP_SIZE_USED,\n\tNODEJS_EXTERNAL_MEMORY\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\nlet v8;\n\ntry {\n\tv8 = require('v8');\n} catch (e) {\n\t// node version is too old\n\t// probably we can use v8-heap-space-statistics for >=node-4.0.0 and <node-6.0.0\n}\n\nconst METRICS = ['total', 'used', 'available'];\n\nconst NODEJS_HEAP_SIZE = {};\n\nMETRICS.forEach(metricType => {\n\tNODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;\n});\n\nmodule.exports = (registry, config = {}) => {\n\tif (\n\t\ttypeof v8 === 'undefined' ||\n\t\ttypeof v8.getHeapSpaceStatistics !== 'function'\n\t) {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauges = {};\n\n\tMETRICS.forEach(metricType => {\n\t\tgauges[metricType] = new Gauge({\n\t\t\tname: namePrefix + NODEJS_HEAP_SIZE[metricType],\n\t\t\thelp: `Process heap space size ${metricType} from node.js in bytes.`,\n\t\t\tlabelNames: ['space'],\n\t\t\tregisters\n\t\t});\n\t});\n\n\treturn () => {\n\t\tconst data = {\n\t\t\ttotal: {},\n\t\t\tused: {},\n\t\t\tavailable: {}\n\t\t};\n\t\tconst now = Date.now();\n\n\t\tv8.getHeapSpaceStatistics().forEach(space => {\n\t\t\tconst spaceName = space.space_name.substr(\n\t\t\t\t0,\n\t\t\t\tspace.space_name.indexOf('_space')\n\t\t\t);\n\n\t\t\tdata.total[spaceName] = space.space_size;\n\t\t\tdata.used[spaceName] = space.space_used_size;\n\t\t\tdata.available[spaceName] = space.space_available_size;\n\n\t\t\tgauges.total.set({ space: spaceName }, space.space_size, now);\n\t\t\tgauges.used.set({ space: spaceName }, space.space_used_size, now);\n\t\t\tgauges.available.set(\n\t\t\t\t{ space: spaceName },\n\t\t\t\tspace.space_available_size,\n\t\t\t\tnow\n\t\t\t);\n\t\t});\n\n\t\treturn data;\n\t};\n};\n\nmodule.exports.metricNames = METRICS.map(\n\tmetricType => NODEJS_HEAP_SIZE[metricType]\n);\n","'use strict';\n\nfunction aggregateByObjectName(list) {\n\tconst data = {};\n\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst listElement = list[i];\n\n\t\tif (!listElement || typeof listElement.constructor === 'undefined') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (data.hasOwnProperty(listElement.constructor.name)) {\n\t\t\tdata[listElement.constructor.name] += 1;\n\t\t} else {\n\t\t\tdata[listElement.constructor.name] = 1;\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction updateMetrics(gauge, data, includeTimestamp) {\n\tgauge.reset();\n\tfor (const key in data) {\n\t\tif (includeTimestamp) {\n\t\t\tgauge.set({ type: key }, data[key], Date.now());\n\t\t} else {\n\t\t\tgauge.set({ type: key }, data[key]);\n\t\t}\n\t}\n}\n\nmodule.exports = {\n\taggregateByObjectName,\n\tupdateMetrics\n};\n","'use strict';\n\nfunction safeMemoryUsage() {\n\tlet memoryUsage;\n\ttry {\n\t\tmemoryUsage = process.memoryUsage();\n\t} catch (ex) {\n\t\t// empty\n\t}\n\n\treturn memoryUsage;\n}\n\nmodule.exports = safeMemoryUsage;\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst linuxVariant = require('./osMemoryHeapLinux');\nconst safeMemoryUsage = require('./helpers/safeMemoryUsage');\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\n\nfunction notLinuxVariant(registry, config = {}) {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst residentMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tconst memUsage = safeMemoryUsage();\n\n\t\t// I don't think the other things returned from `process.memoryUsage()` is relevant to a standard export\n\t\tif (memUsage) {\n\t\t\tresidentMemGauge.set(memUsage.rss, Date.now());\n\t\t}\n\t};\n}\n\nmodule.exports = (registry, config) =>\n\tprocess.platform === 'linux'\n\t\t? linuxVariant(registry, config)\n\t\t: notLinuxVariant(registry, config);\n\nmodule.exports.metricNames =\n\tprocess.platform === 'linux'\n\t\t? linuxVariant.metricNames\n\t\t: [PROCESS_RESIDENT_MEMORY];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst values = ['VmSize', 'VmRSS', 'VmData'];\n\nconst PROCESS_RESIDENT_MEMORY = 'process_resident_memory_bytes';\nconst PROCESS_VIRTUAL_MEMORY = 'process_virtual_memory_bytes';\nconst PROCESS_HEAP = 'process_heap_bytes';\n\nfunction structureOutput(input) {\n\tconst returnValue = {};\n\n\tinput\n\t\t.split('\\n')\n\t\t.filter(s => values.some(value => s.indexOf(value) === 0))\n\t\t.forEach(string => {\n\t\t\tconst split = string.split(':');\n\n\t\t\t// Get the value\n\t\t\tlet value = split[1].trim();\n\t\t\t// Remove trailing ` kb`\n\t\t\tvalue = value.substr(0, value.length - 3);\n\t\t\t// Make it into a number in bytes bytes\n\t\t\tvalue = Number(value) * 1024;\n\n\t\t\treturnValue[split[0]] = value;\n\t\t});\n\n\treturn returnValue;\n}\n\nmodule.exports = (registry, config = {}) => {\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst residentMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_RESIDENT_MEMORY,\n\t\thelp: 'Resident memory size in bytes.',\n\t\tregisters\n\t});\n\tconst virtualMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_VIRTUAL_MEMORY,\n\t\thelp: 'Virtual memory size in bytes.',\n\t\tregisters\n\t});\n\tconst heapSizeMemGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_HEAP,\n\t\thelp: 'Process heap size in bytes.',\n\t\tregisters\n\t});\n\n\treturn () => {\n\t\tfs.readFile('/proc/self/status', 'utf8', (err, status) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst now = Date.now();\n\t\t\tconst structuredOutput = structureOutput(status);\n\n\t\t\tresidentMemGauge.set(structuredOutput.VmRSS, now);\n\t\t\tvirtualMemGauge.set(structuredOutput.VmSize, now);\n\t\t\theapSizeMemGauge.set(structuredOutput.VmData, now);\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_RESIDENT_MEMORY,\n\tPROCESS_VIRTUAL_MEMORY,\n\tPROCESS_HEAP\n];\n","'use strict';\n\nconst Counter = require('../counter');\nconst PROCESS_CPU_USER_SECONDS = 'process_cpu_user_seconds_total';\nconst PROCESS_CPU_SYSTEM_SECONDS = 'process_cpu_system_seconds_total';\nconst PROCESS_CPU_SECONDS = 'process_cpu_seconds_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function doesn't exist (introduced in node@6.1.0)\n\tif (typeof process.cpuUsage !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst registers = registry ? [registry] : undefined;\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst cpuUserUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_USER_SECONDS,\n\t\thelp: 'Total user CPU time spent in seconds.',\n\t\tregisters\n\t});\n\tconst cpuSystemUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,\n\t\thelp: 'Total system CPU time spent in seconds.',\n\t\tregisters\n\t});\n\tconst cpuUsageCounter = new Counter({\n\t\tname: namePrefix + PROCESS_CPU_SECONDS,\n\t\thelp: 'Total user and system CPU time spent in seconds.',\n\t\tregisters\n\t});\n\n\tlet lastCpuUsage = process.cpuUsage();\n\n\treturn () => {\n\t\tconst cpuUsage = process.cpuUsage();\n\t\tconst now = Date.now();\n\n\t\tconst userUsageMicros = cpuUsage.user - lastCpuUsage.user;\n\t\tconst systemUsageMicros = cpuUsage.system - lastCpuUsage.system;\n\n\t\tlastCpuUsage = cpuUsage;\n\n\t\tcpuUserUsageCounter.inc(userUsageMicros / 1e6, now);\n\t\tcpuSystemUsageCounter.inc(systemUsageMicros / 1e6, now);\n\t\tcpuUsageCounter.inc((userUsageMicros + systemUsageMicros) / 1e6, now);\n\t};\n};\n\nmodule.exports.metricNames = [\n\tPROCESS_CPU_USER_SECONDS,\n\tPROCESS_CPU_SYSTEM_SECONDS,\n\tPROCESS_CPU_SECONDS\n];\n","'use strict';\n\nconst { aggregateByObjectName } = require('./helpers/processMetricsHelpers');\nconst { updateMetrics } = require('./helpers/processMetricsHelpers');\nconst Gauge = require('../gauge');\n\nconst NODEJS_ACTIVE_HANDLES = 'nodejs_active_handles';\nconst NODEJS_ACTIVE_HANDLES_TOTAL = 'nodejs_active_handles_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6)\n\tif (typeof process._getActiveHandles !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_HANDLES,\n\t\thelp:\n\t\t\t'Number of active libuv handles grouped by handle type. Every handle type is C++ class name.',\n\t\tlabelNames: ['type'],\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\tconst totalGauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,\n\t\thelp: 'Total number of active handles.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\tconst updater = config.timestamps\n\t\t? () => {\n\t\t\t\tconst handles = process._getActiveHandles();\n\t\t\t\tupdateMetrics(gauge, aggregateByObjectName(handles), true);\n\t\t\t\ttotalGauge.set(handles.length, Date.now());\n\t\t  }\n\t\t: () => {\n\t\t\t\tconst handles = process._getActiveHandles();\n\t\t\t\tupdateMetrics(gauge, aggregateByObjectName(handles), false);\n\t\t\t\ttotalGauge.set(handles.length);\n\t\t  };\n\n\treturn updater;\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_ACTIVE_HANDLES,\n\tNODEJS_ACTIVE_HANDLES_TOTAL\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\n\nconst PROCESS_MAX_FDS = 'process_max_fds';\n\nmodule.exports = (registry, config = {}) => {\n\tlet isSet = false;\n\n\tif (process.platform !== 'linux') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst fileDescriptorsGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_MAX_FDS,\n\t\thelp: 'Maximum number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\n\t\tfs.readFile('/proc/sys/fs/file-max', 'utf8', (err, maxFds) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisSet = true;\n\n\t\t\tfileDescriptorsGauge.set(Number(maxFds));\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_MAX_FDS];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst fs = require('fs');\nconst process = require('process');\n\nconst PROCESS_OPEN_FDS = 'process_open_fds';\n\nmodule.exports = (registry, config = {}) => {\n\tif (process.platform !== 'linux') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst fileDescriptorsGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_OPEN_FDS,\n\t\thelp: 'Number of open file descriptors.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tfs.readdir('/proc/self/fd', (err, list) => {\n\t\t\tif (err) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Minus 1, as this invocation created one\n\t\t\tfileDescriptorsGauge.set(list.length - 1, Date.now());\n\t\t});\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_OPEN_FDS];\n","'use strict';\nconst Gauge = require('../gauge');\nconst { aggregateByObjectName } = require('./helpers/processMetricsHelpers');\nconst { updateMetrics } = require('./helpers/processMetricsHelpers');\n\nconst NODEJS_ACTIVE_REQUESTS = 'nodejs_active_requests';\nconst NODEJS_ACTIVE_REQUESTS_TOTAL = 'nodejs_active_requests_total';\n\nmodule.exports = (registry, config = {}) => {\n\t// Don't do anything if the function is removed in later nodes (exists in node@6)\n\tif (typeof process._getActiveRequests !== 'function') {\n\t\treturn () => {};\n\t}\n\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst gauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_REQUESTS,\n\t\thelp:\n\t\t\t'Number of active libuv requests grouped by request type. Every request type is C++ class name.',\n\t\tlabelNames: ['type'],\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\tconst totalGauge = new Gauge({\n\t\tname: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,\n\t\thelp: 'Total number of active requests.',\n\t\tregisters: registry ? [registry] : undefined\n\t});\n\n\treturn () => {\n\t\tconst requests = process._getActiveRequests();\n\t\tupdateMetrics(gauge, aggregateByObjectName(requests));\n\t\ttotalGauge.set(requests.length, Date.now());\n\t};\n};\n\nmodule.exports.metricNames = [\n\tNODEJS_ACTIVE_REQUESTS,\n\tNODEJS_ACTIVE_REQUESTS_TOTAL\n];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst nowInSeconds = Math.round(Date.now() / 1000 - process.uptime());\n\nconst PROCESS_START_TIME = 'process_start_time_seconds';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst cpuUserGauge = new Gauge({\n\t\tname: namePrefix + PROCESS_START_TIME,\n\t\thelp: 'Start time of the process since unix epoch in seconds.',\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'omit'\n\t});\n\tlet isSet = false;\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\t\tcpuUserGauge.set(nowInSeconds);\n\t\tisSet = true;\n\t};\n};\n\nmodule.exports.metricNames = [PROCESS_START_TIME];\n","'use strict';\n\nconst Gauge = require('../gauge');\nconst version = process.version;\nconst versionSegments = version\n\t.slice(1)\n\t.split('.')\n\t.map(Number);\n\nconst NODE_VERSION_INFO = 'nodejs_version_info';\n\nmodule.exports = (registry, config = {}) => {\n\tconst namePrefix = config.prefix ? config.prefix : '';\n\n\tconst nodeVersionGauge = new Gauge({\n\t\tname: namePrefix + NODE_VERSION_INFO,\n\t\thelp: 'Node.js version info.',\n\t\tlabelNames: ['version', 'major', 'minor', 'patch'],\n\t\tregisters: registry ? [registry] : undefined,\n\t\taggregator: 'first'\n\t});\n\tlet isSet = false;\n\n\treturn () => {\n\t\tif (isSet) {\n\t\t\treturn;\n\t\t}\n\t\tnodeVersionGauge\n\t\t\t.labels(\n\t\t\t\tversion,\n\t\t\t\tversionSegments[0],\n\t\t\t\tversionSegments[1],\n\t\t\t\tversionSegments[2]\n\t\t\t)\n\t\t\t.set(1);\n\t\tisSet = true;\n\t};\n};\n\nmodule.exports.metricNames = [NODE_VERSION_INFO];\n","'use strict';\n\nconst url = require('url');\nconst http = require('http');\nconst https = require('https');\nconst { globalRegistry } = require('./registry');\n\nclass Pushgateway {\n\tconstructor(gatewayUrl, options, registry) {\n\t\tif (!registry) {\n\t\t\tregistry = globalRegistry;\n\t\t}\n\t\tthis.registry = registry;\n\t\tthis.gatewayUrl = gatewayUrl;\n\t\tthis.requestOptions = Object.assign({}, options);\n\t}\n\n\tpushAdd(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'POST', params.jobName, params.groupings, callback);\n\t}\n\n\tpush(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'PUT', params.jobName, params.groupings, callback);\n\t}\n\n\tdelete(params, callback) {\n\t\tif (!params || !params.jobName) {\n\t\t\tthrow new Error('Missing jobName parameter');\n\t\t}\n\n\t\tuseGateway.call(this, 'DELETE', params.jobName, params.groupings, callback);\n\t}\n}\nfunction useGateway(method, job, groupings, callback) {\n\t// `URL` first added in v6.13.0\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst gatewayUrlParsed = url.parse(this.gatewayUrl);\n\tconst gatewayUrlPath =\n\t\tgatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== '/'\n\t\t\t? gatewayUrlParsed.pathname\n\t\t\t: '';\n\tconst path = `${gatewayUrlPath}/metrics/job/${encodeURIComponent(\n\t\tjob\n\t)}${generateGroupings(groupings)}`;\n\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst target = url.resolve(this.gatewayUrl, path);\n\t// eslint-disable-next-line node/no-deprecated-api\n\tconst requestParams = url.parse(target);\n\tconst httpModule = isHttps(requestParams.href) ? https : http;\n\tconst options = Object.assign(requestParams, this.requestOptions, {\n\t\tmethod\n\t});\n\n\tconst req = httpModule.request(options, res => {\n\t\tlet body = '';\n\t\tres.setEncoding('utf8');\n\t\tres.on('data', chunk => {\n\t\t\tbody += chunk;\n\t\t});\n\t\tres.on('end', () => {\n\t\t\tcallback(null, res, body);\n\t\t});\n\t});\n\treq.on('error', err => {\n\t\tcallback(err);\n\t});\n\n\tif (method !== 'DELETE') {\n\t\treq.write(this.registry.metrics({ timestamps: false }));\n\t}\n\treq.end();\n}\n\nfunction generateGroupings(groupings) {\n\tif (!groupings) {\n\t\treturn '';\n\t}\n\treturn Object.keys(groupings)\n\t\t.map(\n\t\t\tkey => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`\n\t\t)\n\t\t.join('');\n}\n\nfunction isHttps(href) {\n\treturn href.search(/^https/) !== -1;\n}\n\nmodule.exports = Pushgateway;\n","'use strict';\nconst { getValueAsString } = require('./util');\n\nfunction escapeString(str) {\n\treturn str.replace(/\\n/g, '\\\\n').replace(/\\\\(?!n)/g, '\\\\\\\\');\n}\nfunction escapeLabelValue(str) {\n\tif (typeof str !== 'string') {\n\t\treturn str;\n\t}\n\treturn escapeString(str).replace(/\"/g, '\\\\\"');\n}\n\nconst defaultMetricsOpts = {\n\ttimestamps: true\n};\n\nclass Registry {\n\tconstructor() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tgetMetricsAsArray() {\n\t\treturn Object.keys(this._metrics).map(this.getSingleMetric, this);\n\t}\n\n\tgetMetricAsPrometheusString(metric, conf) {\n\t\tconst opts = Object.assign({}, defaultMetricsOpts, conf);\n\t\tconst item = metric.get();\n\t\tconst name = escapeString(item.name);\n\t\tconst help = `# HELP ${name} ${escapeString(item.help)}`;\n\t\tconst type = `# TYPE ${name} ${item.type}`;\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tlet values = '';\n\t\tfor (const val of item.values || []) {\n\t\t\tval.labels = val.labels || {};\n\n\t\t\tif (defaultLabelNames.length > 0) {\n\t\t\t\t// Make a copy before mutating\n\t\t\t\tval.labels = Object.assign({}, val.labels);\n\t\t\t}\n\n\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\tval.labels[labelName] =\n\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t}\n\n\t\t\tlet labels = '';\n\t\t\tfor (const key of Object.keys(val.labels)) {\n\t\t\t\tlabels += `${key}=\"${escapeLabelValue(val.labels[key])}\",`;\n\t\t\t}\n\n\t\t\tlet metricName = val.metricName || item.name;\n\t\t\tif (labels) {\n\t\t\t\tmetricName += `{${labels.substring(0, labels.length - 1)}}`;\n\t\t\t}\n\n\t\t\tlet line = `${metricName} ${getValueAsString(val.value)}`;\n\t\t\tif (opts.timestamps && val.timestamp) {\n\t\t\t\tline += ` ${val.timestamp}`;\n\t\t\t}\n\t\t\tvalues += `${line.trim()}\\n`;\n\t\t}\n\n\t\treturn `${help}\\n${type}\\n${values}`.trim();\n\t}\n\n\tmetrics(opts) {\n\t\tlet metrics = '';\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tmetrics += `${this.getMetricAsPrometheusString(metric, opts)}\\n\\n`;\n\t\t}\n\n\t\treturn metrics.substring(0, metrics.length - 1);\n\t}\n\n\tregisterMetric(metricFn) {\n\t\tif (\n\t\t\tthis._metrics[metricFn.name] &&\n\t\t\tthis._metrics[metricFn.name] !== metricFn\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`A metric with the name ${metricFn.name} has already been registered.`\n\t\t\t);\n\t\t}\n\n\t\tthis._metrics[metricFn.name] = metricFn;\n\t}\n\n\tclear() {\n\t\tthis._metrics = {};\n\t\tthis._defaultLabels = {};\n\t}\n\n\tgetMetricsAsJSON() {\n\t\tconst metrics = [];\n\t\tconst defaultLabelNames = Object.keys(this._defaultLabels);\n\n\t\tfor (const metric of this.getMetricsAsArray()) {\n\t\t\tconst item = metric.get();\n\n\t\t\tif (item.values) {\n\t\t\t\tfor (const val of item.values) {\n\t\t\t\t\tfor (const labelName of defaultLabelNames) {\n\t\t\t\t\t\tval.labels[labelName] =\n\t\t\t\t\t\t\tval.labels[labelName] || this._defaultLabels[labelName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmetrics.push(item);\n\t\t}\n\n\t\treturn metrics;\n\t}\n\n\tremoveSingleMetric(name) {\n\t\tdelete this._metrics[name];\n\t}\n\n\tgetSingleMetricAsString(name) {\n\t\treturn this.getMetricAsPrometheusString(this._metrics[name]);\n\t}\n\n\tgetSingleMetric(name) {\n\t\treturn this._metrics[name];\n\t}\n\n\tsetDefaultLabels(labels) {\n\t\tthis._defaultLabels = labels;\n\t}\n\n\tresetMetrics() {\n\t\tfor (const metric in this._metrics) {\n\t\t\tthis._metrics[metric].reset();\n\t\t}\n\t}\n\n\tget contentType() {\n\t\treturn 'text/plain; version=0.0.4; charset=utf-8';\n\t}\n\n\tstatic merge(registers) {\n\t\tconst mergedRegistry = new Registry();\n\n\t\tconst metricsToMerge = registers.reduce(\n\t\t\t(acc, reg) => acc.concat(reg.getMetricsAsArray()),\n\t\t\t[]\n\t\t);\n\n\t\tmetricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);\n\t\treturn mergedRegistry;\n\t}\n}\n\nmodule.exports = Registry;\nmodule.exports.globalRegistry = new Registry();\n","/**\n * Summary\n */\n'use strict';\n\nconst util = require('util');\nconst { globalRegistry } = require('./registry');\nconst type = 'summary';\nconst {\n\tgetPropertiesFromObj,\n\tgetLabels,\n\thashObject,\n\tisObject,\n\tprintDeprecationObjectConstructor,\n\tremoveLabels\n} = require('./util');\nconst {\n\tvalidateLabel,\n\tvalidateMetricName,\n\tvalidateLabelName\n} = require('./validation');\nconst timeWindowQuantiles = require('./timeWindowQuantiles');\n\nconst DEFAULT_COMPRESS_COUNT = 1000; // every 1000 measurements\n\nclass Summary {\n\t/**\n\t * Summary\n\t * @param {string} name - Name of the metric\n\t * @param {string} help - Help for the metric\n\t * @param {object|Array.<string>} labelsOrConf - Either array of label names or config object as a key-value object\n\t * @param {object} conf - Configuration object\n\t */\n\tconstructor(name, help, labelsOrConf, conf) {\n\t\tlet config;\n\t\tif (isObject(name)) {\n\t\t\tconfig = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tpercentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],\n\t\t\t\t\tlabelNames: []\n\t\t\t\t},\n\t\t\t\tname\n\t\t\t);\n\n\t\t\tif (!config.registers) {\n\t\t\t\tconfig.registers = [globalRegistry];\n\t\t\t}\n\t\t} else {\n\t\t\tlet obj;\n\t\t\tlet labels = [];\n\n\t\t\tif (Array.isArray(labelsOrConf)) {\n\t\t\t\tobj = conf || {};\n\t\t\t\tlabels = labelsOrConf;\n\t\t\t} else {\n\t\t\t\tobj = labelsOrConf || {};\n\t\t\t}\n\n\t\t\tprintDeprecationObjectConstructor();\n\n\t\t\tconfig = {\n\t\t\t\tname,\n\t\t\t\thelp,\n\t\t\t\tlabelNames: labels,\n\t\t\t\tpercentiles: configurePercentiles(obj.percentiles),\n\t\t\t\tregisters: [globalRegistry],\n\t\t\t\tmaxAgeSeconds: obj.maxAgeSeconds,\n\t\t\t\tageBuckets: obj.ageBuckets\n\t\t\t};\n\t\t}\n\n\t\tvalidateInput(config.name, config.help, config.labelNames);\n\n\t\tthis.maxAgeSeconds = config.maxAgeSeconds;\n\t\tthis.ageBuckets = config.ageBuckets;\n\n\t\tthis.name = config.name;\n\t\tthis.help = config.help;\n\t\tthis.aggregator = config.aggregator || 'sum';\n\n\t\tthis.percentiles = config.percentiles;\n\t\tthis.hashMap = {};\n\t\tthis.labelNames = config.labelNames || [];\n\n\t\tthis.compressCount = config.compressCount || DEFAULT_COMPRESS_COUNT;\n\n\t\tif (this.labelNames.length === 0) {\n\t\t\tthis.hashMap = {\n\t\t\t\t[hashObject({})]: {\n\t\t\t\t\tlabels: {},\n\t\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tsum: 0\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tconfig.registers.forEach(registryInstance =>\n\t\t\tregistryInstance.registerMetric(this)\n\t\t);\n\t}\n\n\t/**\n\t * Observe a value\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @param {Number} value - Value to observe\n\t * @returns {void}\n\t */\n\tobserve(labels, value) {\n\t\tobserve.call(this, labels === 0 ? 0 : labels || {})(value);\n\t}\n\n\tget() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tconst values = [];\n\t\tdata.forEach(s => {\n\t\t\textractSummariesForExport(s, this.percentiles).forEach(v => {\n\t\t\t\tvalues.push(v);\n\t\t\t});\n\t\t\tvalues.push(getSumForExport(s, this));\n\t\t\tvalues.push(getCountForExport(s, this));\n\t\t});\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\thelp: this.help,\n\t\t\ttype,\n\t\t\tvalues,\n\t\t\taggregator: this.aggregator\n\t\t};\n\t}\n\n\treset() {\n\t\tconst data = getPropertiesFromObj(this.hashMap);\n\t\tdata.forEach(s => {\n\t\t\ts.td.reset();\n\t\t\ts.count = 0;\n\t\t\ts.sum = 0;\n\t\t});\n\t}\n\n\t/**\n\t * Start a timer that could be used to logging durations\n\t * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep\n\t * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds\n\t * @example\n\t * var end = summary.startTimer();\n\t * makeExpensiveXHRRequest(function(err, res) {\n\t *\tend(); //Observe the duration of expensiveXHRRequest\n\t * });\n\t */\n\tstartTimer(labels) {\n\t\treturn startTimer.call(this, labels)();\n\t}\n\n\tlabels() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\treturn {\n\t\t\tobserve: observe.call(this, labels),\n\t\t\tstartTimer: startTimer.call(this, labels)\n\t\t};\n\t}\n\n\tremove() {\n\t\tconst labels = getLabels(this.labelNames, arguments);\n\t\tremoveLabels.call(this, this.hashMap, labels);\n\t}\n}\n\nfunction extractSummariesForExport(summaryOfLabels, percentiles) {\n\tsummaryOfLabels.td.compress();\n\n\treturn percentiles.map(percentile => {\n\t\tconst percentileValue = summaryOfLabels.td.percentile(percentile);\n\t\treturn {\n\t\t\tlabels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),\n\t\t\tvalue: percentileValue ? percentileValue : 0\n\t\t};\n\t});\n}\n\nfunction getCountForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_count`,\n\t\tlabels: value.labels,\n\t\tvalue: value.count\n\t};\n}\n\nfunction getSumForExport(value, summary) {\n\treturn {\n\t\tmetricName: `${summary.name}_sum`,\n\t\tlabels: value.labels,\n\t\tvalue: value.sum\n\t};\n}\n\nfunction startTimer(startLabels) {\n\treturn () => {\n\t\tconst start = process.hrtime();\n\t\treturn endLabels => {\n\t\t\tconst delta = process.hrtime(start);\n\t\t\tthis.observe(\n\t\t\t\tObject.assign({}, startLabels, endLabels),\n\t\t\t\tdelta[0] + delta[1] / 1e9\n\t\t\t);\n\t\t};\n\t};\n}\n\nfunction validateInput(name, help, labels) {\n\tif (!help) {\n\t\tthrow new Error('Missing mandatory help parameter');\n\t}\n\tif (!name) {\n\t\tthrow new Error('Missing mandatory name parameter');\n\t}\n\n\tif (!validateMetricName(name)) {\n\t\tthrow new Error('Invalid metric name');\n\t}\n\n\tif (!validateLabelName(labels)) {\n\t\tthrow new Error('Invalid label name');\n\t}\n\n\tlabels.forEach(label => {\n\t\tif (label === 'quantile') {\n\t\t\tthrow new Error('quantile is a reserved label keyword');\n\t\t}\n\t});\n}\n\nfunction configurePercentiles(configuredPercentiles) {\n\tconst defaultPercentiles = [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999];\n\treturn []\n\t\t.concat(configuredPercentiles || defaultPercentiles)\n\t\t.sort(sortAscending);\n}\n\nfunction sortAscending(x, y) {\n\treturn x - y;\n}\n\nfunction observe(labels) {\n\treturn value => {\n\t\tconst labelValuePair = convertLabelsAndValues(labels, value);\n\n\t\tvalidateLabel(this.labelNames, this.labels);\n\t\tif (!Number.isFinite(labelValuePair.value)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value is not a valid number: ${util.format(labelValuePair.value)}`\n\t\t\t);\n\t\t}\n\n\t\tconst hash = hashObject(labelValuePair.labels);\n\t\tlet summaryOfLabel = this.hashMap[hash];\n\t\tif (!summaryOfLabel) {\n\t\t\tsummaryOfLabel = {\n\t\t\t\tlabels: labelValuePair.labels,\n\t\t\t\ttd: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),\n\t\t\t\tcount: 0,\n\t\t\t\tsum: 0\n\t\t\t};\n\t\t}\n\n\t\tsummaryOfLabel.td.push(labelValuePair.value);\n\t\tsummaryOfLabel.count++;\n\t\tif (summaryOfLabel.count % this.compressCount === 0) {\n\t\t\tsummaryOfLabel.td.compress();\n\t\t}\n\t\tsummaryOfLabel.sum += labelValuePair.value;\n\t\tthis.hashMap[hash] = summaryOfLabel;\n\t};\n}\n\nfunction convertLabelsAndValues(labels, value) {\n\tif (value === undefined) {\n\t\treturn {\n\t\t\tvalue: labels,\n\t\t\tlabels: {}\n\t\t};\n\t}\n\n\treturn {\n\t\tlabels,\n\t\tvalue\n\t};\n}\n\nmodule.exports = Summary;\n","'use strict';\n\nconst { TDigest } = require('tdigest');\n\nclass TimeWindowQuantiles {\n\tconstructor(maxAgeSeconds, ageBuckets) {\n\t\tthis.maxAgeSeconds = maxAgeSeconds || 0;\n\t\tthis.ageBuckets = ageBuckets || 0;\n\n\t\tthis.shouldRotate = maxAgeSeconds && ageBuckets;\n\n\t\tthis.ringBuffer = Array(ageBuckets).fill(new TDigest());\n\t\tthis.currentBuffer = 0;\n\n\t\tthis.lastRotateTimestampMillis = Date.now();\n\t\tthis.durationBetweenRotatesMillis =\n\t\t\t(maxAgeSeconds * 1000) / ageBuckets || Infinity;\n\t}\n\n\tpercentile(quantile) {\n\t\tconst bucket = rotate.call(this);\n\t\treturn bucket.percentile(quantile);\n\t}\n\n\tpush(value) {\n\t\trotate.call(this);\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.push(value);\n\t\t});\n\t}\n\n\treset() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.reset();\n\t\t});\n\t}\n\n\tcompress() {\n\t\tthis.ringBuffer.forEach(bucket => {\n\t\t\tbucket.compress();\n\t\t});\n\t}\n}\n\nfunction rotate() {\n\tlet timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;\n\twhile (\n\t\ttimeSinceLastRotateMillis > this.durationBetweenRotatesMillis &&\n\t\tthis.shouldRotate\n\t) {\n\t\tthis.ringBuffer[this.currentBuffer] = new TDigest();\n\n\t\tif (++this.currentBuffer >= this.ringBuffer.length) {\n\t\t\tthis.currentBuffer = 0;\n\t\t}\n\t\ttimeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;\n\t\tthis.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;\n\t}\n\treturn this.ringBuffer[this.currentBuffer];\n}\n\nmodule.exports = TimeWindowQuantiles;\n","'use strict';\n\nconst deprecationsEmitted = {};\n\nexports.isDate = isDate;\n\nexports.getPropertiesFromObj = function(hashMap) {\n\tconst obj = Object.keys(hashMap).map(x => hashMap[x]);\n\treturn obj;\n};\n\nexports.getValueAsString = function getValueString(value) {\n\tif (Number.isNaN(value)) {\n\t\treturn 'Nan';\n\t} else if (!Number.isFinite(value)) {\n\t\tif (value < 0) {\n\t\t\treturn '-Inf';\n\t\t} else {\n\t\t\treturn '+Inf';\n\t\t}\n\t} else {\n\t\treturn `${value}`;\n\t}\n};\n\nexports.removeLabels = function removeLabels(hashMap, labels) {\n\tconst hash = hashObject(labels);\n\tdelete hashMap[hash];\n};\n\nexports.setValue = function setValue(hashMap, value, labels, timestamp) {\n\tconst hash = hashObject(labels);\n\thashMap[hash] = {\n\t\tvalue: typeof value === 'number' ? value : 0,\n\t\tlabels: labels || {},\n\t\ttimestamp: isDate(timestamp)\n\t\t\t? timestamp.valueOf()\n\t\t\t: Number.isFinite(timestamp)\n\t\t\t? timestamp\n\t\t\t: undefined\n\t};\n\treturn hashMap;\n};\n\n// TODO: For node 6, use rest params\nexports.getLabels = function(labelNames, args) {\n\tif (labelNames.length !== args.length) {\n\t\tthrow new Error('Invalid number of arguments');\n\t}\n\n\tconst argsAsArray = Array.prototype.slice.call(args);\n\treturn labelNames.reduce((acc, label, index) => {\n\t\tacc[label] = argsAsArray[index];\n\t\treturn acc;\n\t}, {});\n};\n\nfunction hashObject(labels) {\n\t// We don't actually need a hash here. We just need a string that\n\t// is unique for each possible labels object and consistent across\n\t// calls with equivalent labels objects.\n\tlet keys = Object.keys(labels);\n\tif (keys.length === 0) {\n\t\treturn '';\n\t}\n\t// else\n\tif (keys.length > 1) {\n\t\tkeys = keys.sort(); // need consistency across calls\n\t}\n\n\tlet hash = '';\n\tlet i = 0;\n\tconst size = keys.length;\n\tfor (; i < size - 1; i++) {\n\t\thash += `${keys[i]}:${labels[keys[i]]},`;\n\t}\n\thash += `${keys[i]}:${labels[keys[i]]}`;\n\treturn hash;\n}\nexports.hashObject = hashObject;\n\nfunction isDate(obj) {\n\treturn obj instanceof Date && !isNaN(obj.valueOf());\n}\nexports.isObject = function isObject(obj) {\n\treturn obj === Object(obj);\n};\n\nfunction printDeprecation(msg) {\n\tif (deprecationsEmitted[msg]) {\n\t\treturn;\n\t}\n\n\tdeprecationsEmitted[msg] = true;\n\n\tif (process.emitWarning) {\n\t\tprocess.emitWarning(msg, 'DeprecationWarning');\n\t} else {\n\t\t// Check can be removed when we only support node@>=6\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(new Error(msg));\n\t}\n}\n\nexports.printDeprecationObjectConstructor = () => {\n\tprintDeprecation(\n\t\t'prom-client - Passing a non-object to metrics constructor is deprecated'\n\t);\n};\n\nexports.printDeprecationCollectDefaultMetricsNumber = timeout => {\n\tprintDeprecation(\n\t\t`prom-client - A number to defaultMetrics is deprecated, please use \\`collectDefaultMetrics({ timeout: ${timeout} })\\`.`\n\t);\n};\n\nclass Grouper extends Map {\n\t/**\n\t * Adds the `value` to the `key`'s array of values.\n\t * @param {*} key Key to set.\n\t * @param {*} value Value to add to `key`'s array.\n\t * @returns {undefined} undefined.\n\t */\n\tadd(key, value) {\n\t\tif (this.has(key)) {\n\t\t\tthis.get(key).push(value);\n\t\t} else {\n\t\t\tthis.set(key, [value]);\n\t\t}\n\t}\n}\n\nexports.Grouper = Grouper;\n","'use strict';\n\nconst util = require('util');\n\n// These are from https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels\nconst metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;\nconst labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\nexports.validateMetricName = function(name) {\n\treturn metricRegexp.test(name);\n};\n\nexports.validateLabelName = function(names) {\n\tlet valid = true;\n\t(names || []).forEach(name => {\n\t\tif (!labelRegexp.test(name)) {\n\t\t\tvalid = false;\n\t\t}\n\t});\n\treturn valid;\n};\n\nexports.validateLabel = function validateLabel(savedLabels, labels) {\n\tObject.keys(labels).forEach(label => {\n\t\tif (savedLabels.indexOf(label) === -1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Added label \"${label}\" is not included in initial labelset: ${util.inspect(\n\t\t\t\t\tsavedLabels\n\t\t\t\t)}`\n\t\t\t);\n\t\t}\n\t});\n};\n","/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr\nmodule.exports.all = alladdrs\nmodule.exports.compile = compile\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded')\nvar ipaddr = require('ipaddr.js')\n\n/**\n * Variables.\n * @private\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/\nvar isip = ipaddr.isValid\nvar parseip = ipaddr.parse\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n}\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs (req, trust) {\n  // get addresses\n  var addrs = forwarded(req)\n\n  if (!trust) {\n    // Return all addresses\n    return addrs\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust)\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue\n\n    addrs.length = i + 1\n  }\n\n  return addrs\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile (val) {\n  if (!val) {\n    throw new TypeError('argument is required')\n  }\n\n  var trust\n\n  if (typeof val === 'string') {\n    trust = [val]\n  } else if (Array.isArray(val)) {\n    trust = val.slice()\n  } else {\n    throw new TypeError('unsupported trust argument')\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i]\n\n    if (!IP_RANGES.hasOwnProperty(val)) {\n      continue\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val]\n    trust.splice.apply(trust, [i, 1].concat(val))\n    i += val.length - 1\n  }\n\n  return compileTrust(compileRangeSubnets(trust))\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets (arr) {\n  var rangeSubnets = new Array(arr.length)\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i])\n  }\n\n  return rangeSubnets\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust (rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length\n  return len === 0\n    ? trustNone\n    : len === 1\n      ? trustSingle(rangeSubnets[0])\n      : trustMulti(rangeSubnets)\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation (note) {\n  var pos = note.lastIndexOf('/')\n  var str = pos !== -1\n    ? note.substring(0, pos)\n    : note\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str)\n  }\n\n  var ip = parseip(str)\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address()\n  }\n\n  var max = ip.kind() === 'ipv6'\n    ? 128\n    : 32\n\n  var range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : null\n\n  if (range === null) {\n    range = max\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10)\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range)\n  } else {\n    range = null\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note)\n  }\n\n  return [ip, range]\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask (netmask) {\n  var ip = parseip(netmask)\n  var kind = ip.kind()\n\n  return kind === 'ipv4'\n    ? ip.prefixLengthFromSubnetMask()\n    : null\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr (req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required')\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required')\n  }\n\n  var addrs = alladdrs(req, trust)\n  var addr = addrs[addrs.length - 1]\n\n  return addr\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone () {\n  return false\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti (subnets) {\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var ipconv\n    var kind = ip.kind()\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i]\n      var subnetip = subnet[0]\n      var subnetkind = subnetip.kind()\n      var subnetrange = subnet[1]\n      var trusted = ip\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4'\n            ? ip.toIPv4Address()\n            : ip.toIPv4MappedAddress()\n        }\n\n        trusted = ipconv\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle (subnet) {\n  var subnetip = subnet[0]\n  var subnetkind = subnetip.kind()\n  var subnetisipv4 = subnetkind === 'ipv4'\n  var subnetrange = subnet[1]\n\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var kind = ip.kind()\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4\n        ? ip.toIPv4Address()\n        : ip.toIPv4MappedAddress()\n    }\n\n    return ip.match(subnetip, subnetrange)\n  }\n}\n","'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nmodule.exports = {\n    'default': 'RFC3986',\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return value;\n        }\n    },\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n","'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n","'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\n// This is what browsers will submit when the ✓ character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the ✓ character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);\n            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(val);\n        }\n\n        if (val && options.comma && val.indexOf(',') > -1) {\n            val = val.split(',');\n        }\n\n        if (has.call(obj, key)) {\n            obj[key] = utils.combine(obj[key], val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n    var leaf = val;\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = [].concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (!options.parseArrays && cleanRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    return {\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar formats = require('./formats');\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    formatter: formats.formatters[formats['default']],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar stringify = function stringify( // eslint-disable-line func-name-matching\n    object,\n    prefix,\n    generateArrayPrefix,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    formatter,\n    encodeValuesOnly,\n    charset\n) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = obj.join(',');\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (isArray(obj)) {\n            pushToArray(values, stringify(\n                obj[key],\n                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        } else {\n            pushToArray(values, stringify(\n                obj[key],\n                prefix + (allowDots ? '.' + key : '[' + key + ']'),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        }\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if (opts && 'indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('✓')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, decoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar encode = function encode(str, defaultEncoder, charset) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    merge: merge\n};\n","/*!\n * range-parser\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = rangeParser\n\n/**\n * Parse \"Range\" header `str` relative to the given file `size`.\n *\n * @param {Number} size\n * @param {String} str\n * @param {Object} [options]\n * @return {Array}\n * @public\n */\n\nfunction rangeParser (size, str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string')\n  }\n\n  var index = str.indexOf('=')\n\n  if (index === -1) {\n    return -2\n  }\n\n  // split the range string\n  var arr = str.slice(index + 1).split(',')\n  var ranges = []\n\n  // add ranges type\n  ranges.type = str.slice(0, index)\n\n  // parse all ranges\n  for (var i = 0; i < arr.length; i++) {\n    var range = arr[i].split('-')\n    var start = parseInt(range[0], 10)\n    var end = parseInt(range[1], 10)\n\n    // -nnn\n    if (isNaN(start)) {\n      start = size - end\n      end = size - 1\n    // nnn-\n    } else if (isNaN(end)) {\n      end = size - 1\n    }\n\n    // limit last-byte-pos to current length\n    if (end > size - 1) {\n      end = size - 1\n    }\n\n    // invalid or unsatisifiable\n    if (isNaN(start) || isNaN(end) || start > end || start < 0) {\n      continue\n    }\n\n    // add range\n    ranges.push({\n      start: start,\n      end: end\n    })\n  }\n\n  if (ranges.length < 1) {\n    // unsatisifiable\n    return -1\n  }\n\n  return options && options.combine\n    ? combineRanges(ranges)\n    : ranges\n}\n\n/**\n * Combine overlapping & adjacent ranges.\n * @private\n */\n\nfunction combineRanges (ranges) {\n  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)\n\n  for (var j = 0, i = 1; i < ordered.length; i++) {\n    var range = ordered[i]\n    var current = ordered[j]\n\n    if (range.start > current.end + 1) {\n      // next range\n      ordered[++j] = range\n    } else if (range.end > current.end) {\n      // extend range\n      current.end = range.end\n      current.index = Math.min(current.index, range.index)\n    }\n  }\n\n  // trim ordered array\n  ordered.length = j + 1\n\n  // generate combined range\n  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)\n\n  // copy ranges type\n  combined.type = ranges.type\n\n  return combined\n}\n\n/**\n * Map function to add index value to ranges.\n * @private\n */\n\nfunction mapWithIndex (range, index) {\n  return {\n    start: range.start,\n    end: range.end,\n    index: index\n  }\n}\n\n/**\n * Map function to remove index value from ranges.\n * @private\n */\n\nfunction mapWithoutIndex (range) {\n  return {\n    start: range.start,\n    end: range.end\n  }\n}\n\n/**\n * Sort function to sort ranges by index.\n * @private\n */\n\nfunction sortByRangeIndex (a, b) {\n  return a.index - b.index\n}\n\n/**\n * Sort function to sort ranges by start position.\n * @private\n */\n\nfunction sortByRangeStart (a, b) {\n  return a.start - b.start\n}\n","/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar createError = require('http-errors')\nvar iconv = require('iconv-lite')\nvar unpipe = require('unpipe')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder (encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody (stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, done)\n  }\n\n  return new Promise(function executor (resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt (stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream (stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done () {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback () {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted () {\n    if (complete) return\n\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }))\n  }\n\n  function onData (chunk) {\n    if (complete) return\n\n    received += chunk.length\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }))\n    } else if (decoder) {\n      buffer += decoder.write(chunk)\n    } else {\n      buffer.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      done(null, string)\n    }\n  }\n\n  function cleanup () {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { observable } from './internal/symbol/observable';\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\nexport { asap as asapScheduler } from './internal/scheduler/asap';\nexport { async as asyncScheduler } from './internal/scheduler/async';\nexport { queue as queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame as animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\nexport { Notification, NotificationKind } from './internal/Notification';\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\nexport { TimeoutError } from './internal/util/TimeoutError';\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\nexport { config } from './internal/config';\n//# sourceMappingURL=index.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { Subscription } from './Subscription';\nvar AsyncSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.value = null;\n        _this.hasNext = false;\n        _this.hasCompleted = false;\n        return _this;\n    }\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject));\nexport { AsyncSubject };\n//# sourceMappingURL=AsyncSubject.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nvar BehaviorSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject));\nexport { BehaviorSubject };\n//# sourceMappingURL=BehaviorSubject.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from './Subscriber';\nvar InnerSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        _this.outerValue = outerValue;\n        _this.outerIndex = outerIndex;\n        _this.index = 0;\n        return _this;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber));\nexport { InnerSubscriber };\n//# sourceMappingURL=InnerSubscriber.js.map\n","/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */\nimport { empty } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nexport var NotificationKind;\n/*@__PURE__*/ (function (NotificationKind) {\n    NotificationKind[\"NEXT\"] = \"N\";\n    NotificationKind[\"ERROR\"] = \"E\";\n    NotificationKind[\"COMPLETE\"] = \"C\";\n})(NotificationKind || (NotificationKind = {}));\nvar Notification = /*@__PURE__*/ (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return of(this.value);\n            case 'E':\n                return throwError(this.error);\n            case 'C':\n                return empty();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\nexport { Notification };\n//# sourceMappingURL=Notification.js.map\n","/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\nimport { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nvar Observable = /*@__PURE__*/ (function () {\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            sink.add(operator.call(sink, this.source));\n        }\n        else {\n            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n                this._subscribe(sink) :\n                this._trySubscribe(sink));\n        }\n        if (config.useDeprecatedSynchronousErrorHandling) {\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                sink.syncErrorThrown = true;\n                sink.syncErrorValue = err;\n            }\n            if (canReportError(sink)) {\n                sink.error(err);\n            }\n            else {\n                console.warn(err);\n            }\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                try {\n                    next(value);\n                }\n                catch (err) {\n                    reject(err);\n                    if (subscription) {\n                        subscription.unsubscribe();\n                    }\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        return source && source.subscribe(subscriber);\n    };\n    Observable.prototype[Symbol_observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexport { Observable };\nfunction getPromiseCtor(promiseCtor) {\n    if (!promiseCtor) {\n        promiseCtor = config.Promise || Promise;\n    }\n    if (!promiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return promiseCtor;\n}\n//# sourceMappingURL=Observable.js.map\n","/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\nexport var empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) {\n        if (config.useDeprecatedSynchronousErrorHandling) {\n            throw err;\n        }\n        else {\n            hostReportError(err);\n        }\n    },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from './Subscriber';\nvar OuterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber));\nexport { OuterSubscriber };\n//# sourceMappingURL=OuterSubscriber.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nvar ReplaySubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) {\n            bufferSize = Number.POSITIVE_INFINITY;\n        }\n        if (windowTime === void 0) {\n            windowTime = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this) || this;\n        _this.scheduler = scheduler;\n        _this._events = [];\n        _this._infiniteTimeWindow = false;\n        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        _this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            _this._infiniteTimeWindow = true;\n            _this.next = _this.nextInfiniteTimeWindow;\n        }\n        else {\n            _this.next = _this.nextTimeWindow;\n        }\n        return _this;\n    }\n    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n        var _events = this._events;\n        _events.push(value);\n        if (_events.length > this._bufferSize) {\n            _events.shift();\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype.nextTimeWindow = function (value) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _infiniteTimeWindow = this._infiniteTimeWindow;\n        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var len = _events.length;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject));\nexport { ReplaySubject };\nvar ReplayEvent = /*@__PURE__*/ (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n","var Scheduler = /*@__PURE__*/ (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = function () { return Date.now(); };\n    return Scheduler;\n}());\nexport { Scheduler };\n//# sourceMappingURL=Scheduler.js.map\n","/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nvar SubjectSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        return _this;\n    }\n    return SubjectSubscriber;\n}(Subscriber));\nexport { SubjectSubscriber };\nvar Subject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.observers = [];\n        _this.closed = false;\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype[rxSubscriberSymbol] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable));\nexport { Subject };\nvar AnonymousSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexport { AnonymousSubject };\n//# sourceMappingURL=Subject.js.map\n","/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscription } from './Subscription';\nvar SubjectSubscription = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        var _this = _super.call(this) || this;\n        _this.subject = subject;\n        _this.subscriber = subscriber;\n        _this.closed = false;\n        return _this;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription));\nexport { SubjectSubscription };\n//# sourceMappingURL=SubjectSubscription.js.map\n","/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\nvar Subscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Subscriber, _super);\n    function Subscriber(destinationOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        _this.syncErrorValue = null;\n        _this.syncErrorThrown = false;\n        _this.syncErrorThrowable = false;\n        _this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                _this.destination = emptyObserver;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    _this.destination = emptyObserver;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n                        _this.destination = destinationOrNext;\n                        destinationOrNext.add(_this);\n                    }\n                    else {\n                        _this.syncErrorThrowable = true;\n                        _this.destination = new SafeSubscriber(_this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                _this.syncErrorThrowable = true;\n                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n                break;\n        }\n        return _this;\n    }\n    Subscriber.prototype[rxSubscriberSymbol] = function () { return this; };\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _parentOrParents = this._parentOrParents;\n        this._parentOrParents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parentOrParents = _parentOrParents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription));\nexport { Subscriber };\nvar SafeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        _this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = _this;\n        if (isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== emptyObserver) {\n                context = Object.create(observerOrNext);\n                if (isFunction(context.unsubscribe)) {\n                    _this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = _this.unsubscribe.bind(_this);\n            }\n        }\n        _this._context = context;\n        _this._next = next;\n        _this._error = error;\n        _this._complete = complete;\n        return _this;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n            if (this._error) {\n                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                if (useDeprecatedSynchronousErrorHandling) {\n                    throw err;\n                }\n                hostReportError(err);\n            }\n            else {\n                if (useDeprecatedSynchronousErrorHandling) {\n                    _parentSubscriber.syncErrorValue = err;\n                    _parentSubscriber.syncErrorThrown = true;\n                }\n                else {\n                    hostReportError(err);\n                }\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                throw err;\n            }\n            else {\n                hostReportError(err);\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        if (!config.useDeprecatedSynchronousErrorHandling) {\n            throw new Error('bad call');\n        }\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            else {\n                hostReportError(err);\n                return true;\n            }\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\nexport { SafeSubscriber };\n//# sourceMappingURL=Subscriber.js.map\n","/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */\nimport { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nvar Subscription = /*@__PURE__*/ (function () {\n    function Subscription(unsubscribe) {\n        this.closed = false;\n        this._parentOrParents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parentOrParents = null;\n        this._subscriptions = null;\n        if (_parentOrParents instanceof Subscription) {\n            _parentOrParents.remove(this);\n        }\n        else if (_parentOrParents !== null) {\n            for (var index = 0; index < _parentOrParents.length; ++index) {\n                var parent_1 = _parentOrParents[index];\n                parent_1.remove(this);\n            }\n        }\n        if (isFunction(_unsubscribe)) {\n            try {\n                _unsubscribe.call(this);\n            }\n            catch (e) {\n                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n            }\n        }\n        if (isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject(sub)) {\n                    try {\n                        sub.unsubscribe();\n                    }\n                    catch (e) {\n                        errors = errors || [];\n                        if (e instanceof UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n                        }\n                        else {\n                            errors.push(e);\n                        }\n                    }\n                }\n            }\n        }\n        if (errors) {\n            throw new UnsubscriptionError(errors);\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var subscription = teardown;\n        if (!teardown) {\n            return Subscription.EMPTY;\n        }\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (!(subscription instanceof Subscription)) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default: {\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n            }\n        }\n        var _parentOrParents = subscription._parentOrParents;\n        if (_parentOrParents === null) {\n            subscription._parentOrParents = this;\n        }\n        else if (_parentOrParents instanceof Subscription) {\n            if (_parentOrParents === this) {\n                return subscription;\n            }\n            subscription._parentOrParents = [_parentOrParents, this];\n        }\n        else if (_parentOrParents.indexOf(this) === -1) {\n            _parentOrParents.push(this);\n        }\n        else {\n            return subscription;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions === null) {\n            this._subscriptions = [subscription];\n        }\n        else {\n            subscriptions.push(subscription);\n        }\n        return subscription;\n    };\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexport { Subscription };\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nexport var config = {\n    Promise: undefined,\n    set useDeprecatedSynchronousErrorHandling(value) {\n        if (value) {\n            var error = /*@__PURE__*/ new Error();\n            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n        }\n        else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');\n        }\n        _enable_super_gross_mode_that_will_cause_bad_things = value;\n    },\n    get useDeprecatedSynchronousErrorHandling() {\n        return _enable_super_gross_mode_that_will_cause_bad_things;\n    },\n};\n//# sourceMappingURL=config.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nvar ConnectableObservable = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        var _this = _super.call(this) || this;\n        _this.source = source;\n        _this.subjectFactory = subjectFactory;\n        _this._refCount = 0;\n        _this._isComplete = false;\n        return _this;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription.EMPTY;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return higherOrderRefCount()(this);\n    };\n    return ConnectableObservable;\n}(Observable));\nexport { ConnectableObservable };\nvar connectableProto = ConnectableObservable.prototype;\nexport var connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null, writable: true },\n    _connection: { value: null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n};\nvar ConnectableSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(SubjectSubscriber));\nvar RefCountOperator = /*@__PURE__*/ (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n","/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Observable } from '../Observable';\nimport { asap } from '../scheduler/asap';\nimport { isNumeric } from '../util/isNumeric';\nvar SubscribeOnObservable = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SubscribeOnObservable, _super);\n    function SubscribeOnObservable(source, delayTime, scheduler) {\n        if (delayTime === void 0) {\n            delayTime = 0;\n        }\n        if (scheduler === void 0) {\n            scheduler = asap;\n        }\n        var _this = _super.call(this) || this;\n        _this.source = source;\n        _this.delayTime = delayTime;\n        _this.scheduler = scheduler;\n        if (!isNumeric(delayTime) || delayTime < 0) {\n            _this.delayTime = 0;\n        }\n        if (!scheduler || typeof scheduler.schedule !== 'function') {\n            _this.scheduler = asap;\n        }\n        return _this;\n    }\n    SubscribeOnObservable.create = function (source, delay, scheduler) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (scheduler === void 0) {\n            scheduler = asap;\n        }\n        return new SubscribeOnObservable(source, delay, scheduler);\n    };\n    SubscribeOnObservable.dispatch = function (arg) {\n        var source = arg.source, subscriber = arg.subscriber;\n        return this.add(source.subscribe(subscriber));\n    };\n    SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n        var delay = this.delayTime;\n        var source = this.source;\n        var scheduler = this.scheduler;\n        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n            source: source, subscriber: subscriber\n        });\n    };\n    return SubscribeOnObservable;\n}(Observable));\nexport { SubscribeOnObservable };\n//# sourceMappingURL=SubscribeOnObservable.js.map\n","/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isArray } from '../util/isArray';\nimport { isScheduler } from '../util/isScheduler';\nexport function bindCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\n            };\n        }\n    }\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var context = this;\n        var subject;\n        var params = {\n            context: context,\n            subject: subject,\n            callbackFunc: callbackFunc,\n            scheduler: scheduler,\n        };\n        return new Observable(function (subscriber) {\n            if (!scheduler) {\n                if (!subject) {\n                    subject = new AsyncSubject();\n                    var handler = function () {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, args.concat([handler]));\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                var state = {\n                    args: args, subscriber: subscriber, params: params,\n                };\n                return scheduler.schedule(dispatch, 0, state);\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    var _this = this;\n    var self = this;\n    var args = state.args, subscriber = state.subscriber, params = state.params;\n    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;\n    var subject = params.subject;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        var handler = function () {\n            var innerArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                innerArgs[_i] = arguments[_i];\n            }\n            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n        };\n        try {\n            callbackFunc.apply(context, args.concat([handler]));\n        }\n        catch (err) {\n            subject.error(err);\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(state) {\n    var value = state.value, subject = state.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(state) {\n    var err = state.err, subject = state.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=bindCallback.js.map\n","/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\n            };\n        }\n    }\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var params = {\n            subject: undefined,\n            args: args,\n            callbackFunc: callbackFunc,\n            scheduler: scheduler,\n            context: this,\n        };\n        return new Observable(function (subscriber) {\n            var context = params.context;\n            var subject = params.subject;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = params.subject = new AsyncSubject();\n                    var handler = function () {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        var err = innerArgs.shift();\n                        if (err) {\n                            subject.error(err);\n                            return;\n                        }\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, args.concat([handler]));\n                    }\n                    catch (err) {\n                        if (canReportError(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    var _this = this;\n    var params = state.params, subscriber = state.subscriber, context = state.context;\n    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;\n    var subject = params.subject;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject();\n        var handler = function () {\n            var innerArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                innerArgs[_i] = arguments[_i];\n            }\n            var err = innerArgs.shift();\n            if (err) {\n                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n            }\n            else {\n                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n            }\n        };\n        try {\n            callbackFunc.apply(context, args.concat([handler]));\n        }\n        catch (err) {\n            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(arg) {\n    var value = arg.value, subject = arg.subject;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subject = arg.subject;\n    subject.error(err);\n}\n//# sourceMappingURL=bindNodeCallback.js.map\n","/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { fromArray } from './fromArray';\nvar NONE = {};\nexport function combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    var resultSelector = null;\n    var scheduler = null;\n    if (isScheduler(observables[observables.length - 1])) {\n        scheduler = observables.pop();\n    }\n    if (typeof observables[observables.length - 1] === 'function') {\n        resultSelector = observables.pop();\n    }\n    if (observables.length === 1 && isArray(observables[0])) {\n        observables = observables[0];\n    }\n    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));\n}\nvar CombineLatestOperator = /*@__PURE__*/ (function () {\n    function CombineLatestOperator(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));\n    };\n    return CombineLatestOperator;\n}());\nexport { CombineLatestOperator };\nvar CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, resultSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.resultSelector = resultSelector;\n        _this.active = 0;\n        _this.values = [];\n        _this.observables = [];\n        return _this;\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(NONE);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === NONE ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.resultSelector) {\n                this._tryResultSelector(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {\n        var result;\n        try {\n            result = this.resultSelector.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber));\nexport { CombineLatestSubscriber };\n//# sourceMappingURL=combineLatest.js.map\n","/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */\nimport { of } from './of';\nimport { concatAll } from '../operators/concatAll';\nexport function concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return concatAll()(of.apply(void 0, observables));\n}\n//# sourceMappingURL=concat.js.map\n","/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { empty } from './empty';\nexport function defer(observableFactory) {\n    return new Observable(function (subscriber) {\n        var input;\n        try {\n            input = observableFactory();\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        var source = input ? from(input) : empty();\n        return source.subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=defer.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n//# sourceMappingURL=empty.js.map\n","/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { from } from './from';\nexport function forkJoin() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    if (sources.length === 1) {\n        var first_1 = sources[0];\n        if (isArray(first_1)) {\n            return forkJoinInternal(first_1, null);\n        }\n        if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {\n            var keys = Object.keys(first_1);\n            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);\n        }\n    }\n    if (typeof sources[sources.length - 1] === 'function') {\n        var resultSelector_1 = sources.pop();\n        sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;\n        return forkJoinInternal(sources, null).pipe(map(function (args) { return resultSelector_1.apply(void 0, args); }));\n    }\n    return forkJoinInternal(sources, null);\n}\nfunction forkJoinInternal(sources, keys) {\n    return new Observable(function (subscriber) {\n        var len = sources.length;\n        if (len === 0) {\n            subscriber.complete();\n            return;\n        }\n        var values = new Array(len);\n        var completed = 0;\n        var emitted = 0;\n        var _loop_1 = function (i) {\n            var source = from(sources[i]);\n            var hasValue = false;\n            subscriber.add(source.subscribe({\n                next: function (value) {\n                    if (!hasValue) {\n                        hasValue = true;\n                        emitted++;\n                    }\n                    values[i] = value;\n                },\n                error: function (err) { return subscriber.error(err); },\n                complete: function () {\n                    completed++;\n                    if (completed === len || !hasValue) {\n                        if (emitted === len) {\n                            subscriber.next(keys ?\n                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :\n                                values);\n                        }\n                        subscriber.complete();\n                    }\n                }\n            }));\n        };\n        for (var i = 0; i < len; i++) {\n            _loop_1(i);\n        }\n    });\n}\n//# sourceMappingURL=forkJoin.js.map\n","/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { scheduled } from '../scheduled/scheduled';\nexport function from(input, scheduler) {\n    if (!scheduler) {\n        if (input instanceof Observable) {\n            return input;\n        }\n        return new Observable(subscribeTo(input));\n    }\n    else {\n        return scheduled(input, scheduler);\n    }\n}\n//# sourceMappingURL=from.js.map\n","/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { subscribeToArray } from '../util/subscribeToArray';\nimport { scheduleArray } from '../scheduled/scheduleArray';\nexport function fromArray(input, scheduler) {\n    if (!scheduler) {\n        return new Observable(subscribeToArray(input));\n    }\n    else {\n        return scheduleArray(input, scheduler);\n    }\n}\n//# sourceMappingURL=fromArray.js.map\n","/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nvar toString = Object.prototype.toString;\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\n    }\n    return new Observable(function (subscriber) {\n        function handler(e) {\n            if (arguments.length > 1) {\n                subscriber.next(Array.prototype.slice.call(arguments));\n            }\n            else {\n                subscriber.next(e);\n            }\n        }\n        setupSubscription(target, eventName, handler, subscriber, options);\n    });\n}\nfunction setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n    var unsubscribe;\n    if (isEventTarget(sourceObj)) {\n        var source_1 = sourceObj;\n        sourceObj.addEventListener(eventName, handler, options);\n        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };\n    }\n    else if (isJQueryStyleEventEmitter(sourceObj)) {\n        var source_2 = sourceObj;\n        sourceObj.on(eventName, handler);\n        unsubscribe = function () { return source_2.off(eventName, handler); };\n    }\n    else if (isNodeStyleEventEmitter(sourceObj)) {\n        var source_3 = sourceObj;\n        sourceObj.addListener(eventName, handler);\n        unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n    }\n    else if (sourceObj && sourceObj.length) {\n        for (var i = 0, len = sourceObj.length; i < len; i++) {\n            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n        }\n    }\n    else {\n        throw new TypeError('Invalid event target');\n    }\n    subscriber.add(unsubscribe);\n}\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isEventTarget(sourceObj) {\n    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n//# sourceMappingURL=fromEvent.js.map\n","/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { isFunction } from '../util/isFunction';\nimport { map } from '../operators/map';\nexport function fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));\n    }\n    return new Observable(function (subscriber) {\n        var handler = function () {\n            var e = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                e[_i] = arguments[_i];\n            }\n            return subscriber.next(e.length === 1 ? e[0] : e);\n        };\n        var retValue;\n        try {\n            retValue = addHandler(handler);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!isFunction(removeHandler)) {\n            return undefined;\n        }\n        return function () { return removeHandler(handler, retValue); };\n    });\n}\n//# sourceMappingURL=fromEventPattern.js.map\n","/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n    var resultSelector;\n    var initialState;\n    if (arguments.length == 1) {\n        var options = initialStateOrOptions;\n        initialState = options.initialState;\n        condition = options.condition;\n        iterate = options.iterate;\n        resultSelector = options.resultSelector || identity;\n        scheduler = options.scheduler;\n    }\n    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n        initialState = initialStateOrOptions;\n        resultSelector = identity;\n        scheduler = resultSelectorOrObservable;\n    }\n    else {\n        initialState = initialStateOrOptions;\n        resultSelector = resultSelectorOrObservable;\n    }\n    return new Observable(function (subscriber) {\n        var state = initialState;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                subscriber: subscriber,\n                iterate: iterate,\n                condition: condition,\n                resultSelector: resultSelector,\n                state: state\n            });\n        }\n        do {\n            if (condition) {\n                var conditionResult = void 0;\n                try {\n                    conditionResult = condition(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return undefined;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    break;\n                }\n            }\n            var value = void 0;\n            try {\n                value = resultSelector(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                break;\n            }\n            try {\n                state = iterate(state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return undefined;\n            }\n        } while (true);\n        return undefined;\n    });\n}\nfunction dispatch(state) {\n    var subscriber = state.subscriber, condition = state.condition;\n    if (subscriber.closed) {\n        return undefined;\n    }\n    if (state.needIterate) {\n        try {\n            state.state = state.iterate(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n    }\n    else {\n        state.needIterate = true;\n    }\n    if (condition) {\n        var conditionResult = void 0;\n        try {\n            conditionResult = condition(state.state);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!conditionResult) {\n            subscriber.complete();\n            return undefined;\n        }\n        if (subscriber.closed) {\n            return undefined;\n        }\n    }\n    var value;\n    try {\n        value = state.resultSelector(state.state);\n    }\n    catch (err) {\n        subscriber.error(err);\n        return undefined;\n    }\n    if (subscriber.closed) {\n        return undefined;\n    }\n    subscriber.next(value);\n    if (subscriber.closed) {\n        return undefined;\n    }\n    return this.schedule(state);\n}\n//# sourceMappingURL=generate.js.map\n","/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */\nimport { defer } from './defer';\nimport { EMPTY } from './empty';\nexport function iif(condition, trueResult, falseResult) {\n    if (trueResult === void 0) {\n        trueResult = EMPTY;\n    }\n    if (falseResult === void 0) {\n        falseResult = EMPTY;\n    }\n    return defer(function () { return condition() ? trueResult : falseResult; });\n}\n//# sourceMappingURL=iif.js.map\n","/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period, scheduler) {\n    if (period === void 0) {\n        period = 0;\n    }\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    if (!isNumeric(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = async;\n    }\n    return new Observable(function (subscriber) {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    var subscriber = state.subscriber, counter = state.counter, period = state.period;\n    subscriber.next(counter);\n    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);\n}\n//# sourceMappingURL=interval.js.map\n","/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\nimport { fromArray } from './fromArray';\nexport function merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    var concurrent = Number.POSITIVE_INFINITY;\n    var scheduler = null;\n    var last = observables[observables.length - 1];\n    if (isScheduler(last)) {\n        scheduler = observables.pop();\n        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n            concurrent = observables.pop();\n        }\n    }\n    else if (typeof last === 'number') {\n        concurrent = observables.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n        return observables[0];\n    }\n    return mergeAll(concurrent)(fromArray(observables, scheduler));\n}\n//# sourceMappingURL=merge.js.map\n","/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { noop } from '../util/noop';\nexport var NEVER = /*@__PURE__*/ new Observable(noop);\nexport function never() {\n    return NEVER;\n}\n//# sourceMappingURL=never.js.map\n","/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */\nimport { isScheduler } from '../util/isScheduler';\nimport { fromArray } from './fromArray';\nimport { scheduleArray } from '../scheduled/scheduleArray';\nexport function of() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args[args.length - 1];\n    if (isScheduler(scheduler)) {\n        args.pop();\n        return scheduleArray(args, scheduler);\n    }\n    else {\n        return fromArray(args);\n    }\n}\n//# sourceMappingURL=of.js.map\n","/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nexport function onErrorResumeNext() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    if (sources.length === 0) {\n        return EMPTY;\n    }\n    var first = sources[0], remainder = sources.slice(1);\n    if (sources.length === 1 && isArray(first)) {\n        return onErrorResumeNext.apply(void 0, first);\n    }\n    return new Observable(function (subscriber) {\n        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };\n        return from(first).subscribe({\n            next: function (value) { subscriber.next(value); },\n            error: subNext,\n            complete: subNext,\n        });\n    });\n}\n//# sourceMappingURL=onErrorResumeNext.js.map\n","/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nexport function pairs(obj, scheduler) {\n    if (!scheduler) {\n        return new Observable(function (subscriber) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length && !subscriber.closed; i++) {\n                var key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    subscriber.next([key, obj[key]]);\n                }\n            }\n            subscriber.complete();\n        });\n    }\n    else {\n        return new Observable(function (subscriber) {\n            var keys = Object.keys(obj);\n            var subscription = new Subscription();\n            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));\n            return subscription;\n        });\n    }\n}\nexport function dispatch(state) {\n    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;\n    if (!subscriber.closed) {\n        if (index < keys.length) {\n            var key = keys[index];\n            subscriber.next([key, obj[key]]);\n            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));\n        }\n        else {\n            subscriber.complete();\n        }\n    }\n}\n//# sourceMappingURL=pairs.js.map\n","/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */\nimport { not } from '../util/not';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { filter } from '../operators/filter';\nimport { Observable } from '../Observable';\nexport function partition(source, predicate, thisArg) {\n    return [\n        filter(predicate, thisArg)(new Observable(subscribeTo(source))),\n        filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))\n    ];\n}\n//# sourceMappingURL=partition.js.map\n","/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { isArray } from '../util/isArray';\nimport { fromArray } from './fromArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    if (observables.length === 1) {\n        if (isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return fromArray(observables, undefined).lift(new RaceOperator());\n}\nvar RaceOperator = /*@__PURE__*/ (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexport { RaceOperator };\nvar RaceSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.hasFirst = false;\n        _this.observables = [];\n        _this.subscriptions = [];\n        return _this;\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber));\nexport { RaceSubscriber };\n//# sourceMappingURL=race.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function range(start, count, scheduler) {\n    if (start === void 0) {\n        start = 0;\n    }\n    return new Observable(function (subscriber) {\n        if (count === undefined) {\n            count = start;\n            start = 0;\n        }\n        var index = 0;\n        var current = start;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                index: index, count: count, start: start, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(current++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n        return undefined;\n    });\n}\nexport function dispatch(state) {\n    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n    if (index >= count) {\n        subscriber.complete();\n        return;\n    }\n    subscriber.next(start);\n    if (subscriber.closed) {\n        return;\n    }\n    state.index = index + 1;\n    state.start = start + 1;\n    this.schedule(state);\n}\n//# sourceMappingURL=range.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function throwError(error, scheduler) {\n    if (!scheduler) {\n        return new Observable(function (subscriber) { return subscriber.error(error); });\n    }\n    else {\n        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });\n    }\n}\nfunction dispatch(_a) {\n    var error = _a.error, subscriber = _a.subscriber;\n    subscriber.error(error);\n}\n//# sourceMappingURL=throwError.js.map\n","/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function timer(dueTime, periodOrScheduler, scheduler) {\n    if (dueTime === void 0) {\n        dueTime = 0;\n    }\n    var period = -1;\n    if (isNumeric(periodOrScheduler)) {\n        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n    }\n    else if (isScheduler(periodOrScheduler)) {\n        scheduler = periodOrScheduler;\n    }\n    if (!isScheduler(scheduler)) {\n        scheduler = async;\n    }\n    return new Observable(function (subscriber) {\n        var due = isNumeric(dueTime)\n            ? dueTime\n            : (+dueTime - scheduler.now());\n        return scheduler.schedule(dispatch, due, {\n            index: 0, period: period, subscriber: subscriber\n        });\n    });\n}\nfunction dispatch(state) {\n    var index = state.index, period = state.period, subscriber = state.subscriber;\n    subscriber.next(index);\n    if (subscriber.closed) {\n        return;\n    }\n    else if (period === -1) {\n        return subscriber.complete();\n    }\n    state.index = index + 1;\n    this.schedule(state, period);\n}\n//# sourceMappingURL=timer.js.map\n","/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { EMPTY } from './empty';\nexport function using(resourceFactory, observableFactory) {\n    return new Observable(function (subscriber) {\n        var resource;\n        try {\n            resource = resourceFactory();\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        var result;\n        try {\n            result = observableFactory(resource);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        var source = result ? from(result) : EMPTY;\n        var subscription = source.subscribe(subscriber);\n        return function () {\n            subscription.unsubscribe();\n            if (resource) {\n                resource.unsubscribe();\n            }\n        };\n    });\n}\n//# sourceMappingURL=using.js.map\n","/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { fromArray } from './fromArray';\nimport { isArray } from '../util/isArray';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { iterator as Symbol_iterator } from '../../internal/symbol/iterator';\nexport function zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    var resultSelector = observables[observables.length - 1];\n    if (typeof resultSelector === 'function') {\n        observables.pop();\n    }\n    return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));\n}\nvar ZipOperator = /*@__PURE__*/ (function () {\n    function ZipOperator(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n    };\n    return ZipOperator;\n}());\nexport { ZipOperator };\nvar ZipSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, resultSelector, values) {\n        if (values === void 0) {\n            values = Object.create(null);\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.iterators = [];\n        _this.active = 0;\n        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;\n        _this.values = values;\n        return _this;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[Symbol_iterator] === 'function') {\n            iterators.push(new StaticIterator(value[Symbol_iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        this.unsubscribe();\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                var destination = this.destination;\n                destination.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--;\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.resultSelector) {\n            this._tryresultSelector(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryresultSelector = function (args) {\n        var result;\n        try {\n            result = this.resultSelector.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber));\nexport { ZipSubscriber };\nvar StaticIterator = /*@__PURE__*/ (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = /*@__PURE__*/ (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[Symbol_iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\nvar ZipBufferIterator = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        var _this = _super.call(this, destination) || this;\n        _this.parent = parent;\n        _this.observable = observable;\n        _this.stillUnsubscribed = true;\n        _this.buffer = [];\n        _this.isComplete = false;\n        return _this;\n    }\n    ZipBufferIterator.prototype[Symbol_iterator] = function () {\n        return this;\n    };\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nvar AuditOperator = /*@__PURE__*/ (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\nvar AuditSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.durationSelector = durationSelector;\n        _this.hasValue = false;\n        return _this;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = void 0;\n            try {\n                var durationSelector = this.durationSelector;\n                duration = durationSelector(value);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n            var innerSubscription = subscribeToResult(this, duration);\n            if (!innerSubscription || innerSubscription.closed) {\n                this.clearThrottle();\n            }\n            else {\n                this.add(this.throttled = innerSubscription);\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n","/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */\nimport { async } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nexport function auditTime(duration, scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    return audit(function () { return timer(duration, scheduler); });\n}\n//# sourceMappingURL=auditTime.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function buffer(closingNotifier) {\n    return function bufferOperatorFunction(source) {\n        return source.lift(new BufferOperator(closingNotifier));\n    };\n}\nvar BufferOperator = /*@__PURE__*/ (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\nvar BufferSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        var _this = _super.call(this, destination) || this;\n        _this.buffer = [];\n        _this.add(subscribeToResult(_this, closingNotifier));\n        return _this;\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) {\n        startBufferEvery = null;\n    }\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nvar BufferCountOperator = /*@__PURE__*/ (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\nvar BufferCountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        var _this = _super.call(this, destination) || this;\n        _this.bufferSize = bufferSize;\n        _this.buffer = [];\n        return _this;\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber));\nvar BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        var _this = _super.call(this, destination) || this;\n        _this.bufferSize = bufferSize;\n        _this.startBufferEvery = startBufferEvery;\n        _this.buffers = [];\n        _this.count = 0;\n        return _this;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n","/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nvar BufferTimeOperator = /*@__PURE__*/ (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = /*@__PURE__*/ (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\nvar BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.bufferTimeSpan = bufferTimeSpan;\n        _this.bufferCreationInterval = bufferCreationInterval;\n        _this.maxBufferSize = maxBufferSize;\n        _this.scheduler = scheduler;\n        _this.contexts = [];\n        var context = _this.openContext();\n        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (_this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: _this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n        return _this;\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context_1 = contexts[i];\n            var buffer = context_1.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context_1;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context_2 = contexts.shift();\n            destination.next(context_2.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n","/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nexport function bufferToggle(openings, closingSelector) {\n    return function bufferToggleOperatorFunction(source) {\n        return source.lift(new BufferToggleOperator(openings, closingSelector));\n    };\n}\nvar BufferToggleOperator = /*@__PURE__*/ (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\nvar BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.openings = openings;\n        _this.closingSelector = closingSelector;\n        _this.contexts = [];\n        _this.add(subscribeToResult(_this, openings));\n        return _this;\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context_1 = contexts.shift();\n            context_1.subscription.unsubscribe();\n            context_1.buffer = null;\n            context_1.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context_2 = contexts.shift();\n            this.destination.next(context_2.buffer);\n            context_2.subscription.unsubscribe();\n            context_2.buffer = null;\n            context_2.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n","/** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function bufferWhen(closingSelector) {\n    return function (source) {\n        return source.lift(new BufferWhenOperator(closingSelector));\n    };\n}\nvar BufferWhenOperator = /*@__PURE__*/ (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\nvar BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.closingSelector = closingSelector;\n        _this.subscribing = false;\n        _this.openBuffer();\n        return _this;\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier;\n        try {\n            var closingSelector = this.closingSelector;\n            closingNotifier = closingSelector();\n        }\n        catch (err) {\n            return this.error(err);\n        }\n        closingSubscription = new Subscription();\n        this.closingSubscription = closingSubscription;\n        this.add(closingSubscription);\n        this.subscribing = true;\n        closingSubscription.add(subscribeToResult(this, closingNotifier));\n        this.subscribing = false;\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function catchError(selector) {\n    return function catchErrorOperatorFunction(source) {\n        var operator = new CatchOperator(selector);\n        var caught = source.lift(operator);\n        return (operator.caught = caught);\n    };\n}\nvar CatchOperator = /*@__PURE__*/ (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\nvar CatchSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        var _this = _super.call(this, destination) || this;\n        _this.selector = selector;\n        _this.caught = caught;\n        return _this;\n    }\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n            this.add(innerSubscriber);\n            subscribeToResult(this, result, undefined, undefined, innerSubscriber);\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=catchError.js.map\n","/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */\nimport { CombineLatestOperator } from '../observable/combineLatest';\nexport function combineAll(project) {\n    return function (source) { return source.lift(new CombineLatestOperator(project)); };\n}\n//# sourceMappingURL=combineAll.js.map\n","/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */\nimport { isArray } from '../util/isArray';\nimport { CombineLatestOperator } from '../observable/combineLatest';\nimport { from } from '../observable/from';\nvar none = {};\nexport function combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    if (observables.length === 1 && isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return function (source) { return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project)); };\n}\n//# sourceMappingURL=combineLatest.js.map\n","/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */\nimport { concat as concatStatic } from '../observable/concat';\nexport function concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concatStatic.apply(void 0, [source].concat(observables))); };\n}\n//# sourceMappingURL=concat.js.map\n","/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */\nimport { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n//# sourceMappingURL=concatAll.js.map\n","/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */\nimport { mergeMap } from './mergeMap';\nexport function concatMap(project, resultSelector) {\n    return mergeMap(project, resultSelector, 1);\n}\n//# sourceMappingURL=concatMap.js.map\n","/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */\nimport { concatMap } from './concatMap';\nexport function concatMapTo(innerObservable, resultSelector) {\n    return concatMap(function () { return innerObservable; }, resultSelector);\n}\n//# sourceMappingURL=concatMapTo.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function count(predicate) {\n    return function (source) { return source.lift(new CountOperator(predicate, source)); };\n}\nvar CountOperator = /*@__PURE__*/ (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\nvar CountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.source = source;\n        _this.count = 0;\n        _this.index = 0;\n        return _this;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber));\n//# sourceMappingURL=count.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function debounce(durationSelector) {\n    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };\n}\nvar DebounceOperator = /*@__PURE__*/ (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\nvar DebounceSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.durationSelector = durationSelector;\n        _this.hasValue = false;\n        _this.durationSubscription = null;\n        return _this;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult(this, duration);\n        if (subscription && !subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nvar DebounceTimeOperator = /*@__PURE__*/ (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\nvar DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.dueTime = dueTime;\n        _this.scheduler = scheduler;\n        _this.debouncedSubscription = null;\n        _this.lastValue = null;\n        _this.hasValue = false;\n        return _this;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            var lastValue = this.lastValue;\n            this.lastValue = null;\n            this.hasValue = false;\n            this.destination.next(lastValue);\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function defaultIfEmpty(defaultValue) {\n    if (defaultValue === void 0) {\n        defaultValue = null;\n    }\n    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };\n}\nvar DefaultIfEmptyOperator = /*@__PURE__*/ (function () {\n    function DefaultIfEmptyOperator(defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n    };\n    return DefaultIfEmptyOperator;\n}());\nvar DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DefaultIfEmptySubscriber, _super);\n    function DefaultIfEmptySubscriber(destination, defaultValue) {\n        var _this = _super.call(this, destination) || this;\n        _this.defaultValue = defaultValue;\n        _this.isEmpty = true;\n        return _this;\n    }\n    DefaultIfEmptySubscriber.prototype._next = function (value) {\n        this.isEmpty = false;\n        this.destination.next(value);\n    };\n    DefaultIfEmptySubscriber.prototype._complete = function () {\n        if (this.isEmpty) {\n            this.destination.next(this.defaultValue);\n        }\n        this.destination.complete();\n    };\n    return DefaultIfEmptySubscriber;\n}(Subscriber));\n//# sourceMappingURL=defaultIfEmpty.js.map\n","/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function delay(delay, scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    var absoluteDelay = isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n}\nvar DelayOperator = /*@__PURE__*/ (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\nvar DelaySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.delay = delay;\n        _this.scheduler = scheduler;\n        _this.queue = [];\n        _this.active = false;\n        _this.errored = false;\n        return _this;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            this.unsubscribe();\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        var destination = this.destination;\n        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification.createComplete());\n        this.unsubscribe();\n    };\n    return DelaySubscriber;\n}(Subscriber));\nvar DelayMessage = /*@__PURE__*/ (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return function (source) {\n            return new SubscriptionDelayObservable(source, subscriptionDelay)\n                .lift(new DelayWhenOperator(delayDurationSelector));\n        };\n    }\n    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\n}\nvar DelayWhenOperator = /*@__PURE__*/ (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\nvar DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.delayDurationSelector = delayDurationSelector;\n        _this.completed = false;\n        _this.delayNotifierSubscriptions = [];\n        _this.index = 0;\n        return _this;\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        try {\n            var delayNotifier = this.delayDurationSelector(value, index);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n        this.unsubscribe();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        if (subscriptionIdx !== -1) {\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n        }\n        return subscription.outerValue;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            var destination = this.destination;\n            destination.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber));\nvar SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(source, subscriptionDelay) {\n        var _this = _super.call(this) || this;\n        _this.source = source;\n        _this.subscriptionDelay = subscriptionDelay;\n        return _this;\n    }\n    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable));\nvar SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        _this.source = source;\n        _this.sourceSubscribed = false;\n        return _this;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.unsubscribe();\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function dematerialize() {\n    return function dematerializeOperatorFunction(source) {\n        return source.lift(new DeMaterializeOperator());\n    };\n}\nvar DeMaterializeOperator = /*@__PURE__*/ (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\nvar DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        return _super.call(this, destination) || this;\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function distinct(keySelector, flushes) {\n    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\n}\nvar DistinctOperator = /*@__PURE__*/ (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\nvar DistinctSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        var _this = _super.call(this, destination) || this;\n        _this.keySelector = keySelector;\n        _this.values = new Set();\n        if (flushes) {\n            _this.add(subscribeToResult(_this, flushes));\n        }\n        return _this;\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber));\nexport { DistinctSubscriber };\n//# sourceMappingURL=distinct.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function distinctUntilChanged(compare, keySelector) {\n    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };\n}\nvar DistinctUntilChangedOperator = /*@__PURE__*/ (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\nvar DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.keySelector = keySelector;\n        _this.hasKey = false;\n        if (typeof compare === 'function') {\n            _this.compare = compare;\n        }\n        return _this;\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            var keySelector = this.keySelector;\n            key = keySelector ? keySelector(value) : value;\n        }\n        catch (err) {\n            return this.destination.error(err);\n        }\n        var result = false;\n        if (this.hasKey) {\n            try {\n                var compare = this.compare;\n                result = compare(this.key, key);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (!result) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber));\n//# sourceMappingURL=distinctUntilChanged.js.map\n","/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */\nimport { distinctUntilChanged } from './distinctUntilChanged';\nexport function distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n}\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n","/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\nexport function elementAt(index, defaultValue) {\n    if (index < 0) {\n        throw new ArgumentOutOfRangeError();\n    }\n    var hasDefaultValue = arguments.length >= 2;\n    return function (source) {\n        return source.pipe(filter(function (v, i) { return i === index; }), take(1), hasDefaultValue\n            ? defaultIfEmpty(defaultValue)\n            : throwIfEmpty(function () { return new ArgumentOutOfRangeError(); }));\n    };\n}\n//# sourceMappingURL=elementAt.js.map\n","/** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */\nimport { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nexport function endWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i] = arguments[_i];\n    }\n    return function (source) { return concat(source, of.apply(void 0, array)); };\n}\n//# sourceMappingURL=endWith.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function every(predicate, thisArg) {\n    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };\n}\nvar EveryOperator = /*@__PURE__*/ (function () {\n    function EveryOperator(predicate, thisArg, source) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.source = source;\n    }\n    EveryOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n    };\n    return EveryOperator;\n}());\nvar EverySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(EverySubscriber, _super);\n    function EverySubscriber(destination, predicate, thisArg, source) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.thisArg = thisArg;\n        _this.source = source;\n        _this.index = 0;\n        _this.thisArg = thisArg || _this;\n        return _this;\n    }\n    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n        this.destination.next(everyValueMatch);\n        this.destination.complete();\n    };\n    EverySubscriber.prototype._next = function (value) {\n        var result = false;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (!result) {\n            this.notifyComplete(false);\n        }\n    };\n    EverySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return EverySubscriber;\n}(Subscriber));\n//# sourceMappingURL=every.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function exhaust() {\n    return function (source) { return source.lift(new SwitchFirstOperator()); };\n}\nvar SwitchFirstOperator = /*@__PURE__*/ (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\nvar SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.hasCompleted = false;\n        _this.hasSubscription = false;\n        return _this;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { map } from './map';\nimport { from } from '../observable/from';\nexport function exhaustMap(project, resultSelector) {\n    if (resultSelector) {\n        return function (source) { return source.pipe(exhaustMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };\n    }\n    return function (source) {\n        return source.lift(new ExhaustMapOperator(project));\n    };\n}\nvar ExhaustMapOperator = /*@__PURE__*/ (function () {\n    function ExhaustMapOperator(project) {\n        this.project = project;\n    }\n    ExhaustMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));\n    };\n    return ExhaustMapOperator;\n}());\nvar ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ExhaustMapSubscriber, _super);\n    function ExhaustMapSubscriber(destination, project) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.hasSubscription = false;\n        _this.hasCompleted = false;\n        _this.index = 0;\n        return _this;\n    }\n    ExhaustMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    ExhaustMapSubscriber.prototype.tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.hasSubscription = true;\n        this._innerSub(result, value, index);\n    };\n    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n        var destination = this.destination;\n        destination.add(innerSubscriber);\n        subscribeToResult(this, result, value, index, innerSubscriber);\n    };\n    ExhaustMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    };\n    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    ExhaustMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        destination.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return ExhaustMapSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) {\n        concurrent = Number.POSITIVE_INFINITY;\n    }\n    if (scheduler === void 0) {\n        scheduler = undefined;\n    }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n}\nvar ExpandOperator = /*@__PURE__*/ (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexport { ExpandOperator };\nvar ExpandSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.concurrent = concurrent;\n        _this.scheduler = scheduler;\n        _this.index = 0;\n        _this.active = 0;\n        _this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            _this.buffer = [];\n        }\n        return _this;\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            try {\n                var project = this.project;\n                var result = project(value, index);\n                if (!this.scheduler) {\n                    this.subscribeToProjection(result, value, index);\n                }\n                else {\n                    var state = { subscriber: this, result: result, value: value, index: index };\n                    var destination_1 = this.destination;\n                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n                }\n            }\n            catch (e) {\n                destination.error(e);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        var destination = this.destination;\n        destination.add(subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        var destination = this.destination;\n        destination.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber));\nexport { ExpandSubscriber };\n//# sourceMappingURL=expand.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nvar FilterOperator = /*@__PURE__*/ (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\nvar FilterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.thisArg = thisArg;\n        _this.count = 0;\n        return _this;\n    }\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber));\n//# sourceMappingURL=filter.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nexport function finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nvar FinallyOperator = /*@__PURE__*/ (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\nvar FinallySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        var _this = _super.call(this, destination) || this;\n        _this.add(new Subscription(callback));\n        return _this;\n    }\n    return FinallySubscriber;\n}(Subscriber));\n//# sourceMappingURL=finalize.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };\n}\nvar FindValueOperator = /*@__PURE__*/ (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexport { FindValueOperator };\nvar FindValueSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.source = source;\n        _this.yieldIndex = yieldIndex;\n        _this.thisArg = thisArg;\n        _this.index = 0;\n        return _this;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n        this.unsubscribe();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber));\nexport { FindValueSubscriber };\n//# sourceMappingURL=find.js.map\n","/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */\nimport { FindValueOperator } from '../operators/find';\nexport function findIndex(predicate, thisArg) {\n    return function (source) { return source.lift(new FindValueOperator(predicate, source, true, thisArg)); };\n}\n//# sourceMappingURL=findIndex.js.map\n","/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */\nimport { EmptyError } from '../util/EmptyError';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\nexport function first(predicate, defaultValue) {\n    var hasDefaultValue = arguments.length >= 2;\n    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };\n}\n//# sourceMappingURL=first.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nexport function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return function (source) {\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n    };\n}\nvar GroupByOperator = /*@__PURE__*/ (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\nvar GroupBySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.keySelector = keySelector;\n        _this.elementSelector = elementSelector;\n        _this.durationSelector = durationSelector;\n        _this.subjectSelector = subjectSelector;\n        _this.groups = null;\n        _this.attemptedToUnsubscribe = false;\n        _this.count = 0;\n        return _this;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = new Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = (this.subjectSelector ? this.subjectSelector() : new Subject());\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber));\nvar GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        var _this = _super.call(this, group) || this;\n        _this.key = key;\n        _this.group = group;\n        _this.parent = parent;\n        return _this;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber));\nvar GroupedObservable = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.groupSubject = groupSubject;\n        _this.refCountSubscription = refCountSubscription;\n        return _this;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable));\nexport { GroupedObservable };\nvar InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        parent.count++;\n        return _this;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription));\n//# sourceMappingURL=groupBy.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function ignoreElements() {\n    return function ignoreElementsOperatorFunction(source) {\n        return source.lift(new IgnoreElementsOperator());\n    };\n}\nvar IgnoreElementsOperator = /*@__PURE__*/ (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\nvar IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function isEmpty() {\n    return function (source) { return source.lift(new IsEmptyOperator()); };\n}\nvar IsEmptyOperator = /*@__PURE__*/ (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\nvar IsEmptySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        return _super.call(this, destination) || this;\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n","/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */\nimport { EmptyError } from '../util/EmptyError';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\nexport function last(predicate, defaultValue) {\n    var hasDefaultValue = arguments.length >= 2;\n    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };\n}\n//# sourceMappingURL=last.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function map(project, thisArg) {\n    return function mapOperation(source) {\n        if (typeof project !== 'function') {\n            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n        }\n        return source.lift(new MapOperator(project, thisArg));\n    };\n}\nvar MapOperator = /*@__PURE__*/ (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexport { MapOperator };\nvar MapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.count = 0;\n        _this.thisArg = thisArg || _this;\n        return _this;\n    }\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber));\n//# sourceMappingURL=map.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function mapTo(value) {\n    return function (source) { return source.lift(new MapToOperator(value)); };\n}\nvar MapToOperator = /*@__PURE__*/ (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\nvar MapToSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        var _this = _super.call(this, destination) || this;\n        _this.value = value;\n        return _this;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber));\n//# sourceMappingURL=mapTo.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function materialize() {\n    return function materializeOperatorFunction(source) {\n        return source.lift(new MaterializeOperator());\n    };\n}\nvar MaterializeOperator = /*@__PURE__*/ (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\nvar MaterializeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        return _super.call(this, destination) || this;\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=materialize.js.map\n","/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */\nimport { reduce } from './reduce';\nexport function max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return reduce(max);\n}\n//# sourceMappingURL=max.js.map\n","/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */\nimport { merge as mergeStatic } from '../observable/merge';\nexport function merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(mergeStatic.apply(void 0, [source].concat(observables))); };\n}\n//# sourceMappingURL=merge.js.map\n","/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */\nimport { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent) {\n    if (concurrent === void 0) {\n        concurrent = Number.POSITIVE_INFINITY;\n    }\n    return mergeMap(identity, concurrent);\n}\n//# sourceMappingURL=mergeAll.js.map\n","/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { map } from './map';\nimport { from } from '../observable/from';\nexport function mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n        concurrent = Number.POSITIVE_INFINITY;\n    }\n    if (typeof resultSelector === 'function') {\n        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };\n}\nvar MergeMapOperator = /*@__PURE__*/ (function () {\n    function MergeMapOperator(project, concurrent) {\n        if (concurrent === void 0) {\n            concurrent = Number.POSITIVE_INFINITY;\n        }\n        this.project = project;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexport { MergeMapOperator };\nvar MergeMapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, concurrent) {\n        if (concurrent === void 0) {\n            concurrent = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.concurrent = concurrent;\n        _this.hasCompleted = false;\n        _this.buffer = [];\n        _this.active = 0;\n        _this.index = 0;\n        return _this;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n        var destination = this.destination;\n        destination.add(innerSubscriber);\n        subscribeToResult(this, ish, value, index, innerSubscriber);\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber));\nexport { MergeMapSubscriber };\n//# sourceMappingURL=mergeMap.js.map\n","/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */\nimport { mergeMap } from './mergeMap';\nexport function mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n        concurrent = Number.POSITIVE_INFINITY;\n    }\n    if (typeof resultSelector === 'function') {\n        return mergeMap(function () { return innerObservable; }, resultSelector, concurrent);\n    }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return mergeMap(function () { return innerObservable; }, concurrent);\n}\n//# sourceMappingURL=mergeMapTo.js.map\n","/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nexport function mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) {\n        concurrent = Number.POSITIVE_INFINITY;\n    }\n    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };\n}\nvar MergeScanOperator = /*@__PURE__*/ (function () {\n    function MergeScanOperator(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexport { MergeScanOperator };\nvar MergeScanSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n        var _this = _super.call(this, destination) || this;\n        _this.accumulator = accumulator;\n        _this.acc = acc;\n        _this.concurrent = concurrent;\n        _this.hasValue = false;\n        _this.hasCompleted = false;\n        _this.buffer = [];\n        _this.active = 0;\n        _this.index = 0;\n        return _this;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var destination = this.destination;\n            var ish = void 0;\n            try {\n                var accumulator = this.accumulator;\n                ish = accumulator(this.acc, value, index);\n            }\n            catch (e) {\n                return destination.error(e);\n            }\n            this.active++;\n            this._innerSub(ish, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n        var destination = this.destination;\n        destination.add(innerSubscriber);\n        subscribeToResult(this, ish, value, index, innerSubscriber);\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n        this.unsubscribe();\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        var destination = this.destination;\n        destination.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber));\nexport { MergeScanSubscriber };\n//# sourceMappingURL=mergeScan.js.map\n","/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */\nimport { reduce } from './reduce';\nexport function min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return reduce(min);\n}\n//# sourceMappingURL=min.js.map\n","/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */\nimport { connectableObservableDescriptor } from '../observable/ConnectableObservable';\nexport function multicast(subjectOrSubjectFactory, selector) {\n    return function multicastOperatorFunction(source) {\n        var subjectFactory;\n        if (typeof subjectOrSubjectFactory === 'function') {\n            subjectFactory = subjectOrSubjectFactory;\n        }\n        else {\n            subjectFactory = function subjectFactory() {\n                return subjectOrSubjectFactory;\n            };\n        }\n        if (typeof selector === 'function') {\n            return source.lift(new MulticastOperator(subjectFactory, selector));\n        }\n        var connectable = Object.create(source, connectableObservableDescriptor);\n        connectable.source = source;\n        connectable.subjectFactory = subjectFactory;\n        return connectable;\n    };\n}\nvar MulticastOperator = /*@__PURE__*/ (function () {\n    function MulticastOperator(subjectFactory, selector) {\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastOperator.prototype.call = function (subscriber, source) {\n        var selector = this.selector;\n        var subject = this.subjectFactory();\n        var subscription = selector(subject).subscribe(subscriber);\n        subscription.add(source.subscribe(subject));\n        return subscription;\n    };\n    return MulticastOperator;\n}());\nexport { MulticastOperator };\n//# sourceMappingURL=multicast.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function observeOn(scheduler, delay) {\n    if (delay === void 0) {\n        delay = 0;\n    }\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nvar ObserveOnOperator = /*@__PURE__*/ (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\nexport { ObserveOnOperator };\nvar ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.scheduler = scheduler;\n        _this.delay = delay;\n        return _this;\n    }\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        var destination = this.destination;\n        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification.createError(err));\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification.createComplete());\n        this.unsubscribe();\n    };\n    return ObserveOnSubscriber;\n}(Subscriber));\nexport { ObserveOnSubscriber };\nvar ObserveOnMessage = /*@__PURE__*/ (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\nexport { ObserveOnMessage };\n//# sourceMappingURL=observeOn.js.map\n","/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { from } from '../observable/from';\nimport { isArray } from '../util/isArray';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };\n}\nexport function onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return from(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nvar OnErrorResumeNextOperator = /*@__PURE__*/ (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.nextSources = nextSources;\n        return _this;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n        this.unsubscribe();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n        this.unsubscribe();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (!!next) {\n            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n            var destination = this.destination;\n            destination.add(innerSubscriber);\n            subscribeToResult(this, next, undefined, undefined, innerSubscriber);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function pairwise() {\n    return function (source) { return source.lift(new PairwiseOperator()); };\n}\nvar PairwiseOperator = /*@__PURE__*/ (function () {\n    function PairwiseOperator() {\n    }\n    PairwiseOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new PairwiseSubscriber(subscriber));\n    };\n    return PairwiseOperator;\n}());\nvar PairwiseSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(PairwiseSubscriber, _super);\n    function PairwiseSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.hasPrev = false;\n        return _this;\n    }\n    PairwiseSubscriber.prototype._next = function (value) {\n        var pair;\n        if (this.hasPrev) {\n            pair = [this.prev, value];\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n        if (pair) {\n            this.destination.next(pair);\n        }\n    };\n    return PairwiseSubscriber;\n}(Subscriber));\n//# sourceMappingURL=pairwise.js.map\n","/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */\nimport { not } from '../util/not';\nimport { filter } from './filter';\nexport function partition(predicate, thisArg) {\n    return function (source) {\n        return [\n            filter(predicate, thisArg)(source),\n            filter(not(predicate, thisArg))(source)\n        ];\n    };\n}\n//# sourceMappingURL=partition.js.map\n","/** PURE_IMPORTS_START _map PURE_IMPORTS_END */\nimport { map } from './map';\nexport function pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return function (source) { return map(plucker(properties, length))(source); };\n}\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n","/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */\nimport { Subject } from '../Subject';\nimport { multicast } from './multicast';\nexport function publish(selector) {\n    return selector ?\n        multicast(function () { return new Subject(); }, selector) :\n        multicast(new Subject());\n}\n//# sourceMappingURL=publish.js.map\n","/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */\nimport { BehaviorSubject } from '../BehaviorSubject';\nimport { multicast } from './multicast';\nexport function publishBehavior(value) {\n    return function (source) { return multicast(new BehaviorSubject(value))(source); };\n}\n//# sourceMappingURL=publishBehavior.js.map\n","/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */\nimport { AsyncSubject } from '../AsyncSubject';\nimport { multicast } from './multicast';\nexport function publishLast() {\n    return function (source) { return multicast(new AsyncSubject())(source); };\n}\n//# sourceMappingURL=publishLast.js.map\n","/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nexport function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n        scheduler = selectorOrScheduler;\n    }\n    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n    var subject = new ReplaySubject(bufferSize, windowTime, scheduler);\n    return function (source) { return multicast(function () { return subject; }, selector)(source); };\n}\n//# sourceMappingURL=publishReplay.js.map\n","/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */\nimport { isArray } from '../util/isArray';\nimport { race as raceStatic } from '../observable/race';\nexport function race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return function raceOperatorFunction(source) {\n        if (observables.length === 1 && isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return source.lift.call(raceStatic.apply(void 0, [source].concat(observables)));\n    };\n}\n//# sourceMappingURL=race.js.map\n","/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */\nimport { scan } from './scan';\nimport { takeLast } from './takeLast';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { pipe } from '../util/pipe';\nexport function reduce(accumulator, seed) {\n    if (arguments.length >= 2) {\n        return function reduceOperatorFunctionWithSeed(source) {\n            return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);\n        };\n    }\n    return function reduceOperatorFunction(source) {\n        return pipe(scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast(1))(source);\n    };\n}\n//# sourceMappingURL=reduce.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function refCount() {\n    return function refCountOperatorFunction(source) {\n        return source.lift(new RefCountOperator(source));\n    };\n}\nvar RefCountOperator = /*@__PURE__*/ (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber));\n//# sourceMappingURL=refCount.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { empty } from '../observable/empty';\nexport function repeat(count) {\n    if (count === void 0) {\n        count = -1;\n    }\n    return function (source) {\n        if (count === 0) {\n            return empty();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nvar RepeatOperator = /*@__PURE__*/ (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\nvar RepeatSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        var _this = _super.call(this, destination) || this;\n        _this.count = count;\n        _this.source = source;\n        return _this;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber));\n//# sourceMappingURL=repeat.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function repeatWhen(notifier) {\n    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };\n}\nvar RepeatWhenOperator = /*@__PURE__*/ (function () {\n    function RepeatWhenOperator(notifier) {\n        this.notifier = notifier;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    };\n    return RepeatWhenOperator;\n}());\nvar RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        var _this = _super.call(this, destination) || this;\n        _this.notifier = notifier;\n        _this.source = source;\n        _this.sourceIsBeingSubscribedTo = true;\n        return _this;\n    }\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    };\n    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return _super.prototype.complete.call(this);\n        }\n    };\n    RepeatWhenSubscriber.prototype.complete = function () {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            if (!this.retriesSubscription || this.retriesSubscription.closed) {\n                return _super.prototype.complete.call(this);\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    };\n    RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n        var _unsubscribe = this._unsubscribe;\n        this._unsubscribe = null;\n        _super.prototype._unsubscribeAndRecycle.call(this);\n        this._unsubscribe = _unsubscribe;\n        return this;\n    };\n    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n        this.notifications = new Subject();\n        var retries;\n        try {\n            var notifier = this.notifier;\n            retries = notifier(this.notifications);\n        }\n        catch (e) {\n            return _super.prototype.complete.call(this);\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult(this, retries);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function retry(count) {\n    if (count === void 0) {\n        count = -1;\n    }\n    return function (source) { return source.lift(new RetryOperator(count, source)); };\n}\nvar RetryOperator = /*@__PURE__*/ (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\nvar RetrySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        var _this = _super.call(this, destination) || this;\n        _this.count = count;\n        _this.source = source;\n        return _this;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber));\n//# sourceMappingURL=retry.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function retryWhen(notifier) {\n    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n}\nvar RetryWhenOperator = /*@__PURE__*/ (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\nvar RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        var _this = _super.call(this, destination) || this;\n        _this.notifier = notifier;\n        _this.source = source;\n        return _this;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject();\n                try {\n                    var notifier = this.notifier;\n                    retries = notifier(errors);\n                }\n                catch (e) {\n                    return _super.prototype.error.call(this, e);\n                }\n                retriesSubscription = subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _unsubscribe = this._unsubscribe;\n        this._unsubscribe = null;\n        this._unsubscribeAndRecycle();\n        this._unsubscribe = _unsubscribe;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function sample(notifier) {\n    return function (source) { return source.lift(new SampleOperator(notifier)); };\n}\nvar SampleOperator = /*@__PURE__*/ (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        var sampleSubscriber = new SampleSubscriber(subscriber);\n        var subscription = source.subscribe(sampleSubscriber);\n        subscription.add(subscribeToResult(sampleSubscriber, this.notifier));\n        return subscription;\n    };\n    return SampleOperator;\n}());\nvar SampleSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SampleSubscriber, _super);\n    function SampleSubscriber() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.hasValue = false;\n        return _this;\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function sampleTime(period, scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n}\nvar SampleTimeOperator = /*@__PURE__*/ (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\nvar SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.period = period;\n        _this.scheduler = scheduler;\n        _this.hasValue = false;\n        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));\n        return _this;\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function scan(accumulator, seed) {\n    var hasSeed = false;\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return function scanOperatorFunction(source) {\n        return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n    };\n}\nvar ScanOperator = /*@__PURE__*/ (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) {\n            hasSeed = false;\n        }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\nvar ScanSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        var _this = _super.call(this, destination) || this;\n        _this.accumulator = accumulator;\n        _this._seed = _seed;\n        _this.hasSeed = hasSeed;\n        _this.index = 0;\n        return _this;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber));\n//# sourceMappingURL=scan.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function sequenceEqual(compareTo, comparator) {\n    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };\n}\nvar SequenceEqualOperator = /*@__PURE__*/ (function () {\n    function SequenceEqualOperator(compareTo, comparator) {\n        this.compareTo = compareTo;\n        this.comparator = comparator;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));\n    };\n    return SequenceEqualOperator;\n}());\nexport { SequenceEqualOperator };\nvar SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparator) {\n        var _this = _super.call(this, destination) || this;\n        _this.compareTo = compareTo;\n        _this.comparator = comparator;\n        _this._a = [];\n        _this._b = [];\n        _this._oneComplete = false;\n        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));\n        return _this;\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n        this.unsubscribe();\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            try {\n                areEqual = comparator ? comparator(a, b) : a === b;\n            }\n            catch (e) {\n                this.destination.error(e);\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype.completeB = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber));\nexport { SequenceEqualSubscriber };\nvar SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        var _this = _super.call(this, destination) || this;\n        _this.parent = parent;\n        return _this;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n        this.unsubscribe();\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent.completeB();\n        this.unsubscribe();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n","/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */\nimport { multicast } from './multicast';\nimport { refCount } from './refCount';\nimport { Subject } from '../Subject';\nfunction shareSubjectFactory() {\n    return new Subject();\n}\nexport function share() {\n    return function (source) { return refCount()(multicast(shareSubjectFactory)(source)); };\n}\n//# sourceMappingURL=share.js.map\n","/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */\nimport { ReplaySubject } from '../ReplaySubject';\nexport function shareReplay(configOrBufferSize, windowTime, scheduler) {\n    var config;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        config = configOrBufferSize;\n    }\n    else {\n        config = {\n            bufferSize: configOrBufferSize,\n            windowTime: windowTime,\n            refCount: false,\n            scheduler: scheduler\n        };\n    }\n    return function (source) { return source.lift(shareReplayOperator(config)); };\n}\nfunction shareReplayOperator(_a) {\n    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;\n    var subject;\n    var refCount = 0;\n    var subscription;\n    var hasError = false;\n    var isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject(bufferSize, windowTime, scheduler);\n            subscription = source.subscribe({\n                next: function (value) { subject.next(value); },\n                error: function (err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete: function () {\n                    isComplete = true;\n                    subject.complete();\n                },\n            });\n        }\n        var innerSub = subject.subscribe(this);\n        this.add(function () {\n            refCount--;\n            innerSub.unsubscribe();\n            if (subscription && !isComplete && useRefCount && refCount === 0) {\n                subscription.unsubscribe();\n                subscription = undefined;\n                subject = undefined;\n            }\n        });\n    };\n}\n//# sourceMappingURL=shareReplay.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nexport function single(predicate) {\n    return function (source) { return source.lift(new SingleOperator(predicate, source)); };\n}\nvar SingleOperator = /*@__PURE__*/ (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\nvar SingleSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.source = source;\n        _this.seenValue = false;\n        _this.index = 0;\n        return _this;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber));\n//# sourceMappingURL=single.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function skip(count) {\n    return function (source) { return source.lift(new SkipOperator(count)); };\n}\nvar SkipOperator = /*@__PURE__*/ (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\nvar SkipSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        var _this = _super.call(this, destination) || this;\n        _this.total = total;\n        _this.count = 0;\n        return _this;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber));\n//# sourceMappingURL=skip.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nexport function skipLast(count) {\n    return function (source) { return source.lift(new SkipLastOperator(count)); };\n}\nvar SkipLastOperator = /*@__PURE__*/ (function () {\n    function SkipLastOperator(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError;\n        }\n    }\n    SkipLastOperator.prototype.call = function (subscriber, source) {\n        if (this._skipCount === 0) {\n            return source.subscribe(new Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    };\n    return SkipLastOperator;\n}());\nvar SkipLastSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SkipLastSubscriber, _super);\n    function SkipLastSubscriber(destination, _skipCount) {\n        var _this = _super.call(this, destination) || this;\n        _this._skipCount = _skipCount;\n        _this._count = 0;\n        _this._ring = new Array(_skipCount);\n        return _this;\n    }\n    SkipLastSubscriber.prototype._next = function (value) {\n        var skipCount = this._skipCount;\n        var count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            var currentIndex = count % skipCount;\n            var ring = this._ring;\n            var oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    };\n    return SkipLastSubscriber;\n}(Subscriber));\n//# sourceMappingURL=skipLast.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function skipUntil(notifier) {\n    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n}\nvar SkipUntilOperator = /*@__PURE__*/ (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (destination, source) {\n        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\nvar SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        var _this = _super.call(this, destination) || this;\n        _this.hasValue = false;\n        var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);\n        _this.add(innerSubscriber);\n        _this.innerSubscription = innerSubscriber;\n        subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);\n        return _this;\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n        if (this.innerSubscription) {\n            this.innerSubscription.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function skipWhile(predicate) {\n    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n}\nvar SkipWhileOperator = /*@__PURE__*/ (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\nvar SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.skipping = true;\n        _this.index = 0;\n        return _this;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n","/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */\nimport { concat } from '../observable/concat';\nimport { isScheduler } from '../util/isScheduler';\nexport function startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i] = arguments[_i];\n    }\n    var scheduler = array[array.length - 1];\n    if (isScheduler(scheduler)) {\n        array.pop();\n        return function (source) { return concat(array, source, scheduler); };\n    }\n    else {\n        return function (source) { return concat(array, source); };\n    }\n}\n//# sourceMappingURL=startWith.js.map\n","/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */\nimport { SubscribeOnObservable } from '../observable/SubscribeOnObservable';\nexport function subscribeOn(scheduler, delay) {\n    if (delay === void 0) {\n        delay = 0;\n    }\n    return function subscribeOnOperatorFunction(source) {\n        return source.lift(new SubscribeOnOperator(scheduler, delay));\n    };\n}\nvar SubscribeOnOperator = /*@__PURE__*/ (function () {\n    function SubscribeOnOperator(scheduler, delay) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    SubscribeOnOperator.prototype.call = function (subscriber, source) {\n        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);\n    };\n    return SubscribeOnOperator;\n}());\n//# sourceMappingURL=subscribeOn.js.map\n","/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\nexport function switchAll() {\n    return switchMap(identity);\n}\n//# sourceMappingURL=switchAll.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { map } from './map';\nimport { from } from '../observable/from';\nexport function switchMap(project, resultSelector) {\n    if (typeof resultSelector === 'function') {\n        return function (source) { return source.pipe(switchMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };\n    }\n    return function (source) { return source.lift(new SwitchMapOperator(project)); };\n}\nvar SwitchMapOperator = /*@__PURE__*/ (function () {\n    function SwitchMapOperator(project) {\n        this.project = project;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n    };\n    return SwitchMapOperator;\n}());\nvar SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.index = 0;\n        return _this;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);\n        var destination = this.destination;\n        destination.add(innerSubscriber);\n        this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n        this.unsubscribe();\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        destination.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n","/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */\nimport { switchMap } from './switchMap';\nexport function switchMapTo(innerObservable, resultSelector) {\n    return resultSelector ? switchMap(function () { return innerObservable; }, resultSelector) : switchMap(function () { return innerObservable; });\n}\n//# sourceMappingURL=switchMapTo.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nexport function take(count) {\n    return function (source) {\n        if (count === 0) {\n            return empty();\n        }\n        else {\n            return source.lift(new TakeOperator(count));\n        }\n    };\n}\nvar TakeOperator = /*@__PURE__*/ (function () {\n    function TakeOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError;\n        }\n    }\n    TakeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeSubscriber(subscriber, this.total));\n    };\n    return TakeOperator;\n}());\nvar TakeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TakeSubscriber, _super);\n    function TakeSubscriber(destination, total) {\n        var _this = _super.call(this, destination) || this;\n        _this.total = total;\n        _this.count = 0;\n        return _this;\n    }\n    TakeSubscriber.prototype._next = function (value) {\n        var total = this.total;\n        var count = ++this.count;\n        if (count <= total) {\n            this.destination.next(value);\n            if (count === total) {\n                this.destination.complete();\n                this.unsubscribe();\n            }\n        }\n    };\n    return TakeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=take.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nexport function takeLast(count) {\n    return function takeLastOperatorFunction(source) {\n        if (count === 0) {\n            return empty();\n        }\n        else {\n            return source.lift(new TakeLastOperator(count));\n        }\n    };\n}\nvar TakeLastOperator = /*@__PURE__*/ (function () {\n    function TakeLastOperator(total) {\n        this.total = total;\n        if (this.total < 0) {\n            throw new ArgumentOutOfRangeError;\n        }\n    }\n    TakeLastOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n    };\n    return TakeLastOperator;\n}());\nvar TakeLastSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TakeLastSubscriber, _super);\n    function TakeLastSubscriber(destination, total) {\n        var _this = _super.call(this, destination) || this;\n        _this.total = total;\n        _this.ring = new Array();\n        _this.count = 0;\n        return _this;\n    }\n    TakeLastSubscriber.prototype._next = function (value) {\n        var ring = this.ring;\n        var total = this.total;\n        var count = this.count++;\n        if (ring.length < total) {\n            ring.push(value);\n        }\n        else {\n            var index = count % total;\n            ring[index] = value;\n        }\n    };\n    TakeLastSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        var count = this.count;\n        if (count > 0) {\n            var total = this.count >= this.total ? this.total : this.count;\n            var ring = this.ring;\n            for (var i = 0; i < total; i++) {\n                var idx = (count++) % total;\n                destination.next(ring[idx]);\n            }\n        }\n        destination.complete();\n    };\n    return TakeLastSubscriber;\n}(Subscriber));\n//# sourceMappingURL=takeLast.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function takeUntil(notifier) {\n    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };\n}\nvar TakeUntilOperator = /*@__PURE__*/ (function () {\n    function TakeUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    TakeUntilOperator.prototype.call = function (subscriber, source) {\n        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);\n        var notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);\n        if (notifierSubscription && !takeUntilSubscriber.seenValue) {\n            takeUntilSubscriber.add(notifierSubscription);\n            return source.subscribe(takeUntilSubscriber);\n        }\n        return takeUntilSubscriber;\n    };\n    return TakeUntilOperator;\n}());\nvar TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TakeUntilSubscriber, _super);\n    function TakeUntilSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.seenValue = false;\n        return _this;\n    }\n    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.seenValue = true;\n        this.complete();\n    };\n    TakeUntilSubscriber.prototype.notifyComplete = function () {\n    };\n    return TakeUntilSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=takeUntil.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function takeWhile(predicate, inclusive) {\n    if (inclusive === void 0) {\n        inclusive = false;\n    }\n    return function (source) {\n        return source.lift(new TakeWhileOperator(predicate, inclusive));\n    };\n}\nvar TakeWhileOperator = /*@__PURE__*/ (function () {\n    function TakeWhileOperator(predicate, inclusive) {\n        this.predicate = predicate;\n        this.inclusive = inclusive;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n    };\n    return TakeWhileOperator;\n}());\nvar TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate, inclusive) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.inclusive = inclusive;\n        _this.index = 0;\n        return _this;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            if (this.inclusive) {\n                destination.next(value);\n            }\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\nexport function tap(nextOrObserver, error, complete) {\n    return function tapOperatorFunction(source) {\n        return source.lift(new DoOperator(nextOrObserver, error, complete));\n    };\n}\nvar DoOperator = /*@__PURE__*/ (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\nvar TapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TapSubscriber, _super);\n    function TapSubscriber(destination, observerOrNext, error, complete) {\n        var _this = _super.call(this, destination) || this;\n        _this._tapNext = noop;\n        _this._tapError = noop;\n        _this._tapComplete = noop;\n        _this._tapError = error || noop;\n        _this._tapComplete = complete || noop;\n        if (isFunction(observerOrNext)) {\n            _this._context = _this;\n            _this._tapNext = observerOrNext;\n        }\n        else if (observerOrNext) {\n            _this._context = observerOrNext;\n            _this._tapNext = observerOrNext.next || noop;\n            _this._tapError = observerOrNext.error || noop;\n            _this._tapComplete = observerOrNext.complete || noop;\n        }\n        return _this;\n    }\n    TapSubscriber.prototype._next = function (value) {\n        try {\n            this._tapNext.call(this._context, value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(value);\n    };\n    TapSubscriber.prototype._error = function (err) {\n        try {\n            this._tapError.call(this._context, err);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.error(err);\n    };\n    TapSubscriber.prototype._complete = function () {\n        try {\n            this._tapComplete.call(this._context);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        return this.destination.complete();\n    };\n    return TapSubscriber;\n}(Subscriber));\n//# sourceMappingURL=tap.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport var defaultThrottleConfig = {\n    leading: true,\n    trailing: false\n};\nexport function throttle(durationSelector, config) {\n    if (config === void 0) {\n        config = defaultThrottleConfig;\n    }\n    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };\n}\nvar ThrottleOperator = /*@__PURE__*/ (function () {\n    function ThrottleOperator(durationSelector, leading, trailing) {\n        this.durationSelector = durationSelector;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n    };\n    return ThrottleOperator;\n}());\nvar ThrottleSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ThrottleSubscriber, _super);\n    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.durationSelector = durationSelector;\n        _this._leading = _leading;\n        _this._trailing = _trailing;\n        _this._hasValue = false;\n        return _this;\n    }\n    ThrottleSubscriber.prototype._next = function (value) {\n        this._hasValue = true;\n        this._sendValue = value;\n        if (!this._throttled) {\n            if (this._leading) {\n                this.send();\n            }\n            else {\n                this.throttle(value);\n            }\n        }\n    };\n    ThrottleSubscriber.prototype.send = function () {\n        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;\n        if (_hasValue) {\n            this.destination.next(_sendValue);\n            this.throttle(_sendValue);\n        }\n        this._hasValue = false;\n        this._sendValue = null;\n    };\n    ThrottleSubscriber.prototype.throttle = function (value) {\n        var duration = this.tryDurationSelector(value);\n        if (!!duration) {\n            this.add(this._throttled = subscribeToResult(this, duration));\n        }\n    };\n    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n        try {\n            return this.durationSelector(value);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return null;\n        }\n    };\n    ThrottleSubscriber.prototype.throttlingDone = function () {\n        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;\n        if (_throttled) {\n            _throttled.unsubscribe();\n        }\n        this._throttled = null;\n        if (_trailing) {\n            this.send();\n        }\n    };\n    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.throttlingDone();\n    };\n    ThrottleSubscriber.prototype.notifyComplete = function () {\n        this.throttlingDone();\n    };\n    return ThrottleSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=throttle.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nimport { defaultThrottleConfig } from './throttle';\nexport function throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    if (config === void 0) {\n        config = defaultThrottleConfig;\n    }\n    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n}\nvar ThrottleTimeOperator = /*@__PURE__*/ (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\nvar ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        var _this = _super.call(this, destination) || this;\n        _this.duration = duration;\n        _this.scheduler = scheduler;\n        _this.leading = leading;\n        _this.trailing = trailing;\n        _this._hasTrailingValue = false;\n        _this._trailingValue = null;\n        return _this;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n            else if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype._complete = function () {\n        if (this._hasTrailingValue) {\n            this.destination.next(this._trailingValue);\n            this.destination.complete();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n","/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { EmptyError } from '../util/EmptyError';\nimport { Subscriber } from '../Subscriber';\nexport function throwIfEmpty(errorFactory) {\n    if (errorFactory === void 0) {\n        errorFactory = defaultErrorFactory;\n    }\n    return function (source) {\n        return source.lift(new ThrowIfEmptyOperator(errorFactory));\n    };\n}\nvar ThrowIfEmptyOperator = /*@__PURE__*/ (function () {\n    function ThrowIfEmptyOperator(errorFactory) {\n        this.errorFactory = errorFactory;\n    }\n    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));\n    };\n    return ThrowIfEmptyOperator;\n}());\nvar ThrowIfEmptySubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ThrowIfEmptySubscriber, _super);\n    function ThrowIfEmptySubscriber(destination, errorFactory) {\n        var _this = _super.call(this, destination) || this;\n        _this.errorFactory = errorFactory;\n        _this.hasValue = false;\n        return _this;\n    }\n    ThrowIfEmptySubscriber.prototype._next = function (value) {\n        this.hasValue = true;\n        this.destination.next(value);\n    };\n    ThrowIfEmptySubscriber.prototype._complete = function () {\n        if (!this.hasValue) {\n            var err = void 0;\n            try {\n                err = this.errorFactory();\n            }\n            catch (e) {\n                err = e;\n            }\n            this.destination.error(err);\n        }\n        else {\n            return this.destination.complete();\n        }\n    };\n    return ThrowIfEmptySubscriber;\n}(Subscriber));\nfunction defaultErrorFactory() {\n    return new EmptyError();\n}\n//# sourceMappingURL=throwIfEmpty.js.map\n","/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */\nimport { async } from '../scheduler/async';\nimport { scan } from './scan';\nimport { defer } from '../observable/defer';\nimport { map } from './map';\nexport function timeInterval(scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    return function (source) {\n        return defer(function () {\n            return source.pipe(scan(function (_a, value) {\n                var current = _a.current;\n                return ({ value: value, current: scheduler.now(), last: current });\n            }, { current: scheduler.now(), value: undefined, last: undefined }), map(function (_a) {\n                var current = _a.current, last = _a.last, value = _a.value;\n                return new TimeInterval(value, current - last);\n            }));\n        });\n    };\n}\nvar TimeInterval = /*@__PURE__*/ (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexport { TimeInterval };\n//# sourceMappingURL=timeInterval.js.map\n","/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */\nimport { async } from '../scheduler/async';\nimport { TimeoutError } from '../util/TimeoutError';\nimport { timeoutWith } from './timeoutWith';\nimport { throwError } from '../observable/throwError';\nexport function timeout(due, scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n//# sourceMappingURL=timeout.js.map\n","/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    return function (source) {\n        var absoluteTimeout = isDate(due);\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n    };\n}\nvar TimeoutWithOperator = /*@__PURE__*/ (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\nvar TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.absoluteTimeout = absoluteTimeout;\n        _this.waitFor = waitFor;\n        _this.withObservable = withObservable;\n        _this.scheduler = scheduler;\n        _this.action = null;\n        _this.scheduleTimeout();\n        return _this;\n    }\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n        var withObservable = subscriber.withObservable;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult(subscriber, withObservable));\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutWithSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n","/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */\nimport { async } from '../scheduler/async';\nimport { map } from './map';\nexport function timestamp(scheduler) {\n    if (scheduler === void 0) {\n        scheduler = async;\n    }\n    return map(function (value) { return new Timestamp(value, scheduler.now()); });\n}\nvar Timestamp = /*@__PURE__*/ (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexport { Timestamp };\n//# sourceMappingURL=timestamp.js.map\n","/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */\nimport { reduce } from './reduce';\nfunction toArrayReducer(arr, item, index) {\n    if (index === 0) {\n        return [item];\n    }\n    arr.push(item);\n    return arr;\n}\nexport function toArray() {\n    return reduce(toArrayReducer, []);\n}\n//# sourceMappingURL=toArray.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function window(windowBoundaries) {\n    return function windowOperatorFunction(source) {\n        return source.lift(new WindowOperator(windowBoundaries));\n    };\n}\nvar WindowOperator = /*@__PURE__*/ (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\nvar WindowSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.window = new Subject();\n        destination.next(_this.window);\n        return _this;\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=window.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\nexport function windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) {\n        startWindowEvery = 0;\n    }\n    return function windowCountOperatorFunction(source) {\n        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n    };\n}\nvar WindowCountOperator = /*@__PURE__*/ (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\nvar WindowCountSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.windowSize = windowSize;\n        _this.startWindowEvery = startWindowEvery;\n        _this.windows = [new Subject()];\n        _this.count = 0;\n        destination.next(_this.windows[0]);\n        return _this;\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber));\n//# sourceMappingURL=windowCount.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n    var scheduler = async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nvar WindowTimeOperator = /*@__PURE__*/ (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(CountedSubject, _super);\n    function CountedSubject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._numberOfNextedValues = 0;\n        return _this;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject));\nvar WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.windowTimeSpan = windowTimeSpan;\n        _this.windowCreationInterval = windowCreationInterval;\n        _this.maxWindowSize = maxWindowSize;\n        _this.scheduler = scheduler;\n        _this.windows = [];\n        var window = _this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: _this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };\n            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };\n            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n        return _this;\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function windowToggle(openings, closingSelector) {\n    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n}\nvar WindowToggleOperator = /*@__PURE__*/ (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\nvar WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.openings = openings;\n        _this.closingSelector = closingSelector;\n        _this.contexts = [];\n        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));\n        return _this;\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context_1 = contexts[index];\n                context_1.window.error(err);\n                context_1.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context_2 = contexts[index];\n                context_2.window.complete();\n                context_2.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context_3 = contexts[index];\n                context_3.window.unsubscribe();\n                context_3.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingNotifier = void 0;\n            try {\n                var closingSelector = this.closingSelector;\n                closingNotifier = closingSelector(innerValue);\n            }\n            catch (e) {\n                return this.error(e);\n            }\n            var window_1 = new Subject();\n            var subscription = new Subscription();\n            var context_4 = { window: window_1, subscription: subscription };\n            this.contexts.push(context_4);\n            var innerSubscription = subscribeToResult(this, closingNotifier, context_4);\n            if (innerSubscription.closed) {\n                this.closeWindow(this.contexts.length - 1);\n            }\n            else {\n                innerSubscription.context = context_4;\n                subscription.add(innerSubscription);\n            }\n            this.destination.next(window_1);\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function windowWhen(closingSelector) {\n    return function windowWhenOperatorFunction(source) {\n        return source.lift(new WindowOperator(closingSelector));\n    };\n}\nvar WindowOperator = /*@__PURE__*/ (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\nvar WindowSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        _this.closingSelector = closingSelector;\n        _this.openWindow();\n        return _this;\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) {\n            innerSub = null;\n        }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject();\n        this.destination.next(window);\n        var closingNotifier;\n        try {\n            var closingSelector = this.closingSelector;\n            closingNotifier = closingSelector();\n        }\n        catch (e) {\n            this.destination.error(e);\n            this.window.error(e);\n            return;\n        }\n        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));\n    };\n    return WindowSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return function (source) {\n        var project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        var observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nvar WithLatestFromOperator = /*@__PURE__*/ (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\nvar WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        var _this = _super.call(this, destination) || this;\n        _this.observables = observables;\n        _this.project = project;\n        _this.toRespond = [];\n        var len = observables.length;\n        _this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            _this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            _this.add(subscribeToResult(_this, observable, observable, i));\n        }\n        return _this;\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n","/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */\nimport { zip as zipStatic } from '../observable/zip';\nexport function zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i] = arguments[_i];\n    }\n    return function zipOperatorFunction(source) {\n        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n    };\n}\n//# sourceMappingURL=zip.js.map\n","/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */\nimport { ZipOperator } from '../observable/zip';\nexport function zipAll(project) {\n    return function (source) { return source.lift(new ZipOperator(project)); };\n}\n//# sourceMappingURL=zipAll.js.map\n","/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nexport function scheduleArray(input, scheduler) {\n    return new Observable(function (subscriber) {\n        var sub = new Subscription();\n        var i = 0;\n        sub.add(scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(input[i++]);\n            if (!subscriber.closed) {\n                sub.add(this.schedule());\n            }\n        }));\n        return sub;\n    });\n}\n//# sourceMappingURL=scheduleArray.js.map\n","/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nexport function scheduleIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new Observable(function (subscriber) {\n        var sub = new Subscription();\n        var iterator;\n        sub.add(function () {\n            if (iterator && typeof iterator.return === 'function') {\n                iterator.return();\n            }\n        });\n        sub.add(scheduler.schedule(function () {\n            iterator = input[Symbol_iterator]();\n            sub.add(scheduler.schedule(function () {\n                if (subscriber.closed) {\n                    return;\n                }\n                var value;\n                var done;\n                try {\n                    var result = iterator.next();\n                    value = result.value;\n                    done = result.done;\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                    this.schedule();\n                }\n            }));\n        }));\n        return sub;\n    });\n}\n//# sourceMappingURL=scheduleIterable.js.map\n","/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function scheduleObservable(input, scheduler) {\n    return new Observable(function (subscriber) {\n        var sub = new Subscription();\n        sub.add(scheduler.schedule(function () {\n            var observable = input[Symbol_observable]();\n            sub.add(observable.subscribe({\n                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },\n                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },\n                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },\n            }));\n        }));\n        return sub;\n    });\n}\n//# sourceMappingURL=scheduleObservable.js.map\n","/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nexport function schedulePromise(input, scheduler) {\n    return new Observable(function (subscriber) {\n        var sub = new Subscription();\n        sub.add(scheduler.schedule(function () {\n            return input.then(function (value) {\n                sub.add(scheduler.schedule(function () {\n                    subscriber.next(value);\n                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));\n                }));\n            }, function (err) {\n                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));\n            });\n        }));\n        return sub;\n    });\n}\n//# sourceMappingURL=schedulePromise.js.map\n","/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */\nimport { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nexport function scheduled(input, scheduler) {\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return scheduleObservable(input, scheduler);\n        }\n        else if (isPromise(input)) {\n            return schedulePromise(input, scheduler);\n        }\n        else if (isArrayLike(input)) {\n            return scheduleArray(input, scheduler);\n        }\n        else if (isIterable(input) || typeof input === 'string') {\n            return scheduleIterable(input, scheduler);\n        }\n    }\n    throw new TypeError((input !== null && typeof input || input) + ' is not observable');\n}\n//# sourceMappingURL=scheduled.js.map\n","/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscription } from '../Subscription';\nvar Action = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Action, _super);\n    function Action(scheduler, work) {\n        return _super.call(this) || this;\n    }\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return this;\n    };\n    return Action;\n}(Subscription));\nexport { Action };\n//# sourceMappingURL=Action.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar AnimationFrameAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction));\nexport { AnimationFrameAction };\n//# sourceMappingURL=AnimationFrameAction.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler));\nexport { AnimationFrameScheduler };\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n","/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Immediate } from '../util/Immediate';\nimport { AsyncAction } from './AsyncAction';\nvar AsapAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction));\nexport { AsapAction };\n//# sourceMappingURL=AsapAction.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AsapScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler));\nexport { AsapScheduler };\n//# sourceMappingURL=AsapScheduler.js.map\n","/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Action } from './Action';\nvar AsyncAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.pending = false;\n        return _this;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        clearInterval(id);\n        return undefined;\n    };\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action));\nexport { AsyncAction };\n//# sourceMappingURL=AsyncAction.js.map\n","/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Scheduler } from '../Scheduler';\nvar AsyncScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        var _this = _super.call(this, SchedulerAction, function () {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        }) || this;\n        _this.actions = [];\n        _this.active = false;\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return _super.prototype.schedule.call(this, work, delay, state);\n        }\n    };\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler));\nexport { AsyncScheduler };\n//# sourceMappingURL=AsyncScheduler.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar QueueAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction));\nexport { QueueAction };\n//# sourceMappingURL=QueueAction.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar QueueScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QueueScheduler;\n}(AsyncScheduler));\nexport { QueueScheduler };\n//# sourceMappingURL=QueueScheduler.js.map\n","/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nvar VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n        if (SchedulerAction === void 0) {\n            SchedulerAction = VirtualAction;\n        }\n        if (maxFrames === void 0) {\n            maxFrames = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;\n        _this.maxFrames = maxFrames;\n        _this.frame = 0;\n        _this.index = -1;\n        return _this;\n    }\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error, action;\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n            actions.shift();\n            this.frame = action.delay;\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler));\nexport { VirtualTimeScheduler };\nvar VirtualAction = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) {\n            index = scheduler.index += 1;\n        }\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.index = index;\n        _this.active = true;\n        _this.index = scheduler.index = index;\n        return _this;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (!this.id) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.active = false;\n        var action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return undefined;\n    };\n    VirtualAction.prototype._execute = function (state, delay) {\n        if (this.active === true) {\n            return _super.prototype._execute.call(this, state, delay);\n        }\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction));\nexport { VirtualAction };\n//# sourceMappingURL=VirtualTimeScheduler.js.map\n","/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */\nimport { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);\n//# sourceMappingURL=animationFrame.js.map\n","/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */\nimport { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\nexport var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);\n//# sourceMappingURL=asap.js.map\n","/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);\n//# sourceMappingURL=async.js.map\n","/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */\nimport { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\nexport var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);\n//# sourceMappingURL=queue.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexport var iterator = /*@__PURE__*/ getSymbolIterator();\nexport var $$iterator = iterator;\n//# sourceMappingURL=iterator.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';\n//# sourceMappingURL=observable.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var rxSubscriber = typeof Symbol === 'function'\n    ? /*@__PURE__*/ Symbol('rxSubscriber')\n    : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();\nexport var $$rxSubscriber = rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction ArgumentOutOfRangeErrorImpl() {\n    Error.call(this);\n    this.message = 'argument out of range';\n    this.name = 'ArgumentOutOfRangeError';\n    return this;\n}\nArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\nexport var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction EmptyErrorImpl() {\n    Error.call(this);\n    this.message = 'no elements in sequence';\n    this.name = 'EmptyError';\n    return this;\n}\nEmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\nexport var EmptyError = EmptyErrorImpl;\n//# sourceMappingURL=EmptyError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar nextHandle = 1;\nvar tasksByHandle = {};\nfunction runIfPresent(handle) {\n    var cb = tasksByHandle[handle];\n    if (cb) {\n        cb();\n    }\n}\nexport var Immediate = {\n    setImmediate: function (cb) {\n        var handle = nextHandle++;\n        tasksByHandle[handle] = cb;\n        Promise.resolve().then(function () { return runIfPresent(handle); });\n        return handle;\n    },\n    clearImmediate: function (handle) {\n        delete tasksByHandle[handle];\n    },\n};\n//# sourceMappingURL=Immediate.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction ObjectUnsubscribedErrorImpl() {\n    Error.call(this);\n    this.message = 'object unsubscribed';\n    this.name = 'ObjectUnsubscribedError';\n    return this;\n}\nObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\nexport var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction TimeoutErrorImpl() {\n    Error.call(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    return this;\n}\nTimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\nexport var TimeoutError = TimeoutErrorImpl;\n//# sourceMappingURL=TimeoutError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction UnsubscriptionErrorImpl(errors) {\n    Error.call(this);\n    this.message = errors ?\n        errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ') : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n    return this;\n}\nUnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\nexport var UnsubscriptionError = UnsubscriptionErrorImpl;\n//# sourceMappingURL=UnsubscriptionError.js.map\n","/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\nimport { Subscriber } from '../Subscriber';\nexport function canReportError(observer) {\n    while (observer) {\n        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;\n        if (closed_1 || isStopped) {\n            return false;\n        }\n        else if (destination && destination instanceof Subscriber) {\n            observer = destination;\n        }\n        else {\n            observer = null;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=canReportError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function hostReportError(err) {\n    setTimeout(function () { throw err; }, 0);\n}\n//# sourceMappingURL=hostReportError.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n//# sourceMappingURL=isArrayLike.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\n//# sourceMappingURL=isDate.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function isFunction(x) {\n    return typeof x === 'function';\n}\n//# sourceMappingURL=isFunction.js.map\n","/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function isInteropObservable(input) {\n    return input && typeof input[Symbol_observable] === 'function';\n}\n//# sourceMappingURL=isInteropObservable.js.map\n","/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nexport function isIterable(input) {\n    return input && typeof input[Symbol_iterator] === 'function';\n}\n//# sourceMappingURL=isIterable.js.map\n","/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\nimport { isArray } from './isArray';\nexport function isNumeric(val) {\n    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\n//# sourceMappingURL=isNumeric.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function isObject(x) {\n    return x !== null && typeof x === 'object';\n}\n//# sourceMappingURL=isObject.js.map\n","/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\n}\n//# sourceMappingURL=isObservable.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function isPromise(value) {\n    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n//# sourceMappingURL=isPromise.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\n//# sourceMappingURL=isScheduler.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function noop() { }\n//# sourceMappingURL=noop.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\n//# sourceMappingURL=not.js.map\n","/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */\nimport { noop } from './noop';\nexport function pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (!fns) {\n        return noop;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map\n","/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\nimport { subscribeToArray } from './subscribeToArray';\nimport { subscribeToPromise } from './subscribeToPromise';\nimport { subscribeToIterable } from './subscribeToIterable';\nimport { subscribeToObservable } from './subscribeToObservable';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport var subscribeTo = function (result) {\n    if (!!result && typeof result[Symbol_observable] === 'function') {\n        return subscribeToObservable(result);\n    }\n    else if (isArrayLike(result)) {\n        return subscribeToArray(result);\n    }\n    else if (isPromise(result)) {\n        return subscribeToPromise(result);\n    }\n    else if (!!result && typeof result[Symbol_iterator] === 'function') {\n        return subscribeToIterable(result);\n    }\n    else {\n        var value = isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n        var msg = \"You provided \" + value + \" where a stream was expected.\"\n            + ' You can provide an Observable, Promise, Array, or Iterable.';\n        throw new TypeError(msg);\n    }\n};\n//# sourceMappingURL=subscribeTo.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var subscribeToArray = function (array) {\n    return function (subscriber) {\n        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    };\n};\n//# sourceMappingURL=subscribeToArray.js.map\n","/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nexport var subscribeToIterable = function (iterable) {\n    return function (subscriber) {\n        var iterator = iterable[Symbol_iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                subscriber.complete();\n                break;\n            }\n            subscriber.next(item.value);\n            if (subscriber.closed) {\n                break;\n            }\n        } while (true);\n        if (typeof iterator.return === 'function') {\n            subscriber.add(function () {\n                if (iterator.return) {\n                    iterator.return();\n                }\n            });\n        }\n        return subscriber;\n    };\n};\n//# sourceMappingURL=subscribeToIterable.js.map\n","/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport var subscribeToObservable = function (obj) {\n    return function (subscriber) {\n        var obs = obj[Symbol_observable]();\n        if (typeof obs.subscribe !== 'function') {\n            throw new TypeError('Provided object does not correctly implement Symbol.observable');\n        }\n        else {\n            return obs.subscribe(subscriber);\n        }\n    };\n};\n//# sourceMappingURL=subscribeToObservable.js.map\n","/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\nimport { hostReportError } from './hostReportError';\nexport var subscribeToPromise = function (promise) {\n    return function (subscriber) {\n        promise.then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, hostReportError);\n        return subscriber;\n    };\n};\n//# sourceMappingURL=subscribeToPromise.js.map\n","/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeTo } from './subscribeTo';\nimport { Observable } from '../Observable';\nexport function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {\n    if (destination === void 0) {\n        destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    }\n    if (destination.closed) {\n        return undefined;\n    }\n    if (result instanceof Observable) {\n        return result.subscribe(destination);\n    }\n    return subscribeTo(result)(destination);\n}\n//# sourceMappingURL=subscribeToResult.js.map\n","/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\nimport { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nexport function toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriberSymbol]) {\n            return nextOrObserver[rxSubscriberSymbol]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber(emptyObserver);\n    }\n    return new Subscriber(nextOrObserver, error, complete);\n}\n//# sourceMappingURL=toSubscriber.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport { audit } from '../internal/operators/audit';\nexport { auditTime } from '../internal/operators/auditTime';\nexport { buffer } from '../internal/operators/buffer';\nexport { bufferCount } from '../internal/operators/bufferCount';\nexport { bufferTime } from '../internal/operators/bufferTime';\nexport { bufferToggle } from '../internal/operators/bufferToggle';\nexport { bufferWhen } from '../internal/operators/bufferWhen';\nexport { catchError } from '../internal/operators/catchError';\nexport { combineAll } from '../internal/operators/combineAll';\nexport { combineLatest } from '../internal/operators/combineLatest';\nexport { concat } from '../internal/operators/concat';\nexport { concatAll } from '../internal/operators/concatAll';\nexport { concatMap } from '../internal/operators/concatMap';\nexport { concatMapTo } from '../internal/operators/concatMapTo';\nexport { count } from '../internal/operators/count';\nexport { debounce } from '../internal/operators/debounce';\nexport { debounceTime } from '../internal/operators/debounceTime';\nexport { defaultIfEmpty } from '../internal/operators/defaultIfEmpty';\nexport { delay } from '../internal/operators/delay';\nexport { delayWhen } from '../internal/operators/delayWhen';\nexport { dematerialize } from '../internal/operators/dematerialize';\nexport { distinct } from '../internal/operators/distinct';\nexport { distinctUntilChanged } from '../internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from '../internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from '../internal/operators/elementAt';\nexport { endWith } from '../internal/operators/endWith';\nexport { every } from '../internal/operators/every';\nexport { exhaust } from '../internal/operators/exhaust';\nexport { exhaustMap } from '../internal/operators/exhaustMap';\nexport { expand } from '../internal/operators/expand';\nexport { filter } from '../internal/operators/filter';\nexport { finalize } from '../internal/operators/finalize';\nexport { find } from '../internal/operators/find';\nexport { findIndex } from '../internal/operators/findIndex';\nexport { first } from '../internal/operators/first';\nexport { groupBy } from '../internal/operators/groupBy';\nexport { ignoreElements } from '../internal/operators/ignoreElements';\nexport { isEmpty } from '../internal/operators/isEmpty';\nexport { last } from '../internal/operators/last';\nexport { map } from '../internal/operators/map';\nexport { mapTo } from '../internal/operators/mapTo';\nexport { materialize } from '../internal/operators/materialize';\nexport { max } from '../internal/operators/max';\nexport { merge } from '../internal/operators/merge';\nexport { mergeAll } from '../internal/operators/mergeAll';\nexport { mergeMap } from '../internal/operators/mergeMap';\nexport { mergeMap as flatMap } from '../internal/operators/mergeMap';\nexport { mergeMapTo } from '../internal/operators/mergeMapTo';\nexport { mergeScan } from '../internal/operators/mergeScan';\nexport { min } from '../internal/operators/min';\nexport { multicast } from '../internal/operators/multicast';\nexport { observeOn } from '../internal/operators/observeOn';\nexport { onErrorResumeNext } from '../internal/operators/onErrorResumeNext';\nexport { pairwise } from '../internal/operators/pairwise';\nexport { partition } from '../internal/operators/partition';\nexport { pluck } from '../internal/operators/pluck';\nexport { publish } from '../internal/operators/publish';\nexport { publishBehavior } from '../internal/operators/publishBehavior';\nexport { publishLast } from '../internal/operators/publishLast';\nexport { publishReplay } from '../internal/operators/publishReplay';\nexport { race } from '../internal/operators/race';\nexport { reduce } from '../internal/operators/reduce';\nexport { repeat } from '../internal/operators/repeat';\nexport { repeatWhen } from '../internal/operators/repeatWhen';\nexport { retry } from '../internal/operators/retry';\nexport { retryWhen } from '../internal/operators/retryWhen';\nexport { refCount } from '../internal/operators/refCount';\nexport { sample } from '../internal/operators/sample';\nexport { sampleTime } from '../internal/operators/sampleTime';\nexport { scan } from '../internal/operators/scan';\nexport { sequenceEqual } from '../internal/operators/sequenceEqual';\nexport { share } from '../internal/operators/share';\nexport { shareReplay } from '../internal/operators/shareReplay';\nexport { single } from '../internal/operators/single';\nexport { skip } from '../internal/operators/skip';\nexport { skipLast } from '../internal/operators/skipLast';\nexport { skipUntil } from '../internal/operators/skipUntil';\nexport { skipWhile } from '../internal/operators/skipWhile';\nexport { startWith } from '../internal/operators/startWith';\nexport { subscribeOn } from '../internal/operators/subscribeOn';\nexport { switchAll } from '../internal/operators/switchAll';\nexport { switchMap } from '../internal/operators/switchMap';\nexport { switchMapTo } from '../internal/operators/switchMapTo';\nexport { take } from '../internal/operators/take';\nexport { takeLast } from '../internal/operators/takeLast';\nexport { takeUntil } from '../internal/operators/takeUntil';\nexport { takeWhile } from '../internal/operators/takeWhile';\nexport { tap } from '../internal/operators/tap';\nexport { throttle } from '../internal/operators/throttle';\nexport { throttleTime } from '../internal/operators/throttleTime';\nexport { throwIfEmpty } from '../internal/operators/throwIfEmpty';\nexport { timeInterval } from '../internal/operators/timeInterval';\nexport { timeout } from '../internal/operators/timeout';\nexport { timeoutWith } from '../internal/operators/timeoutWith';\nexport { timestamp } from '../internal/operators/timestamp';\nexport { toArray } from '../internal/operators/toArray';\nexport { window } from '../internal/operators/window';\nexport { windowCount } from '../internal/operators/windowCount';\nexport { windowTime } from '../internal/operators/windowTime';\nexport { windowToggle } from '../internal/operators/windowToggle';\nexport { windowWhen } from '../internal/operators/windowWhen';\nexport { withLatestFrom } from '../internal/operators/withLatestFrom';\nexport { zip } from '../internal/operators/zip';\nexport { zipAll } from '../internal/operators/zipAll';\n//# sourceMappingURL=index.js.map\n","/* eslint-disable node/no-deprecated-api */\n\n'use strict'\n\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\nvar safer = {}\n\nvar key\n\nfor (key in buffer) {\n  if (!buffer.hasOwnProperty(key)) continue\n  if (key === 'SlowBuffer' || key === 'Buffer') continue\n  safer[key] = buffer[key]\n}\n\nvar Safer = safer.Buffer = {}\nfor (key in Buffer) {\n  if (!Buffer.hasOwnProperty(key)) continue\n  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue\n  Safer[key] = Buffer[key]\n}\n\nsafer.Buffer.prototype = Buffer.prototype\n\nif (!Safer.from || Safer.from === Uint8Array.from) {\n  Safer.from = function (value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof value)\n    }\n    if (value && typeof value.length === 'undefined') {\n      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)\n    }\n    return Buffer(value, encodingOrOffset, length)\n  }\n}\n\nif (!Safer.alloc) {\n  Safer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof size)\n    }\n    if (size < 0 || size >= 2 * (1 << 30)) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n    }\n    var buf = Buffer(size)\n    if (!fill || fill.length === 0) {\n      buf.fill(0)\n    } else if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n    return buf\n  }\n}\n\nif (!safer.kStringMaxLength) {\n  try {\n    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength\n  } catch (e) {\n    // we can't determine kStringMaxLength in environments where process.binding\n    // is unsupported, so let's not set it\n  }\n}\n\nif (!safer.constants) {\n  safer.constants = {\n    MAX_LENGTH: safer.kMaxLength\n  }\n  if (safer.kStringMaxLength) {\n    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength\n  }\n}\n\nmodule.exports = safer\n","/*!\n * send\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar debug = require('debug')('send')\nvar deprecate = require('depd')('send')\nvar destroy = require('destroy')\nvar encodeUrl = require('encodeurl')\nvar escapeHtml = require('escape-html')\nvar etag = require('etag')\nvar fresh = require('fresh')\nvar fs = require('fs')\nvar mime = require('mime')\nvar ms = require('ms')\nvar onFinished = require('on-finished')\nvar parseRange = require('range-parser')\nvar path = require('path')\nvar statuses = require('statuses')\nvar Stream = require('stream')\nvar util = require('util')\n\n/**\n * Path function references.\n * @private\n */\n\nvar extname = path.extname\nvar join = path.join\nvar normalize = path.normalize\nvar resolve = path.resolve\nvar sep = path.sep\n\n/**\n * Regular expression for identifying a bytes Range header.\n * @private\n */\n\nvar BYTES_RANGE_REGEXP = /^ *bytes=/\n\n/**\n * Maximum value allowed for the max age.\n * @private\n */\n\nvar MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year\n\n/**\n * Regular expression to match a path with a directory up component.\n * @private\n */\n\nvar UP_PATH_REGEXP = /(?:^|[\\\\/])\\.\\.(?:[\\\\/]|$)/\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = send\nmodule.exports.mime = mime\n\n/**\n * Return a `SendStream` for `req` and `path`.\n *\n * @param {object} req\n * @param {string} path\n * @param {object} [options]\n * @return {SendStream}\n * @public\n */\n\nfunction send (req, path, options) {\n  return new SendStream(req, path, options)\n}\n\n/**\n * Initialize a `SendStream` with the given `path`.\n *\n * @param {Request} req\n * @param {String} path\n * @param {object} [options]\n * @private\n */\n\nfunction SendStream (req, path, options) {\n  Stream.call(this)\n\n  var opts = options || {}\n\n  this.options = opts\n  this.path = path\n  this.req = req\n\n  this._acceptRanges = opts.acceptRanges !== undefined\n    ? Boolean(opts.acceptRanges)\n    : true\n\n  this._cacheControl = opts.cacheControl !== undefined\n    ? Boolean(opts.cacheControl)\n    : true\n\n  this._etag = opts.etag !== undefined\n    ? Boolean(opts.etag)\n    : true\n\n  this._dotfiles = opts.dotfiles !== undefined\n    ? opts.dotfiles\n    : 'ignore'\n\n  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {\n    throw new TypeError('dotfiles option must be \"allow\", \"deny\", or \"ignore\"')\n  }\n\n  this._hidden = Boolean(opts.hidden)\n\n  if (opts.hidden !== undefined) {\n    deprecate('hidden: use dotfiles: \\'' + (this._hidden ? 'allow' : 'ignore') + '\\' instead')\n  }\n\n  // legacy support\n  if (opts.dotfiles === undefined) {\n    this._dotfiles = undefined\n  }\n\n  this._extensions = opts.extensions !== undefined\n    ? normalizeList(opts.extensions, 'extensions option')\n    : []\n\n  this._immutable = opts.immutable !== undefined\n    ? Boolean(opts.immutable)\n    : false\n\n  this._index = opts.index !== undefined\n    ? normalizeList(opts.index, 'index option')\n    : ['index.html']\n\n  this._lastModified = opts.lastModified !== undefined\n    ? Boolean(opts.lastModified)\n    : true\n\n  this._maxage = opts.maxAge || opts.maxage\n  this._maxage = typeof this._maxage === 'string'\n    ? ms(this._maxage)\n    : Number(this._maxage)\n  this._maxage = !isNaN(this._maxage)\n    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)\n    : 0\n\n  this._root = opts.root\n    ? resolve(opts.root)\n    : null\n\n  if (!this._root && opts.from) {\n    this.from(opts.from)\n  }\n}\n\n/**\n * Inherits from `Stream`.\n */\n\nutil.inherits(SendStream, Stream)\n\n/**\n * Enable or disable etag generation.\n *\n * @param {Boolean} val\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.etag = deprecate.function(function etag (val) {\n  this._etag = Boolean(val)\n  debug('etag %s', this._etag)\n  return this\n}, 'send.etag: pass etag as option')\n\n/**\n * Enable or disable \"hidden\" (dot) files.\n *\n * @param {Boolean} path\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.hidden = deprecate.function(function hidden (val) {\n  this._hidden = Boolean(val)\n  this._dotfiles = undefined\n  debug('hidden %s', this._hidden)\n  return this\n}, 'send.hidden: use dotfiles option')\n\n/**\n * Set index `paths`, set to a falsy\n * value to disable index support.\n *\n * @param {String|Boolean|Array} paths\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.index = deprecate.function(function index (paths) {\n  var index = !paths ? [] : normalizeList(paths, 'paths argument')\n  debug('index %o', paths)\n  this._index = index\n  return this\n}, 'send.index: pass index as option')\n\n/**\n * Set root `path`.\n *\n * @param {String} path\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.root = function root (path) {\n  this._root = resolve(String(path))\n  debug('root %s', this._root)\n  return this\n}\n\nSendStream.prototype.from = deprecate.function(SendStream.prototype.root,\n  'send.from: pass root as option')\n\nSendStream.prototype.root = deprecate.function(SendStream.prototype.root,\n  'send.root: pass root as option')\n\n/**\n * Set max-age to `maxAge`.\n *\n * @param {Number} maxAge\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {\n  this._maxage = typeof maxAge === 'string'\n    ? ms(maxAge)\n    : Number(maxAge)\n  this._maxage = !isNaN(this._maxage)\n    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)\n    : 0\n  debug('max-age %d', this._maxage)\n  return this\n}, 'send.maxage: pass maxAge as option')\n\n/**\n * Emit error with `status`.\n *\n * @param {number} status\n * @param {Error} [err]\n * @private\n */\n\nSendStream.prototype.error = function error (status, err) {\n  // emit if listeners instead of responding\n  if (hasListeners(this, 'error')) {\n    return this.emit('error', createError(status, err, {\n      expose: false\n    }))\n  }\n\n  var res = this.res\n  var msg = statuses[status] || String(status)\n  var doc = createHtmlDocument('Error', escapeHtml(msg))\n\n  // clear existing headers\n  clearHeaders(res)\n\n  // add error headers\n  if (err && err.headers) {\n    setHeaders(res, err.headers)\n  }\n\n  // send basic response\n  res.statusCode = status\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n  res.setHeader('Content-Length', Buffer.byteLength(doc))\n  res.setHeader('Content-Security-Policy', \"default-src 'none'\")\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.end(doc)\n}\n\n/**\n * Check if the pathname ends with \"/\".\n *\n * @return {boolean}\n * @private\n */\n\nSendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {\n  return this.path[this.path.length - 1] === '/'\n}\n\n/**\n * Check if this is a conditional GET request.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isConditionalGET = function isConditionalGET () {\n  return this.req.headers['if-match'] ||\n    this.req.headers['if-unmodified-since'] ||\n    this.req.headers['if-none-match'] ||\n    this.req.headers['if-modified-since']\n}\n\n/**\n * Check if the request preconditions failed.\n *\n * @return {boolean}\n * @private\n */\n\nSendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {\n  var req = this.req\n  var res = this.res\n\n  // if-match\n  var match = req.headers['if-match']\n  if (match) {\n    var etag = res.getHeader('ETag')\n    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {\n      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag\n    }))\n  }\n\n  // if-unmodified-since\n  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])\n  if (!isNaN(unmodifiedSince)) {\n    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))\n    return isNaN(lastModified) || lastModified > unmodifiedSince\n  }\n\n  return false\n}\n\n/**\n * Strip content-* header fields.\n *\n * @private\n */\n\nSendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {\n  var res = this.res\n  var headers = getHeaderNames(res)\n\n  for (var i = 0; i < headers.length; i++) {\n    var header = headers[i]\n    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {\n      res.removeHeader(header)\n    }\n  }\n}\n\n/**\n * Respond with 304 not modified.\n *\n * @api private\n */\n\nSendStream.prototype.notModified = function notModified () {\n  var res = this.res\n  debug('not modified')\n  this.removeContentHeaderFields()\n  res.statusCode = 304\n  res.end()\n}\n\n/**\n * Raise error that headers already sent.\n *\n * @api private\n */\n\nSendStream.prototype.headersAlreadySent = function headersAlreadySent () {\n  var err = new Error('Can\\'t set headers after they are sent.')\n  debug('headers already sent')\n  this.error(500, err)\n}\n\n/**\n * Check if the request is cacheable, aka\n * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isCachable = function isCachable () {\n  var statusCode = this.res.statusCode\n  return (statusCode >= 200 && statusCode < 300) ||\n    statusCode === 304\n}\n\n/**\n * Handle stat() error.\n *\n * @param {Error} error\n * @private\n */\n\nSendStream.prototype.onStatError = function onStatError (error) {\n  switch (error.code) {\n    case 'ENAMETOOLONG':\n    case 'ENOENT':\n    case 'ENOTDIR':\n      this.error(404, error)\n      break\n    default:\n      this.error(500, error)\n      break\n  }\n}\n\n/**\n * Check if the cache is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isFresh = function isFresh () {\n  return fresh(this.req.headers, {\n    'etag': this.res.getHeader('ETag'),\n    'last-modified': this.res.getHeader('Last-Modified')\n  })\n}\n\n/**\n * Check if the range is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isRangeFresh = function isRangeFresh () {\n  var ifRange = this.req.headers['if-range']\n\n  if (!ifRange) {\n    return true\n  }\n\n  // if-range as etag\n  if (ifRange.indexOf('\"') !== -1) {\n    var etag = this.res.getHeader('ETag')\n    return Boolean(etag && ifRange.indexOf(etag) !== -1)\n  }\n\n  // if-range as modified date\n  var lastModified = this.res.getHeader('Last-Modified')\n  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)\n}\n\n/**\n * Redirect to path.\n *\n * @param {string} path\n * @private\n */\n\nSendStream.prototype.redirect = function redirect (path) {\n  var res = this.res\n\n  if (hasListeners(this, 'directory')) {\n    this.emit('directory', res, path)\n    return\n  }\n\n  if (this.hasTrailingSlash()) {\n    this.error(403)\n    return\n  }\n\n  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))\n  var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href=\"' + escapeHtml(loc) + '\">' +\n    escapeHtml(loc) + '</a>')\n\n  // redirect\n  res.statusCode = 301\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n  res.setHeader('Content-Length', Buffer.byteLength(doc))\n  res.setHeader('Content-Security-Policy', \"default-src 'none'\")\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.setHeader('Location', loc)\n  res.end(doc)\n}\n\n/**\n * Pipe to `res.\n *\n * @param {Stream} res\n * @return {Stream} res\n * @api public\n */\n\nSendStream.prototype.pipe = function pipe (res) {\n  // root path\n  var root = this._root\n\n  // references\n  this.res = res\n\n  // decode the path\n  var path = decode(this.path)\n  if (path === -1) {\n    this.error(400)\n    return res\n  }\n\n  // null byte(s)\n  if (~path.indexOf('\\0')) {\n    this.error(400)\n    return res\n  }\n\n  var parts\n  if (root !== null) {\n    // normalize\n    if (path) {\n      path = normalize('.' + sep + path)\n    }\n\n    // malicious path\n    if (UP_PATH_REGEXP.test(path)) {\n      debug('malicious path \"%s\"', path)\n      this.error(403)\n      return res\n    }\n\n    // explode path parts\n    parts = path.split(sep)\n\n    // join / normalize from optional root dir\n    path = normalize(join(root, path))\n  } else {\n    // \"..\" is malicious without \"root\"\n    if (UP_PATH_REGEXP.test(path)) {\n      debug('malicious path \"%s\"', path)\n      this.error(403)\n      return res\n    }\n\n    // explode path parts\n    parts = normalize(path).split(sep)\n\n    // resolve the path\n    path = resolve(path)\n  }\n\n  // dotfile handling\n  if (containsDotFile(parts)) {\n    var access = this._dotfiles\n\n    // legacy support\n    if (access === undefined) {\n      access = parts[parts.length - 1][0] === '.'\n        ? (this._hidden ? 'allow' : 'ignore')\n        : 'allow'\n    }\n\n    debug('%s dotfile \"%s\"', access, path)\n    switch (access) {\n      case 'allow':\n        break\n      case 'deny':\n        this.error(403)\n        return res\n      case 'ignore':\n      default:\n        this.error(404)\n        return res\n    }\n  }\n\n  // index file support\n  if (this._index.length && this.hasTrailingSlash()) {\n    this.sendIndex(path)\n    return res\n  }\n\n  this.sendFile(path)\n  return res\n}\n\n/**\n * Transfer `path`.\n *\n * @param {String} path\n * @api public\n */\n\nSendStream.prototype.send = function send (path, stat) {\n  var len = stat.size\n  var options = this.options\n  var opts = {}\n  var res = this.res\n  var req = this.req\n  var ranges = req.headers.range\n  var offset = options.start || 0\n\n  if (headersSent(res)) {\n    // impossible to send now\n    this.headersAlreadySent()\n    return\n  }\n\n  debug('pipe \"%s\"', path)\n\n  // set header fields\n  this.setHeader(path, stat)\n\n  // set content-type\n  this.type(path)\n\n  // conditional GET support\n  if (this.isConditionalGET()) {\n    if (this.isPreconditionFailure()) {\n      this.error(412)\n      return\n    }\n\n    if (this.isCachable() && this.isFresh()) {\n      this.notModified()\n      return\n    }\n  }\n\n  // adjust len to start/end options\n  len = Math.max(0, len - offset)\n  if (options.end !== undefined) {\n    var bytes = options.end - offset + 1\n    if (len > bytes) len = bytes\n  }\n\n  // Range support\n  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {\n    // parse\n    ranges = parseRange(len, ranges, {\n      combine: true\n    })\n\n    // If-Range support\n    if (!this.isRangeFresh()) {\n      debug('range stale')\n      ranges = -2\n    }\n\n    // unsatisfiable\n    if (ranges === -1) {\n      debug('range unsatisfiable')\n\n      // Content-Range\n      res.setHeader('Content-Range', contentRange('bytes', len))\n\n      // 416 Requested Range Not Satisfiable\n      return this.error(416, {\n        headers: { 'Content-Range': res.getHeader('Content-Range') }\n      })\n    }\n\n    // valid (syntactically invalid/multiple ranges are treated as a regular response)\n    if (ranges !== -2 && ranges.length === 1) {\n      debug('range %j', ranges)\n\n      // Content-Range\n      res.statusCode = 206\n      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))\n\n      // adjust for requested range\n      offset += ranges[0].start\n      len = ranges[0].end - ranges[0].start + 1\n    }\n  }\n\n  // clone options\n  for (var prop in options) {\n    opts[prop] = options[prop]\n  }\n\n  // set read options\n  opts.start = offset\n  opts.end = Math.max(offset, offset + len - 1)\n\n  // content-length\n  res.setHeader('Content-Length', len)\n\n  // HEAD support\n  if (req.method === 'HEAD') {\n    res.end()\n    return\n  }\n\n  this.stream(path, opts)\n}\n\n/**\n * Transfer file for `path`.\n *\n * @param {String} path\n * @api private\n */\nSendStream.prototype.sendFile = function sendFile (path) {\n  var i = 0\n  var self = this\n\n  debug('stat \"%s\"', path)\n  fs.stat(path, function onstat (err, stat) {\n    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {\n      // not found, check extensions\n      return next(err)\n    }\n    if (err) return self.onStatError(err)\n    if (stat.isDirectory()) return self.redirect(path)\n    self.emit('file', path, stat)\n    self.send(path, stat)\n  })\n\n  function next (err) {\n    if (self._extensions.length <= i) {\n      return err\n        ? self.onStatError(err)\n        : self.error(404)\n    }\n\n    var p = path + '.' + self._extensions[i++]\n\n    debug('stat \"%s\"', p)\n    fs.stat(p, function (err, stat) {\n      if (err) return next(err)\n      if (stat.isDirectory()) return next()\n      self.emit('file', p, stat)\n      self.send(p, stat)\n    })\n  }\n}\n\n/**\n * Transfer index for `path`.\n *\n * @param {String} path\n * @api private\n */\nSendStream.prototype.sendIndex = function sendIndex (path) {\n  var i = -1\n  var self = this\n\n  function next (err) {\n    if (++i >= self._index.length) {\n      if (err) return self.onStatError(err)\n      return self.error(404)\n    }\n\n    var p = join(path, self._index[i])\n\n    debug('stat \"%s\"', p)\n    fs.stat(p, function (err, stat) {\n      if (err) return next(err)\n      if (stat.isDirectory()) return next()\n      self.emit('file', p, stat)\n      self.send(p, stat)\n    })\n  }\n\n  next()\n}\n\n/**\n * Stream `path` to the response.\n *\n * @param {String} path\n * @param {Object} options\n * @api private\n */\n\nSendStream.prototype.stream = function stream (path, options) {\n  // TODO: this is all lame, refactor meeee\n  var finished = false\n  var self = this\n  var res = this.res\n\n  // pipe\n  var stream = fs.createReadStream(path, options)\n  this.emit('stream', stream)\n  stream.pipe(res)\n\n  // response finished, done with the fd\n  onFinished(res, function onfinished () {\n    finished = true\n    destroy(stream)\n  })\n\n  // error handling code-smell\n  stream.on('error', function onerror (err) {\n    // request already finished\n    if (finished) return\n\n    // clean up stream\n    finished = true\n    destroy(stream)\n\n    // error\n    self.onStatError(err)\n  })\n\n  // end\n  stream.on('end', function onend () {\n    self.emit('end')\n  })\n}\n\n/**\n * Set content-type based on `path`\n * if it hasn't been explicitly set.\n *\n * @param {String} path\n * @api private\n */\n\nSendStream.prototype.type = function type (path) {\n  var res = this.res\n\n  if (res.getHeader('Content-Type')) return\n\n  var type = mime.lookup(path)\n\n  if (!type) {\n    debug('no content-type')\n    return\n  }\n\n  var charset = mime.charsets.lookup(type)\n\n  debug('content-type %s', type)\n  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))\n}\n\n/**\n * Set response header fields, most\n * fields may be pre-defined.\n *\n * @param {String} path\n * @param {Object} stat\n * @api private\n */\n\nSendStream.prototype.setHeader = function setHeader (path, stat) {\n  var res = this.res\n\n  this.emit('headers', res, path, stat)\n\n  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {\n    debug('accept ranges')\n    res.setHeader('Accept-Ranges', 'bytes')\n  }\n\n  if (this._cacheControl && !res.getHeader('Cache-Control')) {\n    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)\n\n    if (this._immutable) {\n      cacheControl += ', immutable'\n    }\n\n    debug('cache-control %s', cacheControl)\n    res.setHeader('Cache-Control', cacheControl)\n  }\n\n  if (this._lastModified && !res.getHeader('Last-Modified')) {\n    var modified = stat.mtime.toUTCString()\n    debug('modified %s', modified)\n    res.setHeader('Last-Modified', modified)\n  }\n\n  if (this._etag && !res.getHeader('ETag')) {\n    var val = etag(stat)\n    debug('etag %s', val)\n    res.setHeader('ETag', val)\n  }\n}\n\n/**\n * Clear all headers from a response.\n *\n * @param {object} res\n * @private\n */\n\nfunction clearHeaders (res) {\n  var headers = getHeaderNames(res)\n\n  for (var i = 0; i < headers.length; i++) {\n    res.removeHeader(headers[i])\n  }\n}\n\n/**\n * Collapse all leading slashes into a single slash\n *\n * @param {string} str\n * @private\n */\nfunction collapseLeadingSlashes (str) {\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] !== '/') {\n      break\n    }\n  }\n\n  return i > 1\n    ? '/' + str.substr(i)\n    : str\n}\n\n/**\n * Determine if path parts contain a dotfile.\n *\n * @api private\n */\n\nfunction containsDotFile (parts) {\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i]\n    if (part.length > 1 && part[0] === '.') {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Create a Content-Range header.\n *\n * @param {string} type\n * @param {number} size\n * @param {array} [range]\n */\n\nfunction contentRange (type, size, range) {\n  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size\n}\n\n/**\n * Create a minimal HTML document.\n *\n * @param {string} title\n * @param {string} body\n * @private\n */\n\nfunction createHtmlDocument (title, body) {\n  return '<!DOCTYPE html>\\n' +\n    '<html lang=\"en\">\\n' +\n    '<head>\\n' +\n    '<meta charset=\"utf-8\">\\n' +\n    '<title>' + title + '</title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '<pre>' + body + '</pre>\\n' +\n    '</body>\\n' +\n    '</html>\\n'\n}\n\n/**\n * decodeURIComponent.\n *\n * Allows V8 to only deoptimize this fn instead of all\n * of send().\n *\n * @param {String} path\n * @api private\n */\n\nfunction decode (path) {\n  try {\n    return decodeURIComponent(path)\n  } catch (err) {\n    return -1\n  }\n}\n\n/**\n * Get the header names on a respnse.\n *\n * @param {object} res\n * @returns {array[string]}\n * @private\n */\n\nfunction getHeaderNames (res) {\n  return typeof res.getHeaderNames !== 'function'\n    ? Object.keys(res._headers || {})\n    : res.getHeaderNames()\n}\n\n/**\n * Determine if emitter has listeners of a given type.\n *\n * The way to do this check is done three different ways in Node.js >= 0.8\n * so this consolidates them into a minimal set using instance methods.\n *\n * @param {EventEmitter} emitter\n * @param {string} type\n * @returns {boolean}\n * @private\n */\n\nfunction hasListeners (emitter, type) {\n  var count = typeof emitter.listenerCount !== 'function'\n    ? emitter.listeners(type).length\n    : emitter.listenerCount(type)\n\n  return count > 0\n}\n\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\nfunction headersSent (res) {\n  return typeof res.headersSent !== 'boolean'\n    ? Boolean(res._header)\n    : res.headersSent\n}\n\n/**\n * Normalize the index option into an array.\n *\n * @param {boolean|string|array} val\n * @param {string} name\n * @private\n */\n\nfunction normalizeList (val, name) {\n  var list = [].concat(val || [])\n\n  for (var i = 0; i < list.length; i++) {\n    if (typeof list[i] !== 'string') {\n      throw new TypeError(name + ' must be array of strings or false')\n    }\n  }\n\n  return list\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  return typeof timestamp === 'number'\n    ? timestamp\n    : NaN\n}\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(str.substring(start, end))\n\n  return list\n}\n\n/**\n * Set an object of headers on a response.\n *\n * @param {object} res\n * @param {object} headers\n * @private\n */\n\nfunction setHeaders (res, headers) {\n  var keys = Object.keys(headers)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    res.setHeader(key, headers[key])\n  }\n}\n","/*!\n * http-errors\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar deprecate = require('depd')('http-errors')\nvar setPrototypeOf = require('setprototypeof')\nvar statuses = require('statuses')\nvar inherits = require('inherits')\nvar toIdentifier = require('toidentifier')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = createError\nmodule.exports.HttpError = createHttpErrorConstructor()\n\n// Populate exports for all constructors\npopulateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)\n\n/**\n * Get the code class of a status code.\n * @private\n */\n\nfunction codeClass (status) {\n  return Number(String(status).charAt(0) + '00')\n}\n\n/**\n * Create a new HTTP Error.\n *\n * @returns {Error}\n * @public\n */\n\nfunction createError () {\n  // so much arity going on ~_~\n  var err\n  var msg\n  var status = 500\n  var props = {}\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i]\n    if (arg instanceof Error) {\n      err = arg\n      status = err.status || err.statusCode || status\n      continue\n    }\n    switch (typeof arg) {\n      case 'string':\n        msg = arg\n        break\n      case 'number':\n        status = arg\n        if (i !== 0) {\n          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)')\n        }\n        break\n      case 'object':\n        props = arg\n        break\n    }\n  }\n\n  if (typeof status === 'number' && (status < 400 || status >= 600)) {\n    deprecate('non-error status code; use only 4xx or 5xx status codes')\n  }\n\n  if (typeof status !== 'number' ||\n    (!statuses[status] && (status < 400 || status >= 600))) {\n    status = 500\n  }\n\n  // constructor\n  var HttpError = createError[status] || createError[codeClass(status)]\n\n  if (!err) {\n    // create error\n    err = HttpError\n      ? new HttpError(msg)\n      : new Error(msg || statuses[status])\n    Error.captureStackTrace(err, createError)\n  }\n\n  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {\n    // add properties to generic error\n    err.expose = status < 500\n    err.status = err.statusCode = status\n  }\n\n  for (var key in props) {\n    if (key !== 'status' && key !== 'statusCode') {\n      err[key] = props[key]\n    }\n  }\n\n  return err\n}\n\n/**\n * Create HTTP error abstract base class.\n * @private\n */\n\nfunction createHttpErrorConstructor () {\n  function HttpError () {\n    throw new TypeError('cannot construct abstract class')\n  }\n\n  inherits(HttpError, Error)\n\n  return HttpError\n}\n\n/**\n * Create a constructor for a client error.\n * @private\n */\n\nfunction createClientErrorConstructor (HttpError, name, code) {\n  var className = name.match(/Error$/) ? name : name + 'Error'\n\n  function ClientError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ClientError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ClientError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ClientError, HttpError)\n  nameFunc(ClientError, className)\n\n  ClientError.prototype.status = code\n  ClientError.prototype.statusCode = code\n  ClientError.prototype.expose = true\n\n  return ClientError\n}\n\n/**\n * Create a constructor for a server error.\n * @private\n */\n\nfunction createServerErrorConstructor (HttpError, name, code) {\n  var className = name.match(/Error$/) ? name : name + 'Error'\n\n  function ServerError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ServerError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ServerError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ServerError, HttpError)\n  nameFunc(ServerError, className)\n\n  ServerError.prototype.status = code\n  ServerError.prototype.statusCode = code\n  ServerError.prototype.expose = false\n\n  return ServerError\n}\n\n/**\n * Set the name of a function, if possible.\n * @private\n */\n\nfunction nameFunc (func, name) {\n  var desc = Object.getOwnPropertyDescriptor(func, 'name')\n\n  if (desc && desc.configurable) {\n    desc.value = name\n    Object.defineProperty(func, 'name', desc)\n  }\n}\n\n/**\n * Populate the exports object with constructors for every error class.\n * @private\n */\n\nfunction populateConstructorExports (exports, codes, HttpError) {\n  codes.forEach(function forEachCode (code) {\n    var CodeError\n    var name = toIdentifier(statuses[code])\n\n    switch (codeClass(code)) {\n      case 400:\n        CodeError = createClientErrorConstructor(HttpError, name, code)\n        break\n      case 500:\n        CodeError = createServerErrorConstructor(HttpError, name, code)\n        break\n    }\n\n    if (CodeError) {\n      // export the constructor\n      exports[code] = CodeError\n      exports[name] = CodeError\n    }\n  })\n\n  // backwards-compatibility\n  exports[\"I'mateapot\"] = deprecate.function(exports.ImATeapot,\n    '\"I\\'mateapot\"; use \"ImATeapot\" instead')\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/*!\n * serve-static\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar encodeUrl = require('encodeurl')\nvar escapeHtml = require('escape-html')\nvar parseUrl = require('parseurl')\nvar resolve = require('path').resolve\nvar send = require('send')\nvar url = require('url')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = serveStatic\nmodule.exports.mime = send.mime\n\n/**\n * @param {string} root\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction serveStatic (root, options) {\n  if (!root) {\n    throw new TypeError('root path required')\n  }\n\n  if (typeof root !== 'string') {\n    throw new TypeError('root path must be a string')\n  }\n\n  // copy options object\n  var opts = Object.create(options || null)\n\n  // fall-though\n  var fallthrough = opts.fallthrough !== false\n\n  // default redirect\n  var redirect = opts.redirect !== false\n\n  // headers listener\n  var setHeaders = opts.setHeaders\n\n  if (setHeaders && typeof setHeaders !== 'function') {\n    throw new TypeError('option setHeaders must be function')\n  }\n\n  // setup options for send\n  opts.maxage = opts.maxage || opts.maxAge || 0\n  opts.root = resolve(root)\n\n  // construct directory listener\n  var onDirectory = redirect\n    ? createRedirectDirectoryListener()\n    : createNotFoundDirectoryListener()\n\n  return function serveStatic (req, res, next) {\n    if (req.method !== 'GET' && req.method !== 'HEAD') {\n      if (fallthrough) {\n        return next()\n      }\n\n      // method not allowed\n      res.statusCode = 405\n      res.setHeader('Allow', 'GET, HEAD')\n      res.setHeader('Content-Length', '0')\n      res.end()\n      return\n    }\n\n    var forwardError = !fallthrough\n    var originalUrl = parseUrl.original(req)\n    var path = parseUrl(req).pathname\n\n    // make sure redirect occurs at mount\n    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {\n      path = ''\n    }\n\n    // create send stream\n    var stream = send(req, path, opts)\n\n    // add directory handler\n    stream.on('directory', onDirectory)\n\n    // add headers listener\n    if (setHeaders) {\n      stream.on('headers', setHeaders)\n    }\n\n    // add file listener for fallthrough\n    if (fallthrough) {\n      stream.on('file', function onFile () {\n        // once file is determined, always forward error\n        forwardError = true\n      })\n    }\n\n    // forward errors\n    stream.on('error', function error (err) {\n      if (forwardError || !(err.statusCode < 500)) {\n        next(err)\n        return\n      }\n\n      next()\n    })\n\n    // pipe\n    stream.pipe(res)\n  }\n}\n\n/**\n * Collapse all leading slashes into a single slash\n * @private\n */\nfunction collapseLeadingSlashes (str) {\n  for (var i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) !== 0x2f /* / */) {\n      break\n    }\n  }\n\n  return i > 1\n    ? '/' + str.substr(i)\n    : str\n}\n\n/**\n * Create a minimal HTML document.\n *\n * @param {string} title\n * @param {string} body\n * @private\n */\n\nfunction createHtmlDocument (title, body) {\n  return '<!DOCTYPE html>\\n' +\n    '<html lang=\"en\">\\n' +\n    '<head>\\n' +\n    '<meta charset=\"utf-8\">\\n' +\n    '<title>' + title + '</title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '<pre>' + body + '</pre>\\n' +\n    '</body>\\n' +\n    '</html>\\n'\n}\n\n/**\n * Create a directory listener that just 404s.\n * @private\n */\n\nfunction createNotFoundDirectoryListener () {\n  return function notFound () {\n    this.error(404)\n  }\n}\n\n/**\n * Create a directory listener that performs a redirect.\n * @private\n */\n\nfunction createRedirectDirectoryListener () {\n  return function redirect (res) {\n    if (this.hasTrailingSlash()) {\n      this.error(404)\n      return\n    }\n\n    // get original URL\n    var originalUrl = parseUrl.original(this.req)\n\n    // append trailing slash\n    originalUrl.path = null\n    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')\n\n    // reformat the URL\n    var loc = encodeUrl(url.format(originalUrl))\n    var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href=\"' + escapeHtml(loc) + '\">' +\n      escapeHtml(loc) + '</a>')\n\n    // send redirect response\n    res.statusCode = 301\n    res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n    res.setHeader('Content-Length', Buffer.byteLength(doc))\n    res.setHeader('Content-Security-Policy', \"default-src 'none'\")\n    res.setHeader('X-Content-Type-Options', 'nosniff')\n    res.setHeader('Location', loc)\n    res.end(doc)\n  }\n}\n","'use strict'\n/* eslint no-proto: 0 */\nmodule.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties)\n\nfunction setProtoOf (obj, proto) {\n  obj.__proto__ = proto\n  return obj\n}\n\nfunction mixinProperties (obj, proto) {\n  for (var prop in proto) {\n    if (!obj.hasOwnProperty(prop)) {\n      obj[prop] = proto[prop]\n    }\n  }\n  return obj\n}\n","/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require('./codes.json')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.STATUS_CODES = codes\n\n// array of status codes\nstatus.codes = populateStatusesMap(status, codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Populate the statuses map for given codes.\n * @private\n */\n\nfunction populateStatusesMap (statuses, codes) {\n  var arr = []\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // Populate properties\n    statuses[status] = message\n    statuses[message] = status\n    statuses[message.toLowerCase()] = status\n\n    // Add to array\n    arr.push(status)\n  })\n\n  return arr\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    if (!status[code]) throw new Error('invalid status code: ' + code)\n    return code\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    if (!status[n]) throw new Error('invalid status code: ' + n)\n    return n\n  }\n\n  n = status[code.toLowerCase()]\n  if (!n) throw new Error('invalid status message: \"' + code + '\"')\n  return n\n}\n","//\n// TDigest:\n//\n// approximate distribution percentiles from a stream of reals\n//\nvar RBTree = require('bintrees').RBTree;\n\nfunction TDigest(delta, K, CX) {\n    // allocate a TDigest structure.\n    //\n    // delta is the compression factor, the max fraction of mass that\n    // can be owned by one centroid (bigger, up to 1.0, means more\n    // compression). delta=false switches off TDigest behavior and treats\n    // the distribution as discrete, with no merging and exact values\n    // reported.\n    //\n    // K is a size threshold that triggers recompression as the TDigest\n    // grows during input.  (Set it to 0 to disable automatic recompression)\n    //\n    // CX specifies how often to update cached cumulative totals used\n    // for quantile estimation during ingest (see cumulate()).  Set to\n    // 0 to use exact quantiles for each new point.\n    //\n    this.discrete = (delta === false);\n    this.delta = delta || 0.01;\n    this.K = (K === undefined) ? 25 : K;\n    this.CX = (CX === undefined) ? 1.1 : CX;\n    this.centroids = new RBTree(compare_centroid_means);\n    this.nreset = 0;\n    this.reset();\n}\n\nTDigest.prototype.reset = function() {\n    // prepare to digest new points.\n    //\n    this.centroids.clear();\n    this.n = 0;\n    this.nreset += 1;\n    this.last_cumulate = 0;\n};\n\nTDigest.prototype.size = function() {\n    return this.centroids.size;\n};\n\nTDigest.prototype.toArray = function(everything) {\n    // return {mean,n} of centroids as an array ordered by mean.\n    //\n    var result = [];\n    if (everything) {\n        this._cumulate(true); // be sure cumns are exact\n        this.centroids.each(function(c) { result.push(c); });\n    } else {\n        this.centroids.each(function(c) { result.push({mean:c.mean, n:c.n}); });\n    }\n    return result;\n};\n\nTDigest.prototype.summary = function() {\n    var approx = (this.discrete) ? \"exact \" : \"approximating \";\n    var s = [approx + this.n + \" samples using \" + this.size() + \" centroids\",\n             \"min = \"+this.percentile(0),\n             \"Q1  = \"+this.percentile(0.25),\n             \"Q2  = \"+this.percentile(0.5),\n             \"Q3  = \"+this.percentile(0.75),\n             \"max = \"+this.percentile(1.0)];\n    return s.join('\\n');\n};\n\nfunction compare_centroid_means(a, b) {\n    // order two centroids by mean.\n    //\n    return (a.mean > b.mean) ? 1 : (a.mean < b.mean) ? -1 : 0;\n}\n\nfunction compare_centroid_mean_cumns(a, b) {\n    // order two centroids by mean_cumn.\n    //\n    return (a.mean_cumn - b.mean_cumn);\n}\n\nTDigest.prototype.push = function(x, n) {\n    // incorporate value or array of values x, having count n into the\n    // TDigest. n defaults to 1.\n    //\n    n = n || 1;\n    x = Array.isArray(x) ? x : [x];\n    for (var i = 0 ; i < x.length ; i++) {\n        this._digest(x[i], n);\n    }\n};\n\nTDigest.prototype.push_centroid = function(c) {\n    // incorporate centroid or array of centroids c\n    //\n    c = Array.isArray(c) ? c : [c];\n    for (var i = 0 ; i < c.length ; i++) {\n        this._digest(c[i].mean, c[i].n);\n    }\n};\n\nTDigest.prototype._cumulate = function(exact) {\n    // update cumulative counts for each centroid\n    //\n    // exact: falsey means only cumulate after sufficient\n    // growth. During ingest, these counts are used as quantile\n    // estimates, and they work well even when somewhat out of\n    // date. (this is a departure from the publication, you may set CX\n    // to 0 to disable).\n    //\n    if (this.n === this.last_cumulate ||\n        !exact && this.CX && this.CX > (this.n / this.last_cumulate)) {\n        return;\n    }\n    var cumn = 0;\n    var self = this;\n    this.centroids.each(function(c) {\n        c.mean_cumn = cumn + c.n / 2; // half of n at the mean\n        cumn = c.cumn = cumn + c.n;\n    });\n    this.n = this.last_cumulate = cumn;\n};\n\nTDigest.prototype.find_nearest = function(x) {\n    // find the centroid closest to x. The assumption of\n    // unique means and a unique nearest centroid departs from the\n    // paper, see _digest() below\n    //\n    if (this.size() === 0) {\n        return null;\n    }\n    var iter = this.centroids.lowerBound({mean:x}); // x <= iter || iter==null\n    var c = (iter.data() === null) ? iter.prev() : iter.data();\n    if (c.mean === x || this.discrete) {\n        return c; // c is either x or a neighbor (discrete: no distance func)\n    }\n    var prev = iter.prev();\n    if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {\n        return prev;\n    } else {\n        return c;\n    }\n};\n\nTDigest.prototype._new_centroid = function(x, n, cumn) {\n    // create and insert a new centroid into the digest (don't update\n    // cumulatives).\n    //\n    var c = {mean:x, n:n, cumn:cumn};\n    this.centroids.insert(c);\n    this.n += n;\n    return c;\n};\n\nTDigest.prototype._addweight = function(nearest, x, n) {\n    // add weight at location x to nearest centroid.  adding x to\n    // nearest will not shift its relative position in the tree and\n    // require reinsertion.\n    //\n    if (x !== nearest.mean) {\n        nearest.mean += n * (x - nearest.mean) / (nearest.n + n);\n    }\n    nearest.cumn += n;\n    nearest.mean_cumn += n / 2;\n    nearest.n += n;\n    this.n += n;\n};\n\nTDigest.prototype._digest = function(x, n) {\n    // incorporate value x, having count n into the TDigest.\n    //\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var nearest = this.find_nearest(x);\n    if (nearest && nearest.mean === x) {\n        // accumulate exact matches into the centroid without\n        // limit. this is a departure from the paper, made so\n        // centroids remain unique and code can be simple.\n        this._addweight(nearest, x, n);\n    } else if (nearest === min) {\n        this._new_centroid(x, n, 0); // new point around min boundary\n    } else if (nearest === max ) {\n        this._new_centroid(x, n, this.n); // new point around max boundary\n    } else if (this.discrete) {\n        this._new_centroid(x, n, nearest.cumn); // never merge\n    } else {\n        // conider a merge based on nearest centroid's capacity. if\n        // there's not room for all of n, don't bother merging any of\n        // it into nearest, as we'll have to make a new centroid\n        // anyway for the remainder (departure from the paper).\n        var p = nearest.mean_cumn / this.n;\n        var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));\n        if (max_n - nearest.n >= n) {\n            this._addweight(nearest, x, n);\n        } else {\n            this._new_centroid(x, n, nearest.cumn);\n        }\n    }\n    this._cumulate(false);\n    if (!this.discrete && this.K && this.size() > this.K / this.delta) {\n        // re-process the centroids and hope for some compression.\n        this.compress();\n    }\n};\n\nTDigest.prototype.bound_mean = function(x) {\n    // find centroids lower and upper such that lower.mean < x <\n    // upper.mean or lower.mean === x === upper.mean. Don't call\n    // this for x out of bounds.\n    //\n    var iter = this.centroids.upperBound({mean:x}); // x < iter\n    var lower = iter.prev();      // lower <= x\n    var upper = (lower.mean === x) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.p_rank = function(x_or_xlist) {\n    // return approximate percentile-ranks (0..1) for data value x.\n    // or list of x.  calculated according to\n    // https://en.wikipedia.org/wiki/Percentile_rank\n    //\n    // (Note that in continuous mode, boundary sample values will\n    // report half their centroid weight inward from 0/1 as the\n    // percentile-rank. X values outside the observed range return\n    // 0/1)\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];\n    var ps = xs.map(this._p_rank, this);\n    return Array.isArray(x_or_xlist) ? ps : ps[0];\n};\n\nTDigest.prototype._p_rank = function(x) {\n    if (this.size() === 0) {\n        return undefined;\n    } else if (x < this.centroids.min().mean) {\n        return 0.0;\n    } else if (x > this.centroids.max().mean) {\n        return 1.0;\n    }\n    // find centroids that bracket x and interpolate x's cumn from\n    // their cumn's.\n    this._cumulate(true); // be sure cumns are exact\n    var bound = this.bound_mean(x);\n    var lower = bound[0], upper = bound[1];\n    if (this.discrete) {\n        return lower.cumn / this.n;\n    } else {\n        var cumn = lower.mean_cumn;\n        if (lower !== upper) {\n            cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);\n        }\n        return cumn / this.n;\n    }\n};\n\nTDigest.prototype.bound_mean_cumn = function(cumn) {\n    // find centroids lower and upper such that lower.mean_cumn < x <\n    // upper.mean_cumn or lower.mean_cumn === x === upper.mean_cumn. Don't call\n    // this for cumn out of bounds.\n    //\n    // XXX because mean and mean_cumn give rise to the same sort order\n    // (up to identical means), use the mean rbtree for our search.\n    this.centroids._comparator = compare_centroid_mean_cumns;\n    var iter = this.centroids.upperBound({mean_cumn:cumn}); // cumn < iter\n    this.centroids._comparator = compare_centroid_means;\n    var lower = iter.prev();      // lower <= cumn\n    var upper = (lower && lower.mean_cumn === cumn) ? lower : iter.next();\n    return [lower, upper];\n};\n\nTDigest.prototype.percentile = function(p_or_plist) {\n    // for percentage p (0..1), or for each p in a list of ps, return\n    // the smallest data value q at which at least p percent of the\n    // observations <= q.\n    //\n    // for discrete distributions, this selects q using the Nearest\n    // Rank Method\n    // (https://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method)\n    // (in scipy, same as percentile(...., interpolation='higher')\n    //\n    // for continuous distributions, interpolates data values between\n    // count-weighted bracketing means.\n    //\n    // this triggers cumulate() if cumn's are out of date.\n    //\n    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];\n    var qs = ps.map(this._percentile, this);\n    return Array.isArray(p_or_plist) ? qs : qs[0];\n};\n\nTDigest.prototype._percentile = function(p) {\n    if (this.size() === 0) {\n        return undefined;\n    }\n    this._cumulate(true); // be sure cumns are exact\n    var min = this.centroids.min();\n    var max = this.centroids.max();\n    var h = this.n * p;\n    var bound = this.bound_mean_cumn(h);\n    var lower = bound[0], upper = bound[1];\n\n    if (upper === lower || lower === null || upper === null) {\n        return (lower || upper).mean;\n    } else if (!this.discrete) {\n        return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);\n    } else if (h <= lower.cumn) {\n        return lower.mean;\n    } else {\n        return upper.mean;\n    }\n};\n\nfunction pop_random(choices) {\n    // remove and return an item randomly chosen from the array of choices\n    // (mutates choices)\n    //\n    var idx = Math.floor(Math.random() * choices.length);\n    return choices.splice(idx, 1)[0];\n}\n\nTDigest.prototype.compress = function() {\n    // TDigests experience worst case compression (none) when input\n    // increases monotonically.  Improve on any bad luck by\n    // reconsuming digest centroids as if they were weighted points\n    // while shuffling their order (and hope for the best).\n    //\n    if (this.compressing) {\n        return;\n    }\n    var points = this.toArray();\n    this.reset();\n    this.compressing = true;\n    while (points.length > 0) {\n        this.push_centroid(pop_random(points));\n    }\n    this._cumulate(true);\n    this.compressing = false;\n};\n\nfunction Digest(config) {\n    // allocate a distribution digest structure. This is an extension\n    // of a TDigest structure that starts in exact histogram (discrete)\n    // mode, and automatically switches to TDigest mode for large\n    // samples that appear to be from a continuous distribution.\n    //\n    this.config = config || {};\n    this.mode = this.config.mode || 'auto'; // disc, cont, auto\n    TDigest.call(this, this.mode === 'cont' ? config.delta : false);\n    this.digest_ratio = this.config.ratio || 0.9;\n    this.digest_thresh = this.config.thresh || 1000;\n    this.n_unique = 0;\n}\nDigest.prototype = Object.create(TDigest.prototype);\nDigest.prototype.constructor = Digest;\n\nDigest.prototype.push = function(x_or_xlist) {\n    TDigest.prototype.push.call(this, x_or_xlist);\n    this.check_continuous();\n};\n\nDigest.prototype._new_centroid = function(x, n, cumn) {\n    this.n_unique += 1;\n    TDigest.prototype._new_centroid.call(this, x, n, cumn);\n};\n\nDigest.prototype._addweight = function(nearest, x, n) {\n    if (nearest.n === 1) {\n        this.n_unique -= 1;\n    }\n    TDigest.prototype._addweight.call(this, nearest, x, n);\n};\n\nDigest.prototype.check_continuous = function() {\n    // while in 'auto' mode, if there are many unique elements, assume\n    // they are from a continuous distribution and switch to 'cont'\n    // mode (tdigest behavior). Return true on transition from\n    // disctete to continuous.\n    if (this.mode !== 'auto' || this.size() < this.digest_thresh) {\n        return false;\n    }\n    if (this.n_unique / this.size() > this.digest_ratio) {\n        this.mode = 'cont';\n        this.discrete = false;\n        this.delta = this.config.delta || 0.01;\n        this.compress();\n        return true;\n    }\n    return false;\n};\n\nmodule.exports = {\n    'TDigest': TDigest,\n    'Digest': Digest\n};\n","/*!\n * toidentifier\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = toIdentifier\n\n/**\n * Trasform the given string into a JavaScript identifier\n *\n * @param {string} str\n * @returns {string}\n * @public\n */\n\nfunction toIdentifier (str) {\n  return str\n    .split(' ')\n    .map(function (token) {\n      return token.slice(0, 1).toUpperCase() + token.slice(1)\n    })\n    .join('')\n    .replace(/[^ _0-9a-z]/gi, '')\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar typer = require('media-typer')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = typeofrequest\nmodule.exports.is = typeis\nmodule.exports.hasBody = hasbody\nmodule.exports.normalize = normalize\nmodule.exports.match = mimeMatch\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction typeis (value, types_) {\n  var i\n  var types = types_\n\n  // remove parameters and normalize\n  var val = tryNormalizeType(value)\n\n  // no type or invalid\n  if (!val) {\n    return false\n  }\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1)\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // no types, return the content type\n  if (!types || !types.length) {\n    return val\n  }\n\n  var type\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1\n        ? val\n        : type\n    }\n  }\n\n  // no matches\n  return false\n}\n\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\nfunction hasbody (req) {\n  return req.headers['transfer-encoding'] !== undefined ||\n    !isNaN(req.headers['content-length'])\n}\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nfunction typeofrequest (req, types_) {\n  var types = types_\n\n  // no body\n  if (!hasbody(req)) {\n    return null\n  }\n\n  // support flattened arguments\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // request content type\n  var value = req.headers['content-type']\n\n  return typeis(value, types)\n}\n\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\nfunction normalize (type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded'\n    case 'multipart':\n      return 'multipart/*'\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type\n  }\n\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\nfunction mimeMatch (expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false\n  }\n\n  // split types\n  var actualParts = actual.split('/')\n  var expectedParts = expected.split('/')\n\n  // invalid format\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false\n  }\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false\n  }\n\n  // validate suffix wildcard\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 &&\n      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)\n  }\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction normalizeType (value) {\n  // parse the type\n  var type = typer.parse(value)\n\n  // remove the parameters\n  type.parameters = undefined\n\n  // reformat it\n  return typer.format(type)\n}\n\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction tryNormalizeType (value) {\n  if (!value) {\n    return null\n  }\n\n  try {\n    return normalizeType(value)\n  } catch (err) {\n    return null\n  }\n}\n","/*!\n * unpipe\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = unpipe\n\n/**\n * Determine if there are Node.js pipe-like data listeners.\n * @private\n */\n\nfunction hasPipeDataListeners(stream) {\n  var listeners = stream.listeners('data')\n\n  for (var i = 0; i < listeners.length; i++) {\n    if (listeners[i].name === 'ondata') {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Unpipe a stream from all destinations.\n *\n * @param {object} stream\n * @public\n */\n\nfunction unpipe(stream) {\n  if (!stream) {\n    throw new TypeError('argument stream is required')\n  }\n\n  if (typeof stream.unpipe === 'function') {\n    // new-style\n    stream.unpipe()\n    return\n  }\n\n  // Node.js 0.8 hack\n  if (!hasPipeDataListeners(stream)) {\n    return\n  }\n\n  var listener\n  var listeners = stream.listeners('close')\n\n  for (var i = 0; i < listeners.length; i++) {\n    listener = listeners[i]\n\n    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {\n      continue\n    }\n\n    // invoke the listener\n    listener.call(stream)\n  }\n}\n","/**\n * Merge object b with object a.\n *\n *     var a = { foo: 'bar' }\n *       , b = { bar: 'baz' };\n *\n *     merge(a, b);\n *     // => { foo: 'bar', bar: 'baz' }\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object}\n * @api public\n */\n\nexports = module.exports = function(a, b){\n  if (a && b) {\n    for (var key in b) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n","/*!\n * vary\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = vary\nmodule.exports.append = append\n\n/**\n * RegExp to match field-name in RFC 7230 sec 3.2\n *\n * field-name    = token\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n */\n\nvar FIELD_NAME_REGEXP = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/\n\n/**\n * Append a field to a vary header.\n *\n * @param {String} header\n * @param {String|Array} field\n * @return {String}\n * @public\n */\n\nfunction append (header, field) {\n  if (typeof header !== 'string') {\n    throw new TypeError('header argument is required')\n  }\n\n  if (!field) {\n    throw new TypeError('field argument is required')\n  }\n\n  // get fields array\n  var fields = !Array.isArray(field)\n    ? parse(String(field))\n    : field\n\n  // assert on invalid field names\n  for (var j = 0; j < fields.length; j++) {\n    if (!FIELD_NAME_REGEXP.test(fields[j])) {\n      throw new TypeError('field argument contains an invalid header name')\n    }\n  }\n\n  // existing, unspecified vary\n  if (header === '*') {\n    return header\n  }\n\n  // enumerate current values\n  var val = header\n  var vals = parse(header.toLowerCase())\n\n  // unspecified vary\n  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {\n    return '*'\n  }\n\n  for (var i = 0; i < fields.length; i++) {\n    var fld = fields[i].toLowerCase()\n\n    // append value (case-preserving)\n    if (vals.indexOf(fld) === -1) {\n      vals.push(fld)\n      val = val\n        ? val + ', ' + fields[i]\n        : fields[i]\n    }\n  }\n\n  return val\n}\n\n/**\n * Parse a vary header into an array.\n *\n * @param {String} header\n * @return {Array}\n * @private\n */\n\nfunction parse (header) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = header.length; i < len; i++) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(header.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(header.substring(start, end))\n\n  return list\n}\n\n/**\n * Mark that a request is varied on a header field.\n *\n * @param {Object} res\n * @param {String|Array} field\n * @public\n */\n\nfunction vary (res, field) {\n  if (!res || !res.getHeader || !res.setHeader) {\n    // quack quack\n    throw new TypeError('res argument is required')\n  }\n\n  // get existing header\n  var val = res.getHeader('Vary') || ''\n  var header = Array.isArray(val)\n    ? val.join(', ')\n    : String(val)\n\n  // set new header\n  if ((val = append(header, field))) {\n    res.setHeader('Vary', val)\n  }\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import { fromEvent, from } from 'rxjs'\nimport * as express from 'express'\nimport { mergeMap, take, map, combineAll, reduce } from 'rxjs/operators'\nimport * as cass from 'cassandra-driver'\n\nconst promClient = require('prom-client')\nconst basicAuth = require('express-basic-auth')\n\n\nconst setENV = (name: string, defValue: string): string => {\n  return process.env[name] ? process.env[name] : defValue\n}\n\n// -------------Initialize the environmnet---------------\nconst cassServers = setENV('CASS', 'localhost')\nconst dataCenter = setENV('DC', 'datacenter1')\nconst keySpace = setENV('KEYSPACE', 'local')\nconst table = setENV('TABLE', 'ref')\nconst port = setENV('PORT', '80')\n\n\n// -------------Set the siginterrupt--------------------\nfrom(['SIGINT', 'SIGTERM']).pipe(\n  mergeMap(s => fromEvent(process, s))\n).subscribe((d:any) => {\n  process.exit(d[1])\n})\n\n\n// -------------------------------------------------------\nconst register = new promClient.Registry()\n\n\nconst client = new cass.Client({ contactPoints: cassServers.split(','), localDataCenter: dataCenter, keyspace: keySpace });\nconst query = `SELECT room, content, ts FROM ${table}`;\nfrom(client.execute(query, [])).pipe(\n  mergeMap(v => from(v.rows))\n).subscribe({\n  next: x => {\n    console.info(x.keys())\n  },\n})\n// When received terminate signal, must delete the program.\n\nconst app = express()\n// --------------------Middlewares--------------------------\n// app.use(basicAuth({\n//   users: { 'admin': 'admin' },\n//   challenge: true,\n//   realm: 'Imb4T3st4pp',\n// }))\n\napp.get('/data/index.json', (req, res) => {\n  res.set({\"Content-Type\": \"text/csv\"})\n  from(client.execute(query, [])).pipe(\n    mergeMap(v => from(v.rows)),\n    reduce((ac, value) => {\n      return ac +`${value.room},${value.ts},${value.content}\\r\\n`\n    }, \"room,date,content\\r\\n\"),\n    take(1),\n  ).subscribe({\n    next: x => {\n      res.send(x)\n    },\n  })\n})\n\n// ----------------Prometheus counter----------------\nconst c = new promClient.Counter({\n\tname: 'test_counter',\n\thelp: 'Example of a counter',\n  labelNames: ['code'],\n  registers: [register]\n})\n\napp.get('/metrics', (req, res) => {\n  c.inc({code: 200})\n  res.set('Content-Type', register.contentType)\n  res.end(register.metrics())\n})\napp.listen(port, () => console.log(`app listening on port ${port}`))","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"cluster\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"path\");","module.exports = require(\"process\");","module.exports = require(\"querystring\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"v8\");","module.exports = require(\"vm\");","module.exports = require(\"zlib\");"],"sourceRoot":""}